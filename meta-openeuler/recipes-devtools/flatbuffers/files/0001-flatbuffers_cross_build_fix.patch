diff -urN a/BUILD.bazel b/BUILD.bazel
--- a/BUILD.bazel	2021-05-10 18:45:16.000000000 +0000
+++ b/BUILD.bazel	2023-01-13 07:47:06.185227175 +0000
@@ -10,6 +10,20 @@
     "LICENSE",
 ])
 
+config_setting(
+    name = "platform_freebsd",
+    constraint_values = [
+        "@platforms//os:freebsd",
+    ],
+)
+
+config_setting(
+    name = "platform_openbsd",
+    constraint_values = [
+        "@platforms//os:openbsd",
+    ],
+)
+
 # Public flatc library to compile flatbuffer files at runtime.
 cc_library(
     name = "flatbuffers",
@@ -23,8 +37,16 @@
 filegroup(
     name = "public_headers",
     srcs = [
+        "include/flatbuffers/allocator.h",
+        "include/flatbuffers/array.h",
         "include/flatbuffers/base.h",
+        "include/flatbuffers/bfbs_generator.h",
+        "include/flatbuffers/buffer.h",
+        "include/flatbuffers/buffer_ref.h",
         "include/flatbuffers/code_generators.h",
+        "include/flatbuffers/default_allocator.h",
+        "include/flatbuffers/detached_buffer.h",
+        "include/flatbuffers/flatbuffer_builder.h",
         "include/flatbuffers/flatbuffers.h",
         "include/flatbuffers/flexbuffers.h",
         "include/flatbuffers/grpc.h",
@@ -35,7 +57,13 @@
         "include/flatbuffers/reflection_generated.h",
         "include/flatbuffers/registry.h",
         "include/flatbuffers/stl_emulation.h",
+        "include/flatbuffers/string.h",
+        "include/flatbuffers/struct.h",
+        "include/flatbuffers/table.h",
         "include/flatbuffers/util.h",
+        "include/flatbuffers/vector.h",
+        "include/flatbuffers/vector_downward.h",
+        "include/flatbuffers/verifier.h",
     ],
 )
 
@@ -73,6 +101,8 @@
         "include/flatbuffers/flexbuffers.h",
         "include/flatbuffers/stl_emulation.h",
         "include/flatbuffers/util.h",
+        "include/flatbuffers/vector.h",
+        "include/flatbuffers/verifier.h",
     ],
     linkstatic = 1,
     strip_include_prefix = "/include",
diff -urN a/CMake/BuildFlatBuffers.cmake b/CMake/BuildFlatBuffers.cmake
--- a/CMake/BuildFlatBuffers.cmake	2021-05-10 18:45:16.000000000 +0000
+++ b/CMake/BuildFlatBuffers.cmake	2023-01-13 07:47:13.007290179 +0000
@@ -95,7 +95,7 @@
       set(generated_include ${generated_includes_dir}/${filename}_generated.h)
       add_custom_command(
         OUTPUT ${generated_include}
-        COMMAND ${FLATC} ${FLATC_ARGS}
+        COMMAND ${FLATC} ${FLATC_SCHEMA_ARGS}
         -o ${generated_includes_dir}
         ${include_params}
         -c ${schema}
@@ -230,16 +230,30 @@
   foreach(schema ${FLATBUFFERS_GENERATE_HEADERS_SCHEMAS})
     get_filename_component(filename ${schema} NAME_WE)
     set(generated_include "${generated_include_dir}/${filename}_generated.h")
+
+    # Generate files for grpc if needed
+    set(generated_source_file)
+    if("${FLATBUFFERS_GENERATE_HEADERS_FLAGS}" MATCHES "--grpc")
+      # Check if schema file contain a rpc_service definition
+      file(STRINGS ${schema} has_grpc REGEX "rpc_service")
+      if(has_grpc)
+        list(APPEND generated_include "${generated_include_dir}/${filename}.grpc.fb.h")
+        set(generated_source_file "${generated_include_dir}/${filename}.grpc.fb.cc")
+      endif()
+    endif()
+
     add_custom_command(
-      OUTPUT ${generated_include}
+      OUTPUT ${generated_include} ${generated_source_file}
       COMMAND ${FLATC} ${FLATC_ARGS}
       -o ${generated_include_dir}
       ${include_params}
       -c ${schema}
       ${FLATBUFFERS_GENERATE_HEADERS_FLAGS}
       DEPENDS ${FLATC_TARGET} ${schema}
-      WORKING_DIRECTORY "${working_dir}")
+      WORKING_DIRECTORY "${working_dir}"
+      COMMENT "Building ${schema} flatbuffers...")
     list(APPEND all_generated_header_files ${generated_include})
+    list(APPEND all_generated_source_files ${generated_source_file})
 
     # Geneate the binary flatbuffers schemas if instructed to.
     if (NOT ${FLATBUFFERS_GENERATE_HEADERS_BINARY_SCHEMAS_DIR} STREQUAL "")
@@ -264,6 +278,7 @@
     INTERFACE
       ${all_generated_header_files}
       ${all_generated_binary_files}
+      ${all_generated_source_files}
       ${FLATBUFFERS_GENERATE_HEADERS_SCHEMAS})
   add_dependencies(
     ${FLATBUFFERS_GENERATE_HEADERS_TARGET}
@@ -279,6 +294,10 @@
     PREFIX "Flatbuffers/Generated/Headers Files"
     FILES ${all_generated_header_files})
   source_group(
+    TREE "${generated_target_dir}"
+    PREFIX "Flatbuffers/Generated/Source Files"
+    FILES ${all_generated_source_files})
+  source_group(
     TREE ${working_dir}
     PREFIX "Flatbuffers/Schemas"
     FILES ${FLATBUFFERS_GENERATE_HEADERS_SCHEMAS})
@@ -371,7 +390,8 @@
       -b ${FLATBUFFERS_GENERATE_BINARY_FILES_SCHEMA} ${json_file}
       ${FLATBUFFERS_GENERATE_BINARY_FILES_FLAGS}
       DEPENDS ${FLATC_TARGET} ${json_file}
-      WORKING_DIRECTORY "${working_dir}")
+      WORKING_DIRECTORY "${working_dir}"
+      COMMENT "Building ${json_file} binary flatbuffers...")
       list(APPEND all_generated_binary_files ${generated_binary_file})
   endforeach()
 
diff -urN a/CMake/Version.cmake b/CMake/Version.cmake
--- a/CMake/Version.cmake	2021-05-10 18:45:16.000000000 +0000
+++ b/CMake/Version.cmake	2023-01-13 07:47:13.065290715 +0000
@@ -1,12 +1,12 @@
 set(VERSION_MAJOR 2)
 set(VERSION_MINOR 0)
-set(VERSION_PATCH 0)
+set(VERSION_PATCH 6)
 set(VERSION_COMMIT 0)
 
 find_program(GIT git)
-if(GIT)
+if(GIT AND EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/.git")
   execute_process(
-      COMMAND ${GIT} describe
+      COMMAND ${GIT} describe --tags
       WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
       OUTPUT_VARIABLE GIT_DESCRIBE_DIRTY
       OUTPUT_STRIP_TRAILING_WHITESPACE
diff -urN a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2021-05-10 18:45:16.000000000 +0000
+++ b/CMakeLists.txt	2023-01-13 07:47:06.191227231 +0000
@@ -1,9 +1,34 @@
+# This is the legacy minimum version flatbuffers supported for a while.
 cmake_minimum_required(VERSION 2.8.12)
+
+# CMake version 3.16 is the 'de-facto' minimum version for flatbuffers. If the
+# current cmake is older than this, warn the user and include the legacy file to
+# provide some level of support.
+if(CMAKE_VERSION VERSION_LESS 3.16)
+  message(WARNING "Using cmake version ${CMAKE_VERSION} which is older than "
+  "our target version of 3.16. This will use the legacy CMakeLists.txt that "
+  "supports version 2.8.12 and higher, but not actively maintained. Consider "
+  "upgrading cmake to a newer version, as this may become a fatal error in the "
+  "future.")
+  # Use the legacy version of CMakeLists.txt
+  include(CMake/CMakeLists_legacy.cmake.in)
+  return()
+endif()
+
+if (POLICY CMP0048)
+  cmake_policy(SET CMP0048 NEW)
+  project(FlatBuffers
+        DESCRIPTION "Flatbuffers serialization library"
+        VERSION 2.0.0
+        LANGUAGES CXX)
+else()
+  project(FlatBuffers)
+endif (POLICY CMP0048)
+
+include(CMake/Version.cmake)
+
 # generate compile_commands.json
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
-include(CheckCXXSymbolExists)
-
-project(FlatBuffers)
 
 # NOTE: Code coverage only works on Linux & OSX.
 option(FLATBUFFERS_CODE_COVERAGE "Enable the code coverage build option." OFF)
@@ -16,6 +41,9 @@
 option(FLATBUFFERS_STATIC_FLATC "Build flatbuffers compiler with -static flag"
        OFF)
 option(FLATBUFFERS_BUILD_FLATHASH "Enable the build of flathash" ON)
+option(FLATBUFFERS_BUILD_BENCHMARKS "Enable the build of flatbenchmark. \"
+       Requires C++11."
+       OFF)
 option(FLATBUFFERS_BUILD_GRPCTEST "Enable the build of grpctest" OFF)
 option(FLATBUFFERS_BUILD_SHAREDLIB
        "Enable the build of the flatbuffers shared library"
@@ -43,6 +71,12 @@
         Only work if CMake supports 'target_precompile_headers'. \"
         This can speed up compilation time."
        OFF)
+option(FLATBUFFERS_SKIP_MONSTER_EXTRA 
+      "Skip generating monster_extra.fbs that contains non-supported numerical\"
+      types." OFF)
+option(FLATBUFFERS_OSX_BUILD_UNIVERSAL
+      "Enable the build for multiple architectures on OS X (arm64, x86_64)."
+      ON)
 
 if(NOT FLATBUFFERS_BUILD_FLATC AND FLATBUFFERS_BUILD_TESTS)
     message(WARNING
@@ -58,7 +92,9 @@
 
 # Auto-detect locale-narrow 'strtod_l' and  'strtoull_l' functions.
 if(NOT DEFINED FLATBUFFERS_LOCALE_INDEPENDENT)
-  set(FLATBUFFERS_LOCALE_INDEPENDENT 0)
+  include(CheckCXXSymbolExists)
+
+  set(FLATBUFFERS_LOCALE_INDEPENDENT 1)
   if(MSVC)
     check_cxx_symbol_exists(_strtof_l stdlib.h FLATBUFFERS_HAS_STRTOF_L)
     check_cxx_symbol_exists(_strtoui64_l stdlib.h FLATBUFFERS_HAS_STRTOULL_L)
@@ -73,17 +109,31 @@
 add_definitions(-DFLATBUFFERS_LOCALE_INDEPENDENT=$<BOOL:${FLATBUFFERS_LOCALE_INDEPENDENT}>)
 
 set(FlatBuffers_Library_SRCS
+  include/flatbuffers/allocator.h
+  include/flatbuffers/array.h
   include/flatbuffers/base.h
+  include/flatbuffers/bfbs_generator.h
+  include/flatbuffers/buffer.h
+  include/flatbuffers/buffer_ref.h
+  include/flatbuffers/default_allocator.h
+  include/flatbuffers/detached_buffer.h
+  include/flatbuffers/flatbuffer_builder.h
   include/flatbuffers/flatbuffers.h
+  include/flatbuffers/flexbuffers.h
   include/flatbuffers/hash.h
   include/flatbuffers/idl.h
-  include/flatbuffers/util.h
+  include/flatbuffers/minireflect.h
   include/flatbuffers/reflection.h
   include/flatbuffers/reflection_generated.h
-  include/flatbuffers/stl_emulation.h
-  include/flatbuffers/flexbuffers.h
   include/flatbuffers/registry.h
-  include/flatbuffers/minireflect.h
+  include/flatbuffers/stl_emulation.h
+  include/flatbuffers/string.h
+  include/flatbuffers/struct.h
+  include/flatbuffers/table.h
+  include/flatbuffers/util.h
+  include/flatbuffers/vector.h
+  include/flatbuffers/vector_downward.h
+  include/flatbuffers/verifier.h
   src/idl_parser.cpp
   src/idl_gen_text.cpp
   src/reflection.cpp
@@ -110,7 +160,10 @@
   src/idl_gen_swift.cpp
   src/flatc.cpp
   src/flatc_main.cpp
+  src/bfbs_gen.h
+  src/bfbs_gen_lua.h
   include/flatbuffers/code_generators.h
+  src/bfbs_gen_lua.cpp
   src/code_generators.cpp
   grpc/src/compiler/schema_interface.h
   grpc/src/compiler/cpp_generator.h
@@ -220,10 +273,6 @@
   # do not apply any global settings if the toolchain
   # is being configured externally
   message(STATUS "Using toolchain file: ${CMAKE_TOOLCHAIN_FILE}.")
-elseif(APPLE)
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -stdlib=libc++")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -Werror -Wextra -Wno-unused-parameter")
-  set(FLATBUFFERS_PRIVATE_CXX_FLAGS "-Wold-style-cast")
 elseif(CMAKE_COMPILER_IS_GNUCXX)
   if(CYGWIN)
     set(CMAKE_CXX_FLAGS
@@ -241,7 +290,7 @@
         "${CMAKE_CXX_FLAGS} -faligned-new -Werror=implicit-fallthrough=2")
     endif()
     set(CMAKE_CXX_FLAGS
-      "${CMAKE_CXX_FLAGS} -Wunused-result -Werror=unused-result -Wunused-parameter -Werror=unused-parameter")
+      "${CMAKE_CXX_FLAGS} -Wno-unused-result -Wno-error=unused-result -Wno-unused-parameter -Wno-error=unused-parameter")
   endif()
 
   # Certain platforms such as ARM do not use signed chars by default
@@ -249,9 +298,31 @@
   set(CMAKE_CXX_FLAGS
     "${CMAKE_CXX_FLAGS} -fsigned-char")
 
+# MSVC **MUST** come before the Clang check, as clang-cl is flagged by CMake as "MSVC", but it still textually 
+# matches as Clang in its Compiler Id :)
+# Note: in CMake >= 3.14 we can check CMAKE_CXX_COMPILER_FRONTEND_VARIANT STREQUAL "GNU" or "MSVC" to differentiate...
+elseif(MSVC)
+  # Visual Studio pedantic build settings
+  # warning C4512: assignment operator could not be generated
+  # warning C4316: object allocated on the heap may not be aligned
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4 /WX /wd4512 /wd4316")
+
+  if(${CMAKE_CXX_COMPILER_ID} MATCHES "Clang")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /D_CRT_SECURE_NO_WARNINGS")
+  endif()
+
 elseif(${CMAKE_CXX_COMPILER_ID} MATCHES "Clang")
-  set(CMAKE_CXX_FLAGS
-      "${CMAKE_CXX_FLAGS} -std=c++0x -Wall -pedantic -Werror -Wextra -Wno-unused-parameter")
+  if(APPLE)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+
+    if(FLATBUFFERS_OSX_BUILD_UNIVERSAL)
+      set(CMAKE_OSX_ARCHITECTURES "arm64;x86_64")
+    endif()
+  else()
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")
+  endif()
+
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -pedantic -Werror -Wextra -Wno-unused-parameter")
   set(FLATBUFFERS_PRIVATE_CXX_FLAGS "-Wold-style-cast")
   if(NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 3.8)
     list(APPEND FLATBUFFERS_PRIVATE_CXX_FLAGS "-Wimplicit-fallthrough" "-Wextra-semi" "-Werror=unused-private-field") # enable warning
@@ -273,14 +344,6 @@
   set(CMAKE_CXX_FLAGS
     "${CMAKE_CXX_FLAGS} -fsigned-char")
 
-elseif(MSVC)
-  # Visual Studio pedantic build settings
-  # warning C4512: assignment operator could not be generated
-  # warning C4316: object allocated on the heap may not be aligned
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4 /WX /wd4512 /wd4316")
-
-  # multi-core build.
-  add_definitions("/MP")
 endif()
 
 # Append FLATBUFFERS_CXX_FLAGS to CMAKE_CXX_FLAGS.
@@ -331,11 +394,6 @@
   endif()
 endfunction()
 
-if(BIICODE)
-  include(biicode/cmake/biicode.cmake)
-  return()
-endif()
-
 include_directories(include)
 include_directories(grpc)
 
@@ -382,8 +440,8 @@
   # - micro updated every release when there is no API/ABI changes
   # - minor updated when there are additions in API/ABI
   # - major (ABI number) updated when there are changes in ABI (or removals)
-  set(FlatBuffers_Library_SONAME_MAJOR "2")
-  set(FlatBuffers_Library_SONAME_FULL "${FlatBuffers_Library_SONAME_MAJOR}.0.0")
+  set(FlatBuffers_Library_SONAME_MAJOR ${VERSION_MAJOR})
+  set(FlatBuffers_Library_SONAME_FULL "${FlatBuffers_Library_SONAME_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH}")
   set_target_properties(flatbuffers_shared PROPERTIES OUTPUT_NAME flatbuffers
                         SOVERSION "${FlatBuffers_Library_SONAME_MAJOR}"
                         VERSION "${FlatBuffers_Library_SONAME_FULL}")
@@ -438,11 +496,12 @@
   message(STATUS "`${SRC_FBS}`: add generation of binary (.bfbs) schema")
   get_filename_component(SRC_FBS_DIR ${SRC_FBS} PATH)
   string(REGEX REPLACE "\\.fbs$" ".bfbs" GEN_BINARY_SCHEMA ${SRC_FBS})
-  # For details about flags see generate_code.bat(sh)
+  # For details about flags see generate_code.py
   add_custom_command(
     OUTPUT ${GEN_BINARY_SCHEMA}
     COMMAND "${FLATBUFFERS_FLATC_EXECUTABLE}"
             -b --schema --bfbs-comments --bfbs-builtins
+            --bfbs-filenames ${SRC_FBS_DIR}
             -I "${CMAKE_CURRENT_SOURCE_DIR}/tests/include_test"
             -o "${SRC_FBS_DIR}"
             "${CMAKE_CURRENT_SOURCE_DIR}/${SRC_FBS}"
@@ -460,7 +519,7 @@
   message(STATUS "`${SRC_FBS}`: add generation of C++ embedded binary schema code with '${OPT}'")
   get_filename_component(SRC_FBS_DIR ${SRC_FBS} PATH)
   string(REGEX REPLACE "\\.fbs$" "_bfbs_generated.h" GEN_BFBS_HEADER ${SRC_FBS})
-  # For details about flags see generate_code.bat(sh)
+  # For details about flags see generate_code.py
   add_custom_command(
           OUTPUT ${GEN_BFBS_HEADER}
           COMMAND "${FLATBUFFERS_FLATC_EXECUTABLE}"
@@ -468,6 +527,7 @@
           --cpp-ptr-type flatbuffers::unique_ptr # Used to test with C++98 STLs
           ${OPT}
           --bfbs-comments --bfbs-builtins --bfbs-gen-embed
+          --bfbs-filenames ${SRC_FBS_DIR}
           -I "${CMAKE_CURRENT_SOURCE_DIR}/tests/include_test"
           -o "${SRC_FBS_DIR}"
           "${CMAKE_CURRENT_SOURCE_DIR}/${SRC_FBS}"
@@ -476,6 +536,30 @@
   register_generated_output(${GEN_BFBS_HEADER})
 endfunction()
 
+# Look if we have python 3.5 installed so that we can run the generate code
+# python script after flatc is built.
+find_package(Python3 3.5 COMPONENTS Interpreter)
+
+if(Python3_Interpreter_FOUND)
+  set(GENERATION_OPTS --flatc "${FLATBUFFERS_FLATC_EXECUTABLE}")
+  if(FLATBUFFERS_BUILD_LEGACY)
+    # Need to set --cpp-std c++-0x options
+    set(GENERATION_OPTS ${GENERATION_OPTS}--cpp-0x)
+  endif()
+  if(FLATBUFFERS_SKIP_MONSTER_EXTRA)
+    set(GENERATION_OPTS ${GENERATION_OPTS} --skip-monster-extra)
+  endif()
+  add_custom_command(
+    TARGET flatc
+    POST_BUILD
+    COMMAND ${Python3_EXECUTABLE} scripts/generate_code.py ${GENERATION_OPTS} --skip-gen-reflection
+    WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
+    COMMENT "Running scripts/generate_code.py..."
+    VERBATIM)
+else()
+  message("No Python3 interpreter found! Unable to generate files automatically.")
+endif()
+
 if(FLATBUFFERS_BUILD_TESTS)
   file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/tests" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}")
   file(COPY "${CMAKE_CURRENT_SOURCE_DIR}/samples" DESTINATION "${CMAKE_CURRENT_BINARY_DIR}")
@@ -483,9 +567,9 @@
   # TODO Add (monster_test.fbs monsterdata_test.json)->monsterdata_test.mon
   compile_flatbuffers_schema_to_cpp(tests/monster_test.fbs)
   compile_flatbuffers_schema_to_binary(tests/monster_test.fbs)
-  compile_flatbuffers_schema_to_cpp(tests/namespace_test/namespace_test1.fbs)
-  compile_flatbuffers_schema_to_cpp(tests/namespace_test/namespace_test2.fbs)
-  compile_flatbuffers_schema_to_cpp(tests/union_vector/union_vector.fbs)
+  compile_flatbuffers_schema_to_cpp_opt(tests/namespace_test/namespace_test1.fbs "--no-includes;--gen-compare;--gen-name-strings")
+  compile_flatbuffers_schema_to_cpp_opt(tests/namespace_test/namespace_test2.fbs "--no-includes;--gen-compare;--gen-name-strings")
+  compile_flatbuffers_schema_to_cpp_opt(tests/union_vector/union_vector.fbs "--no-includes;--gen-compare;--gen-name-strings")
   compile_flatbuffers_schema_to_cpp(tests/optional_scalars.fbs)
   compile_flatbuffers_schema_to_cpp_opt(tests/native_type_test.fbs "")
   compile_flatbuffers_schema_to_cpp_opt(tests/arrays_test.fbs "--scoped-enums;--gen-compare")
@@ -517,7 +601,7 @@
   if(FLATBUFFERS_BUILD_CPP17)
     # Don't generate header for flattests_cpp17 target.
     # This target uses "generated_cpp17/monster_test_generated.h"
-    # produced by direct call of generate_code.bat(sh) script.
+    # produced by direct call of generate_code.py script.
     add_executable(flattests_cpp17 ${FlatBuffers_Tests_CPP17_SRCS})
     add_dependencies(flattests_cpp17 generated_code)
     target_compile_features(flattests_cpp17 PRIVATE cxx_std_17)
@@ -545,6 +629,7 @@
   INCLUDE_DIRECTORIES(${PROTOBUF_DOWNLOAD_PATH}/src)
   find_package(Threads REQUIRED)
   list(APPEND CMAKE_PREFIX_PATH ${GRPC_INSTALL_PATH})
+  find_package(absl CONFIG REQUIRED)
   find_package(protobuf CONFIG REQUIRED)
   find_package(gRPC CONFIG REQUIRED)
   add_executable(grpctest ${FlatBuffers_GRPCTest_SRCS})
@@ -556,7 +641,6 @@
   endif()
 endif()
 
-include(CMake/Version.cmake)
 
 if(FLATBUFFERS_INSTALL)
   include(GNUInstallDirs)
@@ -572,18 +656,11 @@
   )
 
   if(FLATBUFFERS_BUILD_FLATLIB)
-    if(CMAKE_VERSION VERSION_LESS 3.0)
-      install(
-        TARGETS flatbuffers EXPORT FlatbuffersTargets
-        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-      )
-    else()
-      install(
-        TARGETS flatbuffers EXPORT FlatbuffersTargets
-        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
-      )
-    endif()
+    install(
+      TARGETS flatbuffers EXPORT FlatbuffersTargets
+      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+      INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
+    )
 
     install(EXPORT FlatbuffersTargets
       FILE FlatbuffersTargets.cmake
@@ -607,24 +684,15 @@
   endif()
 
   if(FLATBUFFERS_BUILD_SHAREDLIB)
-    if(CMAKE_VERSION VERSION_LESS 3.0)
-      install(
-        TARGETS flatbuffers_shared EXPORT FlatbuffersSharedTargets
-        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        RUNTIME DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-      )
-    else()
-      install(
-        TARGETS flatbuffers_shared EXPORT FlatbuffersSharedTargets
-        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        RUNTIME DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
-      )
-    endif()
+    install(
+      TARGETS flatbuffers_shared EXPORT FlatbuffersSharedTargets
+      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+      RUNTIME DESTINATION ${CMAKE_INSTALL_LIBDIR}
+      LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+      INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
+    )
 
-  install(
+    install(
       EXPORT FlatbuffersSharedTargets
       FILE FlatbuffersSharedTargets.cmake
       NAMESPACE flatbuffers::
@@ -676,3 +744,16 @@
         include(CPack)
     endif()
 endif()
+
+# Include for running Google Benchmarks.
+if(FLATBUFFERS_BUILD_BENCHMARKS)
+  add_subdirectory(benchmarks)
+endif()
+
+# Add FlatBuffers::FlatBuffers interface, needed for FetchContent_Declare
+add_library(FlatBuffers INTERFACE)
+add_library(FlatBuffers::FlatBuffers ALIAS FlatBuffers)
+target_include_directories(
+  FlatBuffers
+  INTERFACE $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+            $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}/include>)
diff -urN a/android/AndroidManifest.xml b/android/AndroidManifest.xml
--- a/android/AndroidManifest.xml	2021-05-10 18:45:16.000000000 +0000
+++ b/android/AndroidManifest.xml	2023-01-13 07:46:48.901067551 +0000
@@ -1,20 +1,4 @@
 <?xml version="1.0" encoding="utf-8"?>
-<!-- Copyright (c) 2013 Google, Inc.
-
-     This software is provided 'as-is', without any express or implied
-     warranty.  In no event will the authors be held liable for any damages
-     arising from the use of this software.
-     Permission is granted to anyone to use this software for any purpose,
-     including commercial applications, and to alter it and redistribute it
-     freely, subject to the following restrictions:
-     1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-     2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-     3. This notice may not be removed or altered from any source distribution.
- -->
 <!-- BEGIN_INCLUDE(manifest) -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
           package="com.example.FlatBufferTest">
diff -urN a/android/app/build.gradle b/android/app/build.gradle
--- a/android/app/build.gradle	2021-05-10 18:45:16.000000000 +0000
+++ b/android/app/build.gradle	2023-01-13 07:46:48.980068281 +0000
@@ -101,16 +101,6 @@
 
   flavorDimensions "stl-variant"
   productFlavors {
-    stlport {
-      dimension "stl-variant"
-      applicationIdSuffix ".stlport"
-      versionNameSuffix "-stlport"
-      externalNativeBuild {
-        ndkBuild {
-          arguments "APP_STL=stlport_static"
-        }
-      }
-    }
     gnustl {
       dimension "stl-variant"
       applicationIdSuffix ".gnustl"
diff -urN a/android/app/src/main/cpp/flatbuffers/CMakeLists.txt b/android/app/src/main/cpp/flatbuffers/CMakeLists.txt
--- a/android/app/src/main/cpp/flatbuffers/CMakeLists.txt	2021-05-10 18:45:16.000000000 +0000
+++ b/android/app/src/main/cpp/flatbuffers/CMakeLists.txt	2023-01-13 07:46:48.998068447 +0000
@@ -15,17 +15,31 @@
    "${CMAKE_CXX_FLAGS} -fsigned-char")
 
 set(FlatBuffers_Library_SRCS
+        ${FLATBUFFERS_SRC}/include/flatbuffers/allocator.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/array.h
         ${FLATBUFFERS_SRC}/include/flatbuffers/base.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/bfbs_generator.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/buffer.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/buffer_ref.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/default_allocator.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/detached_buffer.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/flatbuffer_builder.h
         ${FLATBUFFERS_SRC}/include/flatbuffers/flatbuffers.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/flexbuffers.h
         ${FLATBUFFERS_SRC}/include/flatbuffers/hash.h
         ${FLATBUFFERS_SRC}/include/flatbuffers/idl.h
-        ${FLATBUFFERS_SRC}/include/flatbuffers/util.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/minireflect.h
         ${FLATBUFFERS_SRC}/include/flatbuffers/reflection.h
         ${FLATBUFFERS_SRC}/include/flatbuffers/reflection_generated.h
-        ${FLATBUFFERS_SRC}/include/flatbuffers/stl_emulation.h
-        ${FLATBUFFERS_SRC}/include/flatbuffers/flexbuffers.h
         ${FLATBUFFERS_SRC}/include/flatbuffers/registry.h
-        ${FLATBUFFERS_SRC}/include/flatbuffers/minireflect.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/stl_emulation.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/string.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/struct.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/table.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/util.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/vector.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/vector_downward.h
+        ${FLATBUFFERS_SRC}/include/flatbuffers/verifier.h
         ${FLATBUFFERS_SRC}/src/idl_parser.cpp
         ${FLATBUFFERS_SRC}/src/idl_gen_text.cpp
         ${FLATBUFFERS_SRC}/src/reflection.cpp
diff -urN a/build_defs.bzl b/build_defs.bzl
--- a/build_defs.bzl	2021-05-10 18:45:16.000000000 +0000
+++ b/build_defs.bzl	2023-01-13 07:47:06.250227776 +0000
@@ -209,7 +209,7 @@
         Happy dependent Flatbuffering!
     '''
     output_headers = [
-        (out_prefix + "%s_generated.h") % (s.replace(".fbs", "").split("/")[-1])
+        (out_prefix + "%s_generated.h") % (s.replace(".fbs", "").split("/")[-1].split(":")[-1])
         for s in srcs
     ]
     reflection_name = "%s_reflection" % name if gen_reflections else ""
diff -urN a/conan/build.py b/conan/build.py
--- a/conan/build.py	2021-05-10 18:45:16.000000000 +0000
+++ b/conan/build.py	2023-01-13 07:47:11.633277490 +0000
@@ -6,16 +6,6 @@
 from cpt.packager import ConanMultiPackager
 
 
-def set_appveyor_environment():
-    if os.getenv("APPVEYOR") is not None:
-        compiler_version = os.getenv("CMAKE_VS_VERSION").split(" ")[0].replace('"', '')
-        os.environ["CONAN_VISUAL_VERSIONS"] = compiler_version
-        os.environ["CONAN_STABLE_BRANCH_PATTERN"] = "master"
-        ci_platform = os.getenv("Platform").replace('"', '')
-        ci_platform = "x86" if ci_platform == "x86" else "x86_64"
-        os.environ["CONAN_ARCHS"] = ci_platform
-        os.environ["CONAN_BUILD_TYPES"] = os.getenv("Configuration").replace('"', '')
-
 
 def get_branch():
     try:
@@ -56,7 +46,6 @@
     stable_branch_pattern = os.getenv("CONAN_STABLE_BRANCH_PATTERN", r"v\d+\.\d+\.\d+.*")
     test_folder = os.getenv("CPT_TEST_FOLDER", os.path.join("conan", "test_package"))
     upload_only_when_stable = os.getenv("CONAN_UPLOAD_ONLY_WHEN_STABLE", True)
-    set_appveyor_environment()
 
     builder = ConanMultiPackager(reference=get_reference(username),
                                  username=username,
diff -urN a/dart/CHANGELOG.md b/dart/CHANGELOG.md
--- a/dart/CHANGELOG.md	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/CHANGELOG.md	2023-01-13 07:47:12.215282865 +0000
@@ -1,4 +1,22 @@
-# CHANGELOG
+## 2.0.5
+
+- switch to null safety (#6696)
+- add Object APIs (pack/unpack) (#6682, #6723, #6846)
+- add custom builder buffer allocator support (#6711)
+- add `Builder.size()` - finished buffer size (#6403)
+- make `writeString()` argument non-nullable (#6737)
+- make tables fixed size (expect the number of fields when creating) (#6735)
+- make table deduplication optional (param `deduplicateTables`) (#6734)
+- change `Builder.reset()` to reuse an existing buffer (#6661)
+- change table building to assert() instead of exceptions (#6754)
+- optimize `writeString()` for ASCII (param `asciiOptimization`) (#6736)
+- change `StringReader` to make ASCII optimization optional (param `asciiOptimization`) (#6758)
+- change `[byte]` and `[ubyte]` representation to `dart:typed_data` `Int8List` and `Uint8List` (#6839)
+- rename `lowFinish()` to `buffer` getter (#6712)
+- fix `Builder._writeString()` - always write trailing zero byte (#6390)
+- fix `Builder.reset()` - clear vTables (#6386)
+- make sure added padding is zeroed, same as in C++ (#6716)
+- many performance improvements (#6755)
 
 ## 1.9.2
 
@@ -11,4 +29,4 @@
 
 ## 1.9.0
 
-- Initial release, supports Dart 1.x and many dev versions of Dart 2.x
\ No newline at end of file
+- Initial release, supports Dart 1.x and many dev versions of Dart 2.x
diff -urN a/dart/LICENSE b/dart/LICENSE
--- a/dart/LICENSE	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/LICENSE	2023-01-13 07:47:12.232283022 +0000
@@ -1,35 +1,3 @@
-The code in lib/flat_buffers.dart is based on code that was releases under the 
-following license:
-
-Copyright 2012, the Dart project authors. All rights reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-    * Neither the name of Google Inc. nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-To the extent permissible, the changes to that code and the other assets in 
-this package are licensed under the Apache2 license:
-
-
                                  Apache License
                            Version 2.0, January 2004
                         http://www.apache.org/licenses/
diff -urN a/dart/README.md b/dart/README.md
--- a/dart/README.md	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/README.md	2023-01-13 07:47:12.233283032 +0000
@@ -1,13 +1,23 @@
 # FlatBuffers for Dart
 
-This package is used to read and write FlatBuffer files in Dart.
+This package is used to read and write [FlatBuffers](https://google.github.io/flatbuffers/).
 
-Most consumers will want to use the [`flatc`](https://github.com/google/flatbuffers)
-compiler to generate Dart code from a FlatBuffers IDL schema.  For example, the
-`monster_my_game.sample_generated.dart` was generated with `flatc` from
-`monster.fbs` in the example folder. The generated classes can be used to read
-or write binary files that are interoperable with other languages and platforms
-supported by FlatBuffers, as illustrated in the `example.dart` in the
+Most consumers will want to use the [`flatc` - FlatBuffer compiler](https://github.com/google/flatbuffers) binary for your platform.
+You can find it in the `generator/{Platform}` directory of the [released package archive](https://pub.dev/packages/flat_buffers/versions/2.0.5.tar.gz).
+
+The FlatBuffer compiler `flatc` reads a FlatBuffers IDL schema and generates Dart code.
+The generated classes can be used to read or write binary data/files that are interoperable with
+other languages and platforms supported by FlatBuffers, as illustrated in the `example.dart` in the
 examples folder.
 
-Additional documentation and examples are available [at the FlatBuffers site](https://google.github.io/flatbuffers/index.html)
\ No newline at end of file
+For more details and documentation, head over to the official site and read the
+[Tutorial](https://google.github.io/flatbuffers/flatbuffers_guide_tutorial.html) and how to
+[use FlatBuffers in Dart](https://google.github.io/flatbuffers/flatbuffers_guide_use_dart.html).
+
+## Dart 2.0 notes
+Version 2.0.5 ships with it's own custom build of `flatc` because this is an extraordinary release to catch-up
+with FlatBuffers for other platforms. This generator can only generate dart code (to avoid generating code for other platforms which isn't released yet).
+On the other hand, the generated code still produces standard binary FlatBuffers compatible with other languages.
+In other words: only `flatc --dart ...` works with this generator, but your app will be able to produce and read standard binary (`Uint8List`) FlatBuffers that are fully compotible with other languages supporting FlatBuffers (e.g. Java, C++, ...).
+
+In the future a common `flatc` binary for all platforms would be shipped through GitHub release page instead.
diff -urN a/dart/analysis_options.yaml b/dart/analysis_options.yaml
--- a/dart/analysis_options.yaml	1970-01-01 00:00:00.000000000 +0000
+++ b/dart/analysis_options.yaml	2023-01-13 07:47:12.233283032 +0000
@@ -0,0 +1 @@
+include: package:lints/recommended.yaml
diff -urN a/dart/example/example.dart b/dart/example/example.dart
--- a/dart/example/example.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/example/example.dart	2023-01-13 07:47:12.663287002 +0000
@@ -15,7 +15,7 @@
  */
 
 import 'package:flat_buffers/flat_buffers.dart' as fb;
-import './monster_my_game.sample_generated.dart' as myGame;
+import './monster_my_game.sample_generated.dart' as my_game;
 
 // Example how to use FlatBuffers to create and read binary buffers.
 
@@ -25,27 +25,27 @@
 }
 
 void builderTest() {
-  final builder = new fb.Builder(initialSize: 1024);
-  final int weaponOneName = builder.writeString("Sword");
+  final builder = fb.Builder(initialSize: 1024);
+  final int? weaponOneName = builder.writeString("Sword");
   final int weaponOneDamage = 3;
 
-  final int weaponTwoName = builder.writeString("Axe");
+  final int? weaponTwoName = builder.writeString("Axe");
   final int weaponTwoDamage = 5;
 
-  final swordBuilder = new myGame.WeaponBuilder(builder)
+  final swordBuilder = my_game.WeaponBuilder(builder)
     ..begin()
     ..addNameOffset(weaponOneName)
     ..addDamage(weaponOneDamage);
   final int sword = swordBuilder.finish();
 
-  final axeBuilder = new myGame.WeaponBuilder(builder)
+  final axeBuilder = my_game.WeaponBuilder(builder)
     ..begin()
     ..addNameOffset(weaponTwoName)
     ..addDamage(weaponTwoDamage);
   final int axe = axeBuilder.finish();
 
   // Serialize a name for our monster, called "Orc".
-  final int name = builder.writeString('Orc');
+  final int? name = builder.writeString('Orc');
 
   // Create a list representing the inventory of the Orc. Each number
   // could correspond to an item that can be claimed after he is slain.
@@ -54,7 +54,7 @@
   final weapons = builder.writeList([sword, axe]);
 
   // Struct builders are very easy to reuse.
-  final vec3Builder = new myGame.Vec3Builder(builder);
+  final vec3Builder = my_game.Vec3Builder(builder);
 
   vec3Builder.finish(4.0, 5.0, 6.0);
   vec3Builder.finish(1.0, 2.0, 3.0);
@@ -62,21 +62,21 @@
   final int hp = 300;
   final int mana = 150;
 
-  final monster = new myGame.MonsterBuilder(builder)
+  final monster = my_game.MonsterBuilder(builder)
     ..begin()
     ..addNameOffset(name)
     ..addInventoryOffset(inventory)
     ..addWeaponsOffset(weapons)
-    ..addEquippedType(myGame.EquipmentTypeId.Weapon)
+    ..addEquippedType(my_game.EquipmentTypeId.Weapon)
     ..addEquippedOffset(axe)
     ..addHp(hp)
     ..addMana(mana)
     ..addPos(vec3Builder.finish(1.0, 2.0, 3.0))
-    ..addColor(myGame.Color.Red);
+    ..addColor(my_game.Color.Red);
 
   final int monsteroff = monster.finish();
-  final buffer = builder.finish(monsteroff);
-  if (verify(buffer)) {
+  builder.finish(monsteroff);
+  if (verify(builder.buffer)) {
     print(
         "The FlatBuffer was successfully created with a builder and verified!");
   }
@@ -85,17 +85,17 @@
 void objectBuilderTest() {
   // Create the builder here so we can use it for both weapons and equipped
   // the actual data will only be written to the buffer once.
-  var axe = new myGame.WeaponObjectBuilder(name: 'Axe', damage: 5);
+  var axe = my_game.WeaponObjectBuilder(name: 'Axe', damage: 5);
 
-  var monsterBuilder = new myGame.MonsterObjectBuilder(
-    pos: new myGame.Vec3ObjectBuilder(x: 1.0, y: 2.0, z: 3.0),
+  var monsterBuilder = my_game.MonsterObjectBuilder(
+    pos: my_game.Vec3ObjectBuilder(x: 1.0, y: 2.0, z: 3.0),
     mana: 150,
     hp: 300,
     name: 'Orc',
     inventory: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
-    color: myGame.Color.Red,
-    weapons: [new myGame.WeaponObjectBuilder(name: 'Sword', damage: 3), axe],
-    equippedType: myGame.EquipmentTypeId.Weapon,
+    color: my_game.Color.Red,
+    weapons: [my_game.WeaponObjectBuilder(name: 'Sword', damage: 3), axe],
+    equippedType: my_game.EquipmentTypeId.Weapon,
     equipped: axe,
   );
 
@@ -114,7 +114,7 @@
 
 bool verify(List<int> buffer) {
   // Get access to the root:
-  var monster = new myGame.Monster(buffer);
+  var monster = my_game.Monster(buffer);
 
   // Get and test some scalar types from the FlatBuffer.
   assert(monster.hp == 80);
@@ -122,31 +122,29 @@
   assert(monster.name == "MyMonster");
 
   // Get and test a field of the FlatBuffer's `struct`.
-  var pos = monster.pos;
-  assert(pos != null);
+  var pos = monster.pos!;
   assert(pos.z == 3.0);
 
   // Get a test an element from the `inventory` FlatBuffer's `vector`.
-  var inv = monster.inventory;
-  assert(inv != null);
+  var inv = monster.inventory!;
   assert(inv.length == 10);
   assert(inv[9] == 9);
 
   // Get and test the `weapons` FlatBuffers's `vector`.
-  var expected_weapon_names = ["Sword", "Axe"];
-  var expected_weapon_damages = [3, 5];
-  var weps = monster.weapons;
+  var expectedWeaponNames = ["Sword", "Axe"];
+  var expectedWeaponDamages = [3, 5];
+  var weps = monster.weapons!;
   for (int i = 0; i < weps.length; i++) {
-    assert(weps[i].name == expected_weapon_names[i]);
-    assert(weps[i].damage == expected_weapon_damages[i]);
+    assert(weps[i].name == expectedWeaponNames[i]);
+    assert(weps[i].damage == expectedWeaponDamages[i]);
   }
 
   // Get and test the `Equipment` union (`equipped` field).
-  assert(monster.equippedType.value == myGame.EquipmentTypeId.Weapon.value);
-  assert(monster.equippedType == myGame.EquipmentTypeId.Weapon);
+  assert(monster.equippedType!.value == my_game.EquipmentTypeId.Weapon.value);
+  assert(monster.equippedType == my_game.EquipmentTypeId.Weapon);
 
-  assert(monster.equipped is myGame.Weapon);
-  var equipped = monster.equipped as myGame.Weapon;
+  assert(monster.equipped is my_game.Weapon);
+  var equipped = monster.equipped as my_game.Weapon;
   assert(equipped.name == "Axe");
   assert(equipped.damage == 5);
 
diff -urN a/dart/example/monster_my_game.sample_generated.dart b/dart/example/monster_my_game.sample_generated.dart
--- a/dart/example/monster_my_game.sample_generated.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/example/monster_my_game.sample_generated.dart	2023-01-13 07:47:12.663287002 +0000
@@ -1,5 +1,5 @@
 // automatically generated by the FlatBuffers compiler, do not modify
-// ignore_for_file: unused_import, unused_field, unused_local_variable
+// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable
 
 library my_game.sample;
 
@@ -12,23 +12,29 @@
   const Color._(this.value);
 
   factory Color.fromValue(int value) {
-    if (value == null) value = 0;
-    if (!values.containsKey(value)) {
-      throw new StateError('Invalid value $value for bit flag enum Color');
+    final result = values[value];
+    if (result == null) {
+      throw StateError('Invalid value $value for bit flag enum Color');
     }
-    return values[value];
+    return result;
   }
 
+  static Color? _createOrNull(int? value) => 
+      value == null ? null : Color.fromValue(value);
+
   static const int minValue = 0;
   static const int maxValue = 2;
   static bool containsValue(int value) => values.containsKey(value);
 
-  static const Color Red = const Color._(0);
-  static const Color Green = const Color._(1);
-  static const Color Blue = const Color._(2);
-  static const Map<int,Color> values = {0: Red,1: Green,2: Blue,};
+  static const Color Red = Color._(0);
+  static const Color Green = Color._(1);
+  static const Color Blue = Color._(2);
+  static const Map<int, Color> values = {
+    0: Red,
+    1: Green,
+    2: Blue};
 
-  static const fb.Reader<Color> reader = const _ColorReader();
+  static const fb.Reader<Color> reader = _ColorReader();
 
   @override
   String toString() {
@@ -44,7 +50,7 @@
 
   @override
   Color read(fb.BufferContext bc, int offset) =>
-      new Color.fromValue(const fb.Int8Reader().read(bc, offset));
+      Color.fromValue(const fb.Int8Reader().read(bc, offset));
 }
 
 class EquipmentTypeId {
@@ -52,22 +58,27 @@
   const EquipmentTypeId._(this.value);
 
   factory EquipmentTypeId.fromValue(int value) {
-    if (value == null) value = 0;
-    if (!values.containsKey(value)) {
-      throw new StateError('Invalid value $value for bit flag enum EquipmentTypeId');
+    final result = values[value];
+    if (result == null) {
+      throw StateError('Invalid value $value for bit flag enum EquipmentTypeId');
     }
-    return values[value];
+    return result;
   }
 
+  static EquipmentTypeId? _createOrNull(int? value) => 
+      value == null ? null : EquipmentTypeId.fromValue(value);
+
   static const int minValue = 0;
   static const int maxValue = 1;
   static bool containsValue(int value) => values.containsKey(value);
 
-  static const EquipmentTypeId NONE = const EquipmentTypeId._(0);
-  static const EquipmentTypeId Weapon = const EquipmentTypeId._(1);
-  static const Map<int,EquipmentTypeId> values = {0: NONE,1: Weapon,};
+  static const EquipmentTypeId NONE = EquipmentTypeId._(0);
+  static const EquipmentTypeId Weapon = EquipmentTypeId._(1);
+  static const Map<int, EquipmentTypeId> values = {
+    0: NONE,
+    1: Weapon};
 
-  static const fb.Reader<EquipmentTypeId> reader = const _EquipmentTypeIdReader();
+  static const fb.Reader<EquipmentTypeId> reader = _EquipmentTypeIdReader();
 
   @override
   String toString() {
@@ -83,13 +94,13 @@
 
   @override
   EquipmentTypeId read(fb.BufferContext bc, int offset) =>
-      new EquipmentTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
+      EquipmentTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
 }
 
 class Vec3 {
   Vec3._(this._bc, this._bcOffset);
 
-  static const fb.Reader<Vec3> reader = const _Vec3Reader();
+  static const fb.Reader<Vec3> reader = _Vec3Reader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -112,13 +123,11 @@
 
   @override
   Vec3 createObject(fb.BufferContext bc, int offset) => 
-    new Vec3._(bc, offset);
+    Vec3._(bc, offset);
 }
 
 class Vec3Builder {
-  Vec3Builder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  Vec3Builder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
@@ -137,9 +146,9 @@
   final double _z;
 
   Vec3ObjectBuilder({
-    double x,
-    double y,
-    double z,
+    required double x,
+    required double y,
+    required double z,
   })
       : _x = x,
         _y = y,
@@ -147,10 +156,7 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
+  int finish(fb.Builder fbBuilder) {
     fbBuilder.putFloat32(_z);
     fbBuilder.putFloat32(_y);
     fbBuilder.putFloat32(_x);
@@ -159,39 +165,39 @@
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class Monster {
   Monster._(this._bc, this._bcOffset);
   factory Monster(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<Monster> reader = const _MonsterReader();
+  static const fb.Reader<Monster> reader = _MonsterReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
 
-  Vec3 get pos => Vec3.reader.vTableGet(_bc, _bcOffset, 4, null);
+  Vec3? get pos => Vec3.reader.vTableGetNullable(_bc, _bcOffset, 4);
   int get mana => const fb.Int16Reader().vTableGet(_bc, _bcOffset, 6, 150);
   int get hp => const fb.Int16Reader().vTableGet(_bc, _bcOffset, 8, 100);
-  String get name => const fb.StringReader().vTableGet(_bc, _bcOffset, 10, null);
-  List<int> get inventory => const fb.ListReader<int>(const fb.Uint8Reader()).vTableGet(_bc, _bcOffset, 14, null);
-  Color get color => new Color.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 16, 2));
-  List<Weapon> get weapons => const fb.ListReader<Weapon>(Weapon.reader).vTableGet(_bc, _bcOffset, 18, null);
-  EquipmentTypeId get equippedType => new EquipmentTypeId.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 20, 0));
+  String? get name => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 10);
+  List<int>? get inventory => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 14);
+  Color get color => Color.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 16, 2));
+  List<Weapon>? get weapons => const fb.ListReader<Weapon>(Weapon.reader).vTableGetNullable(_bc, _bcOffset, 18);
+  EquipmentTypeId? get equippedType => EquipmentTypeId._createOrNull(const fb.Uint8Reader().vTableGetNullable(_bc, _bcOffset, 20));
   dynamic get equipped {
     switch (equippedType?.value) {
-      case 1: return Weapon.reader.vTableGet(_bc, _bcOffset, 22, null);
+      case 1: return Weapon.reader.vTableGetNullable(_bc, _bcOffset, 22);
       default: return null;
     }
   }
-  List<Vec3> get path => const fb.ListReader<Vec3>(Vec3.reader).vTableGet(_bc, _bcOffset, 24, null);
+  List<Vec3>? get path => const fb.ListReader<Vec3>(Vec3.reader).vTableGetNullable(_bc, _bcOffset, 24);
 
   @override
   String toString() {
@@ -204,57 +210,55 @@
 
   @override
   Monster createObject(fb.BufferContext bc, int offset) => 
-    new Monster._(bc, offset);
+    Monster._(bc, offset);
 }
 
 class MonsterBuilder {
-  MonsterBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  MonsterBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
   void begin() {
-    fbBuilder.startTable();
+    fbBuilder.startTable(10);
   }
 
   int addPos(int offset) {
     fbBuilder.addStruct(0, offset);
     return fbBuilder.offset;
   }
-  int addMana(int mana) {
+  int addMana(int? mana) {
     fbBuilder.addInt16(1, mana);
     return fbBuilder.offset;
   }
-  int addHp(int hp) {
+  int addHp(int? hp) {
     fbBuilder.addInt16(2, hp);
     return fbBuilder.offset;
   }
-  int addNameOffset(int offset) {
+  int addNameOffset(int? offset) {
     fbBuilder.addOffset(3, offset);
     return fbBuilder.offset;
   }
-  int addInventoryOffset(int offset) {
+  int addInventoryOffset(int? offset) {
     fbBuilder.addOffset(5, offset);
     return fbBuilder.offset;
   }
-  int addColor(Color color) {
+  int addColor(Color? color) {
     fbBuilder.addInt8(6, color?.value);
     return fbBuilder.offset;
   }
-  int addWeaponsOffset(int offset) {
+  int addWeaponsOffset(int? offset) {
     fbBuilder.addOffset(7, offset);
     return fbBuilder.offset;
   }
-  int addEquippedType(EquipmentTypeId equippedType) {
+  int addEquippedType(EquipmentTypeId? equippedType) {
     fbBuilder.addUint8(8, equippedType?.value);
     return fbBuilder.offset;
   }
-  int addEquippedOffset(int offset) {
+  int addEquippedOffset(int? offset) {
     fbBuilder.addOffset(9, offset);
     return fbBuilder.offset;
   }
-  int addPathOffset(int offset) {
+  int addPathOffset(int? offset) {
     fbBuilder.addOffset(10, offset);
     return fbBuilder.offset;
   }
@@ -265,28 +269,28 @@
 }
 
 class MonsterObjectBuilder extends fb.ObjectBuilder {
-  final Vec3ObjectBuilder _pos;
-  final int _mana;
-  final int _hp;
-  final String _name;
-  final List<int> _inventory;
-  final Color _color;
-  final List<WeaponObjectBuilder> _weapons;
-  final EquipmentTypeId _equippedType;
+  final Vec3ObjectBuilder? _pos;
+  final int? _mana;
+  final int? _hp;
+  final String? _name;
+  final List<int>? _inventory;
+  final Color? _color;
+  final List<WeaponObjectBuilder>? _weapons;
+  final EquipmentTypeId? _equippedType;
   final dynamic _equipped;
-  final List<Vec3ObjectBuilder> _path;
+  final List<Vec3ObjectBuilder>? _path;
 
   MonsterObjectBuilder({
-    Vec3ObjectBuilder pos,
-    int mana,
-    int hp,
-    String name,
-    List<int> inventory,
-    Color color,
-    List<WeaponObjectBuilder> weapons,
-    EquipmentTypeId equippedType,
+    Vec3ObjectBuilder? pos,
+    int? mana,
+    int? hp,
+    String? name,
+    List<int>? inventory,
+    Color? color,
+    List<WeaponObjectBuilder>? weapons,
+    EquipmentTypeId? equippedType,
     dynamic equipped,
-    List<Vec3ObjectBuilder> path,
+    List<Vec3ObjectBuilder>? path,
   })
       : _pos = pos,
         _mana = mana,
@@ -301,68 +305,53 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-    final int nameOffset = fbBuilder.writeString(_name);
-    final int inventoryOffset = _inventory?.isNotEmpty == true
-        ? fbBuilder.writeListUint8(_inventory)
-        : null;
-    final int weaponsOffset = _weapons?.isNotEmpty == true
-        ? fbBuilder.writeList(_weapons.map((b) => b.getOrCreateOffset(fbBuilder)).toList())
-        : null;
-    final int equippedOffset = _equipped?.getOrCreateOffset(fbBuilder);
-    final int pathOffset = _path?.isNotEmpty == true
-        ? fbBuilder.writeListOfStructs(_path)
-        : null;
-
-    fbBuilder.startTable();
+  int finish(fb.Builder fbBuilder) {
+    final int? nameOffset = _name == null ? null
+        : fbBuilder.writeString(_name!);
+    final int? inventoryOffset = _inventory == null ? null
+        : fbBuilder.writeListUint8(_inventory!);
+    final int? weaponsOffset = _weapons == null ? null
+        : fbBuilder.writeList(_weapons!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
+    final int? equippedOffset = _equipped?.getOrCreateOffset(fbBuilder);
+    final int? pathOffset = _path == null ? null
+        : fbBuilder.writeListOfStructs(_path!);
+    fbBuilder.startTable(10);
     if (_pos != null) {
-      fbBuilder.addStruct(0, _pos.finish(fbBuilder));
+      fbBuilder.addStruct(0, _pos!.finish(fbBuilder));
     }
     fbBuilder.addInt16(1, _mana);
     fbBuilder.addInt16(2, _hp);
-    if (nameOffset != null) {
-      fbBuilder.addOffset(3, nameOffset);
-    }
-    if (inventoryOffset != null) {
-      fbBuilder.addOffset(5, inventoryOffset);
-    }
+    fbBuilder.addOffset(3, nameOffset);
+    fbBuilder.addOffset(5, inventoryOffset);
     fbBuilder.addInt8(6, _color?.value);
-    if (weaponsOffset != null) {
-      fbBuilder.addOffset(7, weaponsOffset);
-    }
+    fbBuilder.addOffset(7, weaponsOffset);
     fbBuilder.addUint8(8, _equippedType?.value);
-    if (equippedOffset != null) {
-      fbBuilder.addOffset(9, equippedOffset);
-    }
-    if (pathOffset != null) {
-      fbBuilder.addOffset(10, pathOffset);
-    }
+    fbBuilder.addOffset(9, equippedOffset);
+    fbBuilder.addOffset(10, pathOffset);
     return fbBuilder.endTable();
   }
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class Weapon {
   Weapon._(this._bc, this._bcOffset);
   factory Weapon(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<Weapon> reader = const _WeaponReader();
+  static const fb.Reader<Weapon> reader = _WeaponReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
 
-  String get name => const fb.StringReader().vTableGet(_bc, _bcOffset, 4, null);
+  String? get name => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
   int get damage => const fb.Int16Reader().vTableGet(_bc, _bcOffset, 6, 0);
 
   @override
@@ -376,25 +365,23 @@
 
   @override
   Weapon createObject(fb.BufferContext bc, int offset) => 
-    new Weapon._(bc, offset);
+    Weapon._(bc, offset);
 }
 
 class WeaponBuilder {
-  WeaponBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  WeaponBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
   void begin() {
-    fbBuilder.startTable();
+    fbBuilder.startTable(2);
   }
 
-  int addNameOffset(int offset) {
+  int addNameOffset(int? offset) {
     fbBuilder.addOffset(0, offset);
     return fbBuilder.offset;
   }
-  int addDamage(int damage) {
+  int addDamage(int? damage) {
     fbBuilder.addInt16(1, damage);
     return fbBuilder.offset;
   }
@@ -405,36 +392,32 @@
 }
 
 class WeaponObjectBuilder extends fb.ObjectBuilder {
-  final String _name;
-  final int _damage;
+  final String? _name;
+  final int? _damage;
 
   WeaponObjectBuilder({
-    String name,
-    int damage,
+    String? name,
+    int? damage,
   })
       : _name = name,
         _damage = damage;
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-    final int nameOffset = fbBuilder.writeString(_name);
-
-    fbBuilder.startTable();
-    if (nameOffset != null) {
-      fbBuilder.addOffset(0, nameOffset);
-    }
+  int finish(fb.Builder fbBuilder) {
+    final int? nameOffset = _name == null ? null
+        : fbBuilder.writeString(_name!);
+    fbBuilder.startTable(2);
+    fbBuilder.addOffset(0, nameOffset);
     fbBuilder.addInt16(1, _damage);
     return fbBuilder.endTable();
   }
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
diff -urN a/dart/lib/flat_buffers.dart b/dart/lib/flat_buffers.dart
--- a/dart/lib/flat_buffers.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/lib/flat_buffers.dart	2023-01-13 07:47:11.787278913 +0000
@@ -22,69 +22,70 @@
 ///
 /// This callback is used by other struct's `finish` methods to write the nested
 /// struct's fields inline.
-typedef void StructBuilder();
+typedef StructBuilder = void Function();
 
 /// Buffer with data and some context about it.
 class BufferContext {
   final ByteData _buffer;
 
-  factory BufferContext.fromBytes(List<int> byteList) {
-    Uint8List uint8List = _asUint8List(byteList);
-    ByteData buf = new ByteData.view(uint8List.buffer, uint8List.offsetInBytes);
-    return new BufferContext._(buf);
-  }
+  ByteData get buffer => _buffer;
 
-  BufferContext._(this._buffer);
+  /// Create from a FlatBuffer represented by a list of bytes (uint8).
+  factory BufferContext.fromBytes(List<int> byteList) =>
+      BufferContext(byteList is Uint8List
+          ? byteList.buffer.asByteData(byteList.offsetInBytes)
+          : ByteData.view(Uint8List.fromList(byteList).buffer));
 
-  int derefObject(int offset) {
-    return offset + _getUint32(offset);
-  }
+  /// Create from a FlatBuffer represented by ByteData.
+  BufferContext(this._buffer);
+
+  @pragma('vm:prefer-inline')
+  int derefObject(int offset) => offset + _getUint32(offset);
 
-  Uint8List _asUint8LIst(int offset, int length) =>
+  @pragma('vm:prefer-inline')
+  Uint8List _asUint8List(int offset, int length) =>
       _buffer.buffer.asUint8List(_buffer.offsetInBytes + offset, length);
 
-  double _getFloat64(int offset) =>
-      _buffer.getFloat64(offset, Endian.little);
+  @pragma('vm:prefer-inline')
+  double _getFloat64(int offset) => _buffer.getFloat64(offset, Endian.little);
 
-  double _getFloat32(int offset) =>
-      _buffer.getFloat32(offset, Endian.little);
+  @pragma('vm:prefer-inline')
+  double _getFloat32(int offset) => _buffer.getFloat32(offset, Endian.little);
 
-  int _getInt64(int offset) =>
-      _buffer.getInt64(offset, Endian.little);
+  @pragma('vm:prefer-inline')
+  int _getInt64(int offset) => _buffer.getInt64(offset, Endian.little);
 
-  int _getInt32(int offset) =>
-      _buffer.getInt32(offset, Endian.little);
+  @pragma('vm:prefer-inline')
+  int _getInt32(int offset) => _buffer.getInt32(offset, Endian.little);
 
-  int _getInt16(int offset) =>
-      _buffer.getInt16(offset, Endian.little);
+  @pragma('vm:prefer-inline')
+  int _getInt16(int offset) => _buffer.getInt16(offset, Endian.little);
 
+  @pragma('vm:prefer-inline')
   int _getInt8(int offset) => _buffer.getInt8(offset);
 
-  int _getUint64(int offset) =>
-      _buffer.getUint64(offset, Endian.little);
+  @pragma('vm:prefer-inline')
+  int _getUint64(int offset) => _buffer.getUint64(offset, Endian.little);
 
-  int _getUint32(int offset) =>
-      _buffer.getUint32(offset, Endian.little);
+  @pragma('vm:prefer-inline')
+  int _getUint32(int offset) => _buffer.getUint32(offset, Endian.little);
 
-  int _getUint16(int offset) =>
-      _buffer.getUint16(offset, Endian.little);
+  @pragma('vm:prefer-inline')
+  int _getUint16(int offset) => _buffer.getUint16(offset, Endian.little);
 
+  @pragma('vm:prefer-inline')
   int _getUint8(int offset) => _buffer.getUint8(offset);
+}
 
-  /// If the [byteList] is already a [Uint8List] return it.
-  /// Otherwise return a [Uint8List] copy of the [byteList].
-  static Uint8List _asUint8List(List<int> byteList) {
-    if (byteList is Uint8List) {
-      return byteList;
-    } else {
-      return new Uint8List.fromList(byteList);
-    }
-  }
+/// Interface implemented by the "object-api" classes (ending with "T").
+abstract class Packable {
+  /// Serialize the object using the given builder, returning the offset.
+  int pack(Builder fbBuilder);
 }
 
 /// Class implemented by typed builders generated by flatc.
 abstract class ObjectBuilder {
-  int _firstOffset;
+  int? _firstOffset;
 
   /// Can be used to write the data represented by this builder to the [Builder]
   /// and reuse the offset created in multiple tables.
@@ -94,7 +95,7 @@
   /// first call to this method.
   int getOrCreateOffset(Builder fbBuilder) {
     _firstOffset ??= finish(fbBuilder);
-    return _firstOffset;
+    return _firstOffset!;
   }
 
   /// Writes the data in this helper to the [Builder].
@@ -107,34 +108,39 @@
 
 /// Class that helps building flat buffers.
 class Builder {
+  bool _finished = false;
+
   final int initialSize;
 
   /// The list of existing VTable(s).
-  //final List<_VTable> _vTables = <_VTable>[];
-  final List<int> _vTables = <int>[];
+  final List<int> _vTables;
+
+  final bool deduplicateTables;
 
   ByteData _buf;
 
+  final Allocator _allocator;
+
   /// The maximum alignment that has been seen so far.  If [_buf] has to be
   /// reallocated in the future (to insert room at its start for more bytes) the
   /// reallocation will need to be a multiple of this many bytes.
-  int _maxAlign;
+  int _maxAlign = 1;
 
   /// The number of bytes that have been written to the buffer so far.  The
   /// most recently written byte is this many bytes from the end of [_buf].
-  int _tail;
+  int _tail = 0;
 
   /// The location of the end of the current table, measured in bytes from the
-  /// end of [_buf], or `null` if a table is not currently being built.
-  int _currentTableEndTail;
+  /// end of [_buf].
+  int _currentTableEndTail = 0;
 
-  _VTable _currentVTable;
+  _VTable? _currentVTable;
 
   /// Map containing all strings that have been written so far.  This allows us
   /// to avoid duplicating strings.
   ///
   /// Allocated only if `internStrings` is set to true on the constructor.
-  Map<String, int> _strings;
+  Map<String, int>? _strings;
 
   /// Creates a new FlatBuffers Builder.
   ///
@@ -142,21 +148,28 @@
   /// automatically grow the array if/as needed.  `internStrings`, if set to
   /// true, will cause [writeString] to pool strings in the buffer so that
   /// identical strings will always use the same offset in tables.
-  Builder({this.initialSize: 1024, bool internStrings = false}) {
-    if (internStrings == true) {
-      _strings = new Map<String, int>();
+  Builder({
+    this.initialSize = 1024,
+    bool internStrings = false,
+    Allocator allocator = const DefaultAllocator(),
+    this.deduplicateTables = true,
+  })  : _allocator = allocator,
+        _buf = allocator.allocate(initialSize),
+        _vTables = deduplicateTables ? [] : const [] {
+    if (internStrings) {
+      _strings = <String, int>{};
     }
-    reset();
   }
 
   /// Calculate the finished buffer size (aligned).
-  int size() => _tail + ((-_tail) % _maxAlign);
+  @pragma('vm:prefer-inline')
+  int size() => _tail + ((-_tail) & (_maxAlign - 1));
 
   /// Add the [field] with the given boolean [value].  The field is not added if
   /// the [value] is equal to [def].  Booleans are stored as 8-bit fields with
   /// `0` for `false` and `1` for `true`.
-  void addBool(int field, bool value, [bool def]) {
-    _ensureCurrentVTable();
+  void addBool(int field, bool? value, [bool? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofUint8, 1);
       _trackField(field);
@@ -166,179 +179,183 @@
 
   /// Add the [field] with the given 32-bit signed integer [value].  The field is
   /// not added if the [value] is equal to [def].
-  void addInt32(int field, int value, [int def]) {
-    _ensureCurrentVTable();
+  void addInt32(int field, int? value, [int? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofInt32, 1);
       _trackField(field);
-      _setInt32AtTail(_buf, _tail, value);
+      _setInt32AtTail(_tail, value);
     }
   }
 
   /// Add the [field] with the given 32-bit signed integer [value].  The field is
   /// not added if the [value] is equal to [def].
-  void addInt16(int field, int value, [int def]) {
-    _ensureCurrentVTable();
+  void addInt16(int field, int? value, [int? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofInt16, 1);
       _trackField(field);
-      _setInt16AtTail(_buf, _tail, value);
+      _setInt16AtTail(_tail, value);
     }
   }
 
   /// Add the [field] with the given 8-bit signed integer [value].  The field is
   /// not added if the [value] is equal to [def].
-  void addInt8(int field, int value, [int def]) {
-    _ensureCurrentVTable();
+  void addInt8(int field, int? value, [int? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofInt8, 1);
       _trackField(field);
-      _setInt8AtTail(_buf, _tail, value);
+      _setInt8AtTail(_tail, value);
     }
   }
 
   void addStruct(int field, int offset) {
-    _ensureCurrentVTable();
+    assert(_inVTable);
     _trackField(field);
-    _currentVTable.addField(field, offset);
+    _currentVTable!.addField(field, offset);
   }
 
   /// Add the [field] referencing an object with the given [offset].
-  void addOffset(int field, int offset) {
-    _ensureCurrentVTable();
+  void addOffset(int field, int? offset) {
+    assert(_inVTable);
     if (offset != null) {
       _prepare(_sizeofUint32, 1);
       _trackField(field);
-      _setUint32AtTail(_buf, _tail, _tail - offset);
+      _setUint32AtTail(_tail, _tail - offset);
     }
   }
 
   /// Add the [field] with the given 32-bit unsigned integer [value].  The field
   /// is not added if the [value] is equal to [def].
-  void addUint32(int field, int value, [int def]) {
-    _ensureCurrentVTable();
+  void addUint32(int field, int? value, [int? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofUint32, 1);
       _trackField(field);
-      _setUint32AtTail(_buf, _tail, value);
+      _setUint32AtTail(_tail, value);
     }
   }
 
   /// Add the [field] with the given 32-bit unsigned integer [value].  The field
   /// is not added if the [value] is equal to [def].
-  void addUint16(int field, int value, [int def]) {
-    _ensureCurrentVTable();
+  void addUint16(int field, int? value, [int? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofUint16, 1);
       _trackField(field);
-      _setUint16AtTail(_buf, _tail, value);
+      _setUint16AtTail(_tail, value);
     }
   }
 
   /// Add the [field] with the given 8-bit unsigned integer [value].  The field
   /// is not added if the [value] is equal to [def].
-  void addUint8(int field, int value, [int def]) {
-    _ensureCurrentVTable();
+  void addUint8(int field, int? value, [int? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofUint8, 1);
       _trackField(field);
-      _setUint8AtTail(_buf, _tail, value);
+      _setUint8AtTail(_tail, value);
     }
   }
 
   /// Add the [field] with the given 32-bit float [value].  The field
   /// is not added if the [value] is equal to [def].
-  void addFloat32(int field, double value, [double def]) {
-    _ensureCurrentVTable();
+  void addFloat32(int field, double? value, [double? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofFloat32, 1);
       _trackField(field);
-      _setFloat32AtTail(_buf, _tail, value);
+      _setFloat32AtTail(_tail, value);
     }
   }
 
   /// Add the [field] with the given 64-bit double [value].  The field
   /// is not added if the [value] is equal to [def].
-  void addFloat64(int field, double value, [double def]) {
-    _ensureCurrentVTable();
+  void addFloat64(int field, double? value, [double? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofFloat64, 1);
       _trackField(field);
-      _setFloat64AtTail(_buf, _tail, value);
+      _setFloat64AtTail(_tail, value);
     }
   }
 
   /// Add the [field] with the given 64-bit unsigned integer [value].  The field
   /// is not added if the [value] is equal to [def].
-  void addUint64(int field, int value, [double def]) {
-    _ensureCurrentVTable();
+  void addUint64(int field, int? value, [double? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofUint64, 1);
       _trackField(field);
-      _setUint64AtTail(_buf, _tail, value);
+      _setUint64AtTail(_tail, value);
     }
   }
 
   /// Add the [field] with the given 64-bit unsigned integer [value].  The field
   /// is not added if the [value] is equal to [def].
-  void addInt64(int field, int value, [double def]) {
-    _ensureCurrentVTable();
+  void addInt64(int field, int? value, [double? def]) {
+    assert(_inVTable);
     if (value != null && value != def) {
       _prepare(_sizeofInt64, 1);
       _trackField(field);
-      _setInt64AtTail(_buf, _tail, value);
+      _setInt64AtTail(_tail, value);
     }
   }
 
   /// End the current table and return its offset.
   int endTable() {
-    if (_currentVTable == null) {
-      throw new StateError('Start a table before ending it.');
-    }
+    assert(_inVTable);
     // Prepare for writing the VTable.
     _prepare(_sizeofInt32, 1);
-    int tableTail = _tail;
+    var tableTail = _tail;
     // Prepare the size of the current table.
-    _currentVTable.tableSize = tableTail - _currentTableEndTail;
+    final currentVTable = _currentVTable!;
+    currentVTable.tableSize = tableTail - _currentTableEndTail;
     // Prepare the VTable to use for the current table.
-    int vTableTail;
+    int? vTableTail;
     {
-      _currentVTable.computeFieldOffsets(tableTail);
+      currentVTable.computeFieldOffsets(tableTail);
+
       // Try to find an existing compatible VTable.
-      // Search backward - more likely to have recently used one
-      for (int i = _vTables.length - 1; i >= 0; i--) {
-        final int vt2Offset = _vTables[i];
-        final int vt2Start = _buf.lengthInBytes - vt2Offset;
-        final int vt2Size = _buf.getUint16(vt2Start, Endian.little);
-
-        if (_currentVTable._vTableSize == vt2Size &&
-            _currentVTable._offsetsMatch(vt2Start, _buf)) {
-          vTableTail = vt2Offset;
-          break;
+      if (deduplicateTables) {
+        // Search backward - more likely to have recently used one
+        for (var i = _vTables.length - 1; i >= 0; i--) {
+          final vt2Offset = _vTables[i];
+          final vt2Start = _buf.lengthInBytes - vt2Offset;
+          final vt2Size = _buf.getUint16(vt2Start, Endian.little);
+
+          if (currentVTable._vTableSize == vt2Size &&
+              currentVTable._offsetsMatch(vt2Start, _buf)) {
+            vTableTail = vt2Offset;
+            break;
+          }
         }
       }
+
       // Write a new VTable.
       if (vTableTail == null) {
-        _prepare(_sizeofUint16, _currentVTable.numOfUint16);
+        _prepare(_sizeofUint16, _currentVTable!.numOfUint16);
         vTableTail = _tail;
-        _currentVTable.tail = vTableTail;
-        _currentVTable.output(_buf, _buf.lengthInBytes - _tail);
-        _vTables.add(_currentVTable.tail);
+        currentVTable.tail = vTableTail;
+        currentVTable.output(_buf, _buf.lengthInBytes - _tail);
+        if (deduplicateTables) _vTables.add(currentVTable.tail);
       }
     }
     // Set the VTable offset.
-    _setInt32AtTail(_buf, tableTail, vTableTail - tableTail);
+    _setInt32AtTail(tableTail, vTableTail - tableTail);
     // Done with this table.
     _currentVTable = null;
     return tableTail;
   }
 
-  /// This method low level method can be used to return a raw piece of the buffer
-  /// after using the the put* methods.
-  ///
-  /// Most clients should prefer calling [finish].
-  Uint8List lowFinish() {
-    return _buf.buffer.asUint8List(_buf.lengthInBytes - size());
+  /// Returns the finished buffer. You must call [finish] before accessing this.
+  @pragma('vm:prefer-inline')
+  Uint8List get buffer {
+    assert(_finished);
+    final finishedSize = size();
+    return _buf.buffer
+        .asUint8List(_buf.lengthInBytes - finishedSize, finishedSize);
   }
 
   /// Finish off the creation of the buffer.  The given [offset] is used as the
@@ -346,17 +363,26 @@
   /// written object.  If [fileIdentifier] is specified (and not `null`), it is
   /// interpreted as a 4-byte Latin-1 encoded string that should be placed at
   /// bytes 4-7 of the file.
-  Uint8List finish(int offset, [String fileIdentifier]) {
-    _prepare(max(_sizeofUint32, _maxAlign), fileIdentifier == null ? 1 : 2);
+  void finish(int offset, [String? fileIdentifier]) {
+    final sizeBeforePadding = size();
+    final requiredBytes = _sizeofUint32 * (fileIdentifier == null ? 1 : 2);
+    _prepare(max(requiredBytes, _maxAlign), 1);
     final finishedSize = size();
-    _setUint32AtTail(_buf, finishedSize, finishedSize - offset);
+    _setUint32AtTail(finishedSize, finishedSize - offset);
     if (fileIdentifier != null) {
-      for (int i = 0; i < 4; i++) {
-        _setUint8AtTail(_buf, finishedSize - _sizeofUint32 - i,
-            fileIdentifier.codeUnitAt(i));
+      for (var i = 0; i < 4; i++) {
+        _setUint8AtTail(
+            finishedSize - _sizeofUint32 - i, fileIdentifier.codeUnitAt(i));
       }
     }
-    return _buf.buffer.asUint8List(_buf.lengthInBytes - finishedSize);
+
+    // zero out the added padding
+    for (var i = sizeBeforePadding + 1;
+        i <= finishedSize - requiredBytes;
+        i++) {
+      _setUint8AtTail(i, 0);
+    }
+    _finished = true;
   }
 
   /// Writes a Float64 to the tail of the buffer after preparing space for it.
@@ -364,7 +390,7 @@
   /// Updates the [offset] pointer.  This method is intended for use when writing structs to the buffer.
   void putFloat64(double value) {
     _prepare(_sizeofFloat64, 1);
-    _setFloat32AtTail(_buf, _tail, value);
+    _setFloat32AtTail(_tail, value);
   }
 
   /// Writes a Float32 to the tail of the buffer after preparing space for it.
@@ -372,7 +398,7 @@
   /// Updates the [offset] pointer.  This method is intended for use when writing structs to the buffer.
   void putFloat32(double value) {
     _prepare(_sizeofFloat32, 1);
-    _setFloat32AtTail(_buf, _tail, value);
+    _setFloat32AtTail(_tail, value);
   }
 
   /// Writes a Int64 to the tail of the buffer after preparing space for it.
@@ -380,7 +406,7 @@
   /// Updates the [offset] pointer.  This method is intended for use when writing structs to the buffer.
   void putInt64(int value) {
     _prepare(_sizeofInt64, 1);
-    _setInt64AtTail(_buf, _tail, value);
+    _setInt64AtTail(_tail, value);
   }
 
   /// Writes a Uint32 to the tail of the buffer after preparing space for it.
@@ -388,7 +414,7 @@
   /// Updates the [offset] pointer.  This method is intended for use when writing structs to the buffer.
   void putInt32(int value) {
     _prepare(_sizeofInt32, 1);
-    _setInt32AtTail(_buf, _tail, value);
+    _setInt32AtTail(_tail, value);
   }
 
   /// Writes a Uint16 to the tail of the buffer after preparing space for it.
@@ -396,7 +422,7 @@
   /// Updates the [offset] pointer.  This method is intended for use when writing structs to the buffer.
   void putInt16(int value) {
     _prepare(_sizeofInt16, 1);
-    _setInt16AtTail(_buf, _tail, value);
+    _setInt16AtTail(_tail, value);
   }
 
   /// Writes a Uint8 to the tail of the buffer after preparing space for it.
@@ -412,7 +438,7 @@
   /// Updates the [offset] pointer.  This method is intended for use when writing structs to the buffer.
   void putUint64(int value) {
     _prepare(_sizeofUint64, 1);
-    _setUint64AtTail(_buf, _tail, value);
+    _setUint64AtTail(_tail, value);
   }
 
   /// Writes a Uint32 to the tail of the buffer after preparing space for it.
@@ -420,7 +446,7 @@
   /// Updates the [offset] pointer.  This method is intended for use when writing structs to the buffer.
   void putUint32(int value) {
     _prepare(_sizeofUint32, 1);
-    _setUint32AtTail(_buf, _tail, value);
+    _setUint32AtTail(_tail, value);
   }
 
   /// Writes a Uint16 to the tail of the buffer after preparing space for it.
@@ -428,7 +454,7 @@
   /// Updates the [offset] pointer.  This method is intended for use when writing structs to the buffer.
   void putUint16(int value) {
     _prepare(_sizeofUint16, 1);
-    _setUint16AtTail(_buf, _tail, value);
+    _setUint16AtTail(_tail, value);
   }
 
   /// Writes a Uint8 to the tail of the buffer after preparing space for it.
@@ -441,22 +467,20 @@
 
   /// Reset the builder and make it ready for filling a new buffer.
   void reset() {
-    _buf = new ByteData(initialSize);
+    _finished = false;
     _maxAlign = 1;
     _tail = 0;
     _currentVTable = null;
-    _vTables.clear();
+    if (deduplicateTables) _vTables.clear();
     if (_strings != null) {
-      _strings = new Map<String, int>();
+      _strings = <String, int>{};
     }
   }
 
-  /// Start a new table.  Must be finished with [endTable] invocation.
-  void startTable() {
-    if (_currentVTable != null) {
-      throw new StateError('Inline tables are not supported.');
-    }
-    _currentVTable = new _VTable();
+  /// Start a new table. Must be finished with [endTable] invocation.
+  void startTable(int numFields) {
+    assert(!_inVTable); // Inline tables are not supported.
+    _currentVTable = _VTable(numFields);
     _currentTableEndTail = _tail;
   }
 
@@ -470,8 +494,8 @@
 
   /// Writes a list of Structs to the buffer, returning the offset
   int writeListOfStructs(List<ObjectBuilder> structBuilders) {
-    _ensureNoVTable();
-    for (int i = structBuilders.length - 1; i >= 0; i--) {
+    assert(!_inVTable);
+    for (var i = structBuilders.length - 1; i >= 0; i--) {
       structBuilders[i].finish(this);
     }
     return endStructVector(structBuilders.length);
@@ -479,14 +503,14 @@
 
   /// Write the given list of [values].
   int writeList(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofUint32, 1 + values.length);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setUint32AtTail(_buf, tail, tail - value);
+    for (var value in values) {
+      _setUint32AtTail(tail, tail - value);
       tail -= _sizeofUint32;
     }
     return result;
@@ -494,14 +518,14 @@
 
   /// Write the given list of 64-bit float [values].
   int writeListFloat64(List<double> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofFloat64, values.length, additionalBytes: _sizeofUint32);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (double value in values) {
-      _setFloat64AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setFloat64AtTail(tail, value);
       tail -= _sizeofFloat64;
     }
     return result;
@@ -509,14 +533,14 @@
 
   /// Write the given list of 32-bit float [values].
   int writeListFloat32(List<double> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofFloat32, 1 + values.length);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (double value in values) {
-      _setFloat32AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setFloat32AtTail(tail, value);
       tail -= _sizeofFloat32;
     }
     return result;
@@ -524,14 +548,14 @@
 
   /// Write the given list of signed 64-bit integer [values].
   int writeListInt64(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofInt64, values.length, additionalBytes: _sizeofUint32);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setInt64AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setInt64AtTail(tail, value);
       tail -= _sizeofInt64;
     }
     return result;
@@ -539,14 +563,14 @@
 
   /// Write the given list of signed 64-bit integer [values].
   int writeListUint64(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofUint64, values.length, additionalBytes: _sizeofUint32);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setUint64AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setUint64AtTail(tail, value);
       tail -= _sizeofUint64;
     }
     return result;
@@ -554,14 +578,14 @@
 
   /// Write the given list of signed 32-bit integer [values].
   int writeListInt32(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofUint32, 1 + values.length);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setInt32AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setInt32AtTail(tail, value);
       tail -= _sizeofInt32;
     }
     return result;
@@ -569,14 +593,14 @@
 
   /// Write the given list of unsigned 32-bit integer [values].
   int writeListUint32(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofUint32, 1 + values.length);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setUint32AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setUint32AtTail(tail, value);
       tail -= _sizeofUint32;
     }
     return result;
@@ -584,14 +608,14 @@
 
   /// Write the given list of signed 16-bit integer [values].
   int writeListInt16(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofUint32, 1, additionalBytes: 2 * values.length);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setInt16AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setInt16AtTail(tail, value);
       tail -= _sizeofInt16;
     }
     return result;
@@ -599,14 +623,14 @@
 
   /// Write the given list of unsigned 16-bit integer [values].
   int writeListUint16(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofUint32, 1, additionalBytes: 2 * values.length);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setUint16AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setUint16AtTail(tail, value);
       tail -= _sizeofUint16;
     }
     return result;
@@ -614,19 +638,19 @@
 
   /// Write the given list of bools as unsigend 8-bit integer [values].
   int writeListBool(List<bool> values) {
-    return writeListUint8(values?.map((b) => b ? 1 : 0)?.toList());
+    return writeListUint8(values.map((b) => b ? 1 : 0).toList());
   }
 
   /// Write the given list of signed 8-bit integer [values].
   int writeListInt8(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofUint32, 1, additionalBytes: values.length);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setInt8AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setInt8AtTail(tail, value);
       tail -= _sizeofUint8;
     }
     return result;
@@ -634,147 +658,187 @@
 
   /// Write the given list of unsigned 8-bit integer [values].
   int writeListUint8(List<int> values) {
-    _ensureNoVTable();
+    assert(!_inVTable);
     _prepare(_sizeofUint32, 1, additionalBytes: values.length);
-    final int result = _tail;
-    int tail = _tail;
-    _setUint32AtTail(_buf, tail, values.length);
+    final result = _tail;
+    var tail = _tail;
+    _setUint32AtTail(tail, values.length);
     tail -= _sizeofUint32;
-    for (int value in values) {
-      _setUint8AtTail(_buf, tail, value);
+    for (var value in values) {
+      _setUint8AtTail(tail, value);
       tail -= _sizeofUint8;
     }
     return result;
   }
 
-  /// Write the given string [value] and return its offset, or `null` if
-  /// the [value] is `null`.
-  int writeString(String value) {
-    _ensureNoVTable();
-    if (value != null) {
-      if (_strings != null) {
-        return _strings.putIfAbsent(value, () => _writeString(value));
-      } else {
-        return _writeString(value);
-      }
+  /// Write the given string [value] and return its offset.
+  ///
+  /// Dart strings are UTF-16 but must be stored as UTF-8 in FlatBuffers.
+  /// If the given string consists only of ASCII characters, you can indicate
+  /// enable [asciiOptimization]. In this mode, [writeString()] first tries to
+  /// copy the ASCII string directly to the output buffer and if that fails
+  /// (because there are no-ASCII characters in the string) it falls back and to
+  /// the default UTF-16 -> UTF-8 conversion (with slight performance penalty).
+  int writeString(String value, {bool asciiOptimization = false}) {
+    assert(!_inVTable);
+    if (_strings != null) {
+      return _strings!
+          .putIfAbsent(value, () => _writeString(value, asciiOptimization));
+    } else {
+      return _writeString(value, asciiOptimization);
     }
-    return null;
   }
 
-  int _writeString(String value) {
-    // TODO(scheglov) optimize for ASCII strings
-    List<int> bytes = utf8.encode(value);
-    int length = bytes.length;
-    _prepare(4, 1, additionalBytes: length + 1);
-    final int result = _tail;
-    _setUint32AtTail(_buf, _tail, length);
-    int offset = _buf.lengthInBytes - _tail + 4;
-    for (int i = 0; i < length; i++) {
-      _buf.setUint8(offset++, bytes[i]);
+  int _writeString(String value, bool asciiOptimization) {
+    if (asciiOptimization) {
+      // [utf8.encode()] is slow (up to at least Dart SDK 2.13). If the given
+      // string is ASCII we can just write it directly, without any conversion.
+      final originalTail = _tail;
+      if (_tryWriteASCIIString(value)) return _tail;
+      // if non-ASCII: reset the output buffer position for [_writeUTFString()]
+      _tail = originalTail;
     }
-    _buf.setUint8(offset, 0); // trailing zero
-    return result;
+    _writeUTFString(value);
+    return _tail;
   }
 
-  /// Throw an exception if there is not currently a vtable.
-  void _ensureCurrentVTable() {
-    if (_currentVTable == null) {
-      throw new StateError('Start a table before adding values.');
+  // Try to write the string as ASCII, return false if there's a non-ascii char.
+  @pragma('vm:prefer-inline')
+  bool _tryWriteASCIIString(String value) {
+    _prepare(4, 1, additionalBytes: value.length + 1);
+    final length = value.length;
+    var offset = _buf.lengthInBytes - _tail + 4;
+    for (var i = 0; i < length; i++) {
+      // utf16 code unit, e.g. for '' it's [0x20 0x20], which is 8224 decimal.
+      // ASCII characters go from 0x00 to 0x7F (which is 0 to 127 decimal).
+      final char = value.codeUnitAt(i);
+      if ((char & ~0x7F) != 0) {
+        return false;
+      }
+      _buf.setUint8(offset++, char);
     }
+    _buf.setUint8(offset, 0); // trailing zero
+    _setUint32AtTail(_tail, value.length);
+    return true;
   }
 
-  /// Throw an exception if there is currently a vtable.
-  void _ensureNoVTable() {
-    if (_currentVTable != null) {
-      throw new StateError(
-          'Cannot write a non-scalar value while writing a table.');
+  @pragma('vm:prefer-inline')
+  void _writeUTFString(String value) {
+    final bytes = utf8.encode(value) as Uint8List;
+    final length = bytes.length;
+    _prepare(4, 1, additionalBytes: length + 1);
+    _setUint32AtTail(_tail, length);
+    var offset = _buf.lengthInBytes - _tail + 4;
+    for (var i = 0; i < length; i++) {
+      _buf.setUint8(offset++, bytes[i]);
     }
+    _buf.setUint8(offset, 0); // trailing zero
   }
 
+  /// Used to assert whether a "Table" is currently being built.
+  ///
+  /// If you hit `assert(!_inVTable())`, you're trying to add table fields
+  /// without starting a table with [Builder.startTable()].
+  ///
+  /// If you hit `assert(_inVTable())`, you're trying to construct a
+  /// Table/Vector/String during the construction of its parent table,
+  /// between the MyTableBuilder and [Builder.endTable()].
+  /// Move the creation of these sub-objects to before the MyTableBuilder to
+  /// not get this assert.
+  @pragma('vm:prefer-inline')
+  bool get _inVTable => _currentVTable != null;
+
   /// The number of bytes that have been written to the buffer so far.  The
   /// most recently written byte is this many bytes from the end of the buffer.
+  @pragma('vm:prefer-inline')
   int get offset => _tail;
 
   /// Zero-pads the buffer, which may be required for some struct layouts.
+  @pragma('vm:prefer-inline')
   void pad(int howManyBytes) {
-    for (int i = 0; i < howManyBytes; i++) putUint8(0);
+    for (var i = 0; i < howManyBytes; i++) {
+      putUint8(0);
+    }
   }
 
   /// Prepare for writing the given `count` of scalars of the given `size`.
   /// Additionally allocate the specified `additionalBytes`. Update the current
   /// tail pointer to point at the allocated space.
+  @pragma('vm:prefer-inline')
   void _prepare(int size, int count, {int additionalBytes = 0}) {
+    assert(!_finished);
     // Update the alignment.
     if (_maxAlign < size) {
       _maxAlign = size;
     }
     // Prepare amount of required space.
-    int dataSize = size * count + additionalBytes;
-    int alignDelta = (-(_tail + dataSize)) % size;
-    int bufSize = alignDelta + dataSize;
+    var dataSize = size * count + additionalBytes;
+    var alignDelta = (-(_tail + dataSize)) & (size - 1);
+    var bufSize = alignDelta + dataSize;
     // Ensure that we have the required amount of space.
     {
-      int oldCapacity = _buf.lengthInBytes;
+      var oldCapacity = _buf.lengthInBytes;
       if (_tail + bufSize > oldCapacity) {
-        int desiredNewCapacity = (oldCapacity + bufSize) * 2;
-        int deltaCapacity = desiredNewCapacity - oldCapacity;
-        deltaCapacity += (-deltaCapacity) % _maxAlign;
-        int newCapacity = oldCapacity + deltaCapacity;
-        ByteData newBuf = new ByteData(newCapacity);
-        newBuf.buffer
-            .asUint8List()
-            .setAll(deltaCapacity, _buf.buffer.asUint8List());
-        _buf = newBuf;
+        var desiredNewCapacity = (oldCapacity + bufSize) * 2;
+        var deltaCapacity = desiredNewCapacity - oldCapacity;
+        deltaCapacity += (-deltaCapacity) & (_maxAlign - 1);
+        var newCapacity = oldCapacity + deltaCapacity;
+        _buf = _allocator.resize(_buf, newCapacity, _tail, 0);
       }
     }
+
+    // zero out the added padding
+    for (var i = _tail + 1; i <= _tail + alignDelta; i++) {
+      _setUint8AtTail(i, 0);
+    }
+
     // Update the tail pointer.
     _tail += bufSize;
   }
 
   /// Record the offset of the given [field].
-  void _trackField(int field) {
-    _currentVTable.addField(field, _tail);
-  }
-
-  static void _setFloat64AtTail(ByteData _buf, int tail, double x) {
-    _buf.setFloat64(_buf.lengthInBytes - tail, x, Endian.little);
-  }
-
-  static void _setFloat32AtTail(ByteData _buf, int tail, double x) {
-    _buf.setFloat32(_buf.lengthInBytes - tail, x, Endian.little);
-  }
-
-  static void _setUint64AtTail(ByteData _buf, int tail, int x) {
-    _buf.setUint64(_buf.lengthInBytes - tail, x, Endian.little);
-  }
-
-  static void _setInt64AtTail(ByteData _buf, int tail, int x) {
-    _buf.setInt64(_buf.lengthInBytes - tail, x, Endian.little);
-  }
+  @pragma('vm:prefer-inline')
+  void _trackField(int field) => _currentVTable!.addField(field, _tail);
 
-  static void _setInt32AtTail(ByteData _buf, int tail, int x) {
-    _buf.setInt32(_buf.lengthInBytes - tail, x, Endian.little);
-  }
-
-  static void _setUint32AtTail(ByteData _buf, int tail, int x) {
-    _buf.setUint32(_buf.lengthInBytes - tail, x, Endian.little);
-  }
-
-  static void _setInt16AtTail(ByteData _buf, int tail, int x) {
-    _buf.setInt16(_buf.lengthInBytes - tail, x, Endian.little);
-  }
-
-  static void _setUint16AtTail(ByteData _buf, int tail, int x) {
-    _buf.setUint16(_buf.lengthInBytes - tail, x, Endian.little);
-  }
-
-  static void _setInt8AtTail(ByteData _buf, int tail, int x) {
-    _buf.setInt8(_buf.lengthInBytes - tail, x);
-  }
-
-  static void _setUint8AtTail(ByteData _buf, int tail, int x) {
-    _buf.setUint8(_buf.lengthInBytes - tail, x);
-  }
+  @pragma('vm:prefer-inline')
+  void _setFloat64AtTail(int tail, double x) =>
+      _buf.setFloat64(_buf.lengthInBytes - tail, x, Endian.little);
+
+  @pragma('vm:prefer-inline')
+  void _setFloat32AtTail(int tail, double x) =>
+      _buf.setFloat32(_buf.lengthInBytes - tail, x, Endian.little);
+
+  @pragma('vm:prefer-inline')
+  void _setUint64AtTail(int tail, int x) =>
+      _buf.setUint64(_buf.lengthInBytes - tail, x, Endian.little);
+
+  @pragma('vm:prefer-inline')
+  void _setInt64AtTail(int tail, int x) =>
+      _buf.setInt64(_buf.lengthInBytes - tail, x, Endian.little);
+
+  @pragma('vm:prefer-inline')
+  void _setInt32AtTail(int tail, int x) =>
+      _buf.setInt32(_buf.lengthInBytes - tail, x, Endian.little);
+
+  @pragma('vm:prefer-inline')
+  void _setUint32AtTail(int tail, int x) =>
+      _buf.setUint32(_buf.lengthInBytes - tail, x, Endian.little);
+
+  @pragma('vm:prefer-inline')
+  void _setInt16AtTail(int tail, int x) =>
+      _buf.setInt16(_buf.lengthInBytes - tail, x, Endian.little);
+
+  @pragma('vm:prefer-inline')
+  void _setUint16AtTail(int tail, int x) =>
+      _buf.setUint16(_buf.lengthInBytes - tail, x, Endian.little);
+
+  @pragma('vm:prefer-inline')
+  void _setInt8AtTail(int tail, int x) =>
+      _buf.setInt8(_buf.lengthInBytes - tail, x);
+
+  @pragma('vm:prefer-inline')
+  void _setUint8AtTail(int tail, int x) =>
+      _buf.setUint8(_buf.lengthInBytes - tail, x);
 }
 
 /// Reader of lists of boolean values.
@@ -784,11 +848,13 @@
   const BoolListReader();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint32;
 
   @override
+  @pragma('vm:prefer-inline')
   List<bool> read(BufferContext bc, int offset) =>
-      new _FbBoolList(bc, bc.derefObject(offset));
+      _FbBoolList(bc, bc.derefObject(offset));
 }
 
 /// The reader of booleans.
@@ -796,9 +862,11 @@
   const BoolReader() : super();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint8;
 
   @override
+  @pragma('vm:prefer-inline')
   bool read(BufferContext bc, int offset) => bc._getInt8(offset) != 0;
 }
 
@@ -809,31 +877,37 @@
   const Float64ListReader();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofFloat64;
 
   @override
+  @pragma('vm:prefer-inline')
   List<double> read(BufferContext bc, int offset) =>
-      new _FbFloat64List(bc, bc.derefObject(offset));
+      _FbFloat64List(bc, bc.derefObject(offset));
 }
 
 class Float32ListReader extends Reader<List<double>> {
   const Float32ListReader();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofFloat32;
 
   @override
+  @pragma('vm:prefer-inline')
   List<double> read(BufferContext bc, int offset) =>
-      new _FbFloat32List(bc, bc.derefObject(offset));
+      _FbFloat32List(bc, bc.derefObject(offset));
 }
 
 class Float64Reader extends Reader<double> {
   const Float64Reader();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofFloat64;
 
   @override
+  @pragma('vm:prefer-inline')
   double read(BufferContext bc, int offset) => bc._getFloat64(offset);
 }
 
@@ -841,18 +915,23 @@
   const Float32Reader();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofFloat32;
 
   @override
+  @pragma('vm:prefer-inline')
   double read(BufferContext bc, int offset) => bc._getFloat32(offset);
 }
 
 class Int64Reader extends Reader<int> {
   const Int64Reader() : super();
+
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofInt64;
 
   @override
+  @pragma('vm:prefer-inline')
   int read(BufferContext bc, int offset) => bc._getInt64(offset);
 }
 
@@ -861,9 +940,11 @@
   const Int32Reader() : super();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofInt32;
 
   @override
+  @pragma('vm:prefer-inline')
   int read(BufferContext bc, int offset) => bc._getInt32(offset);
 }
 
@@ -872,9 +953,11 @@
   const Int16Reader() : super();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofInt16;
 
   @override
+  @pragma('vm:prefer-inline')
   int read(BufferContext bc, int offset) => bc._getInt16(offset);
 }
 
@@ -883,26 +966,43 @@
   const Int8Reader() : super();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofInt8;
 
   @override
+  @pragma('vm:prefer-inline')
   int read(BufferContext bc, int offset) => bc._getInt8(offset);
 }
 
-/// The reader of lists of objects.
-///
-/// The returned unmodifiable lists lazily read objects on access.
+/// The reader of lists of objects. Lazy by default - see [lazy].
 class ListReader<E> extends Reader<List<E>> {
   final Reader<E> _elementReader;
 
-  const ListReader(this._elementReader);
+  /// Enables lazy reading of the list
+  ///
+  /// If true, the returned unmodifiable list lazily reads objects on access.
+  /// Therefore, the underlying buffer must not change while accessing the list.
+  ///
+  /// If false, reads the whole list immediately on access.
+  final bool lazy;
+
+  const ListReader(this._elementReader, {this.lazy = true});
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint32;
 
   @override
-  List<E> read(BufferContext bc, int offset) =>
-      new _FbGenericList<E>(_elementReader, bc, bc.derefObject(offset));
+  List<E> read(BufferContext bc, int offset) {
+    final listOffset = bc.derefObject(offset);
+    return lazy
+        ? _FbGenericList<E>(_elementReader, bc, listOffset)
+        : List<E>.generate(
+            bc.buffer.getUint32(listOffset, Endian.little),
+            (int index) => _elementReader.read(
+                bc, listOffset + size + _elementReader.size * index),
+            growable: true);
+  }
 }
 
 /// Object that can read a value at a [BufferContext].
@@ -916,43 +1016,55 @@
   T read(BufferContext bc, int offset);
 
   /// Read the value of the given [field] in the given [object].
-  T vTableGet(BufferContext object, int offset, int field, [T defaultValue]) {
-    int vTableSOffset = object._getInt32(offset);
-    int vTableOffset = offset - vTableSOffset;
-    int vTableSize = object._getUint16(vTableOffset);
-    int vTableFieldOffset = field;
-    if (vTableFieldOffset < vTableSize) {
-      int fieldOffsetInObject =
-          object._getUint16(vTableOffset + vTableFieldOffset);
-      if (fieldOffsetInObject != 0) {
-        return read(object, offset + fieldOffsetInObject);
-      }
-    }
-    return defaultValue;
+  @pragma('vm:prefer-inline')
+  T vTableGet(BufferContext object, int offset, int field, T defaultValue) {
+    var fieldOffset = _vTableFieldOffset(object, offset, field);
+    return fieldOffset == 0 ? defaultValue : read(object, offset + fieldOffset);
+  }
+
+  /// Read the value of the given [field] in the given [object].
+  @pragma('vm:prefer-inline')
+  T? vTableGetNullable(BufferContext object, int offset, int field) {
+    var fieldOffset = _vTableFieldOffset(object, offset, field);
+    return fieldOffset == 0 ? null : read(object, offset + fieldOffset);
+  }
+
+  @pragma('vm:prefer-inline')
+  int _vTableFieldOffset(BufferContext object, int offset, int field) {
+    var vTableSOffset = object._getInt32(offset);
+    var vTableOffset = offset - vTableSOffset;
+    var vTableSize = object._getUint16(vTableOffset);
+    if (field >= vTableSize) return 0;
+    return object._getUint16(vTableOffset + field);
   }
 }
 
 /// The reader of string values.
 class StringReader extends Reader<String> {
-  const StringReader() : super();
+  final bool asciiOptimization;
+
+  const StringReader({this.asciiOptimization = false}) : super();
 
   @override
-  int get size => 4;
+  @pragma('vm:prefer-inline')
+  int get size => _sizeofUint32;
 
   @override
+  @pragma('vm:prefer-inline')
   String read(BufferContext bc, int offset) {
-    int strOffset = bc.derefObject(offset);
-    int length = bc._getUint32(strOffset);
-    Uint8List bytes = bc._asUint8LIst(strOffset + 4, length);
-    if (_isLatin(bytes)) {
-      return new String.fromCharCodes(bytes);
+    var strOffset = bc.derefObject(offset);
+    var length = bc._getUint32(strOffset);
+    var bytes = bc._asUint8List(strOffset + _sizeofUint32, length);
+    if (asciiOptimization && _isLatin(bytes)) {
+      return String.fromCharCodes(bytes);
     }
     return utf8.decode(bytes);
   }
 
+  @pragma('vm:prefer-inline')
   static bool _isLatin(Uint8List bytes) {
-    int length = bytes.length;
-    for (int i = 0; i < length; i++) {
+    var length = bytes.length;
+    for (var i = 0; i < length; i++) {
       if (bytes[i] > 127) {
         return false;
       }
@@ -968,8 +1080,9 @@
   /// Return the object at `offset`.
   T createObject(BufferContext bc, int offset);
 
-  T read(BufferContext bp, int offset) {
-    return createObject(bp, offset);
+  @override
+  T read(BufferContext bc, int offset) {
+    return createObject(bc, offset);
   }
 }
 
@@ -978,15 +1091,16 @@
   const TableReader();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => 4;
 
   /// Return the object at [offset].
   T createObject(BufferContext bc, int offset);
 
   @override
-  T read(BufferContext bp, int offset) {
-    int objectOffset = bp.derefObject(offset);
-    return createObject(bp, objectOffset);
+  T read(BufferContext bc, int offset) {
+    var objectOffset = bc.derefObject(offset);
+    return createObject(bc, objectOffset);
   }
 }
 
@@ -997,11 +1111,13 @@
   const Uint32ListReader();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint32;
 
   @override
+  @pragma('vm:prefer-inline')
   List<int> read(BufferContext bc, int offset) =>
-      new _FbUint32List(bc, bc.derefObject(offset));
+      _FbUint32List(bc, bc.derefObject(offset));
 }
 
 /// The reader of unsigned 64-bit integers.
@@ -1011,9 +1127,11 @@
   const Uint64Reader() : super();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint64;
 
   @override
+  @pragma('vm:prefer-inline')
   int read(BufferContext bc, int offset) => bc._getUint64(offset);
 }
 
@@ -1022,9 +1140,11 @@
   const Uint32Reader() : super();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint32;
 
   @override
+  @pragma('vm:prefer-inline')
   int read(BufferContext bc, int offset) => bc._getUint32(offset);
 }
 
@@ -1035,11 +1155,13 @@
   const Uint16ListReader();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint32;
 
   @override
+  @pragma('vm:prefer-inline')
   List<int> read(BufferContext bc, int offset) =>
-      new _FbUint16List(bc, bc.derefObject(offset));
+      _FbUint16List(bc, bc.derefObject(offset));
 }
 
 /// The reader of unsigned 32-bit integers.
@@ -1047,24 +1169,44 @@
   const Uint16Reader() : super();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint16;
 
   @override
+  @pragma('vm:prefer-inline')
   int read(BufferContext bc, int offset) => bc._getUint16(offset);
 }
 
-/// Reader of lists of unsigned 8-bit integer values.
-///
-/// The returned unmodifiable lists lazily read values on access.
+/// Reader of unmodifiable binary data (a list of unsigned 8-bit integers).
 class Uint8ListReader extends Reader<List<int>> {
-  const Uint8ListReader();
+  /// Enables lazy reading of the list
+  ///
+  /// If true, the returned unmodifiable list lazily reads bytes on access.
+  /// Therefore, the underlying buffer must not change while accessing the list.
+  ///
+  /// If false, reads the whole list immediately as an Uint8List.
+  final bool lazy;
+
+  const Uint8ListReader({this.lazy = true});
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint32;
 
   @override
-  List<int> read(BufferContext bc, int offset) =>
-      new _FbUint8List(bc, bc.derefObject(offset));
+  @pragma('vm:prefer-inline')
+  List<int> read(BufferContext bc, int offset) {
+    final listOffset = bc.derefObject(offset);
+    if (lazy) return _FbUint8List(bc, listOffset);
+
+    final length = bc._getUint32(listOffset);
+    final result = Uint8List(length);
+    var pos = listOffset + _sizeofUint32;
+    for (var i = 0; i < length; i++, pos++) {
+      result[i] = bc._getUint8(pos);
+    }
+    return result;
+  }
 }
 
 /// The reader of unsigned 8-bit integers.
@@ -1072,20 +1214,53 @@
   const Uint8Reader() : super();
 
   @override
+  @pragma('vm:prefer-inline')
   int get size => _sizeofUint8;
 
   @override
+  @pragma('vm:prefer-inline')
   int read(BufferContext bc, int offset) => bc._getUint8(offset);
 }
 
+/// Reader of unmodifiable binary data (a list of signed 8-bit integers).
+class Int8ListReader extends Reader<List<int>> {
+  /// Enables lazy reading of the list
+  ///
+  /// If true, the returned unmodifiable list lazily reads bytes on access.
+  /// Therefore, the underlying buffer must not change while accessing the list.
+  ///
+  /// If false, reads the whole list immediately as an Uint8List.
+  final bool lazy;
+
+  const Int8ListReader({this.lazy = true});
+
+  @override
+  @pragma('vm:prefer-inline')
+  int get size => _sizeofUint32;
+
+  @override
+  @pragma('vm:prefer-inline')
+  List<int> read(BufferContext bc, int offset) {
+    final listOffset = bc.derefObject(offset);
+    if (lazy) return _FbUint8List(bc, listOffset);
+
+    final length = bc._getUint32(listOffset);
+    final result = Int8List(length);
+    var pos = listOffset + _sizeofUint32;
+    for (var i = 0; i < length; i++, pos++) {
+      result[i] = bc._getInt8(pos);
+    }
+    return result;
+  }
+}
+
 /// The list backed by 64-bit values - Uint64 length and Float64.
 class _FbFloat64List extends _FbList<double> {
   _FbFloat64List(BufferContext bc, int offset) : super(bc, offset);
 
   @override
-  double operator [](int i) {
-    return bc._getFloat64(offset + 4 + 8 * i);
-  }
+  @pragma('vm:prefer-inline')
+  double operator [](int i) => bc._getFloat64(offset + 4 + 8 * i);
 }
 
 /// The list backed by 32-bit values - Float32.
@@ -1093,29 +1268,29 @@
   _FbFloat32List(BufferContext bc, int offset) : super(bc, offset);
 
   @override
-  double operator [](int i) {
-    return bc._getFloat32(offset + 4 + 4 * i);
-  }
+  @pragma('vm:prefer-inline')
+  double operator [](int i) => bc._getFloat32(offset + 4 + 4 * i);
 }
 
 /// List backed by a generic object which may have any size.
 class _FbGenericList<E> extends _FbList<E> {
   final Reader<E> elementReader;
 
-  List<E> _items;
+  List<E?>? _items;
 
   _FbGenericList(this.elementReader, BufferContext bp, int offset)
       : super(bp, offset);
 
   @override
+  @pragma('vm:prefer-inline')
   E operator [](int i) {
-    _items ??= new List<E>(length);
-    E item = _items[i];
+    _items ??= List<E?>.filled(length, null);
+    var item = _items![i];
     if (item == null) {
       item = elementReader.read(bc, offset + 4 + elementReader.size * i);
-      _items[i] = item;
+      _items![i] = item;
     }
-    return item;
+    return item!;
   }
 }
 
@@ -1123,23 +1298,20 @@
 abstract class _FbList<E> extends Object with ListMixin<E> implements List<E> {
   final BufferContext bc;
   final int offset;
-  int _length;
+  int? _length;
 
   _FbList(this.bc, this.offset);
 
   @override
-  int get length {
-    _length ??= bc._getUint32(offset);
-    return _length;
-  }
+  @pragma('vm:prefer-inline')
+  int get length => _length ??= bc._getUint32(offset);
 
   @override
-  void set length(int i) =>
-      throw new StateError('Attempt to modify immutable list');
+  set length(int i) => throw StateError('Attempt to modify immutable list');
 
   @override
   void operator []=(int i, E e) =>
-      throw new StateError('Attempt to modify immutable list');
+      throw StateError('Attempt to modify immutable list');
 }
 
 /// List backed by 32-bit unsigned integers.
@@ -1147,9 +1319,8 @@
   _FbUint32List(BufferContext bc, int offset) : super(bc, offset);
 
   @override
-  int operator [](int i) {
-    return bc._getUint32(offset + 4 + 4 * i);
-  }
+  @pragma('vm:prefer-inline')
+  int operator [](int i) => bc._getUint32(offset + 4 + 4 * i);
 }
 
 /// List backed by 16-bit unsigned integers.
@@ -1157,9 +1328,8 @@
   _FbUint16List(BufferContext bc, int offset) : super(bc, offset);
 
   @override
-  int operator [](int i) {
-    return bc._getUint16(offset + 4 + 2 * i);
-  }
+  @pragma('vm:prefer-inline')
+  int operator [](int i) => bc._getUint16(offset + 4 + 2 * i);
 }
 
 /// List backed by 8-bit unsigned integers.
@@ -1167,9 +1337,17 @@
   _FbUint8List(BufferContext bc, int offset) : super(bc, offset);
 
   @override
-  int operator [](int i) {
-    return bc._getUint8(offset + 4 + i);
-  }
+  @pragma('vm:prefer-inline')
+  int operator [](int i) => bc._getUint8(offset + 4 + i);
+}
+
+/// List backed by 8-bit signed integers.
+class _FbInt8List extends _FbList<int> {
+  _FbInt8List(BufferContext bc, int offset) : super(bc, offset);
+
+  @override
+  @pragma('vm:prefer-inline')
+  int operator [](int i) => bc._getInt8(offset + 4 + i);
 }
 
 /// List backed by 8-bit unsigned integers.
@@ -1177,41 +1355,48 @@
   _FbBoolList(BufferContext bc, int offset) : super(bc, offset);
 
   @override
-  bool operator [](int i) {
-    return bc._getUint8(offset + 4 + i) == 1 ? true : false;
-  }
+  @pragma('vm:prefer-inline')
+  bool operator [](int i) => bc._getUint8(offset + 4 + i) == 1 ? true : false;
 }
 
 /// Class that describes the structure of a table.
 class _VTable {
   static const int _metadataLength = 4;
 
-  final List<int> fieldTails = <int>[];
-  final List<int> fieldOffsets = <int>[];
+  final int numFields;
+
+  // Note: fieldOffsets start as "tail offsets" and are then transformed by
+  // [computeFieldOffsets()] to actual offsets when a table is finished.
+  final Uint32List fieldOffsets;
+  bool offsetsComputed = false;
+
+  _VTable(this.numFields) : fieldOffsets = Uint32List(numFields);
 
   /// The size of the table that uses this VTable.
-  int tableSize;
+  int tableSize = 0;
 
-  /// The tail of this VTable.  It is used to share the same VTable between
+  /// The tail of this VTable. It is used to share the same VTable between
   /// multiple tables of identical structure.
-  int tail;
+  int tail = 0;
 
   int get _vTableSize => numOfUint16 * _sizeofUint16;
 
-  int get numOfUint16 => 1 + 1 + fieldTails.length;
+  int get numOfUint16 => 1 + 1 + numFields;
 
+  @pragma('vm:prefer-inline')
   void addField(int field, int offset) {
-    while (fieldTails.length <= field) {
-      fieldTails.add(null);
-    }
-    fieldTails[field] = offset;
+    assert(!offsetsComputed);
+    assert(offset > 0); // it's impossible for field to start at the buffer end
+    assert(offset <= 4294967295); // uint32 max
+    fieldOffsets[field] = offset;
   }
 
+  @pragma('vm:prefer-inline')
   bool _offsetsMatch(int vt2Start, ByteData buf) {
-    for (int i = 0; i < fieldOffsets.length; i++) {
+    assert(offsetsComputed);
+    for (var i = 0; i < numFields; i++) {
       if (fieldOffsets[i] !=
-          buf.getUint16(
-              vt2Start + _metadataLength + (2 * i), Endian.little)) {
+          buf.getUint16(vt2Start + _metadataLength + (2 * i), Endian.little)) {
         return false;
       }
     }
@@ -1219,17 +1404,22 @@
   }
 
   /// Fill the [fieldOffsets] field.
+  @pragma('vm:prefer-inline')
   void computeFieldOffsets(int tableTail) {
-    assert(fieldOffsets.isEmpty);
-    for (int fieldTail in fieldTails) {
-      int fieldOffset = fieldTail == null ? 0 : tableTail - fieldTail;
-      fieldOffsets.add(fieldOffset);
+    assert(!offsetsComputed);
+    offsetsComputed = true;
+    for (var i = 0; i < numFields; i++) {
+      if (fieldOffsets[i] != 0) {
+        fieldOffsets[i] = tableTail - fieldOffsets[i];
+      }
     }
   }
 
   /// Outputs this VTable to [buf], which is is expected to be aligned to 16-bit
   /// and have at least [numOfUint16] 16-bit words available.
+  @pragma('vm:prefer-inline')
   void output(ByteData buf, int bufOffset) {
+    assert(offsetsComputed);
     // VTable size.
     buf.setUint16(bufOffset, numOfUint16 * 2, Endian.little);
     bufOffset += 2;
@@ -1237,9 +1427,62 @@
     buf.setUint16(bufOffset, tableSize, Endian.little);
     bufOffset += 2;
     // Field offsets.
-    for (int fieldOffset in fieldOffsets) {
-      buf.setUint16(bufOffset, fieldOffset, Endian.little);
+    for (var i = 0; i < numFields; i++) {
+      buf.setUint16(bufOffset, fieldOffsets[i], Endian.little);
       bufOffset += 2;
     }
   }
 }
+
+/// The interface that [Builder] uses to allocate buffers for encoding.
+abstract class Allocator {
+  const Allocator();
+
+  /// Allocate a [ByteData] buffer of a given size.
+  ByteData allocate(int size);
+
+  /// Free the given [ByteData] buffer previously allocated by [allocate].
+  void deallocate(ByteData data);
+
+  /// Reallocate [newSize] bytes of memory, replacing the old [oldData]. This
+  /// grows downwards, and is intended specifically for use with [Builder].
+  /// Params [inUseBack] and [inUseFront] indicate how much of [oldData] is
+  /// actually in use at each end, and needs to be copied.
+  ByteData resize(
+      ByteData oldData, int newSize, int inUseBack, int inUseFront) {
+    final newData = allocate(newSize);
+    _copyDownward(oldData, newData, inUseBack, inUseFront);
+    deallocate(oldData);
+    return newData;
+  }
+
+  /// Called by [resize] to copy memory from [oldData] to [newData]. Only
+  /// memory of size [inUseFront] and [inUseBack] will be copied from the front
+  /// and back of the old memory allocation.
+  void _copyDownward(
+      ByteData oldData, ByteData newData, int inUseBack, int inUseFront) {
+    if (inUseBack != 0) {
+      newData.buffer.asUint8List().setAll(
+          newData.lengthInBytes - inUseBack,
+          oldData.buffer.asUint8List().getRange(
+              oldData.lengthInBytes - inUseBack, oldData.lengthInBytes));
+    }
+    if (inUseFront != 0) {
+      newData.buffer
+          .asUint8List()
+          .setAll(0, oldData.buffer.asUint8List().getRange(0, inUseFront));
+    }
+  }
+}
+
+class DefaultAllocator extends Allocator {
+  const DefaultAllocator();
+
+  @override
+  ByteData allocate(int size) => ByteData(size);
+
+  @override
+  void deallocate(ByteData data) {
+    // nothing to do, it's garbage-collected
+  }
+}
diff -urN a/dart/lib/src/builder.dart b/dart/lib/src/builder.dart
--- a/dart/lib/src/builder.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/lib/src/builder.dart	2023-01-13 07:47:11.939280316 +0000
@@ -5,38 +5,27 @@
 
 /// The main builder class for creation of a FlexBuffer.
 class Builder {
-  ByteData _buffer;
-  List<_StackValue> _stack;
-  List<_StackPointer> _stackPointers;
-  int _offset;
-  bool _finished;
-  Map<String, _StackValue> _stringCache;
-  Map<String, _StackValue> _keyCache;
-  Map<_KeysHash, _StackValue> _keyVectorCache;
-  Map<int, _StackValue> _indirectIntCache;
-  Map<double, _StackValue> _indirectDoubleCache;
+  final ByteData _buffer;
+  List<_StackValue> _stack = [];
+  List<_StackPointer> _stackPointers = [];
+  int _offset = 0;
+  bool _finished = false;
+  final Map<String, _StackValue> _stringCache = {};
+  final Map<String, _StackValue> _keyCache = {};
+  final Map<_KeysHash, _StackValue> _keyVectorCache = {};
+  final Map<int, _StackValue> _indirectIntCache = {};
+  final Map<double, _StackValue> _indirectDoubleCache = {};
 
   /// Instantiate the builder if you intent to gradually build up the buffer by calling
   /// add... methods and calling [finish] to receive the the resulting byte array.
   ///
   /// The default size of internal buffer is set to 2048. Provide a different value in order to avoid buffer copies.
-  Builder({int size = 2048}) {
-    _buffer = ByteData(size);
-    _stack = [];
-    _stackPointers = [];
-    _offset = 0;
-    _finished = false;
-    _stringCache = {};
-    _keyCache = {};
-    _keyVectorCache = {};
-    _indirectIntCache = {};
-    _indirectDoubleCache = {};
-  }
+  Builder({int size = 2048}) : _buffer = ByteData(size);
 
   /// Use this method in order to turn an object into a FlexBuffer directly.
   ///
   /// Use the manual instantiation of the [Builder] and gradual addition of values, if performance is more important than convenience.
-  static ByteBuffer buildFromObject(Object value) {
+  static ByteBuffer buildFromObject(Object? value) {
     final builder = Builder();
     builder._add(value);
     final buffer = builder.finish();
@@ -45,7 +34,7 @@
     return byteData.buffer;
   }
 
-  void _add(Object value) {
+  void _add(Object? value) {
     if (value == null) {
       addNull();
     } else if (value is bool) {
@@ -81,32 +70,32 @@
   /// Specifically useful when building up a vector where values can be null.
   void addNull() {
     _integrityCheckOnValueAddition();
-    _stack.add(_StackValue.WithNull());
+    _stack.add(_StackValue.withNull());
   }
 
   /// Adds a string value.
   void addInt(int value) {
     _integrityCheckOnValueAddition();
-    _stack.add(_StackValue.WithInt(value));
+    _stack.add(_StackValue.withInt(value));
   }
 
   /// Adds a bool value.
   void addBool(bool value) {
     _integrityCheckOnValueAddition();
-    _stack.add(_StackValue.WithBool(value));
+    _stack.add(_StackValue.withBool(value));
   }
 
   /// Adds a double value.
   void addDouble(double value) {
     _integrityCheckOnValueAddition();
-    _stack.add(_StackValue.WithDouble(value));
+    _stack.add(_StackValue.withDouble(value));
   }
 
   /// Adds a string value.
   void addString(String value) {
     _integrityCheckOnValueAddition();
     if (_stringCache.containsKey(value)) {
-      _stack.add(_stringCache[value]);
+      _stack.add(_stringCache[value]!);
       return;
     }
     final utf8String = utf8.encode(value);
@@ -118,7 +107,8 @@
     final newOffset = _newOffset(length + 1);
     _pushBuffer(utf8String);
     _offset = newOffset;
-    final stackValue = _StackValue.WithOffset(stringOffset, ValueType.String, bitWidth);
+    final stackValue =
+        _StackValue.withOffset(stringOffset, ValueType.String, bitWidth);
     _stack.add(stackValue);
     _stringCache[value] = stackValue;
   }
@@ -129,7 +119,7 @@
   void addKey(String value) {
     _integrityCheckOnKeyAddition();
     if (_keyCache.containsKey(value)) {
-      _stack.add(_keyCache[value]);
+      _stack.add(_keyCache[value]!);
       return;
     }
     final utf8String = utf8.encode(value);
@@ -138,7 +128,8 @@
     final newOffset = _newOffset(length + 1);
     _pushBuffer(utf8String);
     _offset = newOffset;
-    final stackValue = _StackValue.WithOffset(keyOffset, ValueType.Key, BitWidth.width8);
+    final stackValue =
+        _StackValue.withOffset(keyOffset, ValueType.Key, BitWidth.width8);
     _stack.add(stackValue);
     _keyCache[value] = stackValue;
   }
@@ -156,7 +147,8 @@
     final newOffset = _newOffset(length);
     _pushBuffer(value.asUint8List());
     _offset = newOffset;
-    final stackValue = _StackValue.WithOffset(blobOffset, ValueType.Blob, bitWidth);
+    final stackValue =
+        _StackValue.withOffset(blobOffset, ValueType.Blob, bitWidth);
     _stack.add(stackValue);
   }
 
@@ -169,15 +161,16 @@
   void addIntIndirectly(int value, {bool cache = false}) {
     _integrityCheckOnValueAddition();
     if (_indirectIntCache.containsKey(value)) {
-      _stack.add(_indirectIntCache[value]);
+      _stack.add(_indirectIntCache[value]!);
       return;
     }
-    final stackValue = _StackValue.WithInt(value);
+    final stackValue = _StackValue.withInt(value);
     final byteWidth = _align(stackValue.width);
     final newOffset = _newOffset(byteWidth);
     final valueOffset = _offset;
     _pushBuffer(stackValue.asU8List(stackValue.width));
-    final stackOffset = _StackValue.WithOffset(valueOffset, ValueType.IndirectInt, stackValue.width);
+    final stackOffset = _StackValue.withOffset(
+        valueOffset, ValueType.IndirectInt, stackValue.width);
     _stack.add(stackOffset);
     _offset = newOffset;
     if (cache) {
@@ -193,15 +186,16 @@
   void addDoubleIndirectly(double value, {bool cache = false}) {
     _integrityCheckOnValueAddition();
     if (cache && _indirectDoubleCache.containsKey(value)) {
-      _stack.add(_indirectDoubleCache[value]);
+      _stack.add(_indirectDoubleCache[value]!);
       return;
     }
-    final stackValue = _StackValue.WithDouble(value);
+    final stackValue = _StackValue.withDouble(value);
     final byteWidth = _align(stackValue.width);
     final newOffset = _newOffset(byteWidth);
     final valueOffset = _offset;
     _pushBuffer(stackValue.asU8List(stackValue.width));
-    final stackOffset = _StackValue.WithOffset(valueOffset, ValueType.IndirectFloat, stackValue.width);
+    final stackOffset = _StackValue.withOffset(
+        valueOffset, ValueType.IndirectFloat, stackValue.width);
     _stack.add(stackOffset);
     _offset = newOffset;
     if (cache) {
@@ -258,8 +252,10 @@
     tmp._offset = _offset;
     tmp._stack = List.from(_stack);
     tmp._stackPointers = List.from(_stackPointers);
-    tmp._buffer.buffer.asUint8List().setAll(0, _buffer.buffer.asUint8List(0, _offset));
-    for (var i = 0; i < tmp._stackPointers.length; i++){
+    tmp._buffer.buffer
+        .asUint8List()
+        .setAll(0, _buffer.buffer.asUint8List(0, _offset));
+    for (var i = 0; i < tmp._stackPointers.length; i++) {
       tmp.end();
     }
     final buffer = tmp.finish();
@@ -267,14 +263,15 @@
     bd.buffer.asUint8List().setAll(0, buffer);
     return bd.buffer;
   }
-  
+
   void _integrityCheckOnValueAddition() {
     if (_finished) {
       throw StateError('Adding values after finish is prohibited');
     }
     if (_stackPointers.isNotEmpty && _stackPointers.last.isVector == false) {
       if (_stack.last.type != ValueType.Key) {
-        throw StateError('Adding value to a map before adding a key is prohibited');
+        throw StateError(
+            'Adding value to a map before adding a key is prohibited');
       }
     }
   }
@@ -290,7 +287,8 @@
 
   void _finish() {
     if (_stack.length != 1) {
-      throw StateError('Stack has to be exactly 1, but is ${_stack.length}. You have to end all started vectors and maps, before calling [finish]');
+      throw StateError(
+          'Stack has to be exactly 1, but is ${_stack.length}. You have to end all started vectors and maps, before calling [finish]');
     }
     final value = _stack[0];
     final byteWidth = _align(value.elementWidth(_offset, 0));
@@ -299,8 +297,9 @@
     _writeUInt(byteWidth, 1);
     _finished = true;
   }
-  
-  _StackValue _createVector(int start, int vecLength, int step, [_StackValue keys]) {
+
+  _StackValue _createVector(int start, int vecLength, int step,
+      [_StackValue? keys]) {
     var bitWidth = BitWidthUtil.uwidth(vecLength);
     var prefixElements = 1;
     if (keys != null) {
@@ -327,7 +326,9 @@
       }
     }
     final byteWidth = _align(bitWidth);
-    final fix = typed & ValueTypeUtils.isNumber(vectorType) && vecLength >= 2 && vecLength <= 4;
+    final fix = typed & ValueTypeUtils.isNumber(vectorType) &&
+        vecLength >= 2 &&
+        vecLength <= 4;
     if (keys != null) {
       _writeStackValue(keys, byteWidth);
       _writeUInt(1 << keys.width.index, byteWidth);
@@ -345,13 +346,14 @@
       }
     }
     if (keys != null) {
-      return _StackValue.WithOffset(vecOffset, ValueType.Map, bitWidth);
+      return _StackValue.withOffset(vecOffset, ValueType.Map, bitWidth);
     }
     if (typed) {
-      final vType = ValueTypeUtils.toTypedVector(vectorType, fix ? vecLength : 0);
-      return _StackValue.WithOffset(vecOffset, vType, bitWidth);
+      final vType =
+          ValueTypeUtils.toTypedVector(vectorType, fix ? vecLength : 0);
+      return _StackValue.withOffset(vecOffset, vType, bitWidth);
     }
-    return _StackValue.WithOffset(vecOffset, ValueType.Vector, bitWidth);
+    return _StackValue.withOffset(vecOffset, ValueType.Vector, bitWidth);
   }
 
   void _endVector(_StackPointer pointer) {
@@ -363,12 +365,13 @@
 
   void _sortKeysAndEndMap(_StackPointer pointer) {
     if (((_stack.length - pointer.stackPosition) & 1) == 1) {
-      throw StateError('The stack needs to hold key value pairs (even number of elements). Check if you combined [addKey] with add... method calls properly.');
+      throw StateError(
+          'The stack needs to hold key value pairs (even number of elements). Check if you combined [addKey] with add... method calls properly.');
     }
 
     var sorted = true;
     for (var i = pointer.stackPosition; i < _stack.length - 2; i += 2) {
-      if (_shouldFlip(_stack[i], _stack[i+2])) {
+      if (_shouldFlip(_stack[i], _stack[i + 2])) {
         sorted = false;
         break;
       }
@@ -394,36 +397,38 @@
     }
     _endMap(pointer);
   }
-  
+
   void _endMap(_StackPointer pointer) {
     final vecLength = (_stack.length - pointer.stackPosition) >> 1;
     final offsets = <int>[];
     for (var i = pointer.stackPosition; i < _stack.length; i += 2) {
-      offsets.add(_stack[i].offset);
+      offsets.add(_stack[i].offset!);
     }
     final keysHash = _KeysHash(offsets);
-    var keysStackValue;
+    _StackValue? keysStackValue;
     if (_keyVectorCache.containsKey(keysHash)) {
       keysStackValue = _keyVectorCache[keysHash];
     } else {
       keysStackValue = _createVector(pointer.stackPosition, vecLength, 2);
       _keyVectorCache[keysHash] = keysStackValue;
     }
-    final vec = _createVector(pointer.stackPosition + 1, vecLength, 2, keysStackValue);
+    final vec =
+        _createVector(pointer.stackPosition + 1, vecLength, 2, keysStackValue);
     _stack.removeRange(pointer.stackPosition, _stack.length);
     _stack.add(vec);
   }
 
   bool _shouldFlip(_StackValue v1, _StackValue v2) {
     if (v1.type != ValueType.Key || v2.type != ValueType.Key) {
-      throw StateError('Stack values are not keys $v1 | $v2. Check if you combined [addKey] with add... method calls properly.');
+      throw StateError(
+          'Stack values are not keys $v1 | $v2. Check if you combined [addKey] with add... method calls properly.');
     }
 
-    var c1, c2;
+    late int c1, c2;
     var index = 0;
     do {
-      c1 = _buffer.getUint8(v1.offset + index);
-      c2 = _buffer.getUint8(v2.offset + index);
+      c1 = _buffer.getUint8(v1.offset! + index);
+      c2 = _buffer.getUint8(v2.offset! + index);
       if (c2 < c1) return true;
       if (c1 < c2) return false;
       index += 1;
@@ -440,11 +445,12 @@
   void _writeStackValue(_StackValue value, int byteWidth) {
     final newOffset = _newOffset(byteWidth);
     if (value.isOffset) {
-      final relativeOffset = _offset - value.offset;
+      final relativeOffset = _offset - value.offset!;
       if (byteWidth == 8 || relativeOffset < (1 << (byteWidth * 8))) {
         _writeUInt(relativeOffset, byteWidth);
       } else {
-        throw StateError('Unexpected size $byteWidth. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new');
+        throw StateError(
+            'Unexpected size $byteWidth. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new');
       }
     } else {
       _pushBuffer(value.asU8List(BitWidthUtil.fromByteWidth(byteWidth)));
@@ -467,16 +473,13 @@
     }
     if (prevSize < size) {
       final newBuf = ByteData(size);
-      newBuf.buffer
-          .asUint8List()
-          .setAll(0, _buffer.buffer.asUint8List());
+      newBuf.buffer.asUint8List().setAll(0, _buffer.buffer.asUint8List());
     }
     return newOffset;
   }
 
   void _pushInt(int value, BitWidth width) {
     switch (width) {
-
       case BitWidth.width8:
         _buffer.setInt8(_offset, value);
         break;
@@ -494,7 +497,6 @@
 
   void _pushUInt(int value, BitWidth width) {
     switch (width) {
-
       case BitWidth.width8:
         _buffer.setUint8(_offset, value);
         break;
@@ -516,37 +518,39 @@
 }
 
 class _StackValue {
-  Object _value;
-  int _offset;
-  ValueType _type;
-  BitWidth _width;
-  _StackValue.WithNull() {
-    _type = ValueType.Null;
-    _width = BitWidth.width8;
-  }
-  _StackValue.WithInt(int value) {
-    _type = value != null ? ValueType.Int : ValueType.Null;
-    _width = BitWidthUtil.width(value);
-    _value = value;
-  }
-  _StackValue.WithBool(bool value) {
-    _type = value != null ? ValueType.Bool : ValueType.Null;
-    _width = BitWidth.width8;
-    _value = value;
-  }
-  _StackValue.WithDouble(double value) {
-    _type = value != null ? ValueType.Float : ValueType.Null;
-    _width = BitWidthUtil.width(value);
-    _value = value;
-  }
-  _StackValue.WithOffset(int value, ValueType type, BitWidth width) {
-    _offset = value;
-    _type = type;
-    _width = width;
-  }
+  late Object _value;
+  int? _offset;
+  final ValueType _type;
+  final BitWidth _width;
+
+  _StackValue.withNull()
+      : _type = ValueType.Null,
+        _width = BitWidth.width8;
+
+  _StackValue.withInt(int value)
+      : _type = ValueType.Int,
+        _width = BitWidthUtil.width(value),
+        _value = value;
+
+  _StackValue.withBool(bool value)
+      : _type = ValueType.Bool,
+        _width = BitWidth.width8,
+        _value = value;
+
+  _StackValue.withDouble(double value)
+      : _type = ValueType.Float,
+        _width = BitWidthUtil.width(value),
+        _value = value;
+
+  _StackValue.withOffset(int value, ValueType type, BitWidth width)
+      : _offset = value,
+        _type = type,
+        _width = width;
 
   BitWidth storedWidth({BitWidth width = BitWidth.width8}) {
-    return ValueTypeUtils.isInline(_type) ? BitWidthUtil.max(_width, width) : _width;
+    return ValueTypeUtils.isInline(_type)
+        ? BitWidthUtil.max(_width, width)
+        : _width;
   }
 
   int storedPackedType({BitWidth width = BitWidth.width8}) {
@@ -555,16 +559,19 @@
 
   BitWidth elementWidth(int size, int index) {
     if (ValueTypeUtils.isInline(_type)) return _width;
-    for(var i = 0; i < 4; i++) {
+    final offset = _offset!;
+    for (var i = 0; i < 4; i++) {
       final width = 1 << i;
-      final offsetLoc = size + BitWidthUtil.paddingSize(size, width) + index * width;
-      final offset = offsetLoc - _offset;
-      final bitWidth = BitWidthUtil.uwidth(offset);
+      final bitWidth = BitWidthUtil.uwidth(size +
+          BitWidthUtil.paddingSize(size, width) +
+          index * width -
+          offset);
       if (1 << bitWidth.index == width) {
         return bitWidth;
       }
     }
-    throw StateError('Element is of unknown. Size: $size at index: $index. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new');
+    throw StateError(
+        'Element is of unknown. Size: $size at index: $index. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new');
   }
 
   List<int> asU8List(BitWidth width) {
@@ -572,30 +579,30 @@
       if (_type == ValueType.Float) {
         if (width == BitWidth.width32) {
           final result = ByteData(4);
-          result.setFloat32(0, _value, Endian.little);
+          result.setFloat32(0, _value as double, Endian.little);
           return result.buffer.asUint8List();
         } else {
           final result = ByteData(8);
-          result.setFloat64(0, _value, Endian.little);
+          result.setFloat64(0, _value as double, Endian.little);
           return result.buffer.asUint8List();
         }
       } else {
-        switch(width) {
+        switch (width) {
           case BitWidth.width8:
             final result = ByteData(1);
-            result.setInt8(0, _value);
+            result.setInt8(0, _value as int);
             return result.buffer.asUint8List();
           case BitWidth.width16:
             final result = ByteData(2);
-            result.setInt16(0, _value, Endian.little);
+            result.setInt16(0, _value as int, Endian.little);
             return result.buffer.asUint8List();
           case BitWidth.width32:
             final result = ByteData(4);
-            result.setInt32(0, _value, Endian.little);
+            result.setInt32(0, _value as int, Endian.little);
             return result.buffer.asUint8List();
           case BitWidth.width64:
             final result = ByteData(8);
-            result.setInt64(0, _value, Endian.little);
+            result.setInt64(0, _value as int, Endian.little);
             return result.buffer.asUint8List();
         }
       }
@@ -607,11 +614,12 @@
     }
     if (_type == ValueType.Bool) {
       final result = ByteData(1);
-      result.setInt8(0, _value ? 1 : 0);
+      result.setInt8(0, _value as bool ? 1 : 0);
       return result.buffer.asUint8List();
     }
 
-    throw StateError('Unexpected type: $_type. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new');
+    throw StateError(
+        'Unexpected type: $_type. This might be a bug. Please create an issue https://github.com/google/flatbuffers/issues/new');
   }
 
   ValueType get type {
@@ -625,7 +633,8 @@
   bool get isOffset {
     return !ValueTypeUtils.isInline(_type);
   }
-  int get offset => _offset;
+
+  int? get offset => _offset;
 
   bool get isFloat32 {
     return _type == ValueType.Float && _width == BitWidth.width32;
@@ -635,6 +644,7 @@
 class _StackPointer {
   int stackPosition;
   bool isVector;
+
   _StackPointer(this.stackPosition, this.isVector);
 }
 
diff -urN a/dart/lib/src/reference.dart b/dart/lib/src/reference.dart
--- a/dart/lib/src/reference.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/lib/src/reference.dart	2023-01-13 07:47:12.158282339 +0000
@@ -11,14 +11,15 @@
   final int _offset;
   final BitWidth _parentWidth;
   final String _path;
-  int _byteWidth;
-  ValueType _valueType;
-  int _length;
-
-  Reference._(this._buffer, this._offset, this._parentWidth, int packedType, this._path) {
-    _byteWidth = 1 << (packedType & 3);
-    _valueType = ValueTypeUtils.fromInt(packedType >> 2);
-  }
+  final int _byteWidth;
+  final ValueType _valueType;
+  int? _length;
+
+  Reference._(
+      this._buffer, this._offset, this._parentWidth, int packedType, this._path,
+      [int? byteWidth, ValueType? valueType])
+      : _byteWidth = byteWidth ?? 1 << (packedType & 3),
+        _valueType = valueType ?? ValueTypeUtils.fromInt(packedType >> 2);
 
   /// Use this method to access the root value of a FlexBuffer.
   static Reference fromBuffer(ByteBuffer buffer) {
@@ -30,31 +31,44 @@
     final byteWidth = byteData.getUint8(len - 1);
     final packedType = byteData.getUint8(len - 2);
     final offset = len - byteWidth - 2;
-    return Reference._(ByteData.view(buffer), offset, BitWidthUtil.fromByteWidth(byteWidth), packedType, "/");
+    return Reference._(ByteData.view(buffer), offset,
+        BitWidthUtil.fromByteWidth(byteWidth), packedType, "/");
   }
 
   /// Returns true if the underlying value is null.
   bool get isNull => _valueType == ValueType.Null;
+
   /// Returns true if the underlying value can be represented as [num].
-  bool get isNum => ValueTypeUtils.isNumber(_valueType) || ValueTypeUtils.isIndirectNumber(_valueType);
+  bool get isNum =>
+      ValueTypeUtils.isNumber(_valueType) ||
+      ValueTypeUtils.isIndirectNumber(_valueType);
+
   /// Returns true if the underlying value was encoded as a float (direct or indirect).
-  bool get isDouble => _valueType == ValueType.Float || _valueType == ValueType.IndirectFloat;
+  bool get isDouble =>
+      _valueType == ValueType.Float || _valueType == ValueType.IndirectFloat;
+
   /// Returns true if the underlying value was encoded as an int or uint (direct or indirect).
   bool get isInt => isNum && !isDouble;
+
   /// Returns true if the underlying value was encoded as a string or a key.
-  bool get isString => _valueType == ValueType.String || _valueType == ValueType.Key;
+  bool get isString =>
+      _valueType == ValueType.String || _valueType == ValueType.Key;
+
   /// Returns true if the underlying value was encoded as a bool.
   bool get isBool => _valueType == ValueType.Bool;
+
   /// Returns true if the underlying value was encoded as a blob.
   bool get isBlob => _valueType == ValueType.Blob;
+
   /// Returns true if the underlying value points to a vector.
   bool get isVector => ValueTypeUtils.isAVector(_valueType);
+
   /// Returns true if the underlying value points to a map.
   bool get isMap => _valueType == ValueType.Map;
 
   /// If this [isBool], returns the bool value. Otherwise, returns null.
-  bool get boolValue {
-    if(_valueType == ValueType.Bool) {
+  bool? get boolValue {
+    if (_valueType == ValueType.Bool) {
       return _readInt(_offset, _parentWidth) != 0;
     }
     return null;
@@ -63,7 +77,7 @@
   /// Returns an [int], if the underlying value can be represented as an int.
   ///
   /// Otherwise returns [null].
-  int get intValue {
+  int? get intValue {
     if (_valueType == ValueType.Int) {
       return _readInt(_offset, _parentWidth);
     }
@@ -82,7 +96,7 @@
   /// Returns [double], if the underlying value [isDouble].
   ///
   /// Otherwise returns [null].
-  double get doubleValue {
+  double? get doubleValue {
     if (_valueType == ValueType.Float) {
       return _readFloat(_offset, _parentWidth);
     }
@@ -95,12 +109,12 @@
   /// Returns [num], if the underlying value is numeric, be it int uint, or float (direct or indirect).
   ///
   /// Otherwise returns [null].
-  num get numValue => doubleValue ?? intValue;
+  num? get numValue => doubleValue ?? intValue;
 
   /// Returns [String] value or null otherwise.
-  /// 
-  /// This method performers a utf8 decoding, as FlexBuffers format stores strings in utf8 encoding. 
-  String get stringValue {
+  ///
+  /// This method performers a utf8 decoding, as FlexBuffers format stores strings in utf8 encoding.
+  String? get stringValue {
     if (_valueType == ValueType.String || _valueType == ValueType.Key) {
       return utf8.decode(_buffer.buffer.asUint8List(_indirect, length));
     }
@@ -108,7 +122,7 @@
   }
 
   /// Returns [Uint8List] value or null otherwise.
-  Uint8List get blobValue {
+  Uint8List? get blobValue {
     if (_valueType == ValueType.Blob) {
       return _buffer.buffer.asUint8List(_indirect, length);
     }
@@ -122,22 +136,31 @@
   Reference operator [](Object key) {
     if (key is int && ValueTypeUtils.isAVector(_valueType)) {
       final index = key;
-      if(index >= length || index < 0) {
-        throw ArgumentError('Key: [$key] is not applicable on: $_path of: $_valueType length: $length');
+      if (index >= length || index < 0) {
+        throw ArgumentError(
+            'Key: [$key] is not applicable on: $_path of: $_valueType length: $length');
       }
       final elementOffset = _indirect + index * _byteWidth;
-      final reference = Reference._(_buffer, elementOffset, BitWidthUtil.fromByteWidth(_byteWidth), 0, "$_path[$index]");
-      reference._byteWidth = 1;
+      int packedType = 0;
+      int? byteWidth;
+      ValueType? valueType;
       if (ValueTypeUtils.isTypedVector(_valueType)) {
-        reference._valueType = ValueTypeUtils.typedVectorElementType(_valueType);
-        return reference;
-      }
-      if(ValueTypeUtils.isFixedTypedVector(_valueType)) {
-        reference._valueType = ValueTypeUtils.fixedTypedVectorElementType(_valueType);
-        return reference;
+        byteWidth = 1;
+        valueType = ValueTypeUtils.typedVectorElementType(_valueType);
+      } else if (ValueTypeUtils.isFixedTypedVector(_valueType)) {
+        byteWidth = 1;
+        valueType = ValueTypeUtils.fixedTypedVectorElementType(_valueType);
+      } else {
+        packedType = _buffer.getUint8(_indirect + length * _byteWidth + index);
       }
-      final packedType = _buffer.getUint8(_indirect + length * _byteWidth + index);
-      return Reference._(_buffer, elementOffset, BitWidthUtil.fromByteWidth(_byteWidth), packedType, "$_path[$index]");
+      return Reference._(
+          _buffer,
+          elementOffset,
+          BitWidthUtil.fromByteWidth(_byteWidth),
+          packedType,
+          "$_path[$index]",
+          byteWidth,
+          valueType);
     }
     if (key is String && _valueType == ValueType.Map) {
       final index = _keyIndex(key);
@@ -145,13 +168,14 @@
         return _valueForIndexWithKey(index, key);
       }
     }
-    throw ArgumentError('Key: [$key] is not applicable on: $_path of: $_valueType');
+    throw ArgumentError(
+        'Key: [$key] is not applicable on: $_path of: $_valueType');
   }
 
   /// Get an iterable if the underlying flexBuffer value is a vector.
   /// Otherwise throws an exception.
   Iterable<Reference> get vectorIterable {
-    if(isVector == false) {
+    if (isVector == false) {
       throw UnsupportedError('Value is not a vector. It is: $_valueType');
     }
     return _VectorIterator(this);
@@ -160,7 +184,7 @@
   /// Get an iterable for keys if the underlying flexBuffer value is a map.
   /// Otherwise throws an exception.
   Iterable<String> get mapKeyIterable {
-    if(isMap == false) {
+    if (isMap == false) {
       throw UnsupportedError('Value is not a map. It is: $_valueType');
     }
     return _MapKeyIterator(this);
@@ -169,7 +193,7 @@
   /// Get an iterable for values if the underlying flexBuffer value is a map.
   /// Otherwise throws an exception.
   Iterable<Reference> get mapValueIterable {
-    if(isMap == false) {
+    if (isMap == false) {
       throw UnsupportedError('Value is not a map. It is: $_valueType');
     }
     return _MapValueIterator(this);
@@ -181,59 +205,62 @@
   /// If the underlying value is a vector, or map, the length reflects number of elements / element pairs.
   /// If the values is a string or a blob, the length reflects a number of bytes the value occupies (strings are encoded in utf8 format).
   int get length {
-    if (_length != null) {
-      return _length;
-    }
-    // needs to be checked before more generic isAVector
-    if(ValueTypeUtils.isFixedTypedVector(_valueType)) {
-      _length = ValueTypeUtils.fixedTypedVectorElementSize(_valueType);
-    } else if(_valueType == ValueType.Blob || ValueTypeUtils.isAVector(_valueType) || _valueType == ValueType.Map){
-      _length = _readUInt(_indirect - _byteWidth, BitWidthUtil.fromByteWidth(_byteWidth));
-    } else if (_valueType == ValueType.Null) {
-      _length = 0;
-    } else if (_valueType == ValueType.String) {
-      final indirect = _indirect;
-      var size_byte_width = _byteWidth;
-      var size = _readUInt(indirect - size_byte_width, BitWidthUtil.fromByteWidth(size_byte_width));
-      while (_buffer.getInt8(indirect + size) != 0) {
-        size_byte_width <<= 1;
-        size = _readUInt(indirect - size_byte_width, BitWidthUtil.fromByteWidth(size_byte_width));
-      }
-      _length = size;
-    } else if (_valueType == ValueType.Key) {
-      final indirect = _indirect;
-      var size = 1;
-      while (_buffer.getInt8(indirect + size) != 0) {
-        size += 1;
+    if (_length == null) {
+      // needs to be checked before more generic isAVector
+      if (ValueTypeUtils.isFixedTypedVector(_valueType)) {
+        _length = ValueTypeUtils.fixedTypedVectorElementSize(_valueType);
+      } else if (_valueType == ValueType.Blob ||
+          ValueTypeUtils.isAVector(_valueType) ||
+          _valueType == ValueType.Map) {
+        _length = _readUInt(
+            _indirect - _byteWidth, BitWidthUtil.fromByteWidth(_byteWidth));
+      } else if (_valueType == ValueType.Null) {
+        _length = 0;
+      } else if (_valueType == ValueType.String) {
+        final indirect = _indirect;
+        var sizeByteWidth = _byteWidth;
+        var size = _readUInt(indirect - sizeByteWidth,
+            BitWidthUtil.fromByteWidth(sizeByteWidth));
+        while (_buffer.getInt8(indirect + size) != 0) {
+          sizeByteWidth <<= 1;
+          size = _readUInt(indirect - sizeByteWidth,
+              BitWidthUtil.fromByteWidth(sizeByteWidth));
+        }
+        _length = size;
+      } else if (_valueType == ValueType.Key) {
+        final indirect = _indirect;
+        var size = 1;
+        while (_buffer.getInt8(indirect + size) != 0) {
+          size += 1;
+        }
+        _length = size;
+      } else {
+        _length = 1;
       }
-      _length = size;
-    } else {
-      _length = 1;
     }
-    return _length;
+    return _length!;
   }
 
-
   /// Returns a minified JSON representation of the underlying FlexBuffer value.
   ///
   /// This method involves materializing the entire object tree, which may be
   /// expensive. It is more efficient to work with [Reference] and access only the needed data.
   /// Blob values are represented as base64 encoded string.
   String get json {
-    if(_valueType == ValueType.Bool) {
-      return boolValue ? 'true' : 'false';
+    if (_valueType == ValueType.Bool) {
+      return boolValue! ? 'true' : 'false';
     }
     if (_valueType == ValueType.Null) {
       return 'null';
     }
-    if(ValueTypeUtils.isNumber(_valueType)) {
+    if (ValueTypeUtils.isNumber(_valueType)) {
       return jsonEncode(numValue);
     }
     if (_valueType == ValueType.String) {
       return jsonEncode(stringValue);
     }
     if (_valueType == ValueType.Blob) {
-      return jsonEncode(base64Encode(blobValue));
+      return jsonEncode(base64Encode(blobValue!));
     }
     if (ValueTypeUtils.isAVector(_valueType)) {
       final result = StringBuffer();
@@ -261,7 +288,8 @@
       result.write('}');
       return result.toString();
     }
-    throw UnsupportedError('Type: $_valueType is not supported for JSON conversion');
+    throw UnsupportedError(
+        'Type: $_valueType is not supported for JSON conversion');
   }
 
   /// Computes the indirect offset of the value.
@@ -316,16 +344,20 @@
   }
 
   void _validateOffset(int offset, BitWidth width) {
-    if (_offset < 0 || _buffer.lengthInBytes <= offset + width.index || offset & (BitWidthUtil.toByteWidth(width) - 1) != 0) {
+    if (_offset < 0 ||
+        _buffer.lengthInBytes <= offset + width.index ||
+        offset & (BitWidthUtil.toByteWidth(width) - 1) != 0) {
       throw StateError('Bad offset: $offset, width: $width');
     }
   }
 
-  int _keyIndex(String key) {
+  int? _keyIndex(String key) {
     final input = utf8.encode(key);
     final keysVectorOffset = _indirect - _byteWidth * 3;
-    final indirectOffset = keysVectorOffset - _readUInt(keysVectorOffset, BitWidthUtil.fromByteWidth(_byteWidth));
-    final byteWidth = _readUInt(keysVectorOffset + _byteWidth, BitWidthUtil.fromByteWidth(_byteWidth));
+    final indirectOffset = keysVectorOffset -
+        _readUInt(keysVectorOffset, BitWidthUtil.fromByteWidth(_byteWidth));
+    final byteWidth = _readUInt(
+        keysVectorOffset + _byteWidth, BitWidthUtil.fromByteWidth(_byteWidth));
     var low = 0;
     var high = length - 1;
     while (low <= high) {
@@ -341,9 +373,10 @@
     return null;
   }
 
-  int _diffKeys(List<int> input, int index, int indirect_offset, int byteWidth) {
-    final keyOffset = indirect_offset + index * byteWidth;
-    final keyIndirectOffset = keyOffset - _readUInt(keyOffset, BitWidthUtil.fromByteWidth(byteWidth));
+  int _diffKeys(List<int> input, int index, int indirectOffset, int byteWidth) {
+    final keyOffset = indirectOffset + index * byteWidth;
+    final keyIndirectOffset =
+        keyOffset - _readUInt(keyOffset, BitWidthUtil.fromByteWidth(byteWidth));
     for (var i = 0; i < input.length; i++) {
       final dif = input[i] - _buffer.getUint8(keyIndirectOffset + i);
       if (dif != 0) {
@@ -357,38 +390,42 @@
     final indirect = _indirect;
     final elementOffset = indirect + index * _byteWidth;
     final packedType = _buffer.getUint8(indirect + length * _byteWidth + index);
-    return Reference._(_buffer, elementOffset, BitWidthUtil.fromByteWidth(_byteWidth), packedType, "$_path/$key");
+    return Reference._(_buffer, elementOffset,
+        BitWidthUtil.fromByteWidth(_byteWidth), packedType, "$_path/$key");
   }
 
   Reference _valueForIndex(int index) {
     final indirect = _indirect;
     final elementOffset = indirect + index * _byteWidth;
     final packedType = _buffer.getUint8(indirect + length * _byteWidth + index);
-    return Reference._(_buffer, elementOffset, BitWidthUtil.fromByteWidth(_byteWidth), packedType, "$_path/[$index]");
+    return Reference._(_buffer, elementOffset,
+        BitWidthUtil.fromByteWidth(_byteWidth), packedType, "$_path/[$index]");
   }
 
   String _keyForIndex(int index) {
     final keysVectorOffset = _indirect - _byteWidth * 3;
-    final indirectOffset = keysVectorOffset - _readUInt(keysVectorOffset, BitWidthUtil.fromByteWidth(_byteWidth));
-    final byteWidth = _readUInt(keysVectorOffset + _byteWidth, BitWidthUtil.fromByteWidth(_byteWidth));
+    final indirectOffset = keysVectorOffset -
+        _readUInt(keysVectorOffset, BitWidthUtil.fromByteWidth(_byteWidth));
+    final byteWidth = _readUInt(
+        keysVectorOffset + _byteWidth, BitWidthUtil.fromByteWidth(_byteWidth));
     final keyOffset = indirectOffset + index * byteWidth;
-    final keyIndirectOffset = keyOffset - _readUInt(keyOffset, BitWidthUtil.fromByteWidth(byteWidth));
+    final keyIndirectOffset =
+        keyOffset - _readUInt(keyOffset, BitWidthUtil.fromByteWidth(byteWidth));
     var length = 0;
     while (_buffer.getUint8(keyIndirectOffset + length) != 0) {
       length += 1;
     }
     return utf8.decode(_buffer.buffer.asUint8List(keyIndirectOffset, length));
   }
-
 }
 
-class _VectorIterator with IterableMixin<Reference> implements Iterator<Reference> {
+class _VectorIterator
+    with IterableMixin<Reference>
+    implements Iterator<Reference> {
   final Reference _vector;
-  int index;
+  int index = -1;
 
-  _VectorIterator(this._vector) {
-    index = -1;
-  }
+  _VectorIterator(this._vector);
 
   @override
   Reference get current => _vector[index];
@@ -405,11 +442,9 @@
 
 class _MapKeyIterator with IterableMixin<String> implements Iterator<String> {
   final Reference _map;
-  int index;
+  int index = -1;
 
-  _MapKeyIterator(this._map) {
-    index = -1;
-  }
+  _MapKeyIterator(this._map);
 
   @override
   String get current => _map._keyForIndex(index);
@@ -424,13 +459,13 @@
   Iterator<String> get iterator => this;
 }
 
-class _MapValueIterator with IterableMixin<Reference> implements Iterator<Reference> {
+class _MapValueIterator
+    with IterableMixin<Reference>
+    implements Iterator<Reference> {
   final Reference _map;
-  int index;
+  int index = -1;
 
-  _MapValueIterator(this._map) {
-    index = -1;
-  }
+  _MapValueIterator(this._map);
 
   @override
   Reference get current => _map._valueForIndex(index);
diff -urN a/dart/lib/src/types.dart b/dart/lib/src/types.dart
--- a/dart/lib/src/types.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/lib/src/types.dart	2023-01-13 07:47:12.214282856 +0000
@@ -1,17 +1,13 @@
 import 'dart:typed_data';
 
 /// Represents the number of bits a value occupies.
-enum BitWidth {
-  width8,
-  width16,
-  width32,
-  width64
-}
+enum BitWidth { width8, width16, width32, width64 }
 
 class BitWidthUtil {
   static int toByteWidth(BitWidth self) {
     return 1 << self.index;
   }
+
   static BitWidth width(num value) {
     if (value.toInt() == value) {
       var v = value.toInt().abs();
@@ -20,8 +16,11 @@
       if (v >> 31 == 0) return BitWidth.width32;
       return BitWidth.width64;
     }
-    return value == _toF32(value) ? BitWidth.width32 : BitWidth.width64;
+    return value == _toF32(value as double)
+        ? BitWidth.width32
+        : BitWidth.width64;
   }
+
   static BitWidth uwidth(num value) {
     if (value.toInt() == value) {
       var v = value.toInt().abs();
@@ -30,8 +29,11 @@
       if (v >> 32 == 0) return BitWidth.width32;
       return BitWidth.width64;
     }
-    return value == _toF32(value) ? BitWidth.width32 : BitWidth.width64;
+    return value == _toF32(value as double)
+        ? BitWidth.width32
+        : BitWidth.width64;
   }
+
   static BitWidth fromByteWidth(int value) {
     if (value == 1) {
       return BitWidth.width8;
@@ -45,11 +47,13 @@
     if (value == 8) {
       return BitWidth.width64;
     }
-    throw Exception('Unexpected value ${value}');
+    throw Exception('Unexpected value $value');
   }
+
   static int paddingSize(int bufSize, int scalarSize) {
     return (~bufSize + 1) & (scalarSize - 1);
   }
+
   static double _toF32(double value) {
     var bdata = ByteData(4);
     bdata.setFloat32(0, value);
@@ -66,15 +70,36 @@
 
 /// Represents all internal FlexBuffer types.
 enum ValueType {
-  Null, Int, UInt, Float,
-  Key, String, IndirectInt, IndirectUInt, IndirectFloat,
-  Map, Vector, VectorInt, VectorUInt, VectorFloat, VectorKey,
-  @Deprecated('VectorString is deprecated due to a flaw in the binary format (https://github.com/google/flatbuffers/issues/5627)')
+  Null,
+  Int,
+  UInt,
+  Float,
+  Key,
+  String,
+  IndirectInt,
+  IndirectUInt,
+  IndirectFloat,
+  Map,
+  Vector,
+  VectorInt,
+  VectorUInt,
+  VectorFloat,
+  VectorKey,
+  @Deprecated(
+      'VectorString is deprecated due to a flaw in the binary format (https://github.com/google/flatbuffers/issues/5627)')
   VectorString,
-  VectorInt2, VectorUInt2, VectorFloat2,
-  VectorInt3, VectorUInt3, VectorFloat3,
-  VectorInt4, VectorUInt4, VectorFloat4,
-  Blob, Bool, VectorBool
+  VectorInt2,
+  VectorUInt2,
+  VectorFloat2,
+  VectorInt3,
+  VectorUInt3,
+  VectorFloat3,
+  VectorInt4,
+  VectorUInt4,
+  VectorFloat4,
+  Blob,
+  Bool,
+  VectorBool
 }
 
 class ValueTypeUtils {
@@ -89,71 +114,70 @@
   }
 
   static bool isInline(ValueType self) {
-    return self == ValueType.Bool
-        || toInt(self) <= toInt(ValueType.Float);
+    return self == ValueType.Bool || toInt(self) <= toInt(ValueType.Float);
   }
 
   static bool isNumber(ValueType self) {
-    return toInt(self) >= toInt(ValueType.Int)
-        && toInt(self) <= toInt(ValueType.Float);
+    return toInt(self) >= toInt(ValueType.Int) &&
+        toInt(self) <= toInt(ValueType.Float);
   }
 
   static bool isIndirectNumber(ValueType self) {
-    return toInt(self) >= toInt(ValueType.IndirectInt)
-        && toInt(self) <= toInt(ValueType.IndirectFloat);
+    return toInt(self) >= toInt(ValueType.IndirectInt) &&
+        toInt(self) <= toInt(ValueType.IndirectFloat);
   }
 
   static bool isTypedVectorElement(ValueType self) {
     return self == ValueType.Bool ||
-        (
-            toInt(self) >= toInt(ValueType.Int)
-            && toInt(self) <= toInt(ValueType.String)
-        );
+        (toInt(self) >= toInt(ValueType.Int) &&
+            toInt(self) <= toInt(ValueType.String));
   }
 
   static bool isTypedVector(ValueType self) {
     return self == ValueType.VectorBool ||
-        (
-          toInt(self) >= toInt(ValueType.VectorInt)
-              && toInt(self) <= toInt(ValueType.VectorString)
-        );
+        (toInt(self) >= toInt(ValueType.VectorInt) &&
+            toInt(self) <= toInt(ValueType.VectorString));
   }
 
   static bool isFixedTypedVector(ValueType self) {
-    return (
-            toInt(self) >= toInt(ValueType.VectorInt2)
-                && toInt(self) <= toInt(ValueType.VectorFloat4)
-        );
+    return (toInt(self) >= toInt(ValueType.VectorInt2) &&
+        toInt(self) <= toInt(ValueType.VectorFloat4));
   }
 
   static bool isAVector(ValueType self) {
-    return (
-        isTypedVector(self) || isFixedTypedVector(self) || self == ValueType.Vector
-    );
+    return (isTypedVector(self) ||
+        isFixedTypedVector(self) ||
+        self == ValueType.Vector);
   }
 
   static ValueType toTypedVector(ValueType self, int length) {
     if (length == 0) {
-      return ValueTypeUtils.fromInt(toInt(self) - toInt(ValueType.Int) + toInt(ValueType.VectorInt));
+      return ValueTypeUtils.fromInt(
+          toInt(self) - toInt(ValueType.Int) + toInt(ValueType.VectorInt));
     }
     if (length == 2) {
-      return ValueTypeUtils.fromInt(toInt(self) - toInt(ValueType.Int) + toInt(ValueType.VectorInt2));
+      return ValueTypeUtils.fromInt(
+          toInt(self) - toInt(ValueType.Int) + toInt(ValueType.VectorInt2));
     }
     if (length == 3) {
-      return ValueTypeUtils.fromInt(toInt(self) - toInt(ValueType.Int) + toInt(ValueType.VectorInt3));
+      return ValueTypeUtils.fromInt(
+          toInt(self) - toInt(ValueType.Int) + toInt(ValueType.VectorInt3));
     }
     if (length == 4) {
-      return ValueTypeUtils.fromInt(toInt(self) - toInt(ValueType.Int) + toInt(ValueType.VectorInt4));
+      return ValueTypeUtils.fromInt(
+          toInt(self) - toInt(ValueType.Int) + toInt(ValueType.VectorInt4));
     }
     throw Exception('unexpected length ' + length.toString());
   }
 
   static ValueType typedVectorElementType(ValueType self) {
-    return ValueTypeUtils.fromInt(toInt(self) - toInt(ValueType.VectorInt) + toInt(ValueType.Int));
+    return ValueTypeUtils.fromInt(
+        toInt(self) - toInt(ValueType.VectorInt) + toInt(ValueType.Int));
   }
 
   static ValueType fixedTypedVectorElementType(ValueType self) {
-    return ValueTypeUtils.fromInt((toInt(self) - toInt(ValueType.VectorInt2)) % 3 + toInt(ValueType.Int));
+    return ValueTypeUtils.fromInt(
+        (toInt(self) - toInt(ValueType.VectorInt2)) % 3 + toInt(ValueType.Int));
   }
 
   static int fixedTypedVectorElementSize(ValueType self) {
diff -urN a/dart/publish.sh b/dart/publish.sh
--- a/dart/publish.sh	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/publish.sh	2023-01-13 07:47:12.234283041 +0000
@@ -21,17 +21,12 @@
 
 command -v dart >/dev/null 2>&1 || { echo >&2 "Require `dart` but it's not installed.  Aborting."; exit 1; }
 
-cp ../samples/monster.fbs example/
-cp ../tests/monster_test.fbs test/
-cp -r ../tests/include_test/*.fbs test/
-cp -r ../tests/include_test/sub test/
-
-pushd example
-../../flatc --dart ./monster.fbs
+pushd ../tests
+./DartTest.sh
 popd
 
-pushd test
-../../flatc --dart ./monster_test.fbs
+pushd ../samples
+./dart_sample.sh
 popd
 
 dart pub publish
diff -urN a/dart/pubspec.yaml b/dart/pubspec.yaml
--- a/dart/pubspec.yaml	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/pubspec.yaml	2023-01-13 07:47:12.235283050 +0000
@@ -1,20 +1,15 @@
 name: flat_buffers
-version: 2.0.0
-description: >
-  FlatBuffers reading and writing library for Dart.  Use the flatc compiler to
-  generate Dart classes for a FlatBuffers schema, and this library to assist with
-  reading and writing the binary format.
-
-  Based on original work by Konstantin Scheglov and Paul Berry of the Dart SDK team.
-authors:
-- Dan Field <dfield@gmail.com>
-- Konstantin Scheglov
-- Paul Berry
+version: 2.0.5
+description: FlatBuffers reading and writing library for Dart. Based on original work by Konstantin Scheglov and Paul Berry of the Dart SDK team.
 homepage: https://github.com/google/flatbuffers
 documentation: https://google.github.io/flatbuffers/index.html
-dev_dependencies:
-  test: ^1.3.0
-  test_reflective_loader: ^0.1.4
-  path: ^1.5.1
+
 environment:
-  sdk: '>=2.0.0-dev.28.0 <3.0.0'
\ No newline at end of file
+  sdk: '>=2.12.0 <3.0.0'
+
+dev_dependencies:
+  test: ^1.17.7
+  test_reflective_loader: ^0.2.0
+  path: ^1.8.0
+  lints: ^1.0.1
+
diff -urN a/dart/test/flat_buffers_test.dart b/dart/test/flat_buffers_test.dart
--- a/dart/test/flat_buffers_test.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/test/flat_buffers_test.dart	2023-01-13 07:47:12.521285691 +0000
@@ -12,10 +12,12 @@
 import 'package:test_reflective_loader/test_reflective_loader.dart';
 
 import './monster_test_my_game.example_generated.dart' as example;
+import './monster_test_my_game.example2_generated.dart' as example2;
 
 main() {
   defineReflectiveSuite(() {
     defineReflectiveTests(BuilderTest);
+    defineReflectiveTests(ObjectAPITest);
     defineReflectiveTests(CheckOtherLangaugesData);
     defineReflectiveTests(GeneratorTest);
   });
@@ -28,34 +30,35 @@
 @reflectiveTest
 class CheckOtherLangaugesData {
   test_cppData() async {
-    List<int> data = await new io.File(path.join(
-      path.dirname(io.Platform.script.path),
+    List<int> data = await io.File(path.join(
+      path.context.current,
+      'test',
       'monsterdata_test.mon',
     )).readAsBytes();
-    example.Monster mon = new example.Monster(data);
+    example.Monster mon = example.Monster(data);
     expect(mon.hp, 80);
     expect(mon.mana, 150);
     expect(mon.name, 'MyMonster');
-    expect(mon.pos.x, 1.0);
-    expect(mon.pos.y, 2.0);
-    expect(mon.pos.z, 3.0);
-    expect(mon.pos.test1, 3.0);
-    expect(mon.pos.test2.value, 2.0);
-    expect(mon.pos.test3.a, 5);
-    expect(mon.pos.test3.b, 6);
-    expect(mon.testType.value, example.AnyTypeId.Monster.value);
+    expect(mon.pos!.x, 1.0);
+    expect(mon.pos!.y, 2.0);
+    expect(mon.pos!.z, 3.0);
+    expect(mon.pos!.test1, 3.0);
+    expect(mon.pos!.test2.value, 2.0);
+    expect(mon.pos!.test3.a, 5);
+    expect(mon.pos!.test3.b, 6);
+    expect(mon.testType!.value, example.AnyTypeId.Monster.value);
     expect(mon.test is example.Monster, true);
     final monster2 = mon.test as example.Monster;
     expect(monster2.name, "Fred");
 
-    expect(mon.inventory.length, 5);
-    expect(mon.inventory.reduce((cur, next) => cur + next), 10);
-    expect(mon.test4.length, 2);
-    expect(
-        mon.test4[0].a + mon.test4[0].b + mon.test4[1].a + mon.test4[1].b, 100);
-    expect(mon.testarrayofstring.length, 2);
-    expect(mon.testarrayofstring[0], "test1");
-    expect(mon.testarrayofstring[1], "test2");
+    expect(mon.inventory!.length, 5);
+    expect(mon.inventory!.reduce((cur, next) => cur + next), 10);
+    final test4 = mon.test4!;
+    expect(test4.length, 2);
+    expect(test4[0].a + test4[0].b + test4[1].a + test4[1].b, 100);
+    expect(mon.testarrayofstring!.length, 2);
+    expect(mon.testarrayofstring![0], "test1");
+    expect(mon.testarrayofstring![1], "test2");
 
     // this will fail if accessing any field fails.
     expect(
@@ -65,7 +68,7 @@
       'mana: 150, hp: 80, name: MyMonster, inventory: [0, 1, 2, 3, 4], '
       'color: Color{value: 8}, testType: AnyTypeId{value: 1}, '
       'test: Monster{pos: null, mana: 150, hp: 100, name: Fred, '
-      'inventory: null, color: Color{value: 8}, testType: AnyTypeId{value: 0}, '
+      'inventory: null, color: Color{value: 8}, testType: null, '
       'test: null, test4: null, testarrayofstring: null, '
       'testarrayoftables: null, enemy: null, testnestedflatbuffer: null, '
       'testempty: null, testbool: false, testhashs32Fnv1: 0, '
@@ -79,14 +82,14 @@
       'vectorOfWeakReferences: null, vectorOfStrongReferrables: null, '
       'coOwningReference: 0, vectorOfCoOwningReferences: null, '
       'nonOwningReference: 0, vectorOfNonOwningReferences: null, '
-      'anyUniqueType: AnyUniqueAliasesTypeId{value: 0}, anyUnique: null, '
-      'anyAmbiguousType: AnyAmbiguousAliasesTypeId{value: 0}, '
+      'anyUniqueType: null, anyUnique: null, anyAmbiguousType: null, '
       'anyAmbiguous: null, vectorOfEnums: null, signedEnum: Race{value: -1}, '
-      'testrequirednestedflatbuffer: null}, '
+      'testrequirednestedflatbuffer: null, scalarKeySortedTables: null, '
+      'nativeInline: null}, '
       'test4: [Test{a: 10, b: 20}, Test{a: 30, b: 40}], '
       'testarrayofstring: [test1, test2], testarrayoftables: null, '
       'enemy: Monster{pos: null, mana: 150, hp: 100, name: Fred, '
-      'inventory: null, color: Color{value: 8}, testType: AnyTypeId{value: 0}, '
+      'inventory: null, color: Color{value: 8}, testType: null, '
       'test: null, test4: null, testarrayofstring: null, '
       'testarrayoftables: null, enemy: null, testnestedflatbuffer: null, '
       'testempty: null, testbool: false, testhashs32Fnv1: 0, '
@@ -100,10 +103,10 @@
       'vectorOfWeakReferences: null, vectorOfStrongReferrables: null, '
       'coOwningReference: 0, vectorOfCoOwningReferences: null, '
       'nonOwningReference: 0, vectorOfNonOwningReferences: null, '
-      'anyUniqueType: AnyUniqueAliasesTypeId{value: 0}, anyUnique: null, '
-      'anyAmbiguousType: AnyAmbiguousAliasesTypeId{value: 0}, '
+      'anyUniqueType: null, anyUnique: null, anyAmbiguousType: null, '
       'anyAmbiguous: null, vectorOfEnums: null, signedEnum: Race{value: -1}, '
-      'testrequirednestedflatbuffer: null}, '
+      'testrequirednestedflatbuffer: null, scalarKeySortedTables: null, '
+      'nativeInline: null}, '
       'testnestedflatbuffer: null, testempty: null, testbool: true, '
       'testhashs32Fnv1: -579221183, testhashu32Fnv1: 3715746113, '
       'testhashs64Fnv1: 7930699090847568257, '
@@ -112,7 +115,9 @@
       'testhashs64Fnv1a: 4898026182817603057, '
       'testhashu64Fnv1a: 4898026182817603057, '
       'testarrayofbools: [true, false, true], testf: 3.14159, testf2: 3.0, '
-      'testf3: 0.0, testarrayofstring2: null, testarrayofsortedstruct: null, '
+      'testf3: 0.0, testarrayofstring2: null, testarrayofsortedstruct: ['
+      'Ability{id: 0, distance: 45}, Ability{id: 1, distance: 21}, '
+      'Ability{id: 5, distance: 12}], '
       'flex: null, test5: [Test{a: 10, b: 20}, Test{a: 30, b: 40}], '
       'vectorOfLongs: [1, 100, 10000, 1000000, 100000000], '
       'vectorOfDoubles: [-1.7976931348623157e+308, 0.0, 1.7976931348623157e+308], '
@@ -121,22 +126,44 @@
       'vectorOfStrongReferrables: null, coOwningReference: 0, '
       'vectorOfCoOwningReferences: null, nonOwningReference: 0, '
       'vectorOfNonOwningReferences: null, '
-      'anyUniqueType: AnyUniqueAliasesTypeId{value: 0}, anyUnique: null, '
-      'anyAmbiguousType: AnyAmbiguousAliasesTypeId{value: 0}, '
+      'anyUniqueType: null, anyUnique: null, '
+      'anyAmbiguousType: null, '
       'anyAmbiguous: null, vectorOfEnums: null, signedEnum: Race{value: -1}, '
-      'testrequirednestedflatbuffer: null}',
+      'testrequirednestedflatbuffer: null, scalarKeySortedTables: [Stat{id: '
+      'miss, val: 0, count: 0}, Stat{id: hit, val: 10, count: 1}], '
+      'nativeInline: Test{a: 1, b: 2}}',
     );
   }
 }
 
+/// Test a custom, fixed-memory allocator (no actual allocations performed)
+class CustomAllocator extends Allocator {
+  final _memory = ByteData(10 * 1024);
+  int _used = 0;
+
+  Uint8List buffer(int size) => _memory.buffer.asUint8List(_used - size, size);
+
+  @override
+  ByteData allocate(int size) {
+    if (size > _memory.lengthInBytes) {
+      throw UnsupportedError('Trying to allocate too much');
+    }
+    _used = size;
+    return ByteData.sublistView(_memory, 0, size);
+  }
+
+  @override
+  void deallocate(ByteData _) {}
+}
+
 @reflectiveTest
 class BuilderTest {
-  void test_monsterBuilder() {
-    final fbBuilder = new Builder();
+  void test_monsterBuilder([Builder? builder]) {
+    final fbBuilder = builder ?? Builder();
     final str = fbBuilder.writeString('MyMonster');
 
     fbBuilder.writeString('test1');
-    fbBuilder.writeString('test2');
+    fbBuilder.writeString('test2', asciiOptimization: true);
     final testArrayOfString = fbBuilder.endStructVector(2);
 
     final fred = fbBuilder.writeString('Fred');
@@ -144,12 +171,12 @@
     final List<int> treasure = [0, 1, 2, 3, 4];
     final inventory = fbBuilder.writeListUint8(treasure);
 
-    final monBuilder = new example.MonsterBuilder(fbBuilder)
+    final monBuilder = example.MonsterBuilder(fbBuilder)
       ..begin()
       ..addNameOffset(fred);
     final mon2 = monBuilder.finish();
 
-    final testBuilder = new example.TestBuilder(fbBuilder);
+    final testBuilder = example.TestBuilder(fbBuilder);
     testBuilder.finish(10, 20);
     testBuilder.finish(30, 40);
     final test4 = fbBuilder.endStructVector(2);
@@ -157,7 +184,7 @@
     monBuilder
       ..begin()
       ..addPos(
-        new example.Vec3Builder(fbBuilder).finish(
+        example.Vec3Builder(fbBuilder).finish(
           1.0,
           2.0,
           3.0,
@@ -177,50 +204,51 @@
     fbBuilder.finish(mon);
   }
 
-  void test_error_addInt32_withoutStartTable() {
-    Builder builder = new Builder();
+  void test_error_addInt32_withoutStartTable([Builder? builder]) {
+    builder ??= Builder();
     expect(() {
-      builder.addInt32(0, 0);
-    }, throwsStateError);
+      builder!.addInt32(0, 0);
+    }, throwsA(isA<AssertionError>()));
   }
 
   void test_error_addOffset_withoutStartTable() {
-    Builder builder = new Builder();
+    Builder builder = Builder();
     expect(() {
       builder.addOffset(0, 0);
-    }, throwsStateError);
+    }, throwsA(isA<AssertionError>()));
   }
 
   void test_error_endTable_withoutStartTable() {
-    Builder builder = new Builder();
+    Builder builder = Builder();
     expect(() {
       builder.endTable();
-    }, throwsStateError);
+    }, throwsA(isA<AssertionError>()));
   }
 
   void test_error_startTable_duringTable() {
-    Builder builder = new Builder();
-    builder.startTable();
+    Builder builder = Builder();
+    builder.startTable(0);
     expect(() {
-      builder.startTable();
-    }, throwsStateError);
+      builder.startTable(0);
+    }, throwsA(isA<AssertionError>()));
   }
 
   void test_error_writeString_duringTable() {
-    Builder builder = new Builder();
-    builder.startTable();
+    Builder builder = Builder();
+    builder.startTable(1);
     expect(() {
       builder.writeString('12345');
-    }, throwsStateError);
+    }, throwsA(isA<AssertionError>()));
   }
 
   void test_file_identifier() {
     Uint8List byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
-      builder.startTable();
+      Builder builder = Builder(initialSize: 0);
+      builder.startTable(0);
       int offset = builder.endTable();
-      byteList = builder.finish(offset, 'Az~');
+      builder.finish(offset, 'Az~');
+      byteList = builder.buffer;
     }
     // Convert byteList to a ByteData so that we can read data from it.
     ByteData byteData = byteList.buffer.asByteData(byteList.offsetInBytes);
@@ -243,32 +271,46 @@
   }
 
   void test_low() {
-    Builder builder = new Builder(initialSize: 0);
-    expect((builder..putUint8(1)).lowFinish(), [1]);
-    expect((builder..putUint32(2)).lowFinish(), [2, 0, 0, 0, 0, 0, 0, 1]);
-    expect((builder..putUint8(3)).lowFinish(),
-        [0, 0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 1]);
-    expect((builder..putUint8(4)).lowFinish(),
-        [0, 0, 4, 3, 2, 0, 0, 0, 0, 0, 0, 1]);
-    expect((builder..putUint8(5)).lowFinish(),
-        [0, 5, 4, 3, 2, 0, 0, 0, 0, 0, 0, 1]);
-    expect((builder..putUint32(6)).lowFinish(),
+    final allocator = CustomAllocator();
+    final builder = Builder(initialSize: 0, allocator: allocator);
+
+    builder.putUint8(1);
+    expect(allocator.buffer(builder.size()), [1]);
+
+    builder.putUint32(2);
+    expect(allocator.buffer(builder.size()), [2, 0, 0, 0, 0, 0, 0, 1]);
+
+    builder.putUint8(3);
+    expect(
+        allocator.buffer(builder.size()), [0, 0, 0, 3, 2, 0, 0, 0, 0, 0, 0, 1]);
+
+    builder.putUint8(4);
+    expect(
+        allocator.buffer(builder.size()), [0, 0, 4, 3, 2, 0, 0, 0, 0, 0, 0, 1]);
+
+    builder.putUint8(5);
+    expect(
+        allocator.buffer(builder.size()), [0, 5, 4, 3, 2, 0, 0, 0, 0, 0, 0, 1]);
+
+    builder.putUint32(6);
+    expect(allocator.buffer(builder.size()),
         [6, 0, 0, 0, 0, 5, 4, 3, 2, 0, 0, 0, 0, 0, 0, 1]);
   }
 
   void test_table_default() {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
-      builder.startTable();
+      final builder = Builder(initialSize: 0, allocator: CustomAllocator());
+      builder.startTable(2);
       builder.addInt32(0, 10, 10);
       builder.addInt32(1, 20, 10);
       int offset = builder.endTable();
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
       expect(builder.size(), byteList.length);
     }
     // read and verify
-    BufferContext buffer = new BufferContext.fromBytes(byteList);
+    BufferContext buffer = BufferContext.fromBytes(byteList);
     int objectOffset = buffer.derefObject(0);
     // was not written, so uses the new default value
     expect(
@@ -282,15 +324,16 @@
         20);
   }
 
-  void test_table_format() {
+  void test_table_format([Builder? builder]) {
     Uint8List byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
-      builder.startTable();
+      builder ??= Builder(initialSize: 0);
+      builder.startTable(3);
       builder.addInt32(0, 10);
       builder.addInt32(1, 20);
       builder.addInt32(2, 30);
-      byteList = builder.finish(builder.endTable());
+      builder.finish(builder.endTable());
+      byteList = builder.buffer;
     }
     // Convert byteList to a ByteData so that we can read data from it.
     ByteData byteData = byteList.buffer.asByteData(byteList.offsetInBytes);
@@ -319,30 +362,37 @@
     String unicodeString = ' ';
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
-      int latinStringOffset = builder.writeString(latinString);
-      int unicodeStringOffset = builder.writeString(unicodeString);
-      builder.startTable();
+      Builder builder = Builder(initialSize: 0);
+      int? latinStringOffset =
+          builder.writeString(latinString, asciiOptimization: true);
+      int? unicodeStringOffset =
+          builder.writeString(unicodeString, asciiOptimization: true);
+      builder.startTable(2);
       builder.addOffset(0, latinStringOffset);
       builder.addOffset(1, unicodeStringOffset);
       int offset = builder.endTable();
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
+    BufferContext buf = BufferContext.fromBytes(byteList);
     int objectOffset = buf.derefObject(0);
-    expect(const StringReader().vTableGet(buf, objectOffset, indexToField(0)),
+    expect(
+        const StringReader()
+            .vTableGetNullable(buf, objectOffset, indexToField(0)),
         latinString);
-    expect(const StringReader().vTableGet(buf, objectOffset, indexToField(1)),
+    expect(
+        const StringReader(asciiOptimization: true)
+            .vTableGetNullable(buf, objectOffset, indexToField(1)),
         unicodeString);
   }
 
-  void test_table_types() {
+  void test_table_types([Builder? builder]) {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
-      int stringOffset = builder.writeString('12345');
-      builder.startTable();
+      builder ??= Builder(initialSize: 0);
+      int? stringOffset = builder.writeString('12345');
+      builder.startTable(7);
       builder.addBool(0, true);
       builder.addInt8(1, 10);
       builder.addInt32(2, 20);
@@ -351,24 +401,39 @@
       builder.addUint32(5, 0x9ABCDEF0);
       builder.addUint8(6, 0x9A);
       int offset = builder.endTable();
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
+    BufferContext buf = BufferContext.fromBytes(byteList);
     int objectOffset = buf.derefObject(0);
     expect(
-        const BoolReader().vTableGet(buf, objectOffset, indexToField(0)), true);
+        const BoolReader()
+            .vTableGetNullable(buf, objectOffset, indexToField(0)),
+        true);
+    expect(
+        const Int8Reader()
+            .vTableGetNullable(buf, objectOffset, indexToField(1)),
+        10);
     expect(
-        const Int8Reader().vTableGet(buf, objectOffset, indexToField(1)), 10);
+        const Int32Reader()
+            .vTableGetNullable(buf, objectOffset, indexToField(2)),
+        20);
     expect(
-        const Int32Reader().vTableGet(buf, objectOffset, indexToField(2)), 20);
-    expect(const StringReader().vTableGet(buf, objectOffset, indexToField(3)),
+        const StringReader()
+            .vTableGetNullable(buf, objectOffset, indexToField(3)),
         '12345');
     expect(
-        const Int32Reader().vTableGet(buf, objectOffset, indexToField(4)), 40);
-    expect(const Uint32Reader().vTableGet(buf, objectOffset, indexToField(5)),
+        const Int32Reader()
+            .vTableGetNullable(buf, objectOffset, indexToField(4)),
+        40);
+    expect(
+        const Uint32Reader()
+            .vTableGetNullable(buf, objectOffset, indexToField(5)),
         0x9ABCDEF0);
-    expect(const Uint8Reader().vTableGet(buf, objectOffset, indexToField(6)),
+    expect(
+        const Uint8Reader()
+            .vTableGetNullable(buf, objectOffset, indexToField(6)),
         0x9A);
   }
 
@@ -377,12 +442,13 @@
     // write
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
+      Builder builder = Builder(initialSize: 0);
       int offset = builder.writeListUint32(values);
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
+    BufferContext buf = BufferContext.fromBytes(byteList);
     List<int> items = const Uint32ListReader().read(buf, 0);
     expect(items, hasLength(4));
     expect(items, orderedEquals(values));
@@ -393,16 +459,17 @@
       // write
       List<int> byteList;
       {
-        Builder builder = new Builder(initialSize: 0);
-        List<bool> values = new List<bool>.filled(len, false);
+        Builder builder = Builder(initialSize: 0);
+        List<bool> values = List<bool>.filled(len, false);
         for (int bit in trueBits) {
           values[bit] = true;
         }
         int offset = builder.writeListBool(values);
-        byteList = builder.finish(offset);
+        builder.finish(offset);
+        byteList = builder.buffer;
       }
       // read and verify
-      BufferContext buf = new BufferContext.fromBytes(byteList);
+      BufferContext buf = BufferContext.fromBytes(byteList);
       List<bool> items = const BoolListReader().read(buf, 0);
       expect(items, hasLength(len));
       for (int i = 0; i < items.length; i++) {
@@ -421,25 +488,26 @@
     verifyListBooleans(33, <int>[1, 2, 24, 25, 31, 32]);
     verifyListBooleans(63, <int>[]);
     verifyListBooleans(63, <int>[0, 1, 2, 61, 62]);
-    verifyListBooleans(63, new List<int>.generate(63, (i) => i));
+    verifyListBooleans(63, List<int>.generate(63, (i) => i));
     verifyListBooleans(64, <int>[]);
     verifyListBooleans(64, <int>[0, 1, 2, 61, 62, 63]);
     verifyListBooleans(64, <int>[1, 2, 62]);
     verifyListBooleans(64, <int>[0, 1, 2, 63]);
-    verifyListBooleans(64, new List<int>.generate(64, (i) => i));
+    verifyListBooleans(64, List<int>.generate(64, (i) => i));
     verifyListBooleans(100, <int>[0, 3, 30, 60, 90, 99]);
   }
 
   void test_writeList_ofInt32() {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
+      Builder builder = Builder(initialSize: 0);
       int offset = builder.writeListInt32(<int>[1, 2, 3, 4, 5]);
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
-    List<int> items = const ListReader<int>(const Int32Reader()).read(buf, 0);
+    BufferContext buf = BufferContext.fromBytes(byteList);
+    List<int> items = const ListReader<int>(Int32Reader()).read(buf, 0);
     expect(items, hasLength(5));
     expect(items, orderedEquals(<int>[1, 2, 3, 4, 5]));
   }
@@ -449,13 +517,14 @@
     // write
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
+      Builder builder = Builder(initialSize: 0);
       int offset = builder.writeListFloat64(values);
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
 
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
+    BufferContext buf = BufferContext.fromBytes(byteList);
     List<double> items = const Float64ListReader().read(buf, 0);
 
     expect(items, hasLength(values.length));
@@ -469,12 +538,13 @@
     // write
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
+      Builder builder = Builder(initialSize: 0);
       int offset = builder.writeListFloat32(values);
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
+    BufferContext buf = BufferContext.fromBytes(byteList);
     List<double> items = const Float32ListReader().read(buf, 0);
     expect(items, hasLength(5));
     for (int i = 0; i < values.length; i++) {
@@ -482,14 +552,14 @@
     }
   }
 
-  void test_writeList_ofObjects() {
+  void test_writeList_ofObjects([Builder? builder]) {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
+      builder ??= Builder(initialSize: 0);
       // write the object #1
       int object1;
       {
-        builder.startTable();
+        builder.startTable(2);
         builder.addInt32(0, 10);
         builder.addInt32(1, 20);
         object1 = builder.endTable();
@@ -497,19 +567,20 @@
       // write the object #1
       int object2;
       {
-        builder.startTable();
+        builder.startTable(2);
         builder.addInt32(0, 100);
         builder.addInt32(1, 200);
         object2 = builder.endTable();
       }
       // write the list
       int offset = builder.writeList([object1, object2]);
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
+    BufferContext buf = BufferContext.fromBytes(byteList);
     List<TestPointImpl> items =
-        const ListReader<TestPointImpl>(const TestPointReader()).read(buf, 0);
+        const ListReader<TestPointImpl>(TestPointReader()).read(buf, 0);
     expect(items, hasLength(2));
     expect(items[0].x, 10);
     expect(items[0].y, 20);
@@ -520,36 +591,37 @@
   void test_writeList_ofStrings_asRoot() {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
-      int str1 = builder.writeString('12345');
-      int str2 = builder.writeString('ABC');
+      Builder builder = Builder(initialSize: 0);
+      int? str1 = builder.writeString('12345');
+      int? str2 = builder.writeString('ABC');
       int offset = builder.writeList([str1, str2]);
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
-    List<String> items =
-        const ListReader<String>(const StringReader()).read(buf, 0);
+    BufferContext buf = BufferContext.fromBytes(byteList);
+    List<String> items = const ListReader<String>(StringReader()).read(buf, 0);
     expect(items, hasLength(2));
     expect(items, contains('12345'));
     expect(items, contains('ABC'));
   }
 
-  void test_writeList_ofStrings_inObject() {
+  void test_writeList_ofStrings_inObject([Builder? builder]) {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
+      builder ??= Builder(initialSize: 0);
       int listOffset = builder.writeList(
           [builder.writeString('12345'), builder.writeString('ABC')]);
-      builder.startTable();
+      builder.startTable(1);
       builder.addOffset(0, listOffset);
       int offset = builder.endTable();
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
-    StringListWrapperImpl reader = new StringListWrapperReader().read(buf, 0);
-    List<String> items = reader.items;
+    BufferContext buf = BufferContext.fromBytes(byteList);
+    StringListWrapperImpl reader = StringListWrapperReader().read(buf, 0);
+    List<String>? items = reader.items;
     expect(items, hasLength(2));
     expect(items, contains('12345'));
     expect(items, contains('ABC'));
@@ -558,12 +630,13 @@
   void test_writeList_ofUint32() {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
+      Builder builder = Builder(initialSize: 0);
       int offset = builder.writeListUint32(<int>[1, 2, 0x9ABCDEF0]);
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
+    BufferContext buf = BufferContext.fromBytes(byteList);
     List<int> items = const Uint32ListReader().read(buf, 0);
     expect(items, hasLength(3));
     expect(items, orderedEquals(<int>[1, 2, 0x9ABCDEF0]));
@@ -572,12 +645,13 @@
   void test_writeList_ofUint16() {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
+      Builder builder = Builder(initialSize: 0);
       int offset = builder.writeListUint16(<int>[1, 2, 60000]);
-      byteList = builder.finish(offset);
+      builder.finish(offset);
+      byteList = builder.buffer;
     }
     // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
+    BufferContext buf = BufferContext.fromBytes(byteList);
     List<int> items = const Uint16ListReader().read(buf, 0);
     expect(items, hasLength(3));
     expect(items, orderedEquals(<int>[1, 2, 60000]));
@@ -586,15 +660,188 @@
   void test_writeList_ofUint8() {
     List<int> byteList;
     {
-      Builder builder = new Builder(initialSize: 0);
-      int offset = builder.writeListUint8(<int>[1, 2, 3, 4, 0x9A]);
-      byteList = builder.finish(offset);
+      Builder builder = Builder(initialSize: 0);
+      int offset = builder.writeListUint8(<int>[1, 2, 3, 4, 0x9A, 0xFA]);
+      builder.finish(offset);
+      byteList = builder.buffer;
+    }
+    // read and verify
+    BufferContext buf = BufferContext.fromBytes(byteList);
+    const buffOffset = 8; // 32-bit offset to the list, + 32-bit length
+    for (final lazy in [true, false]) {
+      List<int> items = Uint8ListReader(lazy: lazy).read(buf, 0);
+      expect(items, hasLength(6));
+      expect(items, orderedEquals(<int>[1, 2, 3, 4, 0x9A, 0xFA]));
+
+      // overwrite the buffer to verify the laziness
+      buf.buffer.setUint8(buffOffset + 1, 99);
+      expect(items, orderedEquals(<int>[1, lazy ? 99 : 2, 3, 4, 0x9A, 0xFA]));
+
+      // restore the previous value for the next loop
+      buf.buffer.setUint8(buffOffset + 1, 2);
     }
-    // read and verify
-    BufferContext buf = new BufferContext.fromBytes(byteList);
-    List<int> items = const Uint8ListReader().read(buf, 0);
-    expect(items, hasLength(5));
-    expect(items, orderedEquals(<int>[1, 2, 3, 4, 0x9A]));
+  }
+
+  void test_reset() {
+    // We'll run a selection of tests , reusing the builder between them.
+    final testCases = <void Function(Builder?)>[
+      test_monsterBuilder,
+      test_error_addInt32_withoutStartTable,
+      test_table_format,
+      test_table_types,
+      test_writeList_ofObjects,
+      test_writeList_ofStrings_inObject
+    ];
+
+    // Execute all test cases in all permutations of their order.
+    // To do that, we generate permutations of test case indexes.
+    final testCasesPermutations =
+        _permutationsOf(List.generate(testCases.length, (index) => index));
+    expect(testCasesPermutations.length, _factorial(testCases.length));
+
+    for (var indexes in testCasesPermutations) {
+      // print the order so failures are reproducible
+      printOnFailure('Running reset() test cases in order: $indexes');
+
+      Builder? builder;
+      for (var index in indexes) {
+        if (builder == null) {
+          // Initial size small enough so at least one test case increases it.
+          // On the other hand, it's large enough so that some test cases don't.
+          builder = Builder(initialSize: 32);
+        } else {
+          builder.reset();
+        }
+        testCases[index](builder);
+      }
+    }
+  }
+
+  // Generate permutations of the given list
+  List<List<T>> _permutationsOf<T>(List<T> source) {
+    final result = <List<T>>[];
+
+    void permutate(List<T> items, int startAt) {
+      for (var i = startAt; i < items.length; i++) {
+        List<T> permutation = items.toList(growable: false);
+        permutation[i] = items[startAt];
+        permutation[startAt] = items[i];
+
+        // add the current list upon reaching the end
+        if (startAt == items.length - 1) {
+          result.add(items);
+        } else {
+          permutate(permutation, startAt + 1);
+        }
+      }
+    }
+
+    permutate(source, 0);
+    return result;
+  }
+
+  // a very simple implementation of n!
+  int _factorial(int n) {
+    var result = 1;
+    for (var i = 2; i <= n; i++) {
+      result *= i;
+    }
+    return result;
+  }
+}
+
+@reflectiveTest
+class ObjectAPITest {
+  void test_tableStat() {
+    final object1 = example.StatT(count: 3, id: "foo", val: 4);
+    expect(object1 is Packable, isTrue);
+    final fbb = Builder();
+    fbb.finish(object1.pack(fbb));
+    final object2 = example.Stat(fbb.buffer).unpack();
+    expect(object2.count, object1.count);
+    expect(object2.id, object1.id);
+    expect(object2.val, object1.val);
+    expect(object2.toString(), object1.toString());
+  }
+
+  void test_tableMonster() {
+    final monster = example.MonsterT()
+      ..pos = example.Vec3T(
+          x: 1,
+          y: 2,
+          z: 3,
+          test1: 4.0,
+          test2: example.Color.Red,
+          test3: example.TestT(a: 1, b: 2))
+      ..mana = 2
+      ..name = 'Monstrous'
+      ..inventory = [24, 42]
+      ..color = example.Color.Green
+      // TODO be smarter for unions and automatically set the `type` field?
+      ..testType = example.AnyTypeId.MyGame_Example2_Monster
+      ..test = example2.MonsterT()
+      ..test4 = [example.TestT(a: 3, b: 4), example.TestT(a: 5, b: 6)]
+      ..testarrayofstring = ["foo", "bar"]
+      ..testarrayoftables = [example.MonsterT(name: 'Oof')]
+      ..enemy = example.MonsterT(name: 'Enemy')
+      ..testarrayofbools = [false, true, false]
+      ..testf = 42.24
+      ..testarrayofsortedstruct = [
+        example.AbilityT(id: 1, distance: 5),
+        example.AbilityT(id: 3, distance: 7)
+      ]
+      ..vectorOfLongs = [5, 6, 7]
+      ..vectorOfDoubles = [8.9, 9.0, 10.1, 11.2]
+      ..anyAmbiguousType = example.AnyAmbiguousAliasesTypeId.M2
+      ..anyAmbiguous = null
+      ..vectorOfEnums = [example.Color.Blue, example.Color.Green]
+      ..signedEnum = example.Race.None;
+
+    final fbBuilder = Builder();
+    final offset = monster.pack(fbBuilder);
+    expect(offset, isNonZero);
+    fbBuilder.finish(offset);
+    final data = fbBuilder.buffer;
+
+    // TODO currently broken because of struct builder issue, see #6688
+    // final monster2 = example.Monster(data); // Monster (reader)
+    // expect(
+    //     // map Monster => MonsterT, Vec3 => Vec3T, ...
+    //     monster2.toString().replaceAllMapped(
+    //         RegExp('([a-zA-z0-9]+){'), (match) => match.group(1) + 'T{'),
+    //     monster.toString());
+    //
+    // final monster3 = monster2.unpack(); // MonsterT
+    // expect(monster3.toString(), monster.toString());
+  }
+
+  void test_Lists() {
+    // Ensure unpack() reads lists eagerly by reusing the same builder and
+    // overwriting data. Why: because standard reader reads lists lazily...
+    final fbb = Builder();
+
+    final object1 = example.TypeAliasesT(v8: [1, 2, 3], vf64: [5, 6]);
+    fbb.finish(object1.pack(fbb));
+    final object1Read = example.TypeAliases(fbb.buffer).unpack();
+
+    // overwrite the original buffer by writing to the same builder
+    fbb.reset();
+    final object2 = example.TypeAliasesT(v8: [7, 8, 9], vf64: [10, 11]);
+    fbb.finish(object2.pack(fbb));
+    final object2Read = example.TypeAliases(fbb.buffer).unpack();
+
+    // this is fine even with lazy lists:
+    expect(object2.toString(), object2Read.toString());
+
+    // this fails with lazy lists:
+    expect(object1.toString(), object1Read.toString());
+
+    // empty list must be serialized as such (were stored NULL before v2.0)
+    fbb.reset();
+    final object3 = example.TypeAliasesT(v8: [], vf64: null);
+    fbb.finish(object3.pack(fbb));
+    final object3Read = example.TypeAliases(fbb.buffer).unpack();
+    expect(object3.toString(), object3Read.toString());
   }
 }
 
@@ -604,8 +851,8 @@
 
   StringListWrapperImpl(this.bp, this.offset);
 
-  List<String> get items => const ListReader<String>(const StringReader())
-      .vTableGet(bp, offset, indexToField(0));
+  List<String>? get items => const ListReader<String>(StringReader())
+      .vTableGetNullable(bp, offset, indexToField(0));
 }
 
 class StringListWrapperReader extends TableReader<StringListWrapperImpl> {
@@ -613,7 +860,7 @@
 
   @override
   StringListWrapperImpl createObject(BufferContext object, int offset) {
-    return new StringListWrapperImpl(object, offset);
+    return StringListWrapperImpl(object, offset);
   }
 }
 
@@ -633,7 +880,7 @@
 
   @override
   TestPointImpl createObject(BufferContext object, int offset) {
-    return new TestPointImpl(object, offset);
+    return TestPointImpl(object, offset);
   }
 }
 
@@ -643,7 +890,9 @@
     expect(example.Color.values, same(example.Color.values));
     expect(example.Race.values, same(example.Race.values));
     expect(example.AnyTypeId.values, same(example.AnyTypeId.values));
-    expect(example.AnyUniqueAliasesTypeId.values, same(example.AnyUniqueAliasesTypeId.values));
-    expect(example.AnyAmbiguousAliasesTypeId.values, same(example.AnyAmbiguousAliasesTypeId.values));
+    expect(example.AnyUniqueAliasesTypeId.values,
+        same(example.AnyUniqueAliasesTypeId.values));
+    expect(example.AnyAmbiguousAliasesTypeId.values,
+        same(example.AnyAmbiguousAliasesTypeId.values));
   }
 }
diff -urN a/dart/test/flex_builder_test.dart b/dart/test/flex_builder_test.dart
--- a/dart/test/flex_builder_test.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/test/flex_builder_test.dart	2023-01-13 07:47:12.522285700 +0000
@@ -58,18 +58,18 @@
     {
       var flx = Builder();
       flx.addString('hello ');
-      expect(flx.finish(), [10, 104, 101, 108, 108, 111, 32, 240, 159, 152, 177, 0, 11, 20, 1]);
+      expect(flx.finish(),
+          [10, 104, 101, 108, 108, 111, 32, 240, 159, 152, 177, 0, 11, 20, 1]);
     }
   });
 
-  test('build vector', (){
+  test('build vector', () {
     {
       var flx = Builder()
         ..startVector()
         ..addInt(1)
         ..addInt(2)
-        ..end()
-      ;
+        ..end();
       expect(flx.finish(), [1, 2, 2, 64, 1]);
     }
     {
@@ -77,8 +77,7 @@
         ..startVector()
         ..addInt(-1)
         ..addInt(256)
-        ..end()
-      ;
+        ..end();
       expect(flx.finish(), [255, 255, 0, 1, 4, 65, 1]);
     }
     {
@@ -86,8 +85,7 @@
         ..startVector()
         ..addInt(-45)
         ..addInt(256000)
-        ..end()
-      ;
+        ..end();
       expect(flx.finish(), [211, 255, 255, 255, 0, 232, 3, 0, 8, 66, 1]);
     }
     {
@@ -95,9 +93,28 @@
         ..startVector()
         ..addDouble(1.1)
         ..addDouble(-256)
-        ..end()
-      ;
-      expect(flx.finish(), [154, 153, 153, 153, 153, 153, 241, 63, 0, 0, 0, 0, 0, 0, 112, 192, 16, 75, 1]);
+        ..end();
+      expect(flx.finish(), [
+        154,
+        153,
+        153,
+        153,
+        153,
+        153,
+        241,
+        63,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        112,
+        192,
+        16,
+        75,
+        1
+      ]);
     }
     {
       var flx = Builder()
@@ -105,8 +122,7 @@
         ..addInt(1)
         ..addInt(2)
         ..addInt(4)
-        ..end()
-      ;
+        ..end();
       expect(flx.finish(), [1, 2, 4, 3, 76, 1]);
     }
     {
@@ -115,19 +131,17 @@
         ..addInt(-1)
         ..addInt(256)
         ..addInt(4)
-        ..end()
-      ;
+        ..end();
       expect(flx.finish(), [255, 255, 0, 1, 4, 0, 6, 77, 1]);
     }
     {
       var flx = Builder()
         ..startVector()
-          ..startVector()
-          ..addInt(61)
-          ..end()
-        ..addInt(64)
+        ..startVector()
+        ..addInt(61)
         ..end()
-      ;
+        ..addInt(64)
+        ..end();
       expect(flx.finish(), [1, 61, 2, 2, 64, 44, 4, 4, 40, 1]);
     }
     {
@@ -136,9 +150,31 @@
         ..addString('foo')
         ..addString('bar')
         ..addString('baz')
-        ..end()
-      ;
-      expect(flx.finish(), [3, 102, 111, 111, 0, 3, 98, 97, 114, 0, 3, 98, 97, 122, 0, 3, 15, 11, 7, 3, 60, 1]);
+        ..end();
+      expect(flx.finish(), [
+        3,
+        102,
+        111,
+        111,
+        0,
+        3,
+        98,
+        97,
+        114,
+        0,
+        3,
+        98,
+        97,
+        122,
+        0,
+        3,
+        15,
+        11,
+        7,
+        3,
+        60,
+        1
+      ]);
     }
     {
       var flx = Builder()
@@ -149,9 +185,34 @@
         ..addString('foo')
         ..addString('bar')
         ..addString('baz')
-        ..end()
-      ;
-      expect(flx.finish(), [3, 102, 111, 111, 0, 3, 98, 97, 114, 0, 3, 98, 97, 122, 0, 6, 15, 11, 7, 18, 14, 10, 6, 60, 1]);
+        ..end();
+      expect(flx.finish(), [
+        3,
+        102,
+        111,
+        111,
+        0,
+        3,
+        98,
+        97,
+        114,
+        0,
+        3,
+        98,
+        97,
+        122,
+        0,
+        6,
+        15,
+        11,
+        7,
+        18,
+        14,
+        10,
+        6,
+        60,
+        1
+      ]);
     }
     {
       var flx = Builder()
@@ -159,8 +220,7 @@
         ..addBool(true)
         ..addBool(false)
         ..addBool(true)
-        ..end()
-      ;
+        ..end();
       expect(flx.finish(), [3, 1, 0, 1, 3, 144, 1]);
     }
     {
@@ -171,29 +231,83 @@
         ..addInt(-5)
         ..addDouble(1.3)
         ..addBool(true)
-        ..end()
-      ;
+        ..end();
       expect(flx.finish(), [
-        3, 102, 111, 111, 0, 0, 0, 0,
-        5, 0, 0, 0, 0, 0, 0, 0,
-        15, 0, 0, 0, 0, 0, 0, 0,
-        1, 0, 0, 0, 0, 0, 0, 0,
-        251, 255, 255, 255, 255, 255, 255, 255,
-        205, 204, 204, 204, 204, 204, 244, 63,
-        1, 0, 0, 0, 0, 0, 0, 0,
-        20, 4, 4, 15, 104, 45, 43, 1]);
+        3,
+        102,
+        111,
+        111,
+        0,
+        0,
+        0,
+        0,
+        5,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        15,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        1,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        251,
+        255,
+        255,
+        255,
+        255,
+        255,
+        255,
+        255,
+        205,
+        204,
+        204,
+        204,
+        204,
+        204,
+        244,
+        63,
+        1,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        0,
+        20,
+        4,
+        4,
+        15,
+        104,
+        45,
+        43,
+        1
+      ]);
     }
   });
 
-  test('build map', ()
-  {
+  test('build map', () {
     {
       var flx = Builder()
         ..startMap()
         ..addKey('a')
         ..addInt(12)
-        ..end()
-      ;
+        ..end();
       expect(flx.finish(), [97, 0, 1, 3, 1, 1, 1, 12, 4, 2, 36, 1]);
     }
     {
@@ -203,105 +317,270 @@
         ..addInt(12)
         ..addKey('')
         ..addInt(45)
-        ..end()
-      ;
-      expect(flx.finish(), [97, 0, 0, 2, 2, 5, 2, 1, 2, 45, 12, 4, 4, 4, 36, 1]);
+        ..end();
+      expect(
+          flx.finish(), [97, 0, 0, 2, 2, 5, 2, 1, 2, 45, 12, 4, 4, 4, 36, 1]);
     }
     {
       var flx = Builder()
         ..startVector()
-          ..startMap()
-            ..addKey('something')
-            ..addInt(12)
-          ..end()
-          ..startMap()
-            ..addKey('something')
-            ..addInt(45)
-          ..end()
+        ..startMap()
+        ..addKey('something')
+        ..addInt(12)
         ..end()
-      ;
-      expect(flx.finish(), [115, 111, 109, 101, 116, 104, 105, 110, 103, 0,
-        1, 11, 1, 1, 1, 12, 4, 6, 1, 1, 45, 4, 2, 8, 4, 36, 36, 4, 40, 1]);
+        ..startMap()
+        ..addKey('something')
+        ..addInt(45)
+        ..end()
+        ..end();
+      expect(flx.finish(), [
+        115,
+        111,
+        109,
+        101,
+        116,
+        104,
+        105,
+        110,
+        103,
+        0,
+        1,
+        11,
+        1,
+        1,
+        1,
+        12,
+        4,
+        6,
+        1,
+        1,
+        45,
+        4,
+        2,
+        8,
+        4,
+        36,
+        36,
+        4,
+        40,
+        1
+      ]);
     }
   });
 
-  test('build blob', ()
-  {
+  test('build blob', () {
     {
-      var flx = Builder()
-        ..addBlob(Uint8List.fromList([1, 2, 3]).buffer)
-      ;
+      var flx = Builder()..addBlob(Uint8List.fromList([1, 2, 3]).buffer);
       expect(flx.finish(), [3, 1, 2, 3, 3, 100, 1]);
     }
   });
 
-  test('build from object', (){
-    expect(Builder.buildFromObject(Uint8List.fromList([1, 2, 3]).buffer).asUint8List(), [3, 1, 2, 3, 3, 100, 1]);
+  test('build from object', () {
+    expect(
+        Builder.buildFromObject(Uint8List.fromList([1, 2, 3]).buffer)
+            .asUint8List(),
+        [3, 1, 2, 3, 3, 100, 1]);
     expect(Builder.buildFromObject(null).asUint8List(), [0, 0, 1]);
     expect(Builder.buildFromObject(true).asUint8List(), [1, 104, 1]);
     expect(Builder.buildFromObject(false).asUint8List(), [0, 104, 1]);
     expect(Builder.buildFromObject(25).asUint8List(), [25, 4, 1]);
     expect(Builder.buildFromObject(-250).asUint8List(), [6, 255, 5, 2]);
-    expect(Builder.buildFromObject(-2.50).asUint8List(), [0, 0, 32, 192, 14, 4]);
-    expect(Builder.buildFromObject('Maxim').asUint8List(), [5, 77, 97, 120, 105, 109, 0, 6, 20, 1]);
-    expect(Builder.buildFromObject([1, 3.3, 'max', true, null, false]).asUint8List(), [
-      3, 109, 97, 120, 0, 0, 0, 0,
-      6, 0, 0, 0, 0, 0, 0, 0,
-      1, 0, 0, 0, 0, 0, 0, 0,
-      102, 102, 102, 102, 102, 102, 10, 64,
-      31, 0, 0, 0, 0, 0, 0, 0,
-      1, 0, 0, 0, 0, 0, 0, 0,
-      0, 0, 0, 0, 0, 0, 0, 0,
-      0, 0, 0, 0, 0, 0, 0, 0,
-      4, 15, 20, 104, 0, 104, 54, 43, 1
-    ]);
-    expect(Builder.buildFromObject([{'something':12}, {'something': 45}]).asUint8List(), [
-      115, 111, 109, 101, 116, 104, 105, 110, 103, 0,
-      1, 11, 1, 1, 1, 12, 4, 6, 1, 1, 45, 4, 2, 8, 4, 36, 36, 4, 40, 1
-    ]);
+    expect(
+        Builder.buildFromObject(-2.50).asUint8List(), [0, 0, 32, 192, 14, 4]);
+    expect(Builder.buildFromObject('Maxim').asUint8List(),
+        [5, 77, 97, 120, 105, 109, 0, 6, 20, 1]);
+    expect(
+        Builder.buildFromObject([1, 3.3, 'max', true, null, false])
+            .asUint8List(),
+        [
+          3,
+          109,
+          97,
+          120,
+          0,
+          0,
+          0,
+          0,
+          6,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          1,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          102,
+          102,
+          102,
+          102,
+          102,
+          102,
+          10,
+          64,
+          31,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          1,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          0,
+          4,
+          15,
+          20,
+          104,
+          0,
+          104,
+          54,
+          43,
+          1
+        ]);
+    expect(
+        Builder.buildFromObject([
+          {'something': 12},
+          {'something': 45}
+        ]).asUint8List(),
+        [
+          115,
+          111,
+          109,
+          101,
+          116,
+          104,
+          105,
+          110,
+          103,
+          0,
+          1,
+          11,
+          1,
+          1,
+          1,
+          12,
+          4,
+          6,
+          1,
+          1,
+          45,
+          4,
+          2,
+          8,
+          4,
+          36,
+          36,
+          4,
+          40,
+          1
+        ]);
   });
 
-  test('add double indirectly', (){
-    var flx = Builder()
-      ..addDoubleIndirectly(0.1)
-    ;
+  test('add double indirectly', () {
+    var flx = Builder()..addDoubleIndirectly(0.1);
     expect(flx.finish(), [154, 153, 153, 153, 153, 153, 185, 63, 8, 35, 1]);
   });
 
-  test('add double indirectly to vector with cache', (){
+  test('add double indirectly to vector with cache', () {
     var flx = Builder()
       ..startVector()
       ..addDoubleIndirectly(0.1, cache: true)
       ..addDoubleIndirectly(0.1, cache: true)
       ..addDoubleIndirectly(0.1, cache: true)
       ..addDoubleIndirectly(0.1, cache: true)
-      ..end()
-    ;
-    expect(flx.finish(), [154, 153, 153, 153, 153, 153, 185, 63,
-      4, 9, 10, 11, 12, 35, 35, 35, 35, 8, 40, 1]);
+      ..end();
+    expect(flx.finish(), [
+      154,
+      153,
+      153,
+      153,
+      153,
+      153,
+      185,
+      63,
+      4,
+      9,
+      10,
+      11,
+      12,
+      35,
+      35,
+      35,
+      35,
+      8,
+      40,
+      1
+    ]);
   });
 
-  test('add int indirectly', (){
-    var flx = Builder()
-      ..addIntIndirectly(2345234523452345)
-    ;
+  test('add int indirectly', () {
+    var flx = Builder()..addIntIndirectly(2345234523452345);
     expect(flx.finish(), [185, 115, 175, 118, 250, 84, 8, 0, 8, 27, 1]);
   });
 
-  test('add int indirectly to vector with cache', (){
+  test('add int indirectly to vector with cache', () {
     var flx = Builder()
       ..startVector()
       ..addIntIndirectly(2345234523452345, cache: true)
       ..addIntIndirectly(2345234523452345, cache: true)
       ..addIntIndirectly(2345234523452345, cache: true)
       ..addIntIndirectly(2345234523452345, cache: true)
-      ..end()
-    ;
-    expect(flx.finish(), [185, 115, 175, 118, 250, 84, 8, 0,
-      4, 9, 10, 11, 12, 27, 27, 27, 27, 8, 40, 1]);
+      ..end();
+    expect(flx.finish(), [
+      185,
+      115,
+      175,
+      118,
+      250,
+      84,
+      8,
+      0,
+      4,
+      9,
+      10,
+      11,
+      12,
+      27,
+      27,
+      27,
+      27,
+      8,
+      40,
+      1
+    ]);
   });
 
-  test('snapshot', (){
+  test('snapshot', () {
     var flx = Builder();
     flx.startVector();
     flx.addInt(12);
@@ -312,4 +591,3 @@
     expect(flx.snapshot().asUint8List(), [12, 24, 45, 3, 76, 1]);
   });
 }
-
diff -urN a/dart/test/flex_reader_test.dart b/dart/test/flex_reader_test.dart
--- a/dart/test/flex_reader_test.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/test/flex_reader_test.dart	2023-01-13 07:47:12.522285700 +0000
@@ -21,55 +21,68 @@
     expect(Reference.fromBuffer(b([255, 251, 5, 2])).intValue, -1025);
     expect(Reference.fromBuffer(b([1, 4, 9, 2])).intValue, 1025);
     expect(Reference.fromBuffer(b([255, 255, 255, 127, 6, 4])).intValue,
-      2147483647);
+        2147483647);
+    expect(Reference.fromBuffer(b([0, 0, 0, 128, 6, 4])).intValue, -2147483648);
     expect(
-      Reference.fromBuffer(b([0, 0, 0, 128, 6, 4])).intValue, -2147483648);
+        Reference.fromBuffer(b([255, 255, 255, 255, 0, 0, 0, 0, 7, 8]))
+            .intValue,
+        4294967295);
     expect(
-      Reference.fromBuffer(b([255, 255, 255, 255, 0, 0, 0, 0, 7, 8]))
-        .intValue,
-      4294967295);
-    expect(
-      Reference.fromBuffer(b([255, 255, 255, 255, 255, 255, 255, 127, 7, 8]))
-        .intValue,
-      9223372036854775807);
+        Reference.fromBuffer(b([255, 255, 255, 255, 255, 255, 255, 127, 7, 8]))
+            .intValue,
+        9223372036854775807);
     expect(Reference.fromBuffer(b([0, 0, 0, 0, 0, 0, 0, 128, 7, 8])).intValue,
-      -9223372036854775808);
+        -9223372036854775808);
     // Dart does not really support UInt64
 //      expect(FlxValue.fromBuffer(b([255, 255, 255, 255, 255, 255, 255, 255, 11, 8])).intValue, 18446744073709551615);
   });
   test('double value', () {
     expect(Reference.fromBuffer(b([0, 0, 144, 64, 14, 4])).doubleValue, 4.5);
     expect(Reference.fromBuffer(b([205, 204, 204, 61, 14, 4])).doubleValue,
-      closeTo(.1, .001));
+        closeTo(.1, .001));
     expect(
-      Reference.fromBuffer(b([154, 153, 153, 153, 153, 153, 185, 63, 15, 8]))
-        .doubleValue,
-      .1);
+        Reference.fromBuffer(b([154, 153, 153, 153, 153, 153, 185, 63, 15, 8]))
+            .doubleValue,
+        .1);
   });
   test('num value', () {
     expect(Reference.fromBuffer(b([0, 0, 144, 64, 14, 4])).numValue, 4.5);
     expect(Reference.fromBuffer(b([205, 204, 204, 61, 14, 4])).numValue,
-      closeTo(.1, .001));
+        closeTo(.1, .001));
     expect(
-      Reference.fromBuffer(b([154, 153, 153, 153, 153, 153, 185, 63, 15, 8]))
-        .numValue,
-      .1);
+        Reference.fromBuffer(b([154, 153, 153, 153, 153, 153, 185, 63, 15, 8]))
+            .numValue,
+        .1);
     expect(Reference.fromBuffer(b([255, 251, 5, 2])).numValue, -1025);
   });
   test('string value', () {
     expect(
-      Reference.fromBuffer(b([5, 77, 97, 120, 105, 109, 0, 6, 20, 1]))
-        .stringValue,
-      'Maxim');
-    expect(
-      Reference.fromBuffer(b([
-        10, 104, 101, 108, 108, 111, 32, 240, 159, 152, 177, 0, 11, 20, 1
-      ])).stringValue,
-      'hello ');
+        Reference.fromBuffer(b([5, 77, 97, 120, 105, 109, 0, 6, 20, 1]))
+            .stringValue,
+        'Maxim');
+    expect(
+        Reference.fromBuffer(b([
+          10,
+          104,
+          101,
+          108,
+          108,
+          111,
+          32,
+          240,
+          159,
+          152,
+          177,
+          0,
+          11,
+          20,
+          1
+        ])).stringValue,
+        'hello ');
   });
   test('blob value', () {
     expect(
-      Reference.fromBuffer(b([3, 1, 2, 3, 3, 100, 1])).blobValue, [1, 2, 3]);
+        Reference.fromBuffer(b([3, 1, 2, 3, 3, 100, 1])).blobValue, [1, 2, 3]);
   });
   test('bool vector', () {
     var flx = Reference.fromBuffer(b([3, 1, 0, 1, 3, 144, 1]));
@@ -81,27 +94,92 @@
     testNumbers([3, 1, 2, 3, 3, 44, 1], [1, 2, 3]);
     testNumbers([3, 255, 2, 3, 3, 44, 1], [-1, 2, 3]);
     testNumbers([3, 0, 1, 0, 43, 2, 3, 0, 6, 45, 1], [1, 555, 3]);
-    testNumbers(
-      [3, 0, 0, 0, 1, 0, 0, 0, 204, 216, 0, 0, 3, 0, 0, 0, 12, 46, 1],
-      [1, 55500, 3]);
+    testNumbers([3, 0, 0, 0, 1, 0, 0, 0, 204, 216, 0, 0, 3, 0, 0, 0, 12, 46, 1],
+        [1, 55500, 3]);
     testNumbers([
-      3, 0, 0, 0, 0, 0, 0, 0,
-      1, 0, 0, 0, 0, 0, 0, 0,
-      172, 128, 94, 239, 12, 0, 0, 0,
-      3, 0, 0, 0, 0, 0, 0, 0,
-      24, 47, 1
-    ], [1, 55555555500, 3
+      3,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      1,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      172,
+      128,
+      94,
+      239,
+      12,
+      0,
+      0,
+      0,
+      3,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      24,
+      47,
+      1
+    ], [
+      1,
+      55555555500,
+      3
     ]);
     testNumbers(
-      [3, 0, 0, 0, 0, 0, 192, 63, 0, 0, 32, 64, 0, 0, 96, 64, 12, 54, 1],
-      [1.5, 2.5, 3.5]);
+        [3, 0, 0, 0, 0, 0, 192, 63, 0, 0, 32, 64, 0, 0, 96, 64, 12, 54, 1],
+        [1.5, 2.5, 3.5]);
     testNumbers([
-      3, 0, 0, 0, 0, 0, 0, 0,
-      154, 153, 153, 153, 153, 153, 241, 63,
-      154, 153, 153, 153, 153, 153, 1, 64,
-      102, 102, 102, 102, 102, 102, 10, 64,
-      24, 55, 1
-    ], [1.1, 2.2, 3.3
+      3,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      154,
+      153,
+      153,
+      153,
+      153,
+      153,
+      241,
+      63,
+      154,
+      153,
+      153,
+      153,
+      153,
+      153,
+      1,
+      64,
+      102,
+      102,
+      102,
+      102,
+      102,
+      102,
+      10,
+      64,
+      24,
+      55,
+      1
+    ], [
+      1.1,
+      2.2,
+      3.3
     ]);
   });
   test('number vector, fixed type', () {
@@ -109,11 +187,28 @@
     testNumbers([255, 255, 0, 1, 4, 65, 1], [-1, 256]);
     testNumbers([211, 255, 255, 255, 0, 232, 3, 0, 8, 66, 1], [-45, 256000]);
     testNumbers([
-      211, 255, 255, 255, 255, 255, 255, 255,
-      255, 255, 255, 255, 255, 255, 255, 127,
-      16, 67, 1
+      211,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      127,
+      16,
+      67,
+      1
     ], [
-      -45, 9223372036854775807
+      -45,
+      9223372036854775807
     ]);
 
     testNumbers([1, 2, 2, 68, 1], [1, 2]);
@@ -122,85 +217,326 @@
 
     testNumbers([205, 204, 140, 63, 0, 0, 0, 192, 8, 74, 1], [1.1, -2]);
     testNumbers([
-      154, 153, 153, 153, 153, 153, 241, 63,
-      0, 0, 0, 0, 0, 0, 112, 192,
-      16, 75, 1
+      154,
+      153,
+      153,
+      153,
+      153,
+      153,
+      241,
+      63,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      112,
+      192,
+      16,
+      75,
+      1
     ], [
-      1.1, -256
+      1.1,
+      -256
     ]);
 
     testNumbers([211, 255, 255, 255, 0, 232, 3, 0, 4, 0, 0, 0, 12, 78, 1],
-      [-45, 256000, 4]);
+        [-45, 256000, 4]);
 
     testNumbers([
-      211, 255, 255, 255, 255, 255, 255, 255,
-      255, 255, 255, 255, 255, 255, 255, 127,
-      4, 0, 0, 0, 0, 0, 0, 0,
-      9, 0, 0, 0, 0, 0, 0, 0,
-      32, 91, 1
+      211,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      127,
+      4,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      9,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      32,
+      91,
+      1
     ], [
-      -45, 9223372036854775807, 4, 9
+      -45,
+      9223372036854775807,
+      4,
+      9
     ]);
 
     testNumbers([
-      45, 0, 0, 0, 0, 0, 0, 0,
-      255, 255, 255, 255, 255, 255, 255, 127,
-      4, 0, 0, 0, 0, 0, 0, 0,
-      9, 0, 0, 0, 0, 0, 0, 0,
-      32, 95, 1
+      45,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      127,
+      4,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      9,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      32,
+      95,
+      1
     ], [
-      45, 9223372036854775807, 4, 9
+      45,
+      9223372036854775807,
+      4,
+      9
     ]);
 
     testNumbers([
-      154, 153, 153, 153, 153, 153, 241, 63,
-      0, 0, 0, 0, 0, 0, 112, 64,
-      0, 0, 0, 0, 0, 0, 16, 64,
-      24, 87, 1
+      154,
+      153,
+      153,
+      153,
+      153,
+      153,
+      241,
+      63,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      112,
+      64,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      16,
+      64,
+      24,
+      87,
+      1
     ], [
-      1.1, 256, 4
+      1.1,
+      256,
+      4
     ]);
 
     testNumbers([
-      154, 153, 153, 153, 153, 153, 241, 63,
-      0, 0, 0, 0, 0, 0, 112, 64,
-      0, 0, 0, 0, 0, 0, 16, 64,
-      0, 0, 0, 0, 0, 0, 34, 64,
-      32, 99, 1
+      154,
+      153,
+      153,
+      153,
+      153,
+      153,
+      241,
+      63,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      112,
+      64,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      16,
+      64,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      34,
+      64,
+      32,
+      99,
+      1
     ], [
-      1.1, 256, 4, 9
+      1.1,
+      256,
+      4,
+      9
     ]);
   });
   test('string vector', () {
     testStrings([
-      3, 102, 111, 111, 0,
-      3, 98, 97, 114, 0,
-      3, 98, 97, 122, 0,
-      3, 15, 11, 7,
-      3, 60, 1
+      3,
+      102,
+      111,
+      111,
+      0,
+      3,
+      98,
+      97,
+      114,
+      0,
+      3,
+      98,
+      97,
+      122,
+      0,
+      3,
+      15,
+      11,
+      7,
+      3,
+      60,
+      1
     ], [
-      'foo', 'bar', 'baz'
+      'foo',
+      'bar',
+      'baz'
     ]);
     testStrings([
-      3, 102, 111, 111, 0,
-      3, 98, 97, 114, 0,
-      3, 98, 97, 122, 0,
-      6, 15, 11, 7, 18, 14, 10,
-      6, 60, 1
+      3,
+      102,
+      111,
+      111,
+      0,
+      3,
+      98,
+      97,
+      114,
+      0,
+      3,
+      98,
+      97,
+      122,
+      0,
+      6,
+      15,
+      11,
+      7,
+      18,
+      14,
+      10,
+      6,
+      60,
+      1
     ], [
-      'foo', 'bar', 'baz', 'foo', 'bar', 'baz'
+      'foo',
+      'bar',
+      'baz',
+      'foo',
+      'bar',
+      'baz'
     ]);
   });
   test('mixed vector', () {
     var flx = Reference.fromBuffer(b([
-      3, 102, 111, 111, 0, 0, 0, 0,
-      5, 0, 0, 0, 0, 0, 0, 0,
-      15, 0, 0, 0, 0, 0, 0, 0,
-      1, 0, 0, 0, 0, 0, 0, 0,
-      251, 255, 255, 255, 255, 255, 255, 255,
-      205, 204, 204, 204, 204, 204, 244, 63,
-      1, 0, 0, 0, 0, 0, 0, 0,
-      20, 4, 4, 15, 104, 45, 43, 1
+      3,
+      102,
+      111,
+      111,
+      0,
+      0,
+      0,
+      0,
+      5,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      15,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      1,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      251,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      255,
+      205,
+      204,
+      204,
+      204,
+      204,
+      204,
+      244,
+      63,
+      1,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      0,
+      20,
+      4,
+      4,
+      15,
+      104,
+      45,
+      43,
+      1
     ]));
     expect(flx.length, 5);
     expect(flx[0].stringValue, 'foo');
@@ -216,7 +552,8 @@
     expect(flx['a'].numValue, 12);
   });
   test('two value map', () {
-    var flx = Reference.fromBuffer(b([0, 97, 0, 2, 4, 4, 2, 1, 2, 45, 12, 4, 4, 4, 36, 1]));
+    var flx = Reference.fromBuffer(
+        b([0, 97, 0, 2, 4, 4, 2, 1, 2, 45, 12, 4, 4, 4, 36, 1]));
     expect(flx.length, 2);
     expect(flx['a'].numValue, 12);
     expect(flx[''].numValue, 45);
@@ -239,45 +576,239 @@
     expect(flx['address']['zip'].stringValue, '12345');
     expect(flx['address']['countryCode'].stringValue, 'XX');
 
-    expect(() => flx['address']['country'].stringValue,
-      throwsA(predicate((e) => e is ArgumentError && e.message == 'Key: [country] is not applicable on: //address of: ValueType.Map')));
-    expect(() => flx['address']['countryCode'][0],
-      throwsA(predicate((e) => e is ArgumentError && e.message == 'Key: [0] is not applicable on: //address/countryCode of: ValueType.String')));
-    expect(() => flx[1],
-      throwsA(predicate((e) => e is ArgumentError && e.message == 'Key: [1] is not applicable on: / of: ValueType.Map')));
-    expect(() => flx['flags'][4],
-      throwsA(predicate((e) => e is ArgumentError && e.message == 'Key: [4] is not applicable on: //flags of: ValueType.VectorBool length: 4')));
-    expect(() => flx['flags'][-1],
-      throwsA(predicate((e) => e is ArgumentError && e.message == 'Key: [-1] is not applicable on: //flags of: ValueType.VectorBool length: 4')));
+    expect(
+        () => flx['address']['country'].stringValue,
+        throwsA(predicate((dynamic e) =>
+            e is ArgumentError &&
+            e.message ==
+                'Key: [country] is not applicable on: //address of: ValueType.Map')));
+    expect(
+        () => flx['address']['countryCode'][0],
+        throwsA(predicate((dynamic e) =>
+            e is ArgumentError &&
+            e.message ==
+                'Key: [0] is not applicable on: //address/countryCode of: ValueType.String')));
+    expect(
+        () => flx[1],
+        throwsA(predicate((dynamic e) =>
+            e is ArgumentError &&
+            e.message ==
+                'Key: [1] is not applicable on: / of: ValueType.Map')));
+    expect(
+        () => flx['flags'][4],
+        throwsA(predicate((dynamic e) =>
+            e is ArgumentError &&
+            e.message ==
+                'Key: [4] is not applicable on: //flags of: ValueType.VectorBool length: 4')));
+    expect(
+        () => flx['flags'][-1],
+        throwsA(predicate((dynamic e) =>
+            e is ArgumentError &&
+            e.message ==
+                'Key: [-1] is not applicable on: //flags of: ValueType.VectorBool length: 4')));
   });
   test('complex map to json', () {
     var flx = complexMap();
-    expect(flx.json, '{"address":{"city":"Bla","countryCode":"XX","zip":"12345"},"age":35,"flags":[true,false,true,true],"name":"Maxim","weight":72.5}');
+    expect(flx.json,
+        '{"address":{"city":"Bla","countryCode":"XX","zip":"12345"},"age":35,"flags":[true,false,true,true],"name":"Maxim","weight":72.5}');
   });
 
   test('complex map iterators', () {
     var flx = complexMap();
-    expect(flx.mapKeyIterable.map((e) => e).toList(), ['address', 'age', 'flags', 'name', 'weight']);
-    expect(flx.mapValueIterable.map((e) => e.json).toList(), [flx['address'].json, flx['age'].json, flx['flags'].json, flx['name'].json, flx['weight'].json]);
-    expect(flx['flags'].vectorIterable.map((e) => e.boolValue).toList(), [true, false, true, true]);
+    expect(flx.mapKeyIterable.map((e) => e).toList(),
+        ['address', 'age', 'flags', 'name', 'weight']);
+    expect(flx.mapValueIterable.map((e) => e.json).toList(), [
+      flx['address'].json,
+      flx['age'].json,
+      flx['flags'].json,
+      flx['name'].json,
+      flx['weight'].json
+    ]);
+    expect(flx['flags'].vectorIterable.map((e) => e.boolValue).toList(),
+        [true, false, true, true]);
   });
 
-  test('bug where offest were stored as int instead of uint', (){
-    const data = [99, 104, 97, 110, 110, 101, 108, 115, 95, 105, 110, 0,
-      100, 105, 108, 97, 116, 105, 111, 110, 95, 104, 101, 105, 103, 104, 116, 95, 102, 97, 99, 116, 111, 114, 0,
-      100, 105, 108, 97, 116, 105, 111, 110, 95, 119, 105, 100, 116, 104, 95, 102, 97, 99, 116, 111, 114, 0,
-      102, 117, 115, 101, 100, 95, 97, 99, 116, 105, 118, 97, 116, 105, 111, 110, 95, 102, 117, 110, 99, 116, 105, 111, 110, 0,
-      112, 97, 100, 95, 118, 97, 108, 117, 101, 115, 0, 112, 97, 100, 100, 105, 110, 103, 0,
-      115, 116, 114, 105, 100, 101, 95, 104, 101, 105, 103, 104, 116, 0,
-      115, 116, 114, 105, 100, 101, 95, 119, 105, 100, 116, 104, 0,
-      8, 130, 119, 97, 76, 51, 41, 34, 21, 8, 1, 8, 64, 1, 1, 1, 1, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 16, 36, 1];
+  test('bug where offest were stored as int instead of uint', () {
+    const data = [
+      99,
+      104,
+      97,
+      110,
+      110,
+      101,
+      108,
+      115,
+      95,
+      105,
+      110,
+      0,
+      100,
+      105,
+      108,
+      97,
+      116,
+      105,
+      111,
+      110,
+      95,
+      104,
+      101,
+      105,
+      103,
+      104,
+      116,
+      95,
+      102,
+      97,
+      99,
+      116,
+      111,
+      114,
+      0,
+      100,
+      105,
+      108,
+      97,
+      116,
+      105,
+      111,
+      110,
+      95,
+      119,
+      105,
+      100,
+      116,
+      104,
+      95,
+      102,
+      97,
+      99,
+      116,
+      111,
+      114,
+      0,
+      102,
+      117,
+      115,
+      101,
+      100,
+      95,
+      97,
+      99,
+      116,
+      105,
+      118,
+      97,
+      116,
+      105,
+      111,
+      110,
+      95,
+      102,
+      117,
+      110,
+      99,
+      116,
+      105,
+      111,
+      110,
+      0,
+      112,
+      97,
+      100,
+      95,
+      118,
+      97,
+      108,
+      117,
+      101,
+      115,
+      0,
+      112,
+      97,
+      100,
+      100,
+      105,
+      110,
+      103,
+      0,
+      115,
+      116,
+      114,
+      105,
+      100,
+      101,
+      95,
+      104,
+      101,
+      105,
+      103,
+      104,
+      116,
+      0,
+      115,
+      116,
+      114,
+      105,
+      100,
+      101,
+      95,
+      119,
+      105,
+      100,
+      116,
+      104,
+      0,
+      8,
+      130,
+      119,
+      97,
+      76,
+      51,
+      41,
+      34,
+      21,
+      8,
+      1,
+      8,
+      64,
+      1,
+      1,
+      1,
+      1,
+      0,
+      1,
+      1,
+      4,
+      4,
+      4,
+      4,
+      4,
+      4,
+      4,
+      4,
+      16,
+      36,
+      1
+    ];
     var flx = Reference.fromBuffer(b(data));
-    expect(flx.json, '{"channels_in":64,"dilation_height_factor":1,"dilation_width_factor":1,"fused_activation_function":1,"pad_values":1,"padding":0,"stride_height":1,"stride_width":1}');
-    const object = {"channels_in":64,"dilation_height_factor":1,"dilation_width_factor":1,"fused_activation_function":1,"pad_values":1,"padding":0,"stride_height":1,"stride_width":1};
+    expect(flx.json,
+        '{"channels_in":64,"dilation_height_factor":1,"dilation_width_factor":1,"fused_activation_function":1,"pad_values":1,"padding":0,"stride_height":1,"stride_width":1}');
+    const object = {
+      "channels_in": 64,
+      "dilation_height_factor": 1,
+      "dilation_width_factor": 1,
+      "fused_activation_function": 1,
+      "pad_values": 1,
+      "padding": 0,
+      "stride_height": 1,
+      "stride_width": 1
+    };
     var data1 = Builder.buildFromObject(object).asUint8List();
     expect(data1.length, data.length);
     var flx1 = Reference.fromBuffer(b(data1));
-    expect(flx1.json, '{"channels_in":64,"dilation_height_factor":1,"dilation_width_factor":1,"fused_activation_function":1,"pad_values":1,"padding":0,"stride_height":1,"stride_width":1}');
+    expect(flx1.json,
+        '{"channels_in":64,"dilation_height_factor":1,"dilation_width_factor":1,"fused_activation_function":1,"pad_values":1,"padding":0,"stride_height":1,"stride_width":1}');
   });
 }
 
@@ -302,7 +833,7 @@
   }
 }
 
-Reference complexMap(){
+Reference complexMap() {
 //  {
 //    "age": 35,
 //    "flags": [True, False, True, True],
@@ -315,20 +846,145 @@
 //    }
 //  }
   return Reference.fromBuffer(b([
-  97, 100, 100, 114, 101, 115, 115, 0,
-      99, 105, 116, 121, 0, 3, 66, 108, 97, 0,
-      99, 111, 117, 110, 116, 114, 121, 67, 111, 100, 101, 0,
-      2, 88, 88, 0,
-      122, 105, 112, 0,
-      5, 49, 50, 51, 52, 53, 0,
-      3, 38, 29, 14, 3, 1, 3, 38, 22, 15, 20, 20, 20,
-      97, 103, 101, 0,
-      102, 108, 97, 103, 115, 0,
-      4, 1, 0, 1, 1,
-      110, 97, 109, 101, 0,
-      5, 77, 97, 120, 105, 109, 0,
-      119, 101, 105, 103, 104, 116, 0,
-      5, 93, 36, 33, 23, 12, 0, 0, 7, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 60, 0, 0, 0, 35, 0, 0, 0, 51, 0, 0, 0, 45,
-      0, 0, 0, 0, 0, 145, 66, 36, 4, 144, 20, 14, 25, 38, 1
+    97,
+    100,
+    100,
+    114,
+    101,
+    115,
+    115,
+    0,
+    99,
+    105,
+    116,
+    121,
+    0,
+    3,
+    66,
+    108,
+    97,
+    0,
+    99,
+    111,
+    117,
+    110,
+    116,
+    114,
+    121,
+    67,
+    111,
+    100,
+    101,
+    0,
+    2,
+    88,
+    88,
+    0,
+    122,
+    105,
+    112,
+    0,
+    5,
+    49,
+    50,
+    51,
+    52,
+    53,
+    0,
+    3,
+    38,
+    29,
+    14,
+    3,
+    1,
+    3,
+    38,
+    22,
+    15,
+    20,
+    20,
+    20,
+    97,
+    103,
+    101,
+    0,
+    102,
+    108,
+    97,
+    103,
+    115,
+    0,
+    4,
+    1,
+    0,
+    1,
+    1,
+    110,
+    97,
+    109,
+    101,
+    0,
+    5,
+    77,
+    97,
+    120,
+    105,
+    109,
+    0,
+    119,
+    101,
+    105,
+    103,
+    104,
+    116,
+    0,
+    5,
+    93,
+    36,
+    33,
+    23,
+    12,
+    0,
+    0,
+    7,
+    0,
+    0,
+    0,
+    1,
+    0,
+    0,
+    0,
+    5,
+    0,
+    0,
+    0,
+    60,
+    0,
+    0,
+    0,
+    35,
+    0,
+    0,
+    0,
+    51,
+    0,
+    0,
+    0,
+    45,
+    0,
+    0,
+    0,
+    0,
+    0,
+    145,
+    66,
+    36,
+    4,
+    144,
+    20,
+    14,
+    25,
+    38,
+    1
   ]));
 }
diff -urN a/dart/test/flex_types_test.dart b/dart/test/flex_types_test.dart
--- a/dart/test/flex_types_test.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/test/flex_types_test.dart	2023-01-13 07:47:12.523285709 +0000
@@ -48,69 +48,116 @@
     expect(ValueTypeUtils.isFixedTypedVector(ValueType.VectorInt), isFalse);
   });
   test('to typed vector', () {
-    expect(ValueTypeUtils.toTypedVector(ValueType.Int,0), equals(ValueType.VectorInt));
-    expect(ValueTypeUtils.toTypedVector(ValueType.UInt,0), equals(ValueType.VectorUInt));
-    expect(ValueTypeUtils.toTypedVector(ValueType.Bool,0), equals(ValueType.VectorBool));
-    expect(ValueTypeUtils.toTypedVector(ValueType.Float,0), equals(ValueType.VectorFloat));
-    expect(ValueTypeUtils.toTypedVector(ValueType.Key,0), equals(ValueType.VectorKey));
-    expect(ValueTypeUtils.toTypedVector(ValueType.String,0), equals(ValueType.VectorString));
-
-    expect(ValueTypeUtils.toTypedVector(ValueType.Int,2), equals(ValueType.VectorInt2));
-    expect(ValueTypeUtils.toTypedVector(ValueType.UInt,2), equals(ValueType.VectorUInt2));
-    expect(ValueTypeUtils.toTypedVector(ValueType.Float,2), equals(ValueType.VectorFloat2));
-
-    expect(ValueTypeUtils.toTypedVector(ValueType.Int,3), equals(ValueType.VectorInt3));
-    expect(ValueTypeUtils.toTypedVector(ValueType.UInt,3), equals(ValueType.VectorUInt3));
-    expect(ValueTypeUtils.toTypedVector(ValueType.Float,3), equals(ValueType.VectorFloat3));
-
-    expect(ValueTypeUtils.toTypedVector(ValueType.Int,4), equals(ValueType.VectorInt4));
-    expect(ValueTypeUtils.toTypedVector(ValueType.UInt,4), equals(ValueType.VectorUInt4));
-    expect(ValueTypeUtils.toTypedVector(ValueType.Float,4), equals(ValueType.VectorFloat4));
+    expect(ValueTypeUtils.toTypedVector(ValueType.Int, 0),
+        equals(ValueType.VectorInt));
+    expect(ValueTypeUtils.toTypedVector(ValueType.UInt, 0),
+        equals(ValueType.VectorUInt));
+    expect(ValueTypeUtils.toTypedVector(ValueType.Bool, 0),
+        equals(ValueType.VectorBool));
+    expect(ValueTypeUtils.toTypedVector(ValueType.Float, 0),
+        equals(ValueType.VectorFloat));
+    expect(ValueTypeUtils.toTypedVector(ValueType.Key, 0),
+        equals(ValueType.VectorKey));
+    expect(ValueTypeUtils.toTypedVector(ValueType.String, 0),
+        equals(ValueType.VectorString));
+
+    expect(ValueTypeUtils.toTypedVector(ValueType.Int, 2),
+        equals(ValueType.VectorInt2));
+    expect(ValueTypeUtils.toTypedVector(ValueType.UInt, 2),
+        equals(ValueType.VectorUInt2));
+    expect(ValueTypeUtils.toTypedVector(ValueType.Float, 2),
+        equals(ValueType.VectorFloat2));
+
+    expect(ValueTypeUtils.toTypedVector(ValueType.Int, 3),
+        equals(ValueType.VectorInt3));
+    expect(ValueTypeUtils.toTypedVector(ValueType.UInt, 3),
+        equals(ValueType.VectorUInt3));
+    expect(ValueTypeUtils.toTypedVector(ValueType.Float, 3),
+        equals(ValueType.VectorFloat3));
+
+    expect(ValueTypeUtils.toTypedVector(ValueType.Int, 4),
+        equals(ValueType.VectorInt4));
+    expect(ValueTypeUtils.toTypedVector(ValueType.UInt, 4),
+        equals(ValueType.VectorUInt4));
+    expect(ValueTypeUtils.toTypedVector(ValueType.Float, 4),
+        equals(ValueType.VectorFloat4));
   });
   test('typed vector element type', () {
-    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorInt), equals(ValueType.Int));
-    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorUInt), equals(ValueType.UInt));
-    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorFloat), equals(ValueType.Float));
-    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorString), equals(ValueType.String));
-    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorKey), equals(ValueType.Key));
-    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorBool), equals(ValueType.Bool));
+    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorInt),
+        equals(ValueType.Int));
+    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorUInt),
+        equals(ValueType.UInt));
+    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorFloat),
+        equals(ValueType.Float));
+    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorString),
+        equals(ValueType.String));
+    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorKey),
+        equals(ValueType.Key));
+    expect(ValueTypeUtils.typedVectorElementType(ValueType.VectorBool),
+        equals(ValueType.Bool));
   });
   test('fixed typed vector element type', () {
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorInt2), equals(ValueType.Int));
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorInt3), equals(ValueType.Int));
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorInt4), equals(ValueType.Int));
-
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorUInt2), equals(ValueType.UInt));
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorUInt3), equals(ValueType.UInt));
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorUInt4), equals(ValueType.UInt));
-
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorFloat2), equals(ValueType.Float));
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorFloat3), equals(ValueType.Float));
-    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorFloat4), equals(ValueType.Float));
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorInt2),
+        equals(ValueType.Int));
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorInt3),
+        equals(ValueType.Int));
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorInt4),
+        equals(ValueType.Int));
+
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorUInt2),
+        equals(ValueType.UInt));
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorUInt3),
+        equals(ValueType.UInt));
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorUInt4),
+        equals(ValueType.UInt));
+
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorFloat2),
+        equals(ValueType.Float));
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorFloat3),
+        equals(ValueType.Float));
+    expect(ValueTypeUtils.fixedTypedVectorElementType(ValueType.VectorFloat4),
+        equals(ValueType.Float));
   });
   test('fixed typed vector element size', () {
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorInt2), equals(2));
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorInt3), equals(3));
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorInt4), equals(4));
-
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorUInt2), equals(2));
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorUInt3), equals(3));
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorUInt4), equals(4));
-
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorFloat2), equals(2));
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorFloat3), equals(3));
-    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorFloat4), equals(4));
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorInt2),
+        equals(2));
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorInt3),
+        equals(3));
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorInt4),
+        equals(4));
+
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorUInt2),
+        equals(2));
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorUInt3),
+        equals(3));
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorUInt4),
+        equals(4));
+
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorFloat2),
+        equals(2));
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorFloat3),
+        equals(3));
+    expect(ValueTypeUtils.fixedTypedVectorElementSize(ValueType.VectorFloat4),
+        equals(4));
   });
   test('packed type', () {
-    expect(ValueTypeUtils.packedType(ValueType.Null, BitWidth.width8), equals(0));
-    expect(ValueTypeUtils.packedType(ValueType.Null, BitWidth.width16), equals(1));
-    expect(ValueTypeUtils.packedType(ValueType.Null, BitWidth.width32), equals(2));
-    expect(ValueTypeUtils.packedType(ValueType.Null, BitWidth.width64), equals(3));
-
-    expect(ValueTypeUtils.packedType(ValueType.Int, BitWidth.width8), equals(4));
-    expect(ValueTypeUtils.packedType(ValueType.Int, BitWidth.width16), equals(5));
-    expect(ValueTypeUtils.packedType(ValueType.Int, BitWidth.width32), equals(6));
-    expect(ValueTypeUtils.packedType(ValueType.Int, BitWidth.width64), equals(7));
+    expect(
+        ValueTypeUtils.packedType(ValueType.Null, BitWidth.width8), equals(0));
+    expect(
+        ValueTypeUtils.packedType(ValueType.Null, BitWidth.width16), equals(1));
+    expect(
+        ValueTypeUtils.packedType(ValueType.Null, BitWidth.width32), equals(2));
+    expect(
+        ValueTypeUtils.packedType(ValueType.Null, BitWidth.width64), equals(3));
+
+    expect(
+        ValueTypeUtils.packedType(ValueType.Int, BitWidth.width8), equals(4));
+    expect(
+        ValueTypeUtils.packedType(ValueType.Int, BitWidth.width16), equals(5));
+    expect(
+        ValueTypeUtils.packedType(ValueType.Int, BitWidth.width32), equals(6));
+    expect(
+        ValueTypeUtils.packedType(ValueType.Int, BitWidth.width64), equals(7));
   });
   test('bit width', () {
     expect(BitWidthUtil.width(0), BitWidth.width8);
diff -urN a/dart/test/monster_test.fbs b/dart/test/monster_test.fbs
--- a/dart/test/monster_test.fbs	1970-01-01 00:00:00.000000000 +0000
+++ b/dart/test/monster_test.fbs	2023-01-13 07:47:12.524285719 +0000
@@ -0,0 +1,154 @@
+// test schema file
+
+include "include_test1.fbs";
+
+namespace MyGame;
+
+table InParentNamespace {}
+
+namespace MyGame.Example2;
+
+table Monster {}  // Test having same name as below, but in different namespace.
+
+namespace MyGame.Example;
+
+attribute "priority";
+
+/// Composite components of Monster color.
+enum Color:ubyte (bit_flags) {
+  Red = 0, // color Red = (1u << 0)
+  /// \brief color Green
+  /// Green is bit_flag with value (1u << 1)
+  Green,
+  /// \brief color Blue (1u << 3)
+  Blue = 3,
+}
+
+enum Race:byte {
+  None = -1,
+  Human = 0,
+  Dwarf,
+  Elf,
+}
+
+union Any { Monster, TestSimpleTableWithEnum, MyGame.Example2.Monster }
+
+union AnyUniqueAliases { M: Monster, TS: TestSimpleTableWithEnum, M2: MyGame.Example2.Monster }
+union AnyAmbiguousAliases { M1: Monster, M2: Monster, M3: Monster }
+
+struct Test { a:short; b:byte; }
+
+table TestSimpleTableWithEnum (csharp_partial, private) {
+  color: Color = Green;
+}
+
+struct Vec3 (force_align: 8) {
+  x:float;
+  y:float;
+  z:float;
+  test1:double;
+  test2:Color;
+  test3:Test;
+}
+
+struct Ability {
+  id:uint(key);
+  distance:uint;
+}
+
+struct StructOfStructs {
+  a: Ability;
+  b: Test;
+  c: Ability;
+}
+
+table Stat {
+  id:string;
+  val:long;
+  count:ushort (key);
+}
+
+table Referrable {
+  id:ulong(key, hash:"fnv1a_64");
+}
+
+/// an example documentation comment: "monster object"
+table Monster {
+  pos:Vec3 (id: 0);
+  hp:short = 100 (id: 2);
+  mana:short = 150 (id: 1);
+  name:string (id: 3, key);
+  color:Color = Blue (id: 6);
+  inventory:[ubyte] (id: 5);
+  friendly:bool = false (deprecated, priority: 1, id: 4);
+  /// an example documentation comment: this will end up in the generated code
+  /// multiline too
+  testarrayoftables:[Monster] (id: 11);
+  testarrayofstring:[string] (id: 10);
+  testarrayofstring2:[string] (id: 28);
+  testarrayofbools:[bool] (id: 24);
+  testarrayofsortedstruct:[Ability] (id: 29);
+  enemy:MyGame.Example.Monster (id:12);  // Test referring by full namespace.
+  test:Any (id: 8);
+  test4:[Test] (id: 9);
+  test5:[Test] (id: 31);
+  testnestedflatbuffer:[ubyte] (id:13, nested_flatbuffer: "Monster");
+  testempty:Stat (id:14);
+  testbool:bool (id:15);
+  testhashs32_fnv1:int (id:16, hash:"fnv1_32");
+  testhashu32_fnv1:uint (id:17, hash:"fnv1_32");
+  testhashs64_fnv1:long (id:18, hash:"fnv1_64");
+  testhashu64_fnv1:ulong (id:19, hash:"fnv1_64");
+  testhashs32_fnv1a:int (id:20, hash:"fnv1a_32");
+  testhashu32_fnv1a:uint (id:21, hash:"fnv1a_32", cpp_type:"Stat");
+  testhashs64_fnv1a:long (id:22, hash:"fnv1a_64");
+  testhashu64_fnv1a:ulong (id:23, hash:"fnv1a_64");
+  testf:float = 3.14159 (id:25);
+  testf2:float = 3 (id:26);
+  testf3:float (id:27);
+  flex:[ubyte] (id:30, flexbuffer);
+  vector_of_longs:[long] (id:32);
+  vector_of_doubles:[double] (id:33);
+  parent_namespace_test:InParentNamespace (id:34);
+  vector_of_referrables:[Referrable](id:35);
+  single_weak_reference:ulong(id:36, hash:"fnv1a_64", cpp_type:"ReferrableT");
+  vector_of_weak_references:[ulong](id:37, hash:"fnv1a_64", cpp_type:"ReferrableT");
+  vector_of_strong_referrables:[Referrable](id:38, cpp_ptr_type:"default_ptr_type");                 //was shared_ptr
+  co_owning_reference:ulong(id:39, hash:"fnv1a_64", cpp_type:"ReferrableT", cpp_ptr_type:"naked");  //was shared_ptr as well
+  vector_of_co_owning_references:[ulong](id:40, hash:"fnv1a_64", cpp_type:"ReferrableT", cpp_ptr_type:"default_ptr_type", cpp_ptr_type_get:".get()");  //was shared_ptr
+  non_owning_reference:ulong(id:41, hash:"fnv1a_64", cpp_type:"ReferrableT", cpp_ptr_type:"naked", cpp_ptr_type_get:"");                              //was weak_ptr
+  vector_of_non_owning_references:[ulong](id:42, hash:"fnv1a_64", cpp_type:"ReferrableT", cpp_ptr_type:"naked", cpp_ptr_type_get:"");                 //was weak_ptr
+  any_unique:AnyUniqueAliases(id:44);
+  any_ambiguous:AnyAmbiguousAliases (id:46);
+  vector_of_enums:[Color] (id:47);
+  signed_enum:Race = None (id:48);
+  testrequirednestedflatbuffer:[ubyte] (id:49, nested_flatbuffer: "Monster");
+  scalar_key_sorted_tables:[Stat] (id: 50);
+}
+
+table TypeAliases {
+    i8:int8;
+    u8:uint8;
+    i16:int16;
+    u16:uint16;
+    i32:int32;
+    u32:uint32;
+    i64:int64;
+    u64:uint64;
+    f32:float32;
+    f64:float64;
+    v8:[int8];
+    vf64:[float64];
+}
+
+rpc_service MonsterStorage {
+  Store(Monster):Stat (streaming: "none");
+  Retrieve(Stat):Monster (streaming: "server", idempotent);
+  GetMaxHitPoint(Monster):Stat (streaming: "client");
+  GetMinMaxHitPoints(Monster):Stat (streaming: "bidi");
+}
+
+root_type Monster;
+
+file_identifier "MONS";
+file_extension "mon";
diff -urN a/dart/test/monster_test_my_game.example2_generated.dart b/dart/test/monster_test_my_game.example2_generated.dart
--- a/dart/test/monster_test_my_game.example2_generated.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/test/monster_test_my_game.example2_generated.dart	2023-01-13 07:47:12.553285987 +0000
@@ -1,5 +1,5 @@
 // automatically generated by the FlatBuffers compiler, do not modify
-// ignore_for_file: unused_import, unused_field, unused_local_variable
+// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable
 
 library my_game.example2;
 
@@ -12,11 +12,11 @@
 class Monster {
   Monster._(this._bc, this._bcOffset);
   factory Monster(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<Monster> reader = const _MonsterReader();
+  static const fb.Reader<Monster> reader = _MonsterReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -26,6 +26,26 @@
   String toString() {
     return 'Monster{}';
   }
+
+  MonsterT unpack() => MonsterT();
+
+  static int pack(fb.Builder fbBuilder, MonsterT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class MonsterT implements fb.Packable {
+  @override
+  int pack(fb.Builder fbBuilder) {
+    fbBuilder.startTable(0);
+    return fbBuilder.endTable();
+  }
+
+  @override
+  String toString() {
+    return 'MonsterT{}';
+  }
 }
 
 class _MonsterReader extends fb.TableReader<Monster> {
@@ -33,7 +53,7 @@
 
   @override
   Monster createObject(fb.BufferContext bc, int offset) => 
-    new Monster._(bc, offset);
+    Monster._(bc, offset);
 }
 
 class MonsterObjectBuilder extends fb.ObjectBuilder {
@@ -42,19 +62,16 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
-    fbBuilder.startTable();
+  int finish(fb.Builder fbBuilder) {
+    fbBuilder.startTable(0);
     return fbBuilder.endTable();
   }
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
diff -urN a/dart/test/monster_test_my_game.example_generated.dart b/dart/test/monster_test_my_game.example_generated.dart
--- a/dart/test/monster_test_my_game.example_generated.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/test/monster_test_my_game.example_generated.dart	2023-01-13 07:47:12.571286153 +0000
@@ -1,5 +1,5 @@
 // automatically generated by the FlatBuffers compiler, do not modify
-// ignore_for_file: unused_import, unused_field, unused_local_variable
+// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable
 
 library my_game.example;
 
@@ -15,26 +15,32 @@
   const Color._(this.value);
 
   factory Color.fromValue(int value) {
-    if (value == null) value = 0;
-    if (!values.containsKey(value)) {
-      throw new StateError('Invalid value $value for bit flag enum Color');
+    final result = values[value];
+    if (result == null) {
+      throw StateError('Invalid value $value for bit flag enum Color');
     }
-    return values[value];
+    return result;
   }
 
+  static Color? _createOrNull(int? value) => 
+      value == null ? null : Color.fromValue(value);
+
   static bool containsValue(int value) => values.containsKey(value);
 
-  static const Color Red = const Color._(1);
+  static const Color Red = Color._(1);
 
   ///  \brief color Green
   ///  Green is bit_flag with value (1u << 1)
-  static const Color Green = const Color._(2);
+  static const Color Green = Color._(2);
 
   ///  \brief color Blue (1u << 3)
-  static const Color Blue = const Color._(8);
-  static const Map<int,Color> values = {1: Red,2: Green,8: Blue,};
+  static const Color Blue = Color._(8);
+  static const Map<int, Color> values = {
+    1: Red,
+    2: Green,
+    8: Blue};
 
-  static const fb.Reader<Color> reader = const _ColorReader();
+  static const fb.Reader<Color> reader = _ColorReader();
 
   @override
   String toString() {
@@ -50,7 +56,7 @@
 
   @override
   Color read(fb.BufferContext bc, int offset) =>
-      new Color.fromValue(const fb.Uint8Reader().read(bc, offset));
+      Color.fromValue(const fb.Uint8Reader().read(bc, offset));
 }
 
 class Race {
@@ -58,24 +64,31 @@
   const Race._(this.value);
 
   factory Race.fromValue(int value) {
-    if (value == null) value = 0;
-    if (!values.containsKey(value)) {
-      throw new StateError('Invalid value $value for bit flag enum Race');
+    final result = values[value];
+    if (result == null) {
+      throw StateError('Invalid value $value for bit flag enum Race');
     }
-    return values[value];
+    return result;
   }
 
+  static Race? _createOrNull(int? value) => 
+      value == null ? null : Race.fromValue(value);
+
   static const int minValue = -1;
   static const int maxValue = 2;
   static bool containsValue(int value) => values.containsKey(value);
 
-  static const Race None = const Race._(-1);
-  static const Race Human = const Race._(0);
-  static const Race Dwarf = const Race._(1);
-  static const Race Elf = const Race._(2);
-  static const Map<int,Race> values = {-1: None,0: Human,1: Dwarf,2: Elf,};
+  static const Race None = Race._(-1);
+  static const Race Human = Race._(0);
+  static const Race Dwarf = Race._(1);
+  static const Race Elf = Race._(2);
+  static const Map<int, Race> values = {
+    -1: None,
+    0: Human,
+    1: Dwarf,
+    2: Elf};
 
-  static const fb.Reader<Race> reader = const _RaceReader();
+  static const fb.Reader<Race> reader = _RaceReader();
 
   @override
   String toString() {
@@ -91,7 +104,7 @@
 
   @override
   Race read(fb.BufferContext bc, int offset) =>
-      new Race.fromValue(const fb.Int8Reader().read(bc, offset));
+      Race.fromValue(const fb.Int8Reader().read(bc, offset));
 }
 
 class AnyTypeId {
@@ -99,24 +112,31 @@
   const AnyTypeId._(this.value);
 
   factory AnyTypeId.fromValue(int value) {
-    if (value == null) value = 0;
-    if (!values.containsKey(value)) {
-      throw new StateError('Invalid value $value for bit flag enum AnyTypeId');
+    final result = values[value];
+    if (result == null) {
+      throw StateError('Invalid value $value for bit flag enum AnyTypeId');
     }
-    return values[value];
+    return result;
   }
 
+  static AnyTypeId? _createOrNull(int? value) => 
+      value == null ? null : AnyTypeId.fromValue(value);
+
   static const int minValue = 0;
   static const int maxValue = 3;
   static bool containsValue(int value) => values.containsKey(value);
 
-  static const AnyTypeId NONE = const AnyTypeId._(0);
-  static const AnyTypeId Monster = const AnyTypeId._(1);
-  static const AnyTypeId TestSimpleTableWithEnum = const AnyTypeId._(2);
-  static const AnyTypeId MyGame_Example2_Monster = const AnyTypeId._(3);
-  static const Map<int,AnyTypeId> values = {0: NONE,1: Monster,2: TestSimpleTableWithEnum,3: MyGame_Example2_Monster,};
+  static const AnyTypeId NONE = AnyTypeId._(0);
+  static const AnyTypeId Monster = AnyTypeId._(1);
+  static const AnyTypeId TestSimpleTableWithEnum = AnyTypeId._(2);
+  static const AnyTypeId MyGame_Example2_Monster = AnyTypeId._(3);
+  static const Map<int, AnyTypeId> values = {
+    0: NONE,
+    1: Monster,
+    2: TestSimpleTableWithEnum,
+    3: MyGame_Example2_Monster};
 
-  static const fb.Reader<AnyTypeId> reader = const _AnyTypeIdReader();
+  static const fb.Reader<AnyTypeId> reader = _AnyTypeIdReader();
 
   @override
   String toString() {
@@ -132,7 +152,7 @@
 
   @override
   AnyTypeId read(fb.BufferContext bc, int offset) =>
-      new AnyTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
+      AnyTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
 }
 
 class AnyUniqueAliasesTypeId {
@@ -140,24 +160,31 @@
   const AnyUniqueAliasesTypeId._(this.value);
 
   factory AnyUniqueAliasesTypeId.fromValue(int value) {
-    if (value == null) value = 0;
-    if (!values.containsKey(value)) {
-      throw new StateError('Invalid value $value for bit flag enum AnyUniqueAliasesTypeId');
+    final result = values[value];
+    if (result == null) {
+      throw StateError('Invalid value $value for bit flag enum AnyUniqueAliasesTypeId');
     }
-    return values[value];
+    return result;
   }
 
+  static AnyUniqueAliasesTypeId? _createOrNull(int? value) => 
+      value == null ? null : AnyUniqueAliasesTypeId.fromValue(value);
+
   static const int minValue = 0;
   static const int maxValue = 3;
   static bool containsValue(int value) => values.containsKey(value);
 
-  static const AnyUniqueAliasesTypeId NONE = const AnyUniqueAliasesTypeId._(0);
-  static const AnyUniqueAliasesTypeId M = const AnyUniqueAliasesTypeId._(1);
-  static const AnyUniqueAliasesTypeId TS = const AnyUniqueAliasesTypeId._(2);
-  static const AnyUniqueAliasesTypeId M2 = const AnyUniqueAliasesTypeId._(3);
-  static const Map<int,AnyUniqueAliasesTypeId> values = {0: NONE,1: M,2: TS,3: M2,};
+  static const AnyUniqueAliasesTypeId NONE = AnyUniqueAliasesTypeId._(0);
+  static const AnyUniqueAliasesTypeId M = AnyUniqueAliasesTypeId._(1);
+  static const AnyUniqueAliasesTypeId TS = AnyUniqueAliasesTypeId._(2);
+  static const AnyUniqueAliasesTypeId M2 = AnyUniqueAliasesTypeId._(3);
+  static const Map<int, AnyUniqueAliasesTypeId> values = {
+    0: NONE,
+    1: M,
+    2: TS,
+    3: M2};
 
-  static const fb.Reader<AnyUniqueAliasesTypeId> reader = const _AnyUniqueAliasesTypeIdReader();
+  static const fb.Reader<AnyUniqueAliasesTypeId> reader = _AnyUniqueAliasesTypeIdReader();
 
   @override
   String toString() {
@@ -173,7 +200,7 @@
 
   @override
   AnyUniqueAliasesTypeId read(fb.BufferContext bc, int offset) =>
-      new AnyUniqueAliasesTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
+      AnyUniqueAliasesTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
 }
 
 class AnyAmbiguousAliasesTypeId {
@@ -181,24 +208,31 @@
   const AnyAmbiguousAliasesTypeId._(this.value);
 
   factory AnyAmbiguousAliasesTypeId.fromValue(int value) {
-    if (value == null) value = 0;
-    if (!values.containsKey(value)) {
-      throw new StateError('Invalid value $value for bit flag enum AnyAmbiguousAliasesTypeId');
+    final result = values[value];
+    if (result == null) {
+      throw StateError('Invalid value $value for bit flag enum AnyAmbiguousAliasesTypeId');
     }
-    return values[value];
+    return result;
   }
 
+  static AnyAmbiguousAliasesTypeId? _createOrNull(int? value) => 
+      value == null ? null : AnyAmbiguousAliasesTypeId.fromValue(value);
+
   static const int minValue = 0;
   static const int maxValue = 3;
   static bool containsValue(int value) => values.containsKey(value);
 
-  static const AnyAmbiguousAliasesTypeId NONE = const AnyAmbiguousAliasesTypeId._(0);
-  static const AnyAmbiguousAliasesTypeId M1 = const AnyAmbiguousAliasesTypeId._(1);
-  static const AnyAmbiguousAliasesTypeId M2 = const AnyAmbiguousAliasesTypeId._(2);
-  static const AnyAmbiguousAliasesTypeId M3 = const AnyAmbiguousAliasesTypeId._(3);
-  static const Map<int,AnyAmbiguousAliasesTypeId> values = {0: NONE,1: M1,2: M2,3: M3,};
+  static const AnyAmbiguousAliasesTypeId NONE = AnyAmbiguousAliasesTypeId._(0);
+  static const AnyAmbiguousAliasesTypeId M1 = AnyAmbiguousAliasesTypeId._(1);
+  static const AnyAmbiguousAliasesTypeId M2 = AnyAmbiguousAliasesTypeId._(2);
+  static const AnyAmbiguousAliasesTypeId M3 = AnyAmbiguousAliasesTypeId._(3);
+  static const Map<int, AnyAmbiguousAliasesTypeId> values = {
+    0: NONE,
+    1: M1,
+    2: M2,
+    3: M3};
 
-  static const fb.Reader<AnyAmbiguousAliasesTypeId> reader = const _AnyAmbiguousAliasesTypeIdReader();
+  static const fb.Reader<AnyAmbiguousAliasesTypeId> reader = _AnyAmbiguousAliasesTypeIdReader();
 
   @override
   String toString() {
@@ -214,13 +248,13 @@
 
   @override
   AnyAmbiguousAliasesTypeId read(fb.BufferContext bc, int offset) =>
-      new AnyAmbiguousAliasesTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
+      AnyAmbiguousAliasesTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
 }
 
 class Test {
   Test._(this._bc, this._bcOffset);
 
-  static const fb.Reader<Test> reader = const _TestReader();
+  static const fb.Reader<Test> reader = _TestReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -232,6 +266,37 @@
   String toString() {
     return 'Test{a: $a, b: $b}';
   }
+
+  TestT unpack() => TestT(
+      a: a,
+      b: b);
+
+  static int pack(fb.Builder fbBuilder, TestT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class TestT implements fb.Packable {
+  int a;
+  int b;
+
+  TestT({
+      required this.a,
+      required this.b});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    fbBuilder.pad(1);
+    fbBuilder.putInt8(b);
+    fbBuilder.putInt16(a);
+    return fbBuilder.offset;
+  }
+
+  @override
+  String toString() {
+    return 'TestT{a: $a, b: $b}';
+  }
 }
 
 class _TestReader extends fb.StructReader<Test> {
@@ -242,13 +307,11 @@
 
   @override
   Test createObject(fb.BufferContext bc, int offset) => 
-    new Test._(bc, offset);
+    Test._(bc, offset);
 }
 
 class TestBuilder {
-  TestBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  TestBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
@@ -266,18 +329,15 @@
   final int _b;
 
   TestObjectBuilder({
-    int a,
-    int b,
+    required int a,
+    required int b,
   })
       : _a = a,
         _b = b;
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
+  int finish(fb.Builder fbBuilder) {
     fbBuilder.pad(1);
     fbBuilder.putInt8(_b);
     fbBuilder.putInt16(_a);
@@ -286,30 +346,57 @@
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class TestSimpleTableWithEnum {
   TestSimpleTableWithEnum._(this._bc, this._bcOffset);
   factory TestSimpleTableWithEnum(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<TestSimpleTableWithEnum> reader = const _TestSimpleTableWithEnumReader();
+  static const fb.Reader<TestSimpleTableWithEnum> reader = _TestSimpleTableWithEnumReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
 
-  Color get color => new Color.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 4, 2));
+  Color get color => Color.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 4, 2));
 
   @override
   String toString() {
     return 'TestSimpleTableWithEnum{color: $color}';
   }
+
+  TestSimpleTableWithEnumT unpack() => TestSimpleTableWithEnumT(
+      color: color);
+
+  static int pack(fb.Builder fbBuilder, TestSimpleTableWithEnumT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class TestSimpleTableWithEnumT implements fb.Packable {
+  Color color;
+
+  TestSimpleTableWithEnumT({
+      this.color = Color.Green});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    fbBuilder.startTable(1);
+    fbBuilder.addUint8(0, color.value);
+    return fbBuilder.endTable();
+  }
+
+  @override
+  String toString() {
+    return 'TestSimpleTableWithEnumT{color: $color}';
+  }
 }
 
 class _TestSimpleTableWithEnumReader extends fb.TableReader<TestSimpleTableWithEnum> {
@@ -317,21 +404,19 @@
 
   @override
   TestSimpleTableWithEnum createObject(fb.BufferContext bc, int offset) => 
-    new TestSimpleTableWithEnum._(bc, offset);
+    TestSimpleTableWithEnum._(bc, offset);
 }
 
 class TestSimpleTableWithEnumBuilder {
-  TestSimpleTableWithEnumBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  TestSimpleTableWithEnumBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
   void begin() {
-    fbBuilder.startTable();
+    fbBuilder.startTable(1);
   }
 
-  int addColor(Color color) {
+  int addColor(Color? color) {
     fbBuilder.addUint8(0, color?.value);
     return fbBuilder.offset;
   }
@@ -342,36 +427,33 @@
 }
 
 class TestSimpleTableWithEnumObjectBuilder extends fb.ObjectBuilder {
-  final Color _color;
+  final Color? _color;
 
   TestSimpleTableWithEnumObjectBuilder({
-    Color color,
+    Color? color,
   })
       : _color = color;
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
-    fbBuilder.startTable();
+  int finish(fb.Builder fbBuilder) {
+    fbBuilder.startTable(1);
     fbBuilder.addUint8(0, _color?.value);
     return fbBuilder.endTable();
   }
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class Vec3 {
   Vec3._(this._bc, this._bcOffset);
 
-  static const fb.Reader<Vec3> reader = const _Vec3Reader();
+  static const fb.Reader<Vec3> reader = _Vec3Reader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -380,13 +462,62 @@
   double get y => const fb.Float32Reader().read(_bc, _bcOffset + 4);
   double get z => const fb.Float32Reader().read(_bc, _bcOffset + 8);
   double get test1 => const fb.Float64Reader().read(_bc, _bcOffset + 16);
-  Color get test2 => new Color.fromValue(const fb.Uint8Reader().read(_bc, _bcOffset + 24));
+  Color get test2 => Color.fromValue(const fb.Uint8Reader().read(_bc, _bcOffset + 24));
   Test get test3 => Test.reader.read(_bc, _bcOffset + 26);
 
   @override
   String toString() {
     return 'Vec3{x: $x, y: $y, z: $z, test1: $test1, test2: $test2, test3: $test3}';
   }
+
+  Vec3T unpack() => Vec3T(
+      x: x,
+      y: y,
+      z: z,
+      test1: test1,
+      test2: test2,
+      test3: test3.unpack());
+
+  static int pack(fb.Builder fbBuilder, Vec3T? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class Vec3T implements fb.Packable {
+  double x;
+  double y;
+  double z;
+  double test1;
+  Color test2;
+  TestT test3;
+
+  Vec3T({
+      required this.x,
+      required this.y,
+      required this.z,
+      required this.test1,
+      required this.test2,
+      required this.test3});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    fbBuilder.pad(2);
+    test3.pack(fbBuilder);
+    fbBuilder.pad(1);
+    fbBuilder.putUint8(test2.value);
+    fbBuilder.putFloat64(test1);
+    fbBuilder.pad(4);
+    fbBuilder.putFloat32(z);
+    fbBuilder.putFloat32(y);
+    fbBuilder.putFloat32(x);
+    return fbBuilder.offset;
+  }
+
+  @override
+  String toString() {
+    return 'Vec3T{x: $x, y: $y, z: $z, test1: $test1, test2: $test2, test3: $test3}';
+  }
 }
 
 class _Vec3Reader extends fb.StructReader<Vec3> {
@@ -397,13 +528,11 @@
 
   @override
   Vec3 createObject(fb.BufferContext bc, int offset) => 
-    new Vec3._(bc, offset);
+    Vec3._(bc, offset);
 }
 
 class Vec3Builder {
-  Vec3Builder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  Vec3Builder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
@@ -411,7 +540,7 @@
     fbBuilder.pad(2);
     test3();
     fbBuilder.pad(1);
-    fbBuilder.putUint8(test2?.value);
+    fbBuilder.putUint8(test2.value);
     fbBuilder.putFloat64(test1);
     fbBuilder.pad(4);
     fbBuilder.putFloat32(z);
@@ -431,12 +560,12 @@
   final TestObjectBuilder _test3;
 
   Vec3ObjectBuilder({
-    double x,
-    double y,
-    double z,
-    double test1,
-    Color test2,
-    TestObjectBuilder test3,
+    required double x,
+    required double y,
+    required double z,
+    required double test1,
+    required Color test2,
+    required TestObjectBuilder test3,
   })
       : _x = x,
         _y = y,
@@ -447,14 +576,11 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
+  int finish(fb.Builder fbBuilder) {
     fbBuilder.pad(2);
     _test3.finish(fbBuilder);
     fbBuilder.pad(1);
-    fbBuilder.putUint8(_test2?.value);
+    fbBuilder.putUint8(_test2.value);
     fbBuilder.putFloat64(_test1);
     fbBuilder.pad(4);
     fbBuilder.putFloat32(_z);
@@ -465,16 +591,16 @@
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class Ability {
   Ability._(this._bc, this._bcOffset);
 
-  static const fb.Reader<Ability> reader = const _AbilityReader();
+  static const fb.Reader<Ability> reader = _AbilityReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -486,6 +612,36 @@
   String toString() {
     return 'Ability{id: $id, distance: $distance}';
   }
+
+  AbilityT unpack() => AbilityT(
+      id: id,
+      distance: distance);
+
+  static int pack(fb.Builder fbBuilder, AbilityT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class AbilityT implements fb.Packable {
+  int id;
+  int distance;
+
+  AbilityT({
+      required this.id,
+      required this.distance});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    fbBuilder.putUint32(distance);
+    fbBuilder.putUint32(id);
+    return fbBuilder.offset;
+  }
+
+  @override
+  String toString() {
+    return 'AbilityT{id: $id, distance: $distance}';
+  }
 }
 
 class _AbilityReader extends fb.StructReader<Ability> {
@@ -496,13 +652,11 @@
 
   @override
   Ability createObject(fb.BufferContext bc, int offset) => 
-    new Ability._(bc, offset);
+    Ability._(bc, offset);
 }
 
 class AbilityBuilder {
-  AbilityBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  AbilityBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
@@ -519,18 +673,15 @@
   final int _distance;
 
   AbilityObjectBuilder({
-    int id,
-    int distance,
+    required int id,
+    required int distance,
   })
       : _id = id,
         _distance = distance;
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
+  int finish(fb.Builder fbBuilder) {
     fbBuilder.putUint32(_distance);
     fbBuilder.putUint32(_id);
     return fbBuilder.offset;
@@ -538,16 +689,16 @@
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class StructOfStructs {
   StructOfStructs._(this._bc, this._bcOffset);
 
-  static const fb.Reader<StructOfStructs> reader = const _StructOfStructsReader();
+  static const fb.Reader<StructOfStructs> reader = _StructOfStructsReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -560,6 +711,40 @@
   String toString() {
     return 'StructOfStructs{a: $a, b: $b, c: $c}';
   }
+
+  StructOfStructsT unpack() => StructOfStructsT(
+      a: a.unpack(),
+      b: b.unpack(),
+      c: c.unpack());
+
+  static int pack(fb.Builder fbBuilder, StructOfStructsT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class StructOfStructsT implements fb.Packable {
+  AbilityT a;
+  TestT b;
+  AbilityT c;
+
+  StructOfStructsT({
+      required this.a,
+      required this.b,
+      required this.c});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    c.pack(fbBuilder);
+    b.pack(fbBuilder);
+    a.pack(fbBuilder);
+    return fbBuilder.offset;
+  }
+
+  @override
+  String toString() {
+    return 'StructOfStructsT{a: $a, b: $b, c: $c}';
+  }
 }
 
 class _StructOfStructsReader extends fb.StructReader<StructOfStructs> {
@@ -570,13 +755,11 @@
 
   @override
   StructOfStructs createObject(fb.BufferContext bc, int offset) => 
-    new StructOfStructs._(bc, offset);
+    StructOfStructs._(bc, offset);
 }
 
 class StructOfStructsBuilder {
-  StructOfStructsBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  StructOfStructsBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
@@ -595,9 +778,9 @@
   final AbilityObjectBuilder _c;
 
   StructOfStructsObjectBuilder({
-    AbilityObjectBuilder a,
-    TestObjectBuilder b,
-    AbilityObjectBuilder c,
+    required AbilityObjectBuilder a,
+    required TestObjectBuilder b,
+    required AbilityObjectBuilder c,
   })
       : _a = a,
         _b = b,
@@ -605,10 +788,7 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
+  int finish(fb.Builder fbBuilder) {
     _c.finish(fbBuilder);
     _b.finish(fbBuilder);
     _a.finish(fbBuilder);
@@ -617,25 +797,25 @@
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class Stat {
   Stat._(this._bc, this._bcOffset);
   factory Stat(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<Stat> reader = const _StatReader();
+  static const fb.Reader<Stat> reader = _StatReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
 
-  String get id => const fb.StringReader().vTableGet(_bc, _bcOffset, 4, null);
+  String? get id => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
   int get val => const fb.Int64Reader().vTableGet(_bc, _bcOffset, 6, 0);
   int get count => const fb.Uint16Reader().vTableGet(_bc, _bcOffset, 8, 0);
 
@@ -643,6 +823,43 @@
   String toString() {
     return 'Stat{id: $id, val: $val, count: $count}';
   }
+
+  StatT unpack() => StatT(
+      id: id,
+      val: val,
+      count: count);
+
+  static int pack(fb.Builder fbBuilder, StatT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class StatT implements fb.Packable {
+  String? id;
+  int val;
+  int count;
+
+  StatT({
+      this.id,
+      this.val = 0,
+      this.count = 0});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    final int? idOffset = id == null ? null
+        : fbBuilder.writeString(id!);
+    fbBuilder.startTable(3);
+    fbBuilder.addOffset(0, idOffset);
+    fbBuilder.addInt64(1, val);
+    fbBuilder.addUint16(2, count);
+    return fbBuilder.endTable();
+  }
+
+  @override
+  String toString() {
+    return 'StatT{id: $id, val: $val, count: $count}';
+  }
 }
 
 class _StatReader extends fb.TableReader<Stat> {
@@ -650,29 +867,27 @@
 
   @override
   Stat createObject(fb.BufferContext bc, int offset) => 
-    new Stat._(bc, offset);
+    Stat._(bc, offset);
 }
 
 class StatBuilder {
-  StatBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  StatBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
   void begin() {
-    fbBuilder.startTable();
+    fbBuilder.startTable(3);
   }
 
-  int addIdOffset(int offset) {
+  int addIdOffset(int? offset) {
     fbBuilder.addOffset(0, offset);
     return fbBuilder.offset;
   }
-  int addVal(int val) {
+  int addVal(int? val) {
     fbBuilder.addInt64(1, val);
     return fbBuilder.offset;
   }
-  int addCount(int count) {
+  int addCount(int? count) {
     fbBuilder.addUint16(2, count);
     return fbBuilder.offset;
   }
@@ -683,14 +898,14 @@
 }
 
 class StatObjectBuilder extends fb.ObjectBuilder {
-  final String _id;
-  final int _val;
-  final int _count;
+  final String? _id;
+  final int? _val;
+  final int? _count;
 
   StatObjectBuilder({
-    String id,
-    int val,
-    int count,
+    String? id,
+    int? val,
+    int? count,
   })
       : _id = id,
         _val = val,
@@ -698,15 +913,11 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-    final int idOffset = fbBuilder.writeString(_id);
-
-    fbBuilder.startTable();
-    if (idOffset != null) {
-      fbBuilder.addOffset(0, idOffset);
-    }
+  int finish(fb.Builder fbBuilder) {
+    final int? idOffset = _id == null ? null
+        : fbBuilder.writeString(_id!);
+    fbBuilder.startTable(3);
+    fbBuilder.addOffset(0, idOffset);
     fbBuilder.addInt64(1, _val);
     fbBuilder.addUint16(2, _count);
     return fbBuilder.endTable();
@@ -714,20 +925,20 @@
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class Referrable {
   Referrable._(this._bc, this._bcOffset);
   factory Referrable(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<Referrable> reader = const _ReferrableReader();
+  static const fb.Reader<Referrable> reader = _ReferrableReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -738,6 +949,33 @@
   String toString() {
     return 'Referrable{id: $id}';
   }
+
+  ReferrableT unpack() => ReferrableT(
+      id: id);
+
+  static int pack(fb.Builder fbBuilder, ReferrableT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class ReferrableT implements fb.Packable {
+  int id;
+
+  ReferrableT({
+      this.id = 0});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    fbBuilder.startTable(1);
+    fbBuilder.addUint64(0, id);
+    return fbBuilder.endTable();
+  }
+
+  @override
+  String toString() {
+    return 'ReferrableT{id: $id}';
+  }
 }
 
 class _ReferrableReader extends fb.TableReader<Referrable> {
@@ -745,21 +983,19 @@
 
   @override
   Referrable createObject(fb.BufferContext bc, int offset) => 
-    new Referrable._(bc, offset);
+    Referrable._(bc, offset);
 }
 
 class ReferrableBuilder {
-  ReferrableBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  ReferrableBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
   void begin() {
-    fbBuilder.startTable();
+    fbBuilder.startTable(1);
   }
 
-  int addId(int id) {
+  int addId(int? id) {
     fbBuilder.addUint64(0, id);
     return fbBuilder.offset;
   }
@@ -770,68 +1006,65 @@
 }
 
 class ReferrableObjectBuilder extends fb.ObjectBuilder {
-  final int _id;
+  final int? _id;
 
   ReferrableObjectBuilder({
-    int id,
+    int? id,
   })
       : _id = id;
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
-    fbBuilder.startTable();
+  int finish(fb.Builder fbBuilder) {
+    fbBuilder.startTable(1);
     fbBuilder.addUint64(0, _id);
     return fbBuilder.endTable();
   }
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 ///  an example documentation comment: "monster object"
 class Monster {
   Monster._(this._bc, this._bcOffset);
   factory Monster(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<Monster> reader = const _MonsterReader();
+  static const fb.Reader<Monster> reader = _MonsterReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
 
-  Vec3 get pos => Vec3.reader.vTableGet(_bc, _bcOffset, 4, null);
+  Vec3? get pos => Vec3.reader.vTableGetNullable(_bc, _bcOffset, 4);
   int get mana => const fb.Int16Reader().vTableGet(_bc, _bcOffset, 6, 150);
   int get hp => const fb.Int16Reader().vTableGet(_bc, _bcOffset, 8, 100);
-  String get name => const fb.StringReader().vTableGet(_bc, _bcOffset, 10, null);
-  List<int> get inventory => const fb.ListReader<int>(const fb.Uint8Reader()).vTableGet(_bc, _bcOffset, 14, null);
-  Color get color => new Color.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 16, 8));
-  AnyTypeId get testType => new AnyTypeId.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 18, 0));
+  String? get name => const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 10);
+  List<int>? get inventory => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 14);
+  Color get color => Color.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 16, 8));
+  AnyTypeId? get testType => AnyTypeId._createOrNull(const fb.Uint8Reader().vTableGetNullable(_bc, _bcOffset, 18));
   dynamic get test {
     switch (testType?.value) {
-      case 1: return Monster.reader.vTableGet(_bc, _bcOffset, 20, null);
-      case 2: return TestSimpleTableWithEnum.reader.vTableGet(_bc, _bcOffset, 20, null);
-      case 3: return my_game_example2.Monster.reader.vTableGet(_bc, _bcOffset, 20, null);
+      case 1: return Monster.reader.vTableGetNullable(_bc, _bcOffset, 20);
+      case 2: return TestSimpleTableWithEnum.reader.vTableGetNullable(_bc, _bcOffset, 20);
+      case 3: return my_game_example2.Monster.reader.vTableGetNullable(_bc, _bcOffset, 20);
       default: return null;
     }
   }
-  List<Test> get test4 => const fb.ListReader<Test>(Test.reader).vTableGet(_bc, _bcOffset, 22, null);
-  List<String> get testarrayofstring => const fb.ListReader<String>(const fb.StringReader()).vTableGet(_bc, _bcOffset, 24, null);
+  List<Test>? get test4 => const fb.ListReader<Test>(Test.reader).vTableGetNullable(_bc, _bcOffset, 22);
+  List<String>? get testarrayofstring => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 24);
   ///  an example documentation comment: this will end up in the generated code
   ///  multiline too
-  List<Monster> get testarrayoftables => const fb.ListReader<Monster>(Monster.reader).vTableGet(_bc, _bcOffset, 26, null);
-  Monster get enemy => Monster.reader.vTableGet(_bc, _bcOffset, 28, null);
-  List<int> get testnestedflatbuffer => const fb.ListReader<int>(const fb.Uint8Reader()).vTableGet(_bc, _bcOffset, 30, null);
-  Stat get testempty => Stat.reader.vTableGet(_bc, _bcOffset, 32, null);
+  List<Monster>? get testarrayoftables => const fb.ListReader<Monster>(Monster.reader).vTableGetNullable(_bc, _bcOffset, 26);
+  Monster? get enemy => Monster.reader.vTableGetNullable(_bc, _bcOffset, 28);
+  List<int>? get testnestedflatbuffer => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 30);
+  Stat? get testempty => Stat.reader.vTableGetNullable(_bc, _bcOffset, 32);
   bool get testbool => const fb.BoolReader().vTableGet(_bc, _bcOffset, 34, false);
   int get testhashs32Fnv1 => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 36, 0);
   int get testhashu32Fnv1 => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 38, 0);
@@ -841,52 +1074,337 @@
   int get testhashu32Fnv1a => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 46, 0);
   int get testhashs64Fnv1a => const fb.Int64Reader().vTableGet(_bc, _bcOffset, 48, 0);
   int get testhashu64Fnv1a => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 50, 0);
-  List<bool> get testarrayofbools => const fb.ListReader<bool>(const fb.BoolReader()).vTableGet(_bc, _bcOffset, 52, null);
+  List<bool>? get testarrayofbools => const fb.ListReader<bool>(fb.BoolReader()).vTableGetNullable(_bc, _bcOffset, 52);
   double get testf => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 54, 3.14159);
   double get testf2 => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 56, 3.0);
   double get testf3 => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 58, 0.0);
-  List<String> get testarrayofstring2 => const fb.ListReader<String>(const fb.StringReader()).vTableGet(_bc, _bcOffset, 60, null);
-  List<Ability> get testarrayofsortedstruct => const fb.ListReader<Ability>(Ability.reader).vTableGet(_bc, _bcOffset, 62, null);
-  List<int> get flex => const fb.ListReader<int>(const fb.Uint8Reader()).vTableGet(_bc, _bcOffset, 64, null);
-  List<Test> get test5 => const fb.ListReader<Test>(Test.reader).vTableGet(_bc, _bcOffset, 66, null);
-  List<int> get vectorOfLongs => const fb.ListReader<int>(const fb.Int64Reader()).vTableGet(_bc, _bcOffset, 68, null);
-  List<double> get vectorOfDoubles => const fb.ListReader<double>(const fb.Float64Reader()).vTableGet(_bc, _bcOffset, 70, null);
-  my_game.InParentNamespace get parentNamespaceTest => my_game.InParentNamespace.reader.vTableGet(_bc, _bcOffset, 72, null);
-  List<Referrable> get vectorOfReferrables => const fb.ListReader<Referrable>(Referrable.reader).vTableGet(_bc, _bcOffset, 74, null);
+  List<String>? get testarrayofstring2 => const fb.ListReader<String>(fb.StringReader()).vTableGetNullable(_bc, _bcOffset, 60);
+  List<Ability>? get testarrayofsortedstruct => const fb.ListReader<Ability>(Ability.reader).vTableGetNullable(_bc, _bcOffset, 62);
+  List<int>? get flex => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 64);
+  List<Test>? get test5 => const fb.ListReader<Test>(Test.reader).vTableGetNullable(_bc, _bcOffset, 66);
+  List<int>? get vectorOfLongs => const fb.ListReader<int>(fb.Int64Reader()).vTableGetNullable(_bc, _bcOffset, 68);
+  List<double>? get vectorOfDoubles => const fb.ListReader<double>(fb.Float64Reader()).vTableGetNullable(_bc, _bcOffset, 70);
+  my_game.InParentNamespace? get parentNamespaceTest => my_game.InParentNamespace.reader.vTableGetNullable(_bc, _bcOffset, 72);
+  List<Referrable>? get vectorOfReferrables => const fb.ListReader<Referrable>(Referrable.reader).vTableGetNullable(_bc, _bcOffset, 74);
   int get singleWeakReference => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 76, 0);
-  List<int> get vectorOfWeakReferences => const fb.ListReader<int>(const fb.Uint64Reader()).vTableGet(_bc, _bcOffset, 78, null);
-  List<Referrable> get vectorOfStrongReferrables => const fb.ListReader<Referrable>(Referrable.reader).vTableGet(_bc, _bcOffset, 80, null);
+  List<int>? get vectorOfWeakReferences => const fb.ListReader<int>(fb.Uint64Reader()).vTableGetNullable(_bc, _bcOffset, 78);
+  List<Referrable>? get vectorOfStrongReferrables => const fb.ListReader<Referrable>(Referrable.reader).vTableGetNullable(_bc, _bcOffset, 80);
   int get coOwningReference => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 82, 0);
-  List<int> get vectorOfCoOwningReferences => const fb.ListReader<int>(const fb.Uint64Reader()).vTableGet(_bc, _bcOffset, 84, null);
+  List<int>? get vectorOfCoOwningReferences => const fb.ListReader<int>(fb.Uint64Reader()).vTableGetNullable(_bc, _bcOffset, 84);
   int get nonOwningReference => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 86, 0);
-  List<int> get vectorOfNonOwningReferences => const fb.ListReader<int>(const fb.Uint64Reader()).vTableGet(_bc, _bcOffset, 88, null);
-  AnyUniqueAliasesTypeId get anyUniqueType => new AnyUniqueAliasesTypeId.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 90, 0));
+  List<int>? get vectorOfNonOwningReferences => const fb.ListReader<int>(fb.Uint64Reader()).vTableGetNullable(_bc, _bcOffset, 88);
+  AnyUniqueAliasesTypeId? get anyUniqueType => AnyUniqueAliasesTypeId._createOrNull(const fb.Uint8Reader().vTableGetNullable(_bc, _bcOffset, 90));
   dynamic get anyUnique {
     switch (anyUniqueType?.value) {
-      case 1: return Monster.reader.vTableGet(_bc, _bcOffset, 92, null);
-      case 2: return TestSimpleTableWithEnum.reader.vTableGet(_bc, _bcOffset, 92, null);
-      case 3: return my_game_example2.Monster.reader.vTableGet(_bc, _bcOffset, 92, null);
+      case 1: return Monster.reader.vTableGetNullable(_bc, _bcOffset, 92);
+      case 2: return TestSimpleTableWithEnum.reader.vTableGetNullable(_bc, _bcOffset, 92);
+      case 3: return my_game_example2.Monster.reader.vTableGetNullable(_bc, _bcOffset, 92);
       default: return null;
     }
   }
-  AnyAmbiguousAliasesTypeId get anyAmbiguousType => new AnyAmbiguousAliasesTypeId.fromValue(const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 94, 0));
+  AnyAmbiguousAliasesTypeId? get anyAmbiguousType => AnyAmbiguousAliasesTypeId._createOrNull(const fb.Uint8Reader().vTableGetNullable(_bc, _bcOffset, 94));
   dynamic get anyAmbiguous {
     switch (anyAmbiguousType?.value) {
-      case 1: return Monster.reader.vTableGet(_bc, _bcOffset, 96, null);
-      case 2: return Monster.reader.vTableGet(_bc, _bcOffset, 96, null);
-      case 3: return Monster.reader.vTableGet(_bc, _bcOffset, 96, null);
+      case 1: return Monster.reader.vTableGetNullable(_bc, _bcOffset, 96);
+      case 2: return Monster.reader.vTableGetNullable(_bc, _bcOffset, 96);
+      case 3: return Monster.reader.vTableGetNullable(_bc, _bcOffset, 96);
       default: return null;
     }
   }
-  List<Color> get vectorOfEnums => const fb.ListReader<Color>(Color.reader).vTableGet(_bc, _bcOffset, 98, null);
-  Race get signedEnum => new Race.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 100, -1));
-  List<int> get testrequirednestedflatbuffer => const fb.ListReader<int>(const fb.Uint8Reader()).vTableGet(_bc, _bcOffset, 102, null);
-  List<Stat> get scalarKeySortedTables => const fb.ListReader<Stat>(Stat.reader).vTableGet(_bc, _bcOffset, 104, null);
+  List<Color>? get vectorOfEnums => const fb.ListReader<Color>(Color.reader).vTableGetNullable(_bc, _bcOffset, 98);
+  Race get signedEnum => Race.fromValue(const fb.Int8Reader().vTableGet(_bc, _bcOffset, 100, -1));
+  List<int>? get testrequirednestedflatbuffer => const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 102);
+  List<Stat>? get scalarKeySortedTables => const fb.ListReader<Stat>(Stat.reader).vTableGetNullable(_bc, _bcOffset, 104);
 
   @override
   String toString() {
     return 'Monster{pos: $pos, mana: $mana, hp: $hp, name: $name, inventory: $inventory, color: $color, testType: $testType, test: $test, test4: $test4, testarrayofstring: $testarrayofstring, testarrayoftables: $testarrayoftables, enemy: $enemy, testnestedflatbuffer: $testnestedflatbuffer, testempty: $testempty, testbool: $testbool, testhashs32Fnv1: $testhashs32Fnv1, testhashu32Fnv1: $testhashu32Fnv1, testhashs64Fnv1: $testhashs64Fnv1, testhashu64Fnv1: $testhashu64Fnv1, testhashs32Fnv1a: $testhashs32Fnv1a, testhashu32Fnv1a: $testhashu32Fnv1a, testhashs64Fnv1a: $testhashs64Fnv1a, testhashu64Fnv1a: $testhashu64Fnv1a, testarrayofbools: $testarrayofbools, testf: $testf, testf2: $testf2, testf3: $testf3, testarrayofstring2: $testarrayofstring2, testarrayofsortedstruct: $testarrayofsortedstruct, flex: $flex, test5: $test5, vectorOfLongs: $vectorOfLongs, vectorOfDoubles: $vectorOfDoubles, parentNamespaceTest: $parentNamespaceTest, vectorOfReferrables: $vectorOfReferrables, singleWeakReference: $singleWeakReference, vectorOfWeakReferences: $vectorOfWeakReferences, vectorOfStrongReferrables: $vectorOfStrongReferrables, coOwningReference: $coOwningReference, vectorOfCoOwningReferences: $vectorOfCoOwningReferences, nonOwningReference: $nonOwningReference, vectorOfNonOwningReferences: $vectorOfNonOwningReferences, anyUniqueType: $anyUniqueType, anyUnique: $anyUnique, anyAmbiguousType: $anyAmbiguousType, anyAmbiguous: $anyAmbiguous, vectorOfEnums: $vectorOfEnums, signedEnum: $signedEnum, testrequirednestedflatbuffer: $testrequirednestedflatbuffer, scalarKeySortedTables: $scalarKeySortedTables}';
   }
+
+  MonsterT unpack() => MonsterT(
+      pos: pos?.unpack(),
+      mana: mana,
+      hp: hp,
+      name: name,
+      inventory: const fb.Uint8ListReader(lazy: false).vTableGetNullable(_bc, _bcOffset, 14),
+      color: color,
+      testType: testType,
+      test: test,
+      test4: test4?.map((e) => e.unpack()).toList(),
+      testarrayofstring: const fb.ListReader<String>(fb.StringReader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 24),
+      testarrayoftables: testarrayoftables?.map((e) => e.unpack()).toList(),
+      enemy: enemy?.unpack(),
+      testnestedflatbuffer: const fb.Uint8ListReader(lazy: false).vTableGetNullable(_bc, _bcOffset, 30),
+      testempty: testempty?.unpack(),
+      testbool: testbool,
+      testhashs32Fnv1: testhashs32Fnv1,
+      testhashu32Fnv1: testhashu32Fnv1,
+      testhashs64Fnv1: testhashs64Fnv1,
+      testhashu64Fnv1: testhashu64Fnv1,
+      testhashs32Fnv1a: testhashs32Fnv1a,
+      testhashu32Fnv1a: testhashu32Fnv1a,
+      testhashs64Fnv1a: testhashs64Fnv1a,
+      testhashu64Fnv1a: testhashu64Fnv1a,
+      testarrayofbools: const fb.ListReader<bool>(fb.BoolReader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 52),
+      testf: testf,
+      testf2: testf2,
+      testf3: testf3,
+      testarrayofstring2: const fb.ListReader<String>(fb.StringReader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 60),
+      testarrayofsortedstruct: testarrayofsortedstruct?.map((e) => e.unpack()).toList(),
+      flex: const fb.Uint8ListReader(lazy: false).vTableGetNullable(_bc, _bcOffset, 64),
+      test5: test5?.map((e) => e.unpack()).toList(),
+      vectorOfLongs: const fb.ListReader<int>(fb.Int64Reader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 68),
+      vectorOfDoubles: const fb.ListReader<double>(fb.Float64Reader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 70),
+      parentNamespaceTest: parentNamespaceTest?.unpack(),
+      vectorOfReferrables: vectorOfReferrables?.map((e) => e.unpack()).toList(),
+      singleWeakReference: singleWeakReference,
+      vectorOfWeakReferences: const fb.ListReader<int>(fb.Uint64Reader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 78),
+      vectorOfStrongReferrables: vectorOfStrongReferrables?.map((e) => e.unpack()).toList(),
+      coOwningReference: coOwningReference,
+      vectorOfCoOwningReferences: const fb.ListReader<int>(fb.Uint64Reader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 84),
+      nonOwningReference: nonOwningReference,
+      vectorOfNonOwningReferences: const fb.ListReader<int>(fb.Uint64Reader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 88),
+      anyUniqueType: anyUniqueType,
+      anyUnique: anyUnique,
+      anyAmbiguousType: anyAmbiguousType,
+      anyAmbiguous: anyAmbiguous,
+      vectorOfEnums: const fb.ListReader<Color>(Color.reader, lazy: false).vTableGetNullable(_bc, _bcOffset, 98),
+      signedEnum: signedEnum,
+      testrequirednestedflatbuffer: const fb.Uint8ListReader(lazy: false).vTableGetNullable(_bc, _bcOffset, 102),
+      scalarKeySortedTables: scalarKeySortedTables?.map((e) => e.unpack()).toList());
+
+  static int pack(fb.Builder fbBuilder, MonsterT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+///  an example documentation comment: "monster object"
+class MonsterT implements fb.Packable {
+  Vec3T? pos;
+  int mana;
+  int hp;
+  String? name;
+  List<int>? inventory;
+  Color color;
+  AnyTypeId? testType;
+  dynamic test;
+  List<TestT>? test4;
+  List<String>? testarrayofstring;
+  ///  an example documentation comment: this will end up in the generated code
+  ///  multiline too
+  List<MonsterT>? testarrayoftables;
+  MonsterT? enemy;
+  List<int>? testnestedflatbuffer;
+  StatT? testempty;
+  bool testbool;
+  int testhashs32Fnv1;
+  int testhashu32Fnv1;
+  int testhashs64Fnv1;
+  int testhashu64Fnv1;
+  int testhashs32Fnv1a;
+  int testhashu32Fnv1a;
+  int testhashs64Fnv1a;
+  int testhashu64Fnv1a;
+  List<bool>? testarrayofbools;
+  double testf;
+  double testf2;
+  double testf3;
+  List<String>? testarrayofstring2;
+  List<AbilityT>? testarrayofsortedstruct;
+  List<int>? flex;
+  List<TestT>? test5;
+  List<int>? vectorOfLongs;
+  List<double>? vectorOfDoubles;
+  my_game.InParentNamespaceT? parentNamespaceTest;
+  List<ReferrableT>? vectorOfReferrables;
+  int singleWeakReference;
+  List<int>? vectorOfWeakReferences;
+  List<ReferrableT>? vectorOfStrongReferrables;
+  int coOwningReference;
+  List<int>? vectorOfCoOwningReferences;
+  int nonOwningReference;
+  List<int>? vectorOfNonOwningReferences;
+  AnyUniqueAliasesTypeId? anyUniqueType;
+  dynamic anyUnique;
+  AnyAmbiguousAliasesTypeId? anyAmbiguousType;
+  dynamic anyAmbiguous;
+  List<Color>? vectorOfEnums;
+  Race signedEnum;
+  List<int>? testrequirednestedflatbuffer;
+  List<StatT>? scalarKeySortedTables;
+
+  MonsterT({
+      this.pos,
+      this.mana = 150,
+      this.hp = 100,
+      this.name,
+      this.inventory,
+      this.color = Color.Blue,
+      this.testType,
+      this.test,
+      this.test4,
+      this.testarrayofstring,
+      this.testarrayoftables,
+      this.enemy,
+      this.testnestedflatbuffer,
+      this.testempty,
+      this.testbool = false,
+      this.testhashs32Fnv1 = 0,
+      this.testhashu32Fnv1 = 0,
+      this.testhashs64Fnv1 = 0,
+      this.testhashu64Fnv1 = 0,
+      this.testhashs32Fnv1a = 0,
+      this.testhashu32Fnv1a = 0,
+      this.testhashs64Fnv1a = 0,
+      this.testhashu64Fnv1a = 0,
+      this.testarrayofbools,
+      this.testf = 3.14159,
+      this.testf2 = 3.0,
+      this.testf3 = 0.0,
+      this.testarrayofstring2,
+      this.testarrayofsortedstruct,
+      this.flex,
+      this.test5,
+      this.vectorOfLongs,
+      this.vectorOfDoubles,
+      this.parentNamespaceTest,
+      this.vectorOfReferrables,
+      this.singleWeakReference = 0,
+      this.vectorOfWeakReferences,
+      this.vectorOfStrongReferrables,
+      this.coOwningReference = 0,
+      this.vectorOfCoOwningReferences,
+      this.nonOwningReference = 0,
+      this.vectorOfNonOwningReferences,
+      this.anyUniqueType,
+      this.anyUnique,
+      this.anyAmbiguousType,
+      this.anyAmbiguous,
+      this.vectorOfEnums,
+      this.signedEnum = Race.None,
+      this.testrequirednestedflatbuffer,
+      this.scalarKeySortedTables});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    final int? nameOffset = name == null ? null
+        : fbBuilder.writeString(name!);
+    final int? inventoryOffset = inventory == null ? null
+        : fbBuilder.writeListUint8(inventory!);
+    final int? testOffset = test?.pack(fbBuilder);
+    int? test4Offset;
+    if (test4 != null) {
+      for (var e in test4!) { e.pack(fbBuilder); }
+      test4Offset = fbBuilder.endStructVector(test4!.length);
+    }
+    final int? testarrayofstringOffset = testarrayofstring == null ? null
+        : fbBuilder.writeList(testarrayofstring!.map(fbBuilder.writeString).toList());
+    final int? testarrayoftablesOffset = testarrayoftables == null ? null
+        : fbBuilder.writeList(testarrayoftables!.map((b) => b.pack(fbBuilder)).toList());
+    final int? enemyOffset = enemy?.pack(fbBuilder);
+    final int? testnestedflatbufferOffset = testnestedflatbuffer == null ? null
+        : fbBuilder.writeListUint8(testnestedflatbuffer!);
+    final int? testemptyOffset = testempty?.pack(fbBuilder);
+    final int? testarrayofboolsOffset = testarrayofbools == null ? null
+        : fbBuilder.writeListBool(testarrayofbools!);
+    final int? testarrayofstring2Offset = testarrayofstring2 == null ? null
+        : fbBuilder.writeList(testarrayofstring2!.map(fbBuilder.writeString).toList());
+    int? testarrayofsortedstructOffset;
+    if (testarrayofsortedstruct != null) {
+      for (var e in testarrayofsortedstruct!) { e.pack(fbBuilder); }
+      testarrayofsortedstructOffset = fbBuilder.endStructVector(testarrayofsortedstruct!.length);
+    }
+    final int? flexOffset = flex == null ? null
+        : fbBuilder.writeListUint8(flex!);
+    int? test5Offset;
+    if (test5 != null) {
+      for (var e in test5!) { e.pack(fbBuilder); }
+      test5Offset = fbBuilder.endStructVector(test5!.length);
+    }
+    final int? vectorOfLongsOffset = vectorOfLongs == null ? null
+        : fbBuilder.writeListInt64(vectorOfLongs!);
+    final int? vectorOfDoublesOffset = vectorOfDoubles == null ? null
+        : fbBuilder.writeListFloat64(vectorOfDoubles!);
+    final int? parentNamespaceTestOffset = parentNamespaceTest?.pack(fbBuilder);
+    final int? vectorOfReferrablesOffset = vectorOfReferrables == null ? null
+        : fbBuilder.writeList(vectorOfReferrables!.map((b) => b.pack(fbBuilder)).toList());
+    final int? vectorOfWeakReferencesOffset = vectorOfWeakReferences == null ? null
+        : fbBuilder.writeListUint64(vectorOfWeakReferences!);
+    final int? vectorOfStrongReferrablesOffset = vectorOfStrongReferrables == null ? null
+        : fbBuilder.writeList(vectorOfStrongReferrables!.map((b) => b.pack(fbBuilder)).toList());
+    final int? vectorOfCoOwningReferencesOffset = vectorOfCoOwningReferences == null ? null
+        : fbBuilder.writeListUint64(vectorOfCoOwningReferences!);
+    final int? vectorOfNonOwningReferencesOffset = vectorOfNonOwningReferences == null ? null
+        : fbBuilder.writeListUint64(vectorOfNonOwningReferences!);
+    final int? anyUniqueOffset = anyUnique?.pack(fbBuilder);
+    final int? anyAmbiguousOffset = anyAmbiguous?.pack(fbBuilder);
+    final int? vectorOfEnumsOffset = vectorOfEnums == null ? null
+        : fbBuilder.writeListUint8(vectorOfEnums!.map((f) => f.value).toList());
+    final int? testrequirednestedflatbufferOffset = testrequirednestedflatbuffer == null ? null
+        : fbBuilder.writeListUint8(testrequirednestedflatbuffer!);
+    final int? scalarKeySortedTablesOffset = scalarKeySortedTables == null ? null
+        : fbBuilder.writeList(scalarKeySortedTables!.map((b) => b.pack(fbBuilder)).toList());
+    fbBuilder.startTable(50);
+    if (pos != null) {
+      fbBuilder.addStruct(0, pos!.pack(fbBuilder));
+    }
+    fbBuilder.addInt16(1, mana);
+    fbBuilder.addInt16(2, hp);
+    fbBuilder.addOffset(3, nameOffset);
+    fbBuilder.addOffset(5, inventoryOffset);
+    fbBuilder.addUint8(6, color.value);
+    fbBuilder.addUint8(7, testType?.value);
+    fbBuilder.addOffset(8, testOffset);
+    fbBuilder.addOffset(9, test4Offset);
+    fbBuilder.addOffset(10, testarrayofstringOffset);
+    fbBuilder.addOffset(11, testarrayoftablesOffset);
+    fbBuilder.addOffset(12, enemyOffset);
+    fbBuilder.addOffset(13, testnestedflatbufferOffset);
+    fbBuilder.addOffset(14, testemptyOffset);
+    fbBuilder.addBool(15, testbool);
+    fbBuilder.addInt32(16, testhashs32Fnv1);
+    fbBuilder.addUint32(17, testhashu32Fnv1);
+    fbBuilder.addInt64(18, testhashs64Fnv1);
+    fbBuilder.addUint64(19, testhashu64Fnv1);
+    fbBuilder.addInt32(20, testhashs32Fnv1a);
+    fbBuilder.addUint32(21, testhashu32Fnv1a);
+    fbBuilder.addInt64(22, testhashs64Fnv1a);
+    fbBuilder.addUint64(23, testhashu64Fnv1a);
+    fbBuilder.addOffset(24, testarrayofboolsOffset);
+    fbBuilder.addFloat32(25, testf);
+    fbBuilder.addFloat32(26, testf2);
+    fbBuilder.addFloat32(27, testf3);
+    fbBuilder.addOffset(28, testarrayofstring2Offset);
+    fbBuilder.addOffset(29, testarrayofsortedstructOffset);
+    fbBuilder.addOffset(30, flexOffset);
+    fbBuilder.addOffset(31, test5Offset);
+    fbBuilder.addOffset(32, vectorOfLongsOffset);
+    fbBuilder.addOffset(33, vectorOfDoublesOffset);
+    fbBuilder.addOffset(34, parentNamespaceTestOffset);
+    fbBuilder.addOffset(35, vectorOfReferrablesOffset);
+    fbBuilder.addUint64(36, singleWeakReference);
+    fbBuilder.addOffset(37, vectorOfWeakReferencesOffset);
+    fbBuilder.addOffset(38, vectorOfStrongReferrablesOffset);
+    fbBuilder.addUint64(39, coOwningReference);
+    fbBuilder.addOffset(40, vectorOfCoOwningReferencesOffset);
+    fbBuilder.addUint64(41, nonOwningReference);
+    fbBuilder.addOffset(42, vectorOfNonOwningReferencesOffset);
+    fbBuilder.addUint8(43, anyUniqueType?.value);
+    fbBuilder.addOffset(44, anyUniqueOffset);
+    fbBuilder.addUint8(45, anyAmbiguousType?.value);
+    fbBuilder.addOffset(46, anyAmbiguousOffset);
+    fbBuilder.addOffset(47, vectorOfEnumsOffset);
+    fbBuilder.addInt8(48, signedEnum.value);
+    fbBuilder.addOffset(49, testrequirednestedflatbufferOffset);
+    fbBuilder.addOffset(50, scalarKeySortedTablesOffset);
+    return fbBuilder.endTable();
+  }
+
+  @override
+  String toString() {
+    return 'MonsterT{pos: $pos, mana: $mana, hp: $hp, name: $name, inventory: $inventory, color: $color, testType: $testType, test: $test, test4: $test4, testarrayofstring: $testarrayofstring, testarrayoftables: $testarrayoftables, enemy: $enemy, testnestedflatbuffer: $testnestedflatbuffer, testempty: $testempty, testbool: $testbool, testhashs32Fnv1: $testhashs32Fnv1, testhashu32Fnv1: $testhashu32Fnv1, testhashs64Fnv1: $testhashs64Fnv1, testhashu64Fnv1: $testhashu64Fnv1, testhashs32Fnv1a: $testhashs32Fnv1a, testhashu32Fnv1a: $testhashu32Fnv1a, testhashs64Fnv1a: $testhashs64Fnv1a, testhashu64Fnv1a: $testhashu64Fnv1a, testarrayofbools: $testarrayofbools, testf: $testf, testf2: $testf2, testf3: $testf3, testarrayofstring2: $testarrayofstring2, testarrayofsortedstruct: $testarrayofsortedstruct, flex: $flex, test5: $test5, vectorOfLongs: $vectorOfLongs, vectorOfDoubles: $vectorOfDoubles, parentNamespaceTest: $parentNamespaceTest, vectorOfReferrables: $vectorOfReferrables, singleWeakReference: $singleWeakReference, vectorOfWeakReferences: $vectorOfWeakReferences, vectorOfStrongReferrables: $vectorOfStrongReferrables, coOwningReference: $coOwningReference, vectorOfCoOwningReferences: $vectorOfCoOwningReferences, nonOwningReference: $nonOwningReference, vectorOfNonOwningReferences: $vectorOfNonOwningReferences, anyUniqueType: $anyUniqueType, anyUnique: $anyUnique, anyAmbiguousType: $anyAmbiguousType, anyAmbiguous: $anyAmbiguous, vectorOfEnums: $vectorOfEnums, signedEnum: $signedEnum, testrequirednestedflatbuffer: $testrequirednestedflatbuffer, scalarKeySortedTables: $scalarKeySortedTables}';
+  }
 }
 
 class _MonsterReader extends fb.TableReader<Monster> {
@@ -894,217 +1412,215 @@
 
   @override
   Monster createObject(fb.BufferContext bc, int offset) => 
-    new Monster._(bc, offset);
+    Monster._(bc, offset);
 }
 
 class MonsterBuilder {
-  MonsterBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  MonsterBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
   void begin() {
-    fbBuilder.startTable();
+    fbBuilder.startTable(50);
   }
 
   int addPos(int offset) {
     fbBuilder.addStruct(0, offset);
     return fbBuilder.offset;
   }
-  int addMana(int mana) {
+  int addMana(int? mana) {
     fbBuilder.addInt16(1, mana);
     return fbBuilder.offset;
   }
-  int addHp(int hp) {
+  int addHp(int? hp) {
     fbBuilder.addInt16(2, hp);
     return fbBuilder.offset;
   }
-  int addNameOffset(int offset) {
+  int addNameOffset(int? offset) {
     fbBuilder.addOffset(3, offset);
     return fbBuilder.offset;
   }
-  int addInventoryOffset(int offset) {
+  int addInventoryOffset(int? offset) {
     fbBuilder.addOffset(5, offset);
     return fbBuilder.offset;
   }
-  int addColor(Color color) {
+  int addColor(Color? color) {
     fbBuilder.addUint8(6, color?.value);
     return fbBuilder.offset;
   }
-  int addTestType(AnyTypeId testType) {
+  int addTestType(AnyTypeId? testType) {
     fbBuilder.addUint8(7, testType?.value);
     return fbBuilder.offset;
   }
-  int addTestOffset(int offset) {
+  int addTestOffset(int? offset) {
     fbBuilder.addOffset(8, offset);
     return fbBuilder.offset;
   }
-  int addTest4Offset(int offset) {
+  int addTest4Offset(int? offset) {
     fbBuilder.addOffset(9, offset);
     return fbBuilder.offset;
   }
-  int addTestarrayofstringOffset(int offset) {
+  int addTestarrayofstringOffset(int? offset) {
     fbBuilder.addOffset(10, offset);
     return fbBuilder.offset;
   }
-  int addTestarrayoftablesOffset(int offset) {
+  int addTestarrayoftablesOffset(int? offset) {
     fbBuilder.addOffset(11, offset);
     return fbBuilder.offset;
   }
-  int addEnemyOffset(int offset) {
+  int addEnemyOffset(int? offset) {
     fbBuilder.addOffset(12, offset);
     return fbBuilder.offset;
   }
-  int addTestnestedflatbufferOffset(int offset) {
+  int addTestnestedflatbufferOffset(int? offset) {
     fbBuilder.addOffset(13, offset);
     return fbBuilder.offset;
   }
-  int addTestemptyOffset(int offset) {
+  int addTestemptyOffset(int? offset) {
     fbBuilder.addOffset(14, offset);
     return fbBuilder.offset;
   }
-  int addTestbool(bool testbool) {
+  int addTestbool(bool? testbool) {
     fbBuilder.addBool(15, testbool);
     return fbBuilder.offset;
   }
-  int addTesthashs32Fnv1(int testhashs32Fnv1) {
+  int addTesthashs32Fnv1(int? testhashs32Fnv1) {
     fbBuilder.addInt32(16, testhashs32Fnv1);
     return fbBuilder.offset;
   }
-  int addTesthashu32Fnv1(int testhashu32Fnv1) {
+  int addTesthashu32Fnv1(int? testhashu32Fnv1) {
     fbBuilder.addUint32(17, testhashu32Fnv1);
     return fbBuilder.offset;
   }
-  int addTesthashs64Fnv1(int testhashs64Fnv1) {
+  int addTesthashs64Fnv1(int? testhashs64Fnv1) {
     fbBuilder.addInt64(18, testhashs64Fnv1);
     return fbBuilder.offset;
   }
-  int addTesthashu64Fnv1(int testhashu64Fnv1) {
+  int addTesthashu64Fnv1(int? testhashu64Fnv1) {
     fbBuilder.addUint64(19, testhashu64Fnv1);
     return fbBuilder.offset;
   }
-  int addTesthashs32Fnv1a(int testhashs32Fnv1a) {
+  int addTesthashs32Fnv1a(int? testhashs32Fnv1a) {
     fbBuilder.addInt32(20, testhashs32Fnv1a);
     return fbBuilder.offset;
   }
-  int addTesthashu32Fnv1a(int testhashu32Fnv1a) {
+  int addTesthashu32Fnv1a(int? testhashu32Fnv1a) {
     fbBuilder.addUint32(21, testhashu32Fnv1a);
     return fbBuilder.offset;
   }
-  int addTesthashs64Fnv1a(int testhashs64Fnv1a) {
+  int addTesthashs64Fnv1a(int? testhashs64Fnv1a) {
     fbBuilder.addInt64(22, testhashs64Fnv1a);
     return fbBuilder.offset;
   }
-  int addTesthashu64Fnv1a(int testhashu64Fnv1a) {
+  int addTesthashu64Fnv1a(int? testhashu64Fnv1a) {
     fbBuilder.addUint64(23, testhashu64Fnv1a);
     return fbBuilder.offset;
   }
-  int addTestarrayofboolsOffset(int offset) {
+  int addTestarrayofboolsOffset(int? offset) {
     fbBuilder.addOffset(24, offset);
     return fbBuilder.offset;
   }
-  int addTestf(double testf) {
+  int addTestf(double? testf) {
     fbBuilder.addFloat32(25, testf);
     return fbBuilder.offset;
   }
-  int addTestf2(double testf2) {
+  int addTestf2(double? testf2) {
     fbBuilder.addFloat32(26, testf2);
     return fbBuilder.offset;
   }
-  int addTestf3(double testf3) {
+  int addTestf3(double? testf3) {
     fbBuilder.addFloat32(27, testf3);
     return fbBuilder.offset;
   }
-  int addTestarrayofstring2Offset(int offset) {
+  int addTestarrayofstring2Offset(int? offset) {
     fbBuilder.addOffset(28, offset);
     return fbBuilder.offset;
   }
-  int addTestarrayofsortedstructOffset(int offset) {
+  int addTestarrayofsortedstructOffset(int? offset) {
     fbBuilder.addOffset(29, offset);
     return fbBuilder.offset;
   }
-  int addFlexOffset(int offset) {
+  int addFlexOffset(int? offset) {
     fbBuilder.addOffset(30, offset);
     return fbBuilder.offset;
   }
-  int addTest5Offset(int offset) {
+  int addTest5Offset(int? offset) {
     fbBuilder.addOffset(31, offset);
     return fbBuilder.offset;
   }
-  int addVectorOfLongsOffset(int offset) {
+  int addVectorOfLongsOffset(int? offset) {
     fbBuilder.addOffset(32, offset);
     return fbBuilder.offset;
   }
-  int addVectorOfDoublesOffset(int offset) {
+  int addVectorOfDoublesOffset(int? offset) {
     fbBuilder.addOffset(33, offset);
     return fbBuilder.offset;
   }
-  int addParentNamespaceTestOffset(int offset) {
+  int addParentNamespaceTestOffset(int? offset) {
     fbBuilder.addOffset(34, offset);
     return fbBuilder.offset;
   }
-  int addVectorOfReferrablesOffset(int offset) {
+  int addVectorOfReferrablesOffset(int? offset) {
     fbBuilder.addOffset(35, offset);
     return fbBuilder.offset;
   }
-  int addSingleWeakReference(int singleWeakReference) {
+  int addSingleWeakReference(int? singleWeakReference) {
     fbBuilder.addUint64(36, singleWeakReference);
     return fbBuilder.offset;
   }
-  int addVectorOfWeakReferencesOffset(int offset) {
+  int addVectorOfWeakReferencesOffset(int? offset) {
     fbBuilder.addOffset(37, offset);
     return fbBuilder.offset;
   }
-  int addVectorOfStrongReferrablesOffset(int offset) {
+  int addVectorOfStrongReferrablesOffset(int? offset) {
     fbBuilder.addOffset(38, offset);
     return fbBuilder.offset;
   }
-  int addCoOwningReference(int coOwningReference) {
+  int addCoOwningReference(int? coOwningReference) {
     fbBuilder.addUint64(39, coOwningReference);
     return fbBuilder.offset;
   }
-  int addVectorOfCoOwningReferencesOffset(int offset) {
+  int addVectorOfCoOwningReferencesOffset(int? offset) {
     fbBuilder.addOffset(40, offset);
     return fbBuilder.offset;
   }
-  int addNonOwningReference(int nonOwningReference) {
+  int addNonOwningReference(int? nonOwningReference) {
     fbBuilder.addUint64(41, nonOwningReference);
     return fbBuilder.offset;
   }
-  int addVectorOfNonOwningReferencesOffset(int offset) {
+  int addVectorOfNonOwningReferencesOffset(int? offset) {
     fbBuilder.addOffset(42, offset);
     return fbBuilder.offset;
   }
-  int addAnyUniqueType(AnyUniqueAliasesTypeId anyUniqueType) {
+  int addAnyUniqueType(AnyUniqueAliasesTypeId? anyUniqueType) {
     fbBuilder.addUint8(43, anyUniqueType?.value);
     return fbBuilder.offset;
   }
-  int addAnyUniqueOffset(int offset) {
+  int addAnyUniqueOffset(int? offset) {
     fbBuilder.addOffset(44, offset);
     return fbBuilder.offset;
   }
-  int addAnyAmbiguousType(AnyAmbiguousAliasesTypeId anyAmbiguousType) {
+  int addAnyAmbiguousType(AnyAmbiguousAliasesTypeId? anyAmbiguousType) {
     fbBuilder.addUint8(45, anyAmbiguousType?.value);
     return fbBuilder.offset;
   }
-  int addAnyAmbiguousOffset(int offset) {
+  int addAnyAmbiguousOffset(int? offset) {
     fbBuilder.addOffset(46, offset);
     return fbBuilder.offset;
   }
-  int addVectorOfEnumsOffset(int offset) {
+  int addVectorOfEnumsOffset(int? offset) {
     fbBuilder.addOffset(47, offset);
     return fbBuilder.offset;
   }
-  int addSignedEnum(Race signedEnum) {
+  int addSignedEnum(Race? signedEnum) {
     fbBuilder.addInt8(48, signedEnum?.value);
     return fbBuilder.offset;
   }
-  int addTestrequirednestedflatbufferOffset(int offset) {
+  int addTestrequirednestedflatbufferOffset(int? offset) {
     fbBuilder.addOffset(49, offset);
     return fbBuilder.offset;
   }
-  int addScalarKeySortedTablesOffset(int offset) {
+  int addScalarKeySortedTablesOffset(int? offset) {
     fbBuilder.addOffset(50, offset);
     return fbBuilder.offset;
   }
@@ -1115,108 +1631,108 @@
 }
 
 class MonsterObjectBuilder extends fb.ObjectBuilder {
-  final Vec3ObjectBuilder _pos;
-  final int _mana;
-  final int _hp;
-  final String _name;
-  final List<int> _inventory;
-  final Color _color;
-  final AnyTypeId _testType;
+  final Vec3ObjectBuilder? _pos;
+  final int? _mana;
+  final int? _hp;
+  final String? _name;
+  final List<int>? _inventory;
+  final Color? _color;
+  final AnyTypeId? _testType;
   final dynamic _test;
-  final List<TestObjectBuilder> _test4;
-  final List<String> _testarrayofstring;
-  final List<MonsterObjectBuilder> _testarrayoftables;
-  final MonsterObjectBuilder _enemy;
-  final List<int> _testnestedflatbuffer;
-  final StatObjectBuilder _testempty;
-  final bool _testbool;
-  final int _testhashs32Fnv1;
-  final int _testhashu32Fnv1;
-  final int _testhashs64Fnv1;
-  final int _testhashu64Fnv1;
-  final int _testhashs32Fnv1a;
-  final int _testhashu32Fnv1a;
-  final int _testhashs64Fnv1a;
-  final int _testhashu64Fnv1a;
-  final List<bool> _testarrayofbools;
-  final double _testf;
-  final double _testf2;
-  final double _testf3;
-  final List<String> _testarrayofstring2;
-  final List<AbilityObjectBuilder> _testarrayofsortedstruct;
-  final List<int> _flex;
-  final List<TestObjectBuilder> _test5;
-  final List<int> _vectorOfLongs;
-  final List<double> _vectorOfDoubles;
-  final my_game.InParentNamespaceObjectBuilder _parentNamespaceTest;
-  final List<ReferrableObjectBuilder> _vectorOfReferrables;
-  final int _singleWeakReference;
-  final List<int> _vectorOfWeakReferences;
-  final List<ReferrableObjectBuilder> _vectorOfStrongReferrables;
-  final int _coOwningReference;
-  final List<int> _vectorOfCoOwningReferences;
-  final int _nonOwningReference;
-  final List<int> _vectorOfNonOwningReferences;
-  final AnyUniqueAliasesTypeId _anyUniqueType;
+  final List<TestObjectBuilder>? _test4;
+  final List<String>? _testarrayofstring;
+  final List<MonsterObjectBuilder>? _testarrayoftables;
+  final MonsterObjectBuilder? _enemy;
+  final List<int>? _testnestedflatbuffer;
+  final StatObjectBuilder? _testempty;
+  final bool? _testbool;
+  final int? _testhashs32Fnv1;
+  final int? _testhashu32Fnv1;
+  final int? _testhashs64Fnv1;
+  final int? _testhashu64Fnv1;
+  final int? _testhashs32Fnv1a;
+  final int? _testhashu32Fnv1a;
+  final int? _testhashs64Fnv1a;
+  final int? _testhashu64Fnv1a;
+  final List<bool>? _testarrayofbools;
+  final double? _testf;
+  final double? _testf2;
+  final double? _testf3;
+  final List<String>? _testarrayofstring2;
+  final List<AbilityObjectBuilder>? _testarrayofsortedstruct;
+  final List<int>? _flex;
+  final List<TestObjectBuilder>? _test5;
+  final List<int>? _vectorOfLongs;
+  final List<double>? _vectorOfDoubles;
+  final my_game.InParentNamespaceObjectBuilder? _parentNamespaceTest;
+  final List<ReferrableObjectBuilder>? _vectorOfReferrables;
+  final int? _singleWeakReference;
+  final List<int>? _vectorOfWeakReferences;
+  final List<ReferrableObjectBuilder>? _vectorOfStrongReferrables;
+  final int? _coOwningReference;
+  final List<int>? _vectorOfCoOwningReferences;
+  final int? _nonOwningReference;
+  final List<int>? _vectorOfNonOwningReferences;
+  final AnyUniqueAliasesTypeId? _anyUniqueType;
   final dynamic _anyUnique;
-  final AnyAmbiguousAliasesTypeId _anyAmbiguousType;
+  final AnyAmbiguousAliasesTypeId? _anyAmbiguousType;
   final dynamic _anyAmbiguous;
-  final List<Color> _vectorOfEnums;
-  final Race _signedEnum;
-  final List<int> _testrequirednestedflatbuffer;
-  final List<StatObjectBuilder> _scalarKeySortedTables;
+  final List<Color>? _vectorOfEnums;
+  final Race? _signedEnum;
+  final List<int>? _testrequirednestedflatbuffer;
+  final List<StatObjectBuilder>? _scalarKeySortedTables;
 
   MonsterObjectBuilder({
-    Vec3ObjectBuilder pos,
-    int mana,
-    int hp,
-    String name,
-    List<int> inventory,
-    Color color,
-    AnyTypeId testType,
+    Vec3ObjectBuilder? pos,
+    int? mana,
+    int? hp,
+    String? name,
+    List<int>? inventory,
+    Color? color,
+    AnyTypeId? testType,
     dynamic test,
-    List<TestObjectBuilder> test4,
-    List<String> testarrayofstring,
-    List<MonsterObjectBuilder> testarrayoftables,
-    MonsterObjectBuilder enemy,
-    List<int> testnestedflatbuffer,
-    StatObjectBuilder testempty,
-    bool testbool,
-    int testhashs32Fnv1,
-    int testhashu32Fnv1,
-    int testhashs64Fnv1,
-    int testhashu64Fnv1,
-    int testhashs32Fnv1a,
-    int testhashu32Fnv1a,
-    int testhashs64Fnv1a,
-    int testhashu64Fnv1a,
-    List<bool> testarrayofbools,
-    double testf,
-    double testf2,
-    double testf3,
-    List<String> testarrayofstring2,
-    List<AbilityObjectBuilder> testarrayofsortedstruct,
-    List<int> flex,
-    List<TestObjectBuilder> test5,
-    List<int> vectorOfLongs,
-    List<double> vectorOfDoubles,
-    my_game.InParentNamespaceObjectBuilder parentNamespaceTest,
-    List<ReferrableObjectBuilder> vectorOfReferrables,
-    int singleWeakReference,
-    List<int> vectorOfWeakReferences,
-    List<ReferrableObjectBuilder> vectorOfStrongReferrables,
-    int coOwningReference,
-    List<int> vectorOfCoOwningReferences,
-    int nonOwningReference,
-    List<int> vectorOfNonOwningReferences,
-    AnyUniqueAliasesTypeId anyUniqueType,
+    List<TestObjectBuilder>? test4,
+    List<String>? testarrayofstring,
+    List<MonsterObjectBuilder>? testarrayoftables,
+    MonsterObjectBuilder? enemy,
+    List<int>? testnestedflatbuffer,
+    StatObjectBuilder? testempty,
+    bool? testbool,
+    int? testhashs32Fnv1,
+    int? testhashu32Fnv1,
+    int? testhashs64Fnv1,
+    int? testhashu64Fnv1,
+    int? testhashs32Fnv1a,
+    int? testhashu32Fnv1a,
+    int? testhashs64Fnv1a,
+    int? testhashu64Fnv1a,
+    List<bool>? testarrayofbools,
+    double? testf,
+    double? testf2,
+    double? testf3,
+    List<String>? testarrayofstring2,
+    List<AbilityObjectBuilder>? testarrayofsortedstruct,
+    List<int>? flex,
+    List<TestObjectBuilder>? test5,
+    List<int>? vectorOfLongs,
+    List<double>? vectorOfDoubles,
+    my_game.InParentNamespaceObjectBuilder? parentNamespaceTest,
+    List<ReferrableObjectBuilder>? vectorOfReferrables,
+    int? singleWeakReference,
+    List<int>? vectorOfWeakReferences,
+    List<ReferrableObjectBuilder>? vectorOfStrongReferrables,
+    int? coOwningReference,
+    List<int>? vectorOfCoOwningReferences,
+    int? nonOwningReference,
+    List<int>? vectorOfNonOwningReferences,
+    AnyUniqueAliasesTypeId? anyUniqueType,
     dynamic anyUnique,
-    AnyAmbiguousAliasesTypeId anyAmbiguousType,
+    AnyAmbiguousAliasesTypeId? anyAmbiguousType,
     dynamic anyAmbiguous,
-    List<Color> vectorOfEnums,
-    Race signedEnum,
-    List<int> testrequirednestedflatbuffer,
-    List<StatObjectBuilder> scalarKeySortedTables,
+    List<Color>? vectorOfEnums,
+    Race? signedEnum,
+    List<int>? testrequirednestedflatbuffer,
+    List<StatObjectBuilder>? scalarKeySortedTables,
   })
       : _pos = pos,
         _mana = mana,
@@ -1271,112 +1787,72 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-    final int nameOffset = fbBuilder.writeString(_name);
-    final int inventoryOffset = _inventory?.isNotEmpty == true
-        ? fbBuilder.writeListUint8(_inventory)
-        : null;
-    final int testOffset = _test?.getOrCreateOffset(fbBuilder);
-    final int test4Offset = _test4?.isNotEmpty == true
-        ? fbBuilder.writeListOfStructs(_test4)
-        : null;
-    final int testarrayofstringOffset = _testarrayofstring?.isNotEmpty == true
-        ? fbBuilder.writeList(_testarrayofstring.map((b) => fbBuilder.writeString(b)).toList())
-        : null;
-    final int testarrayoftablesOffset = _testarrayoftables?.isNotEmpty == true
-        ? fbBuilder.writeList(_testarrayoftables.map((b) => b.getOrCreateOffset(fbBuilder)).toList())
-        : null;
-    final int enemyOffset = _enemy?.getOrCreateOffset(fbBuilder);
-    final int testnestedflatbufferOffset = _testnestedflatbuffer?.isNotEmpty == true
-        ? fbBuilder.writeListUint8(_testnestedflatbuffer)
-        : null;
-    final int testemptyOffset = _testempty?.getOrCreateOffset(fbBuilder);
-    final int testarrayofboolsOffset = _testarrayofbools?.isNotEmpty == true
-        ? fbBuilder.writeListBool(_testarrayofbools)
-        : null;
-    final int testarrayofstring2Offset = _testarrayofstring2?.isNotEmpty == true
-        ? fbBuilder.writeList(_testarrayofstring2.map((b) => fbBuilder.writeString(b)).toList())
-        : null;
-    final int testarrayofsortedstructOffset = _testarrayofsortedstruct?.isNotEmpty == true
-        ? fbBuilder.writeListOfStructs(_testarrayofsortedstruct)
-        : null;
-    final int flexOffset = _flex?.isNotEmpty == true
-        ? fbBuilder.writeListUint8(_flex)
-        : null;
-    final int test5Offset = _test5?.isNotEmpty == true
-        ? fbBuilder.writeListOfStructs(_test5)
-        : null;
-    final int vectorOfLongsOffset = _vectorOfLongs?.isNotEmpty == true
-        ? fbBuilder.writeListInt64(_vectorOfLongs)
-        : null;
-    final int vectorOfDoublesOffset = _vectorOfDoubles?.isNotEmpty == true
-        ? fbBuilder.writeListFloat64(_vectorOfDoubles)
-        : null;
-    final int parentNamespaceTestOffset = _parentNamespaceTest?.getOrCreateOffset(fbBuilder);
-    final int vectorOfReferrablesOffset = _vectorOfReferrables?.isNotEmpty == true
-        ? fbBuilder.writeList(_vectorOfReferrables.map((b) => b.getOrCreateOffset(fbBuilder)).toList())
-        : null;
-    final int vectorOfWeakReferencesOffset = _vectorOfWeakReferences?.isNotEmpty == true
-        ? fbBuilder.writeListUint64(_vectorOfWeakReferences)
-        : null;
-    final int vectorOfStrongReferrablesOffset = _vectorOfStrongReferrables?.isNotEmpty == true
-        ? fbBuilder.writeList(_vectorOfStrongReferrables.map((b) => b.getOrCreateOffset(fbBuilder)).toList())
-        : null;
-    final int vectorOfCoOwningReferencesOffset = _vectorOfCoOwningReferences?.isNotEmpty == true
-        ? fbBuilder.writeListUint64(_vectorOfCoOwningReferences)
-        : null;
-    final int vectorOfNonOwningReferencesOffset = _vectorOfNonOwningReferences?.isNotEmpty == true
-        ? fbBuilder.writeListUint64(_vectorOfNonOwningReferences)
-        : null;
-    final int anyUniqueOffset = _anyUnique?.getOrCreateOffset(fbBuilder);
-    final int anyAmbiguousOffset = _anyAmbiguous?.getOrCreateOffset(fbBuilder);
-    final int vectorOfEnumsOffset = _vectorOfEnums?.isNotEmpty == true
-        ? fbBuilder.writeListUint8(_vectorOfEnums.map((f) => f.value))
-        : null;
-    final int testrequirednestedflatbufferOffset = _testrequirednestedflatbuffer?.isNotEmpty == true
-        ? fbBuilder.writeListUint8(_testrequirednestedflatbuffer)
-        : null;
-    final int scalarKeySortedTablesOffset = _scalarKeySortedTables?.isNotEmpty == true
-        ? fbBuilder.writeList(_scalarKeySortedTables.map((b) => b.getOrCreateOffset(fbBuilder)).toList())
-        : null;
-
-    fbBuilder.startTable();
+  int finish(fb.Builder fbBuilder) {
+    final int? nameOffset = _name == null ? null
+        : fbBuilder.writeString(_name!);
+    final int? inventoryOffset = _inventory == null ? null
+        : fbBuilder.writeListUint8(_inventory!);
+    final int? testOffset = _test?.getOrCreateOffset(fbBuilder);
+    final int? test4Offset = _test4 == null ? null
+        : fbBuilder.writeListOfStructs(_test4!);
+    final int? testarrayofstringOffset = _testarrayofstring == null ? null
+        : fbBuilder.writeList(_testarrayofstring!.map(fbBuilder.writeString).toList());
+    final int? testarrayoftablesOffset = _testarrayoftables == null ? null
+        : fbBuilder.writeList(_testarrayoftables!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
+    final int? enemyOffset = _enemy?.getOrCreateOffset(fbBuilder);
+    final int? testnestedflatbufferOffset = _testnestedflatbuffer == null ? null
+        : fbBuilder.writeListUint8(_testnestedflatbuffer!);
+    final int? testemptyOffset = _testempty?.getOrCreateOffset(fbBuilder);
+    final int? testarrayofboolsOffset = _testarrayofbools == null ? null
+        : fbBuilder.writeListBool(_testarrayofbools!);
+    final int? testarrayofstring2Offset = _testarrayofstring2 == null ? null
+        : fbBuilder.writeList(_testarrayofstring2!.map(fbBuilder.writeString).toList());
+    final int? testarrayofsortedstructOffset = _testarrayofsortedstruct == null ? null
+        : fbBuilder.writeListOfStructs(_testarrayofsortedstruct!);
+    final int? flexOffset = _flex == null ? null
+        : fbBuilder.writeListUint8(_flex!);
+    final int? test5Offset = _test5 == null ? null
+        : fbBuilder.writeListOfStructs(_test5!);
+    final int? vectorOfLongsOffset = _vectorOfLongs == null ? null
+        : fbBuilder.writeListInt64(_vectorOfLongs!);
+    final int? vectorOfDoublesOffset = _vectorOfDoubles == null ? null
+        : fbBuilder.writeListFloat64(_vectorOfDoubles!);
+    final int? parentNamespaceTestOffset = _parentNamespaceTest?.getOrCreateOffset(fbBuilder);
+    final int? vectorOfReferrablesOffset = _vectorOfReferrables == null ? null
+        : fbBuilder.writeList(_vectorOfReferrables!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
+    final int? vectorOfWeakReferencesOffset = _vectorOfWeakReferences == null ? null
+        : fbBuilder.writeListUint64(_vectorOfWeakReferences!);
+    final int? vectorOfStrongReferrablesOffset = _vectorOfStrongReferrables == null ? null
+        : fbBuilder.writeList(_vectorOfStrongReferrables!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
+    final int? vectorOfCoOwningReferencesOffset = _vectorOfCoOwningReferences == null ? null
+        : fbBuilder.writeListUint64(_vectorOfCoOwningReferences!);
+    final int? vectorOfNonOwningReferencesOffset = _vectorOfNonOwningReferences == null ? null
+        : fbBuilder.writeListUint64(_vectorOfNonOwningReferences!);
+    final int? anyUniqueOffset = _anyUnique?.getOrCreateOffset(fbBuilder);
+    final int? anyAmbiguousOffset = _anyAmbiguous?.getOrCreateOffset(fbBuilder);
+    final int? vectorOfEnumsOffset = _vectorOfEnums == null ? null
+        : fbBuilder.writeListUint8(_vectorOfEnums!.map((f) => f.value).toList());
+    final int? testrequirednestedflatbufferOffset = _testrequirednestedflatbuffer == null ? null
+        : fbBuilder.writeListUint8(_testrequirednestedflatbuffer!);
+    final int? scalarKeySortedTablesOffset = _scalarKeySortedTables == null ? null
+        : fbBuilder.writeList(_scalarKeySortedTables!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
+    fbBuilder.startTable(50);
     if (_pos != null) {
-      fbBuilder.addStruct(0, _pos.finish(fbBuilder));
+      fbBuilder.addStruct(0, _pos!.finish(fbBuilder));
     }
     fbBuilder.addInt16(1, _mana);
     fbBuilder.addInt16(2, _hp);
-    if (nameOffset != null) {
-      fbBuilder.addOffset(3, nameOffset);
-    }
-    if (inventoryOffset != null) {
-      fbBuilder.addOffset(5, inventoryOffset);
-    }
+    fbBuilder.addOffset(3, nameOffset);
+    fbBuilder.addOffset(5, inventoryOffset);
     fbBuilder.addUint8(6, _color?.value);
     fbBuilder.addUint8(7, _testType?.value);
-    if (testOffset != null) {
-      fbBuilder.addOffset(8, testOffset);
-    }
-    if (test4Offset != null) {
-      fbBuilder.addOffset(9, test4Offset);
-    }
-    if (testarrayofstringOffset != null) {
-      fbBuilder.addOffset(10, testarrayofstringOffset);
-    }
-    if (testarrayoftablesOffset != null) {
-      fbBuilder.addOffset(11, testarrayoftablesOffset);
-    }
-    if (enemyOffset != null) {
-      fbBuilder.addOffset(12, enemyOffset);
-    }
-    if (testnestedflatbufferOffset != null) {
-      fbBuilder.addOffset(13, testnestedflatbufferOffset);
-    }
-    if (testemptyOffset != null) {
-      fbBuilder.addOffset(14, testemptyOffset);
-    }
+    fbBuilder.addOffset(8, testOffset);
+    fbBuilder.addOffset(9, test4Offset);
+    fbBuilder.addOffset(10, testarrayofstringOffset);
+    fbBuilder.addOffset(11, testarrayoftablesOffset);
+    fbBuilder.addOffset(12, enemyOffset);
+    fbBuilder.addOffset(13, testnestedflatbufferOffset);
+    fbBuilder.addOffset(14, testemptyOffset);
     fbBuilder.addBool(15, _testbool);
     fbBuilder.addInt32(16, _testhashs32Fnv1);
     fbBuilder.addUint32(17, _testhashu32Fnv1);
@@ -1386,88 +1862,52 @@
     fbBuilder.addUint32(21, _testhashu32Fnv1a);
     fbBuilder.addInt64(22, _testhashs64Fnv1a);
     fbBuilder.addUint64(23, _testhashu64Fnv1a);
-    if (testarrayofboolsOffset != null) {
-      fbBuilder.addOffset(24, testarrayofboolsOffset);
-    }
+    fbBuilder.addOffset(24, testarrayofboolsOffset);
     fbBuilder.addFloat32(25, _testf);
     fbBuilder.addFloat32(26, _testf2);
     fbBuilder.addFloat32(27, _testf3);
-    if (testarrayofstring2Offset != null) {
-      fbBuilder.addOffset(28, testarrayofstring2Offset);
-    }
-    if (testarrayofsortedstructOffset != null) {
-      fbBuilder.addOffset(29, testarrayofsortedstructOffset);
-    }
-    if (flexOffset != null) {
-      fbBuilder.addOffset(30, flexOffset);
-    }
-    if (test5Offset != null) {
-      fbBuilder.addOffset(31, test5Offset);
-    }
-    if (vectorOfLongsOffset != null) {
-      fbBuilder.addOffset(32, vectorOfLongsOffset);
-    }
-    if (vectorOfDoublesOffset != null) {
-      fbBuilder.addOffset(33, vectorOfDoublesOffset);
-    }
-    if (parentNamespaceTestOffset != null) {
-      fbBuilder.addOffset(34, parentNamespaceTestOffset);
-    }
-    if (vectorOfReferrablesOffset != null) {
-      fbBuilder.addOffset(35, vectorOfReferrablesOffset);
-    }
+    fbBuilder.addOffset(28, testarrayofstring2Offset);
+    fbBuilder.addOffset(29, testarrayofsortedstructOffset);
+    fbBuilder.addOffset(30, flexOffset);
+    fbBuilder.addOffset(31, test5Offset);
+    fbBuilder.addOffset(32, vectorOfLongsOffset);
+    fbBuilder.addOffset(33, vectorOfDoublesOffset);
+    fbBuilder.addOffset(34, parentNamespaceTestOffset);
+    fbBuilder.addOffset(35, vectorOfReferrablesOffset);
     fbBuilder.addUint64(36, _singleWeakReference);
-    if (vectorOfWeakReferencesOffset != null) {
-      fbBuilder.addOffset(37, vectorOfWeakReferencesOffset);
-    }
-    if (vectorOfStrongReferrablesOffset != null) {
-      fbBuilder.addOffset(38, vectorOfStrongReferrablesOffset);
-    }
+    fbBuilder.addOffset(37, vectorOfWeakReferencesOffset);
+    fbBuilder.addOffset(38, vectorOfStrongReferrablesOffset);
     fbBuilder.addUint64(39, _coOwningReference);
-    if (vectorOfCoOwningReferencesOffset != null) {
-      fbBuilder.addOffset(40, vectorOfCoOwningReferencesOffset);
-    }
+    fbBuilder.addOffset(40, vectorOfCoOwningReferencesOffset);
     fbBuilder.addUint64(41, _nonOwningReference);
-    if (vectorOfNonOwningReferencesOffset != null) {
-      fbBuilder.addOffset(42, vectorOfNonOwningReferencesOffset);
-    }
+    fbBuilder.addOffset(42, vectorOfNonOwningReferencesOffset);
     fbBuilder.addUint8(43, _anyUniqueType?.value);
-    if (anyUniqueOffset != null) {
-      fbBuilder.addOffset(44, anyUniqueOffset);
-    }
+    fbBuilder.addOffset(44, anyUniqueOffset);
     fbBuilder.addUint8(45, _anyAmbiguousType?.value);
-    if (anyAmbiguousOffset != null) {
-      fbBuilder.addOffset(46, anyAmbiguousOffset);
-    }
-    if (vectorOfEnumsOffset != null) {
-      fbBuilder.addOffset(47, vectorOfEnumsOffset);
-    }
+    fbBuilder.addOffset(46, anyAmbiguousOffset);
+    fbBuilder.addOffset(47, vectorOfEnumsOffset);
     fbBuilder.addInt8(48, _signedEnum?.value);
-    if (testrequirednestedflatbufferOffset != null) {
-      fbBuilder.addOffset(49, testrequirednestedflatbufferOffset);
-    }
-    if (scalarKeySortedTablesOffset != null) {
-      fbBuilder.addOffset(50, scalarKeySortedTablesOffset);
-    }
+    fbBuilder.addOffset(49, testrequirednestedflatbufferOffset);
+    fbBuilder.addOffset(50, scalarKeySortedTablesOffset);
     return fbBuilder.endTable();
   }
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
 class TypeAliases {
   TypeAliases._(this._bc, this._bcOffset);
   factory TypeAliases(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<TypeAliases> reader = const _TypeAliasesReader();
+  static const fb.Reader<TypeAliases> reader = _TypeAliasesReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -1482,13 +1922,88 @@
   int get u64 => const fb.Uint64Reader().vTableGet(_bc, _bcOffset, 18, 0);
   double get f32 => const fb.Float32Reader().vTableGet(_bc, _bcOffset, 20, 0.0);
   double get f64 => const fb.Float64Reader().vTableGet(_bc, _bcOffset, 22, 0.0);
-  List<int> get v8 => const fb.ListReader<int>(const fb.Int8Reader()).vTableGet(_bc, _bcOffset, 24, null);
-  List<double> get vf64 => const fb.ListReader<double>(const fb.Float64Reader()).vTableGet(_bc, _bcOffset, 26, null);
+  List<int>? get v8 => const fb.Int8ListReader().vTableGetNullable(_bc, _bcOffset, 24);
+  List<double>? get vf64 => const fb.ListReader<double>(fb.Float64Reader()).vTableGetNullable(_bc, _bcOffset, 26);
 
   @override
   String toString() {
     return 'TypeAliases{i8: $i8, u8: $u8, i16: $i16, u16: $u16, i32: $i32, u32: $u32, i64: $i64, u64: $u64, f32: $f32, f64: $f64, v8: $v8, vf64: $vf64}';
   }
+
+  TypeAliasesT unpack() => TypeAliasesT(
+      i8: i8,
+      u8: u8,
+      i16: i16,
+      u16: u16,
+      i32: i32,
+      u32: u32,
+      i64: i64,
+      u64: u64,
+      f32: f32,
+      f64: f64,
+      v8: const fb.Int8ListReader(lazy: false).vTableGetNullable(_bc, _bcOffset, 24),
+      vf64: const fb.ListReader<double>(fb.Float64Reader(), lazy: false).vTableGetNullable(_bc, _bcOffset, 26));
+
+  static int pack(fb.Builder fbBuilder, TypeAliasesT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class TypeAliasesT implements fb.Packable {
+  int i8;
+  int u8;
+  int i16;
+  int u16;
+  int i32;
+  int u32;
+  int i64;
+  int u64;
+  double f32;
+  double f64;
+  List<int>? v8;
+  List<double>? vf64;
+
+  TypeAliasesT({
+      this.i8 = 0,
+      this.u8 = 0,
+      this.i16 = 0,
+      this.u16 = 0,
+      this.i32 = 0,
+      this.u32 = 0,
+      this.i64 = 0,
+      this.u64 = 0,
+      this.f32 = 0.0,
+      this.f64 = 0.0,
+      this.v8,
+      this.vf64});
+
+  @override
+  int pack(fb.Builder fbBuilder) {
+    final int? v8Offset = v8 == null ? null
+        : fbBuilder.writeListInt8(v8!);
+    final int? vf64Offset = vf64 == null ? null
+        : fbBuilder.writeListFloat64(vf64!);
+    fbBuilder.startTable(12);
+    fbBuilder.addInt8(0, i8);
+    fbBuilder.addUint8(1, u8);
+    fbBuilder.addInt16(2, i16);
+    fbBuilder.addUint16(3, u16);
+    fbBuilder.addInt32(4, i32);
+    fbBuilder.addUint32(5, u32);
+    fbBuilder.addInt64(6, i64);
+    fbBuilder.addUint64(7, u64);
+    fbBuilder.addFloat32(8, f32);
+    fbBuilder.addFloat64(9, f64);
+    fbBuilder.addOffset(10, v8Offset);
+    fbBuilder.addOffset(11, vf64Offset);
+    return fbBuilder.endTable();
+  }
+
+  @override
+  String toString() {
+    return 'TypeAliasesT{i8: $i8, u8: $u8, i16: $i16, u16: $u16, i32: $i32, u32: $u32, i64: $i64, u64: $u64, f32: $f32, f64: $f64, v8: $v8, vf64: $vf64}';
+  }
 }
 
 class _TypeAliasesReader extends fb.TableReader<TypeAliases> {
@@ -1496,65 +2011,63 @@
 
   @override
   TypeAliases createObject(fb.BufferContext bc, int offset) => 
-    new TypeAliases._(bc, offset);
+    TypeAliases._(bc, offset);
 }
 
 class TypeAliasesBuilder {
-  TypeAliasesBuilder(this.fbBuilder) {
-    assert(fbBuilder != null);
-  }
+  TypeAliasesBuilder(this.fbBuilder);
 
   final fb.Builder fbBuilder;
 
   void begin() {
-    fbBuilder.startTable();
+    fbBuilder.startTable(12);
   }
 
-  int addI8(int i8) {
+  int addI8(int? i8) {
     fbBuilder.addInt8(0, i8);
     return fbBuilder.offset;
   }
-  int addU8(int u8) {
+  int addU8(int? u8) {
     fbBuilder.addUint8(1, u8);
     return fbBuilder.offset;
   }
-  int addI16(int i16) {
+  int addI16(int? i16) {
     fbBuilder.addInt16(2, i16);
     return fbBuilder.offset;
   }
-  int addU16(int u16) {
+  int addU16(int? u16) {
     fbBuilder.addUint16(3, u16);
     return fbBuilder.offset;
   }
-  int addI32(int i32) {
+  int addI32(int? i32) {
     fbBuilder.addInt32(4, i32);
     return fbBuilder.offset;
   }
-  int addU32(int u32) {
+  int addU32(int? u32) {
     fbBuilder.addUint32(5, u32);
     return fbBuilder.offset;
   }
-  int addI64(int i64) {
+  int addI64(int? i64) {
     fbBuilder.addInt64(6, i64);
     return fbBuilder.offset;
   }
-  int addU64(int u64) {
+  int addU64(int? u64) {
     fbBuilder.addUint64(7, u64);
     return fbBuilder.offset;
   }
-  int addF32(double f32) {
+  int addF32(double? f32) {
     fbBuilder.addFloat32(8, f32);
     return fbBuilder.offset;
   }
-  int addF64(double f64) {
+  int addF64(double? f64) {
     fbBuilder.addFloat64(9, f64);
     return fbBuilder.offset;
   }
-  int addV8Offset(int offset) {
+  int addV8Offset(int? offset) {
     fbBuilder.addOffset(10, offset);
     return fbBuilder.offset;
   }
-  int addVf64Offset(int offset) {
+  int addVf64Offset(int? offset) {
     fbBuilder.addOffset(11, offset);
     return fbBuilder.offset;
   }
@@ -1565,32 +2078,32 @@
 }
 
 class TypeAliasesObjectBuilder extends fb.ObjectBuilder {
-  final int _i8;
-  final int _u8;
-  final int _i16;
-  final int _u16;
-  final int _i32;
-  final int _u32;
-  final int _i64;
-  final int _u64;
-  final double _f32;
-  final double _f64;
-  final List<int> _v8;
-  final List<double> _vf64;
+  final int? _i8;
+  final int? _u8;
+  final int? _i16;
+  final int? _u16;
+  final int? _i32;
+  final int? _u32;
+  final int? _i64;
+  final int? _u64;
+  final double? _f32;
+  final double? _f64;
+  final List<int>? _v8;
+  final List<double>? _vf64;
 
   TypeAliasesObjectBuilder({
-    int i8,
-    int u8,
-    int i16,
-    int u16,
-    int i32,
-    int u32,
-    int i64,
-    int u64,
-    double f32,
-    double f64,
-    List<int> v8,
-    List<double> vf64,
+    int? i8,
+    int? u8,
+    int? i16,
+    int? u16,
+    int? i32,
+    int? u32,
+    int? i64,
+    int? u64,
+    double? f32,
+    double? f64,
+    List<int>? v8,
+    List<double>? vf64,
   })
       : _i8 = i8,
         _u8 = u8,
@@ -1607,17 +2120,12 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-    final int v8Offset = _v8?.isNotEmpty == true
-        ? fbBuilder.writeListInt8(_v8)
-        : null;
-    final int vf64Offset = _vf64?.isNotEmpty == true
-        ? fbBuilder.writeListFloat64(_vf64)
-        : null;
-
-    fbBuilder.startTable();
+  int finish(fb.Builder fbBuilder) {
+    final int? v8Offset = _v8 == null ? null
+        : fbBuilder.writeListInt8(_v8!);
+    final int? vf64Offset = _vf64 == null ? null
+        : fbBuilder.writeListFloat64(_vf64!);
+    fbBuilder.startTable(12);
     fbBuilder.addInt8(0, _i8);
     fbBuilder.addUint8(1, _u8);
     fbBuilder.addInt16(2, _i16);
@@ -1628,20 +2136,16 @@
     fbBuilder.addUint64(7, _u64);
     fbBuilder.addFloat32(8, _f32);
     fbBuilder.addFloat64(9, _f64);
-    if (v8Offset != null) {
-      fbBuilder.addOffset(10, v8Offset);
-    }
-    if (vf64Offset != null) {
-      fbBuilder.addOffset(11, vf64Offset);
-    }
+    fbBuilder.addOffset(10, v8Offset);
+    fbBuilder.addOffset(11, vf64Offset);
     return fbBuilder.endTable();
   }
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
diff -urN a/dart/test/monster_test_my_game_generated.dart b/dart/test/monster_test_my_game_generated.dart
--- a/dart/test/monster_test_my_game_generated.dart	2021-05-10 18:45:16.000000000 +0000
+++ b/dart/test/monster_test_my_game_generated.dart	2023-01-13 07:47:12.571286153 +0000
@@ -1,5 +1,5 @@
 // automatically generated by the FlatBuffers compiler, do not modify
-// ignore_for_file: unused_import, unused_field, unused_local_variable
+// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable
 
 library my_game;
 
@@ -12,11 +12,11 @@
 class InParentNamespace {
   InParentNamespace._(this._bc, this._bcOffset);
   factory InParentNamespace(List<int> bytes) {
-    fb.BufferContext rootRef = new fb.BufferContext.fromBytes(bytes);
+    final rootRef = fb.BufferContext.fromBytes(bytes);
     return reader.read(rootRef, 0);
   }
 
-  static const fb.Reader<InParentNamespace> reader = const _InParentNamespaceReader();
+  static const fb.Reader<InParentNamespace> reader = _InParentNamespaceReader();
 
   final fb.BufferContext _bc;
   final int _bcOffset;
@@ -26,6 +26,26 @@
   String toString() {
     return 'InParentNamespace{}';
   }
+
+  InParentNamespaceT unpack() => InParentNamespaceT();
+
+  static int pack(fb.Builder fbBuilder, InParentNamespaceT? object) {
+    if (object == null) return 0;
+    return object.pack(fbBuilder);
+  }
+}
+
+class InParentNamespaceT implements fb.Packable {
+  @override
+  int pack(fb.Builder fbBuilder) {
+    fbBuilder.startTable(0);
+    return fbBuilder.endTable();
+  }
+
+  @override
+  String toString() {
+    return 'InParentNamespaceT{}';
+  }
 }
 
 class _InParentNamespaceReader extends fb.TableReader<InParentNamespace> {
@@ -33,7 +53,7 @@
 
   @override
   InParentNamespace createObject(fb.BufferContext bc, int offset) => 
-    new InParentNamespace._(bc, offset);
+    InParentNamespace._(bc, offset);
 }
 
 class InParentNamespaceObjectBuilder extends fb.ObjectBuilder {
@@ -42,19 +62,16 @@
 
   /// Finish building, and store into the [fbBuilder].
   @override
-  int finish(
-    fb.Builder fbBuilder) {
-    assert(fbBuilder != null);
-
-    fbBuilder.startTable();
+  int finish(fb.Builder fbBuilder) {
+    fbBuilder.startTable(0);
     return fbBuilder.endTable();
   }
 
   /// Convenience method to serialize to byte list.
   @override
-  Uint8List toBytes([String fileIdentifier]) {
-    fb.Builder fbBuilder = new fb.Builder();
-    int offset = finish(fbBuilder);
-    return fbBuilder.finish(offset, fileIdentifier);
+  Uint8List toBytes([String? fileIdentifier]) {
+    final fbBuilder = fb.Builder(deduplicateTables: false);
+    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
+    return fbBuilder.buffer;
   }
 }
Binary files a/dart/test/monsterdata_test.mon and b/dart/test/monsterdata_test.mon differ
diff -urN a/grpc/README.md b/grpc/README.md
--- a/grpc/README.md	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/README.md	2023-01-13 07:46:49.749075383 +0000
@@ -32,9 +32,8 @@
 
 ### Linux
 
-1. `ln -s ${GRPC_INSTALL_PATH}/lib/libgrpc++_unsecure.so.6 ${GRPC_INSTALL_PATH}/lib/libgrpc++_unsecure.so.1`
-2. `export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${GRPC_INSTALL_PATH}/lib`
-3. `make test ARGS=-V` 
+1. `export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:${GRPC_INSTALL_PATH}/lib`
+2. `make test ARGS=-V`
 
 For Bazel users:
 
diff -urN a/grpc/build_grpc.sh b/grpc/build_grpc.sh
--- a/grpc/build_grpc.sh	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/build_grpc.sh	2023-01-13 07:46:49.750075393 +0000
@@ -1,11 +1,11 @@
 #!/bin/bash
 
-grpc_1_36_0_githash=736e3758351ced3cd842bad3ba4e2540f01bbc48
+grpc_1_39_0_githash=58602e20a3f3e48f24a4114c757099b25b947f7b
 
 function build_grpc () {
   git clone https://github.com/grpc/grpc.git google/grpc
   cd google/grpc
-  git checkout ${grpc_1_36_0_githash}
+  git checkout ${grpc_1_39_0_githash}
   git submodule update --init
   # Apply boringssl build patch
   cd third_party/boringssl-with-bazel
@@ -13,11 +13,8 @@
   cd ../..
   mkdir ../grpc_build
   cd ../grpc_build
-  cmake ../grpc -DgRPC_INSTALL=ON -DgRPC_BUILD_TESTS=OFF -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=`pwd`/../grpc/install
+  cmake ../grpc -DgRPC_INSTALL=ON -DgRPC_BUILD_TESTS=OFF -DABSL_ENABLE_INSTALL=ON -DBUILD_SHARED_LIBS=ON -DCMAKE_INSTALL_PREFIX=`pwd`/../grpc/install
   cmake --build . --target install ${JOBS:+-j$JOBS}
-  if [ ! -f ${GRPC_INSTALL_PATH}/lib/libgrpc++_unsecure.so.1 ]; then
-    ln -s ${GRPC_INSTALL_PATH}/lib/libgrpc++_unsecure.so.6 ${GRPC_INSTALL_PATH}/lib/libgrpc++_unsecure.so.1
-  fi
   cd ../..
 }
 
diff -urN a/grpc/examples/generate.sh b/grpc/examples/generate.sh
--- a/grpc/examples/generate.sh	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/generate.sh	2023-01-13 07:46:51.179088589 +0000
@@ -41,7 +41,7 @@
 cd go
 
 cd greeter
-fbc --go ${generator}
+fbc --bfbs-filenames ../.. --go ${generator}
 
 cd ${current_dir}
 
@@ -50,7 +50,7 @@
 
 cd greeter
 
-fbc --python ${generator}
+fbc --bfbs-filenames ../.. --python ${generator}
 
 cd ${current_dir}
 
@@ -58,7 +58,7 @@
 cd swift
 
 cd Greeter/Sources/Model
-fbc --swift ${generator}
+fbc --bfbs-filenames ../../../.. --swift --gen-json-emit ${generator}
 
 cd ${current_dir}
 
@@ -66,6 +66,6 @@
 cd ts
 
 cd greeter/src
-fbc --ts ${generator}
+fbc --bfbs-filenames ../../.. --ts ${generator}
 
 cd ${current_dir}
diff -urN a/grpc/examples/go/greeter/server/go.mod b/grpc/examples/go/greeter/server/go.mod
--- a/grpc/examples/go/greeter/server/go.mod	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/go/greeter/server/go.mod	2023-01-13 07:46:51.829094592 +0000
@@ -7,5 +7,5 @@
 require (
 	github.com/google/flatbuffers v1.12.0
 	github.com/google/flatbuffers/grpc/examples/go/greeter/models v0.0.0
-	google.golang.org/grpc v1.35.0
+	google.golang.org/grpc v1.39.0-dev
 )
diff -urN a/grpc/examples/go/greeter/server/main.go b/grpc/examples/go/greeter/server/main.go
--- a/grpc/examples/go/greeter/server/main.go	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/go/greeter/server/main.go	2023-01-13 07:46:51.905095294 +0000
@@ -9,7 +9,6 @@
 	flatbuffers "github.com/google/flatbuffers/go"
 	models "github.com/google/flatbuffers/grpc/examples/go/greeter/models"
 	"google.golang.org/grpc"
-	"google.golang.org/grpc/encoding"
 )
 
 var (
@@ -68,8 +67,8 @@
 	if err != nil {
 		log.Fatalf("failed to listen: %v", err)
 	}
-	grpcServer := grpc.NewServer()
-	encoding.RegisterCodec(flatbuffers.FlatbuffersCodec{})
+	codec := &flatbuffers.FlatbuffersCodec{}
+	grpcServer := grpc.NewServer(grpc.ForceServerCodec(codec))
 	models.RegisterGreeterServer(grpcServer, newServer())
 	if err := grpcServer.Serve(lis); err != nil {
 		fmt.Print(err)
diff -urN a/grpc/examples/python/greeter/models/HelloReply.py b/grpc/examples/python/greeter/models/HelloReply.py
--- a/grpc/examples/python/greeter/models/HelloReply.py	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/python/greeter/models/HelloReply.py	2023-01-13 07:46:52.184097871 +0000
@@ -31,15 +31,12 @@
             return self._tab.String(o + self._tab.Pos)
         return None
 
-def Start(builder): builder.StartObject(1)
-def HelloReplyStart(builder):
-    """This method is deprecated. Please switch to Start."""
-    return Start(builder)
-def AddMessage(builder, message): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(message), 0)
-def HelloReplyAddMessage(builder, message):
-    """This method is deprecated. Please switch to AddMessage."""
-    return AddMessage(builder, message)
-def End(builder): return builder.EndObject()
-def HelloReplyEnd(builder):
-    """This method is deprecated. Please switch to End."""
-    return End(builder)
\ No newline at end of file
+def HelloReplyStart(builder): builder.StartObject(1)
+def Start(builder):
+    return HelloReplyStart(builder)
+def HelloReplyAddMessage(builder, message): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(message), 0)
+def AddMessage(builder, message):
+    return HelloReplyAddMessage(builder, message)
+def HelloReplyEnd(builder): return builder.EndObject()
+def End(builder):
+    return HelloReplyEnd(builder)
\ No newline at end of file
diff -urN a/grpc/examples/python/greeter/models/HelloRequest.py b/grpc/examples/python/greeter/models/HelloRequest.py
--- a/grpc/examples/python/greeter/models/HelloRequest.py	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/python/greeter/models/HelloRequest.py	2023-01-13 07:46:52.184097871 +0000
@@ -31,15 +31,12 @@
             return self._tab.String(o + self._tab.Pos)
         return None
 
-def Start(builder): builder.StartObject(1)
-def HelloRequestStart(builder):
-    """This method is deprecated. Please switch to Start."""
-    return Start(builder)
-def AddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
-def HelloRequestAddName(builder, name):
-    """This method is deprecated. Please switch to AddName."""
-    return AddName(builder, name)
-def End(builder): return builder.EndObject()
-def HelloRequestEnd(builder):
-    """This method is deprecated. Please switch to End."""
-    return End(builder)
\ No newline at end of file
+def HelloRequestStart(builder): builder.StartObject(1)
+def Start(builder):
+    return HelloRequestStart(builder)
+def HelloRequestAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
+def AddName(builder, name):
+    return HelloRequestAddName(builder, name)
+def HelloRequestEnd(builder): return builder.EndObject()
+def End(builder):
+    return HelloRequestEnd(builder)
\ No newline at end of file
diff -urN a/grpc/examples/swift/Greeter/Sources/Model/greeter_generated.swift b/grpc/examples/swift/Greeter/Sources/Model/greeter_generated.swift
--- a/grpc/examples/swift/Greeter/Sources/Model/greeter_generated.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/swift/Greeter/Sources/Model/greeter_generated.swift	2023-01-13 07:46:52.175097788 +0000
@@ -4,7 +4,7 @@
 
 import FlatBuffers
 
-public struct models_HelloReply: FlatBufferObject {
+public struct models_HelloReply: FlatBufferObject, Verifiable {
 
   static func validateVersion() { FlatBuffersVersion_2_0_0() }
   public var __buffer: ByteBuffer! { return _accessor.bb }
@@ -34,9 +34,26 @@
     models_HelloReply.add(message: message, &fbb)
     return models_HelloReply.endHelloReply(&fbb, start: __start)
   }
+
+  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
+    var _v = try verifier.visitTable(at: position)
+    try _v.visit(field: VTOFFSET.message.p, fieldName: "message", required: false, type: ForwardOffset<String>.self)
+    _v.finish()
+  }
+}
+
+extension models_HelloReply: Encodable {
+
+  enum CodingKeys: String, CodingKey {
+    case message = "message"
+  }
+  public func encode(to encoder: Encoder) throws {
+    var container = encoder.container(keyedBy: CodingKeys.self)
+    try container.encodeIfPresent(message, forKey: .message)
+  }
 }
 
-public struct models_HelloRequest: FlatBufferObject {
+public struct models_HelloRequest: FlatBufferObject, Verifiable {
 
   static func validateVersion() { FlatBuffersVersion_2_0_0() }
   public var __buffer: ByteBuffer! { return _accessor.bb }
@@ -66,5 +83,22 @@
     models_HelloRequest.add(name: name, &fbb)
     return models_HelloRequest.endHelloRequest(&fbb, start: __start)
   }
+
+  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
+    var _v = try verifier.visitTable(at: position)
+    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
+    _v.finish()
+  }
+}
+
+extension models_HelloRequest: Encodable {
+
+  enum CodingKeys: String, CodingKey {
+    case name = "name"
+  }
+  public func encode(to encoder: Encoder) throws {
+    var container = encoder.container(keyedBy: CodingKeys.self)
+    try container.encodeIfPresent(name, forKey: .name)
+  }
 }
 
diff -urN a/grpc/examples/swift/Greeter/Sources/client/main.swift b/grpc/examples/swift/Greeter/Sources/client/main.swift
--- a/grpc/examples/swift/Greeter/Sources/client/main.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/swift/Greeter/Sources/client/main.swift	2023-01-13 07:46:52.182097852 +0000
@@ -37,7 +37,8 @@
   builder.finish(offset: root)
 
   // Make the RPC call to the server.
-  let sayHello = greeter.SayHello(Message<models_HelloRequest>(builder: &builder))
+  let sayHello = greeter
+    .SayHello(Message<models_HelloRequest>(builder: &builder))
 
   // wait() on the response to stop the program from exiting before the response is received.
   do {
@@ -54,7 +55,8 @@
   builder.finish(offset: manyRoot)
 
   let call = greeter.SayManyHellos(Message(builder: &builder)) { message in
-    print("Greeter SayManyHellos received: \(message.object.message  ?? "Unknown")")
+    print(
+      "Greeter SayManyHellos received: \(message.object.message  ?? "Unknown")")
   }
 
   let status = try! call.status.recover { _ in .processingError }.wait()
diff -urN a/grpc/examples/swift/Greeter/Sources/server/main.swift b/grpc/examples/swift/Greeter/Sources/server/main.swift
--- a/grpc/examples/swift/Greeter/Sources/server/main.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/swift/Greeter/Sources/server/main.swift	2023-01-13 07:46:52.183097861 +0000
@@ -32,7 +32,8 @@
 
   func SayHello(
     request: Message<models_HelloRequest>,
-    context: StatusOnlyCallContext) -> EventLoopFuture<Message<models_HelloReply>>
+    context: StatusOnlyCallContext)
+    -> EventLoopFuture<Message<models_HelloReply>>
   {
     let recipient = request.object.name ?? "Stranger"
 
@@ -40,17 +41,22 @@
     let off = builder.create(string: "Hello \(recipient)")
     let root = models_HelloReply.createHelloReply(&builder, messageOffset: off)
     builder.finish(offset: root)
-    return context.eventLoop.makeSucceededFuture(Message<models_HelloReply>(builder: &builder))
+    return context.eventLoop
+      .makeSucceededFuture(Message<models_HelloReply>(builder: &builder))
   }
 
   func SayManyHellos(
     request: Message<models_HelloRequest>,
-    context: StreamingResponseCallContext<Message<models_HelloReply>>) -> EventLoopFuture<GRPCStatus>
+    context: StreamingResponseCallContext<Message<models_HelloReply>>)
+    -> EventLoopFuture<GRPCStatus>
   {
     for name in greetings {
       var builder = FlatBufferBuilder()
-      let off = builder.create(string: "\(name) \(request.object.name ?? "Unknown")")
-      let root = models_HelloReply.createHelloReply(&builder, messageOffset: off)
+      let off = builder
+        .create(string: "\(name) \(request.object.name ?? "Unknown")")
+      let root = models_HelloReply.createHelloReply(
+        &builder,
+        messageOffset: off)
       builder.finish(offset: root)
       _ = context.sendResponse(Message<models_HelloReply>(builder: &builder))
     }
diff -urN a/grpc/examples/ts/greeter/package.json b/grpc/examples/ts/greeter/package.json
--- a/grpc/examples/ts/greeter/package.json	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/ts/greeter/package.json	2023-01-13 07:46:49.812075966 +0000
@@ -8,7 +8,7 @@
     "server": "node dist/server.js"
   },
   "dependencies": {
-    "flatbuffers": "^2.0.0",
-    "grpc": "^1.24.3"
+    "@grpc/grpc-js": "^1.3.2",
+    "flatbuffers": "^2.0.0"
   }
 }
diff -urN a/grpc/examples/ts/greeter/src/client.ts b/grpc/examples/ts/greeter/src/client.ts
--- a/grpc/examples/ts/greeter/src/client.ts	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/ts/greeter/src/client.ts	2023-01-13 07:46:49.872076520 +0000
@@ -1,22 +1,22 @@
-import grpc from 'grpc';
+import * as grpc from '@grpc/grpc-js';
+import * as flatbuffers from 'flatbuffers';
 import { HelloReply } from './models/hello-reply';
 import { HelloRequest } from './models/hello-request';
 import { GreeterClient } from './greeter_grpc';
-import { flatbuffers } from 'flatbuffers';
 
-async function main(PORT: Number, name: String) {
-    const _server = new GreeterClient(`localhost:${PORT}`, grpc.credentials.createInsecure());
+async function main(PORT: Number, name: string) {
+    const client = new GreeterClient(`localhost:${PORT}`, grpc.credentials.createInsecure());
     const builder = new flatbuffers.Builder();
     const offset = builder.createString(name);
     const root = HelloRequest.createHelloRequest(builder, offset);
     builder.finish(root);
     const buffer = HelloRequest.getRootAsHelloRequest(new flatbuffers.ByteBuffer(builder.asUint8Array()));
 
-    _server.SayHello(buffer, (err, response) => {
+    client.SayHello(buffer, (err, response) => {
         console.log(response.message());
     });
 
-    const data = _server.SayManyHellos(buffer, null);
+    const data = client.SayManyHellos(buffer, null);
 
     data.on('data', (data) => {
         console.log(data.message());
@@ -25,7 +25,7 @@
 
 const args = process.argv.slice(2)
 const PORT = Number(args[0]);
-const name = String(args[1] ?? "flatbuffers");
+const name: string = args[1] ?? "flatbuffers";
 
 if (PORT) {
     main(PORT, name);
diff -urN a/grpc/examples/ts/greeter/src/greeter.ts b/grpc/examples/ts/greeter/src/greeter.ts
--- a/grpc/examples/ts/greeter/src/greeter.ts	1970-01-01 00:00:00.000000000 +0000
+++ b/grpc/examples/ts/greeter/src/greeter.ts	2023-01-13 07:46:50.096078587 +0000
@@ -0,0 +1,2 @@
+export { HelloReply } from './models/hello-reply';
+export { HelloRequest } from './models/hello-request';
diff -urN a/grpc/examples/ts/greeter/src/greeter_grpc.d.ts b/grpc/examples/ts/greeter/src/greeter_grpc.d.ts
--- a/grpc/examples/ts/greeter/src/greeter_grpc.d.ts	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/ts/greeter/src/greeter_grpc.d.ts	2023-01-13 07:46:50.963086594 +0000
@@ -3,7 +3,7 @@
 import { HelloReply as models_HelloReply } from './models/hello-reply';
 import { HelloRequest as models_HelloRequest } from './models/hello-request';
 
-import * as grpc from 'grpc';
+import * as grpc from '@grpc/grpc-js';
 
 interface IGreeterService extends grpc.ServiceDefinition<grpc.UntypedServiceImplementation> {
   SayHello: IGreeterService_ISayHello;
@@ -32,7 +32,7 @@
 
 export const GreeterService: IGreeterService;
 
-export interface IGreeterServer {
+export interface IGreeterServer extends grpc.UntypedServiceImplementation {
   SayHello: grpc.handleUnaryCall<models_HelloRequest, models_HelloReply>;
   SayManyHellos: grpc.handleServerStreamingCall<models_HelloRequest, models_HelloReply>;
 }
@@ -46,7 +46,8 @@
 }
 
 export class GreeterClient extends grpc.Client implements IGreeterClient {
-  constructor(address: string, credentials: grpc.ChannelCredentials, options?: object);  public SayHello(request: models_HelloRequest, callback: (error: grpc.ServiceError | null, response: models_HelloReply) => void): grpc.ClientUnaryCall;
+  constructor(address: string, credentials: grpc.ChannelCredentials, options?: object);
+  public SayHello(request: models_HelloRequest, callback: (error: grpc.ServiceError | null, response: models_HelloReply) => void): grpc.ClientUnaryCall;
   public SayHello(request: models_HelloRequest, metadata: grpc.Metadata, callback: (error: grpc.ServiceError | null, response: models_HelloReply) => void): grpc.ClientUnaryCall;
   public SayHello(request: models_HelloRequest, metadata: grpc.Metadata, options: Partial<grpc.CallOptions>, callback: (error: grpc.ServiceError | null, response: models_HelloReply) => void): grpc.ClientUnaryCall;
   public SayManyHellos(request: models_HelloRequest, metadata: grpc.Metadata): grpc.ClientReadableStream<models_HelloReply>;
diff -urN a/grpc/examples/ts/greeter/src/greeter_grpc.js b/grpc/examples/ts/greeter/src/greeter_grpc.js
--- a/grpc/examples/ts/greeter/src/greeter_grpc.js	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/ts/greeter/src/greeter_grpc.js	2023-01-13 07:46:51.057087464 +0000
@@ -3,13 +3,13 @@
 import { HelloReply as models_HelloReply } from './models/hello-reply';
 import { HelloRequest as models_HelloRequest } from './models/hello-request';
 
-var grpc = require('grpc');
+var grpc = require('@grpc/grpc-js');
 
 function serialize_models_HelloReply(buffer_args) {
   if (!(buffer_args instanceof models_HelloReply)) {
     throw new Error('Expected argument of type HelloReply');
   }
-  return buffer_args.serialize();
+  return Buffer.from(buffer_args.serialize());
 }
 
 function deserialize_models_HelloReply(buffer) {
@@ -21,7 +21,7 @@
   if (!(buffer_args instanceof models_HelloRequest)) {
     throw new Error('Expected argument of type HelloRequest');
   }
-  return buffer_args.serialize();
+  return Buffer.from(buffer_args.serialize());
 }
 
 function deserialize_models_HelloRequest(buffer) {
diff -urN a/grpc/examples/ts/greeter/src/server.ts b/grpc/examples/ts/greeter/src/server.ts
--- a/grpc/examples/ts/greeter/src/server.ts	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/examples/ts/greeter/src/server.ts	2023-01-13 07:46:51.146088284 +0000
@@ -1,21 +1,19 @@
-import grpc from 'grpc';
+import * as grpc from '@grpc/grpc-js';
+import * as flatbuffers from 'flatbuffers';
 import { HelloReply } from './models/hello-reply';
 import { HelloRequest } from './models/hello-request';
 import { IGreeterServer, GreeterService } from './greeter_grpc';
-import { flatbuffers } from 'flatbuffers';
 
-class GreeterServer implements IGreeterServer {
-
-    SayHello(call: grpc.ServerUnaryCall<HelloRequest>, callback: grpc.sendUnaryData<HelloReply>): void {
+const greeter: IGreeterServer = {
+    SayHello(call: grpc.ServerUnaryCall<HelloRequest, HelloReply>, callback: grpc.sendUnaryData<HelloReply>): void {
         console.log(`SayHello ${call.request.name()}`);
         const builder = new flatbuffers.Builder();
         const offset = builder.createString(`welcome ${call.request.name()}`);
         const root = HelloReply.createHelloReply(builder, offset);
         builder.finish(root);
         callback(null, HelloReply.getRootAsHelloReply(new flatbuffers.ByteBuffer(builder.asUint8Array())));
-    }
-
-    async SayManyHellos(call: grpc.ServerWritableStream<HelloRequest>): Promise<void> {
+    },
+    async SayManyHellos(call: grpc.ServerWritableStream<HelloRequest, HelloReply>): Promise<void> {
         const name = call.request.name();
         console.log(`${call.request.name()} saying hi in different langagues`);
         ['Hi', 'Hallo', 'Ciao'].forEach(element => {
@@ -32,10 +30,20 @@
 function serve(): void {
     const PORT = 3000;
     const server = new grpc.Server();
-    server.addService<IGreeterServer>(GreeterService, new GreeterServer());
+    server.addService(GreeterService, greeter);
     console.log(`Listening on ${PORT}`);
-    server.bind(`localhost:${PORT}`, grpc.ServerCredentials.createInsecure());
-    server.start();
+    server.bindAsync(
+        `localhost:${PORT}`,
+        grpc.ServerCredentials.createInsecure(),
+        (err: Error | null, port: number) => {
+          if (err) {
+            console.error(`Server error: ${err.message}`);
+          } else {
+            console.log(`Server bound on port: ${port}`);
+            server.start();
+          }
+        }
+      );
 }
 
 serve();
\ No newline at end of file
diff -urN a/grpc/flatbuffers-java-grpc/pom.xml b/grpc/flatbuffers-java-grpc/pom.xml
--- a/grpc/flatbuffers-java-grpc/pom.xml	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/flatbuffers-java-grpc/pom.xml	2023-01-13 07:46:49.750075393 +0000
@@ -6,7 +6,7 @@
     <parent>
         <groupId>com.google.flatbuffers</groupId>
         <artifactId>flatbuffers-parent</artifactId>
-        <version>2.0.0</version>
+        <version>2.0.3</version>
     </parent>
     <artifactId>flatbuffers-java-grpc</artifactId>
     <name>${project.artifactId}</name>
@@ -24,7 +24,7 @@
         </developer>
     </developers>
     <properties>
-        <gRPC.version>2.0.0</gRPC.version>
+        <gRPC.version>1.36.0</gRPC.version>
     </properties>
     <dependencies>
         <dependency>
diff -urN a/grpc/pom.xml b/grpc/pom.xml
--- a/grpc/pom.xml	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/pom.xml	2023-01-13 07:46:49.771075587 +0000
@@ -4,7 +4,7 @@
     <groupId>com.google.flatbuffers</groupId>
     <artifactId>flatbuffers-parent</artifactId>
     <packaging>pom</packaging>
-    <version>2.0.0</version>
+    <version>2.0.3</version>
     <name>flatbuffers-parent</name>
     <description>parent pom for flatbuffers java artifacts</description>
     <properties>
diff -urN a/grpc/samples/greeter/Makefile b/grpc/samples/greeter/Makefile
--- a/grpc/samples/greeter/Makefile	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/samples/greeter/Makefile	2023-01-13 07:46:49.778075651 +0000
@@ -4,11 +4,11 @@
 .PHONY: all
 all: server client
 
-greeter_generated.h: greeter.fbs
+greeter_generated: greeter.fbs
 	flatc --grpc --cpp $<
 
-server: server.cpp greeter.grpc.fb.cc greeter_generated.h greeter.grpc.fb.h
+server: greeter_generated server.cpp greeter.grpc.fb.cc greeter.grpc.fb.h
 	g++ -std=c++11 -O2 $(CXXFLAGS) $(LDFLAGS) -lgpr -lgrpc -lgrpc++ server.cpp greeter.grpc.fb.cc -o $@
 
-client: client.cpp greeter.grpc.fb.cc greeter_generated.h greeter.grpc.fb.h
+client: greeter_generated client.cpp greeter.grpc.fb.cc greeter.grpc.fb.h
 	g++ -std=c++11 -O2 $(CXXFLAGS) $(LDFLAGS) -lgpr -lgrpc -lgrpc++ client.cpp greeter.grpc.fb.cc -o $@
diff -urN a/grpc/src/compiler/BUILD.bazel b/grpc/src/compiler/BUILD.bazel
--- a/grpc/src/compiler/BUILD.bazel	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/BUILD.bazel	2023-01-13 07:46:52.185097880 +0000
@@ -7,7 +7,6 @@
 filegroup(
     name = "common_headers",
     srcs = [
-        "config.h",
         "schema_interface.h",
     ],
 )
diff -urN a/grpc/src/compiler/config.h b/grpc/src/compiler/config.h
--- a/grpc/src/compiler/config.h	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/config.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,40 +0,0 @@
-/*
- *
- * Copyright 2015, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef SRC_COMPILER_CONFIG_H
-#define SRC_COMPILER_CONFIG_H
-
-// This file is here only because schema_interface.h, which is copied from gRPC,
-// includes it. There is nothing for Flatbuffers to configure.
-
-#endif  // SRC_COMPILER_CONFIG_H
diff -urN a/grpc/src/compiler/cpp_generator.cc b/grpc/src/compiler/cpp_generator.cc
--- a/grpc/src/compiler/cpp_generator.cc	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/cpp_generator.cc	2023-01-13 07:46:52.837103901 +0000
@@ -1,51 +1,17 @@
-/*
- *
- * Copyright 2015, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
+#include "src/compiler/cpp_generator.h"
 
 #include <map>
+#include <sstream>
 
-#include "src/compiler/cpp_generator.h"
 #include "flatbuffers/util.h"
 
-#include <sstream>
-
 namespace grpc_cpp_generator {
 namespace {
 
 grpc::string message_header_ext() { return "_generated.h"; }
 grpc::string service_header_ext() { return ".grpc.fb.h"; }
 
-template <class T>
-grpc::string as_string(T x) {
+template<class T> grpc::string as_string(T x) {
   std::ostringstream out;
   out << x;
   return out.str();
@@ -76,10 +42,7 @@
 }
 }  // namespace
 
-template <class T, size_t N>
-T *array_end(T (&array)[N]) {
-  return array + N;
-}
+template<class T, size_t N> T *array_end(T (&array)[N]) { return array + N; }
 
 void PrintIncludes(grpc_generator::Printer *printer,
                    const std::vector<grpc::string> &headers,
@@ -92,9 +55,7 @@
   auto &s = params.grpc_search_path;
   if (!s.empty()) {
     vars["l"] += s;
-    if (s[s.size() - 1] != '/') {
-      vars["l"] += '/';
-    }
+    if (s[s.size() - 1] != '/') { vars["l"] += '/'; }
   }
 
   for (auto i = headers.begin(); i != headers.end(); i++) {
@@ -114,7 +75,7 @@
     vars["filename"] = file->filename();
     vars["filename_identifier"] = FilenameIdentifier(file->filename());
     vars["filename_base"] = file->filename_without_ext();
-    vars["message_header_ext"] = message_header_ext();
+    vars["message_header_ext"] = file->message_header_ext();
 
     printer->Print(vars, "// Generated by the gRPC C++ plugin.\n");
     printer->Print(vars,
@@ -144,15 +105,16 @@
     std::map<grpc::string, grpc::string> vars;
 
     static const char *headers_strs[] = {
-        "grpcpp/impl/codegen/async_stream.h",
-        "grpcpp/impl/codegen/async_unary_call.h",
-        "grpcpp/impl/codegen/method_handler.h",
-        "grpcpp/impl/codegen/proto_utils.h",
-        "grpcpp/impl/codegen/rpc_method.h",
-        "grpcpp/impl/codegen/service_type.h",
-        "grpcpp/impl/codegen/status.h",
-        "grpcpp/impl/codegen/stub_options.h",
-        "grpcpp/impl/codegen/sync_stream.h"};
+      "grpcpp/impl/codegen/async_stream.h",
+      "grpcpp/impl/codegen/async_unary_call.h",
+      "grpcpp/impl/codegen/method_handler.h",
+      "grpcpp/impl/codegen/proto_utils.h",
+      "grpcpp/impl/codegen/rpc_method.h",
+      "grpcpp/impl/codegen/service_type.h",
+      "grpcpp/impl/codegen/status.h",
+      "grpcpp/impl/codegen/stub_options.h",
+      "grpcpp/impl/codegen/sync_stream.h"
+    };
     std::vector<grpc::string> headers(headers_strs, array_end(headers_strs));
     PrintIncludes(printer.get(), headers, params);
     printer->Print(vars, "\n");
@@ -187,8 +149,8 @@
     grpc::string prefix;
     grpc::string method_params;  // extra arguments to method
     grpc::string raw_args;       // extra arguments to raw version of method
-  } async_prefixes[] = {{"Async", ", void* tag", ", tag"},
-                        {"PrepareAsync", "", ""}};
+  } async_prefixes[] = { { "Async", ", void* tag", ", tag" },
+                         { "PrepareAsync", "", "" } };
 
   if (is_public) {
     if (method->NoStreaming()) {
@@ -196,8 +158,9 @@
           *vars,
           "virtual ::grpc::Status $Method$(::grpc::ClientContext* context, "
           "const $Request$& request, $Response$* response) = 0;\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         printer->Print(
             *vars,
@@ -228,8 +191,9 @@
           "($Method$Raw(context, response));\n");
       printer->Outdent();
       printer->Print("}\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -262,8 +226,9 @@
           "($Method$Raw(context, request));\n");
       printer->Outdent();
       printer->Print("}\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -295,8 +260,9 @@
           "$Method$Raw(context));\n");
       printer->Outdent();
       printer->Print("}\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -318,8 +284,9 @@
     }
   } else {
     if (method->NoStreaming()) {
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         printer->Print(
             *vars,
@@ -334,8 +301,9 @@
           "virtual ::grpc::ClientWriterInterface< $Request$>*"
           " $Method$Raw("
           "::grpc::ClientContext* context, $Response$* response) = 0;\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         printer->Print(
@@ -351,8 +319,9 @@
           "virtual ::grpc::ClientReaderInterface< $Response$>* "
           "$Method$Raw("
           "::grpc::ClientContext* context, const $Request$& request) = 0;\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         printer->Print(
@@ -367,8 +336,9 @@
                      "virtual ::grpc::ClientReaderWriterInterface< $Request$, "
                      "$Response$>* "
                      "$Method$Raw(::grpc::ClientContext* context) = 0;\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         printer->Print(
@@ -393,8 +363,8 @@
     grpc::string prefix;
     grpc::string method_params;  // extra arguments to method
     grpc::string raw_args;       // extra arguments to raw version of method
-  } async_prefixes[] = {{"Async", ", void* tag", ", tag"},
-                        {"PrepareAsync", "", ""}};
+  } async_prefixes[] = { { "Async", ", void* tag", ", tag" },
+                         { "PrepareAsync", "", "" } };
 
   if (is_public) {
     if (method->NoStreaming()) {
@@ -402,8 +372,9 @@
           *vars,
           "::grpc::Status $Method$(::grpc::ClientContext* context, "
           "const $Request$& request, $Response$* response) override;\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         printer->Print(
             *vars,
@@ -431,8 +402,9 @@
                      "($Method$Raw(context, response));\n");
       printer->Outdent();
       printer->Print("}\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -463,8 +435,9 @@
           "($Method$Raw(context, request));\n");
       printer->Outdent();
       printer->Print("}\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -494,8 +467,9 @@
                      "$Method$Raw(context));\n");
       printer->Outdent();
       printer->Print("}\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -516,8 +490,9 @@
     }
   } else {
     if (method->NoStreaming()) {
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         printer->Print(
             *vars,
@@ -531,8 +506,9 @@
                      "::grpc::ClientWriter< $Request$>* $Method$Raw("
                      "::grpc::ClientContext* context, $Response$* response) "
                      "override;\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -547,8 +523,9 @@
                      "::grpc::ClientReader< $Response$>* $Method$Raw("
                      "::grpc::ClientContext* context, const $Request$& request)"
                      " override;\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -562,8 +539,9 @@
       printer->Print(*vars,
                      "::grpc::ClientReaderWriter< $Request$, $Response$>* "
                      "$Method$Raw(::grpc::ClientContext* context) override;\n");
-      for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-        auto& async_prefix = async_prefixes[i];
+      for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+           i++) {
+        auto &async_prefix = async_prefixes[i];
         (*vars)["AsyncPrefix"] = async_prefix.prefix;
         (*vars)["AsyncMethodParams"] = async_prefix.method_params;
         (*vars)["AsyncRawArgs"] = async_prefix.raw_args;
@@ -630,7 +608,8 @@
                  "class WithAsyncMethod_$Method$ : public BaseClass {\n");
   printer->Print(
       " private:\n"
-      "  void BaseClassMustBeDerivedFromService(const Service *service) {}\n");
+      "  void BaseClassMustBeDerivedFromService(const Service */*service*/) "
+      "{}\n");
   printer->Print(" public:\n");
   printer->Indent();
   printer->Print(*vars,
@@ -646,8 +625,8 @@
         *vars,
         "// disable synchronous version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, const $Request$* request, "
-        "$Response$* response) final override {\n"
+        "::grpc::ServerContext* /*context*/, const $Request$* /*request*/, "
+        "$Response$* /*response*/) final override {\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
         "}\n");
@@ -667,8 +646,8 @@
         *vars,
         "// disable synchronous version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, "
-        "::grpc::ServerReader< $Request$>* reader, "
+        "::grpc::ServerContext* /*context*/, "
+        "::grpc::ServerReader< $Request$>* /*reader*/, "
         "$Response$* response) final override {\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
@@ -689,8 +668,8 @@
         *vars,
         "// disable synchronous version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, const $Request$* request, "
-        "::grpc::ServerWriter< $Response$>* writer) final override "
+        "::grpc::ServerContext* /*context*/, const $Request$* /*request*/, "
+        "::grpc::ServerWriter< $Response$>* /*writer*/) final override "
         "{\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
@@ -712,8 +691,8 @@
         *vars,
         "// disable synchronous version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, "
-        "::grpc::ServerReaderWriter< $Response$, $Request$>* stream) "
+        "::grpc::ServerContext* /*context*/, "
+        "::grpc::ServerReaderWriter< $Response$, $Request$>* /*stream*/) "
         "final override {\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
@@ -747,7 +726,7 @@
                    "public BaseClass {\n");
     printer->Print(
         " private:\n"
-        "  void BaseClassMustBeDerivedFromService(const Service *service) "
+        "  void BaseClassMustBeDerivedFromService(const Service */*service*/) "
         "{}\n");
     printer->Print(" public:\n");
     printer->Indent();
@@ -768,8 +747,8 @@
         *vars,
         "// disable regular version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, const $Request$* request, "
-        "$Response$* response) final override {\n"
+        "::grpc::ServerContext* /*context*/, const $Request$* /*request*/, "
+        "$Response$* /*response*/) final override {\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
         "}\n");
@@ -798,8 +777,8 @@
                    "public BaseClass {\n");
     printer->Print(
         " private:\n"
-        "  void BaseClassMustBeDerivedFromService(const Service *service) "
-        "{}\n");
+        "  void BaseClassMustBeDerivedFromService(const Service */*service*/) "
+        "{ }\n");
     printer->Print(" public:\n");
     printer->Indent();
     printer->Print(
@@ -820,8 +799,8 @@
         *vars,
         "// disable regular version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, const $Request$* request, "
-        "::grpc::ServerWriter< $Response$>* writer) final override "
+        "::grpc::ServerContext* /*context*/, const $Request$* /*request*/, "
+        "::grpc::ServerWriter< $Response$>* /*writer*/) final override "
         "{\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
@@ -849,7 +828,8 @@
                  "class WithGenericMethod_$Method$ : public BaseClass {\n");
   printer->Print(
       " private:\n"
-      "  void BaseClassMustBeDerivedFromService(const Service *service) {}\n");
+      "  void BaseClassMustBeDerivedFromService(const Service */*service*/) "
+      "{}\n");
   printer->Print(" public:\n");
   printer->Indent();
   printer->Print(*vars,
@@ -865,8 +845,8 @@
         *vars,
         "// disable synchronous version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, const $Request$* request, "
-        "$Response$* response) final override {\n"
+        "::grpc::ServerContext* /*context*/, const $Request$* /*request*/, "
+        "$Response$* /*response*/) final override {\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
         "}\n");
@@ -875,9 +855,9 @@
         *vars,
         "// disable synchronous version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, "
-        "::grpc::ServerReader< $Request$>* reader, "
-        "$Response$* response) final override {\n"
+        "::grpc::ServerContext* /*context*/, "
+        "::grpc::ServerReader< $Request$>* /*reader*/, "
+        "$Response$* /*response*/) final override {\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
         "}\n");
@@ -886,8 +866,8 @@
         *vars,
         "// disable synchronous version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, const $Request$* request, "
-        "::grpc::ServerWriter< $Response$>* writer) final override "
+        "::grpc::ServerContext* /*context*/, const $Request$* /*request*/, "
+        "::grpc::ServerWriter< $Response$>* /*writer*/) final override "
         "{\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
@@ -897,8 +877,8 @@
         *vars,
         "// disable synchronous version of this method\n"
         "::grpc::Status $Method$("
-        "::grpc::ServerContext* context, "
-        "::grpc::ServerReaderWriter< $Response$, $Request$>* stream) "
+        "::grpc::ServerContext* /*context*/, "
+        "::grpc::ServerReaderWriter< $Response$, $Request$>* /*stream*/) "
         "final override {\n"
         "  abort();\n"
         "  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, \"\");\n"
@@ -1001,9 +981,7 @@
     printer->Print(*vars, "WithAsyncMethod_$method_name$<");
   }
   printer->Print("Service");
-  for (int i = 0; i < service->method_count(); ++i) {
-    printer->Print(" >");
-  }
+  for (int i = 0; i < service->method_count(); ++i) { printer->Print(" >"); }
   printer->Print(" AsyncService;\n");
 
   // Server side - Generic
@@ -1028,9 +1006,7 @@
   }
   printer->Print("Service");
   for (int i = 0; i < service->method_count(); ++i) {
-    if (service->method(i)->NoStreaming()) {
-      printer->Print(" >");
-    }
+    if (service->method(i)->NoStreaming()) { printer->Print(" >"); }
   }
   printer->Print(" StreamedUnaryService;\n");
 
@@ -1052,9 +1028,7 @@
   printer->Print("Service");
   for (int i = 0; i < service->method_count(); ++i) {
     auto method = service->method(i);
-    if (ServerOnlyStreaming(method.get())) {
-      printer->Print(" >");
-    }
+    if (ServerOnlyStreaming(method.get())) { printer->Print(" >"); }
   }
   printer->Print(" SplitStreamedService;\n");
 
@@ -1095,9 +1069,7 @@
     // Package string is empty or ends with a dot. It is used to fully qualify
     // method names.
     vars["Package"] = file->package();
-    if (!file->package().empty()) {
-      vars["Package"].append(".");
-    }
+    if (!file->package().empty()) { vars["Package"].append("."); }
 
     if (!params.services_namespace.empty()) {
       vars["services_namespace"] = params.services_namespace;
@@ -1155,8 +1127,8 @@
 
     vars["filename"] = file->filename();
     vars["filename_base"] = file->filename_without_ext();
-    vars["message_header_ext"] = message_header_ext();
-    vars["service_header_ext"] = service_header_ext();
+    vars["message_header_ext"] = file->message_header_ext();
+    vars["service_header_ext"] = file->service_header_ext();
 
     printer->Print(vars, "// Generated by the gRPC C++ plugin.\n");
     printer->Print(vars,
@@ -1179,14 +1151,15 @@
     std::map<grpc::string, grpc::string> vars;
 
     static const char *headers_strs[] = {
-        "grpcpp/impl/codegen/async_stream.h",
-        "grpcpp/impl/codegen/async_unary_call.h",
-        "grpcpp/impl/codegen/channel_interface.h",
-        "grpcpp/impl/codegen/client_unary_call.h",
-        "grpcpp/impl/codegen/method_handler.h",
-        "grpcpp/impl/codegen/rpc_service_method.h",
-        "grpcpp/impl/codegen/service_type.h",
-        "grpcpp/impl/codegen/sync_stream.h"};
+      "grpcpp/impl/codegen/async_stream.h",
+      "grpcpp/impl/codegen/async_unary_call.h",
+      "grpcpp/impl/codegen/channel_interface.h",
+      "grpcpp/impl/codegen/client_unary_call.h",
+      "grpcpp/impl/codegen/method_handler.h",
+      "grpcpp/impl/codegen/rpc_service_method.h",
+      "grpcpp/impl/codegen/service_type.h",
+      "grpcpp/impl/codegen/sync_stream.h"
+    };
     std::vector<grpc::string> headers(headers_strs, array_end(headers_strs));
     PrintIncludes(printer.get(), headers, params);
 
@@ -1215,8 +1188,8 @@
     grpc::string start;          // bool literal expressed as string
     grpc::string method_params;  // extra arguments to method
     grpc::string create_args;    // extra arguments to creator
-  } async_prefixes[] = {{"Async", "true", ", void* tag", ", tag"},
-                        {"PrepareAsync", "false", "", ", nullptr"}};
+  } async_prefixes[] = { { "Async", "true", ", void* tag", ", tag" },
+                         { "PrepareAsync", "false", "", ", nullptr" } };
   if (method->NoStreaming()) {
     printer->Print(*vars,
                    "::grpc::Status $ns$$Service$::Stub::$Method$("
@@ -1226,8 +1199,9 @@
                    "  return ::grpc::internal::BlockingUnaryCall"
                    "(channel_.get(), rpcmethod_$Method$_, "
                    "context, request, response);\n}\n\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-      auto& async_prefix = async_prefixes[i];
+    for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+         i++) {
+      auto &async_prefix = async_prefixes[i];
       (*vars)["AsyncPrefix"] = async_prefix.prefix;
       (*vars)["AsyncStart"] = async_prefix.start;
       printer->Print(*vars,
@@ -1257,8 +1231,9 @@
         "rpcmethod_$Method$_, "
         "context, response);\n"
         "}\n\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-      auto& async_prefix = async_prefixes[i];
+    for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+         i++) {
+      auto &async_prefix = async_prefixes[i];
       (*vars)["AsyncPrefix"] = async_prefix.prefix;
       (*vars)["AsyncStart"] = async_prefix.start;
       (*vars)["AsyncMethodParams"] = async_prefix.method_params;
@@ -1289,8 +1264,9 @@
         "rpcmethod_$Method$_, "
         "context, request);\n"
         "}\n\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-      auto& async_prefix = async_prefixes[i];
+    for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+         i++) {
+      auto &async_prefix = async_prefixes[i];
       (*vars)["AsyncPrefix"] = async_prefix.prefix;
       (*vars)["AsyncStart"] = async_prefix.start;
       (*vars)["AsyncMethodParams"] = async_prefix.method_params;
@@ -1321,8 +1297,9 @@
                    "rpcmethod_$Method$_, "
                    "context);\n"
                    "}\n\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-      auto& async_prefix = async_prefixes[i];
+    for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+         i++) {
+      auto &async_prefix = async_prefixes[i];
       (*vars)["AsyncPrefix"] = async_prefix.prefix;
       (*vars)["AsyncStart"] = async_prefix.start;
       (*vars)["AsyncMethodParams"] = async_prefix.method_params;
@@ -1351,13 +1328,11 @@
   (*vars)["Request"] = method->input_type_name();
   (*vars)["Response"] = method->output_type_name();
   if (method->NoStreaming()) {
-    printer->Print(*vars,
-                   "::grpc::Status $ns$$Service$::Service::$Method$("
-                   "::grpc::ServerContext* context, "
-                   "const $Request$* request, $Response$* response) {\n");
-    printer->Print("  (void) context;\n");
-    printer->Print("  (void) request;\n");
-    printer->Print("  (void) response;\n");
+    printer->Print(
+        *vars,
+        "::grpc::Status $ns$$Service$::Service::$Method$("
+        "::grpc::ServerContext* /*context*/, "
+        "const $Request$* /*request*/, $Response$* /*response*/) {\n");
     printer->Print(
         "  return ::grpc::Status("
         "::grpc::StatusCode::UNIMPLEMENTED, \"\");\n");
@@ -1365,12 +1340,9 @@
   } else if (ClientOnlyStreaming(method)) {
     printer->Print(*vars,
                    "::grpc::Status $ns$$Service$::Service::$Method$("
-                   "::grpc::ServerContext* context, "
-                   "::grpc::ServerReader< $Request$>* reader, "
-                   "$Response$* response) {\n");
-    printer->Print("  (void) context;\n");
-    printer->Print("  (void) reader;\n");
-    printer->Print("  (void) response;\n");
+                   "::grpc::ServerContext* /*context*/, "
+                   "::grpc::ServerReader< $Request$>* /*reader*/, "
+                   "$Response$* /*response*/) {\n");
     printer->Print(
         "  return ::grpc::Status("
         "::grpc::StatusCode::UNIMPLEMENTED, \"\");\n");
@@ -1378,12 +1350,9 @@
   } else if (ServerOnlyStreaming(method)) {
     printer->Print(*vars,
                    "::grpc::Status $ns$$Service$::Service::$Method$("
-                   "::grpc::ServerContext* context, "
-                   "const $Request$* request, "
-                   "::grpc::ServerWriter< $Response$>* writer) {\n");
-    printer->Print("  (void) context;\n");
-    printer->Print("  (void) request;\n");
-    printer->Print("  (void) writer;\n");
+                   "::grpc::ServerContext* /*context*/, "
+                   "const $Request$* /*request*/, "
+                   "::grpc::ServerWriter< $Response$>* /*writer*/) {\n");
     printer->Print(
         "  return ::grpc::Status("
         "::grpc::StatusCode::UNIMPLEMENTED, \"\");\n");
@@ -1391,11 +1360,9 @@
   } else if (method->BidiStreaming()) {
     printer->Print(*vars,
                    "::grpc::Status $ns$$Service$::Service::$Method$("
-                   "::grpc::ServerContext* context, "
+                   "::grpc::ServerContext* /*context*/, "
                    "::grpc::ServerReaderWriter< $Response$, $Request$>* "
-                   "stream) {\n");
-    printer->Print("  (void) context;\n");
-    printer->Print("  (void) stream;\n");
+                   "/*stream*/) {\n");
     printer->Print(
         "  return ::grpc::Status("
         "::grpc::StatusCode::UNIMPLEMENTED, \"\");\n");
@@ -1421,7 +1388,7 @@
   printer->Print(*vars,
                  "std::unique_ptr< $ns$$Service$::Stub> $ns$$Service$::NewStub("
                  "const std::shared_ptr< ::grpc::ChannelInterface>& channel, "
-                 "const ::grpc::StubOptions& options) {\n"
+                 "const ::grpc::StubOptions& /*options*/) {\n"
                  "  std::unique_ptr< $ns$$Service$::Stub> stub(new "
                  "$ns$$Service$::Stub(channel));\n"
                  "  return stub;\n"
@@ -1530,9 +1497,7 @@
     // Package string is empty or ends with a dot. It is used to fully qualify
     // method names.
     vars["Package"] = file->package();
-    if (!file->package().empty()) {
-      vars["Package"].append(".");
-    }
+    if (!file->package().empty()) { vars["Package"].append("."); }
     if (!params.services_namespace.empty()) {
       vars["ns"] = params.services_namespace + "::";
       vars["prefix"] = params.services_namespace;
@@ -1604,9 +1569,9 @@
     std::map<grpc::string, grpc::string> vars;
 
     static const char *headers_strs[] = {
-        "grpcpp/impl/codegen/async_stream.h",
-        "grpcpp/impl/codegen/sync_stream.h",
-        "gmock/gmock.h",
+      "grpcpp/impl/codegen/async_stream.h",
+      "grpcpp/impl/codegen/sync_stream.h",
+      "gmock/gmock.h",
     };
     std::vector<grpc::string> headers(headers_strs, array_end(headers_strs));
     PrintIncludes(printer.get(), headers, params);
@@ -1636,15 +1601,17 @@
     grpc::string prefix;
     grpc::string method_params;  // extra arguments to method
     int extra_method_param_count;
-  } async_prefixes[] = {{"Async", ", void* tag", 1}, {"PrepareAsync", "", 0}};
+  } async_prefixes[] = { { "Async", ", void* tag", 1 },
+                         { "PrepareAsync", "", 0 } };
 
   if (method->NoStreaming()) {
     printer->Print(
         *vars,
         "MOCK_METHOD3($Method$, ::grpc::Status(::grpc::ClientContext* context, "
         "const $Request$& request, $Response$* response));\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-      auto& async_prefix = async_prefixes[i];
+    for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+         i++) {
+      auto &async_prefix = async_prefixes[i];
       (*vars)["AsyncPrefix"] = async_prefix.prefix;
       printer->Print(
           *vars,
@@ -1659,12 +1626,13 @@
         "MOCK_METHOD2($Method$Raw, "
         "::grpc::ClientWriterInterface< $Request$>*"
         "(::grpc::ClientContext* context, $Response$* response));\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-      auto& async_prefix = async_prefixes[i];
+    for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+         i++) {
+      auto &async_prefix = async_prefixes[i];
       (*vars)["AsyncPrefix"] = async_prefix.prefix;
       (*vars)["AsyncMethodParams"] = async_prefix.method_params;
       (*vars)["MockArgs"] =
-        flatbuffers::NumToString(3 + async_prefix.extra_method_param_count);
+          flatbuffers::NumToString(3 + async_prefix.extra_method_param_count);
       printer->Print(*vars,
                      "MOCK_METHOD$MockArgs$($AsyncPrefix$$Method$Raw, "
                      "::grpc::ClientAsyncWriterInterface< $Request$>*"
@@ -1677,8 +1645,9 @@
         "MOCK_METHOD2($Method$Raw, "
         "::grpc::ClientReaderInterface< $Response$>*"
         "(::grpc::ClientContext* context, const $Request$& request));\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-      auto& async_prefix = async_prefixes[i];
+    for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+         i++) {
+      auto &async_prefix = async_prefixes[i];
       (*vars)["AsyncPrefix"] = async_prefix.prefix;
       (*vars)["AsyncMethodParams"] = async_prefix.method_params;
       (*vars)["MockArgs"] =
@@ -1696,8 +1665,9 @@
         "MOCK_METHOD1($Method$Raw, "
         "::grpc::ClientReaderWriterInterface< $Request$, $Response$>*"
         "(::grpc::ClientContext* context));\n");
-    for (size_t i = 0; i < sizeof(async_prefixes)/sizeof(async_prefixes[0]); i ++) {
-      auto& async_prefix = async_prefixes[i];
+    for (size_t i = 0; i < sizeof(async_prefixes) / sizeof(async_prefixes[0]);
+         i++) {
+      auto &async_prefix = async_prefixes[i];
       (*vars)["AsyncPrefix"] = async_prefix.prefix;
       (*vars)["AsyncMethodParams"] = async_prefix.method_params;
       (*vars)["MockArgs"] =
@@ -1738,9 +1708,7 @@
     // Package string is empty or ends with a dot. It is used to fully qualify
     // method names.
     vars["Package"] = file->package();
-    if (!file->package().empty()) {
-      vars["Package"].append(".");
-    }
+    if (!file->package().empty()) { vars["Package"].append("."); }
 
     if (!params.services_namespace.empty()) {
       vars["services_namespace"] = params.services_namespace;
diff -urN a/grpc/src/compiler/cpp_generator.h b/grpc/src/compiler/cpp_generator.h
--- a/grpc/src/compiler/cpp_generator.h	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/cpp_generator.h	2023-01-13 07:46:52.837103901 +0000
@@ -1,36 +1,3 @@
-/*
- *
- * Copyright 2015, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
 #ifndef GRPC_INTERNAL_COMPILER_CPP_GENERATOR_H
 #define GRPC_INTERNAL_COMPILER_CPP_GENERATOR_H
 
@@ -41,12 +8,11 @@
 #include <memory>
 #include <vector>
 
-#include "src/compiler/config.h"
 #include "src/compiler/schema_interface.h"
 
 #ifndef GRPC_CUSTOM_STRING
-#include <string>
-#define GRPC_CUSTOM_STRING std::string
+#  include <string>
+#  define GRPC_CUSTOM_STRING std::string
 #endif
 
 namespace grpc {
diff -urN a/grpc/src/compiler/go_generator.cc b/grpc/src/compiler/go_generator.cc
--- a/grpc/src/compiler/go_generator.cc	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/go_generator.cc	2023-01-13 07:46:52.838103910 +0000
@@ -1,47 +1,13 @@
-/*
- *
- * Copyright 2015, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation AN/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
+#include "src/compiler/go_generator.h"
 
-#include <map>
 #include <cctype>
+#include <map>
 #include <sstream>
 
-#include "src/compiler/go_generator.h"
-
-template <class T>
-grpc::string as_string(T x) {
-	std::ostringstream out;
-	out << x;
-	return out.str();
+template<class T> grpc::string as_string(T x) {
+  std::ostringstream out;
+  out << x;
+  return out.str();
 }
 
 inline bool ClientOnlyStreaming(const grpc_generator::Method *method) {
@@ -56,18 +22,16 @@
 
 // Returns string with first letter to lowerCase
 grpc::string unexportName(grpc::string s) {
-	if (s.empty())
-		return s;
-	s[0] = static_cast<char>(std::tolower(s[0]));
-	return s;
+  if (s.empty()) return s;
+  s[0] = static_cast<char>(std::tolower(s[0]));
+  return s;
 }
 
 // Returns string with first letter to uppercase
 grpc::string exportName(grpc::string s) {
-	if (s.empty())
-		return s;
-	s[0] = static_cast<char>(std::toupper(s[0]));
-	return s;
+  if (s.empty()) return s;
+  s[0] = static_cast<char>(std::toupper(s[0]));
+  return s;
 }
 
 void GenerateError(grpc_generator::Printer *printer,
@@ -82,50 +46,65 @@
 }
 
 // Generates imports for the service
-void GenerateImports(grpc_generator::File *file, grpc_generator::Printer *printer,
+void GenerateImports(grpc_generator::File *file,
+                     grpc_generator::Printer *printer,
                      std::map<grpc::string, grpc::string> vars) {
-	vars["filename"] = file->filename();
-	printer->Print("//Generated by gRPC Go plugin\n");
-	printer->Print("//If you make any local changes, they will be lost\n");
-	printer->Print(vars, "//source: $filename$\n\n");
-	printer->Print(vars, "package $Package$\n\n");
-	printer->Print("import (\n");
-	printer->Indent();
-	printer->Print(vars, "$context$ \"context\"\n");
+  vars["filename"] = file->filename();
+  printer->Print("//Generated by gRPC Go plugin\n");
+  printer->Print("//If you make any local changes, they will be lost\n");
+  printer->Print(vars, "//source: $filename$\n\n");
+  printer->Print(vars, "package $Package$\n\n");
+  printer->Print("import (\n");
+  printer->Indent();
+  printer->Print(vars, "$context$ \"context\"\n");
   printer->Print("flatbuffers \"github.com/google/flatbuffers/go\"\n");
-	printer->Print(vars, "$grpc$ \"google.golang.org/grpc\"\n");
+  printer->Print(vars, "$grpc$ \"google.golang.org/grpc\"\n");
   printer->Print("\"google.golang.org/grpc/codes\"\n");
   printer->Print("\"google.golang.org/grpc/status\"\n");
-	printer->Outdent();
-	printer->Print(")\n\n");
+  printer->Outdent();
+  printer->Print(")\n\n");
 }
 
 // Generates Server method signature source
-void GenerateServerMethodSignature(const grpc_generator::Method *method, grpc_generator::Printer *printer,
+void GenerateServerMethodSignature(const grpc_generator::Method *method,
+                                   grpc_generator::Printer *printer,
                                    std::map<grpc::string, grpc::string> vars) {
   vars["Method"] = exportName(method->name());
-	vars["Request"] = method->get_input_type_name();
-	vars["Response"] = (vars["CustomMethodIO"] == "") ? method->get_output_type_name() : vars["CustomMethodIO"];
-	if (method->NoStreaming()) {
-		printer->Print(vars, "$Method$($context$.Context, *$Request$) (*$Response$, error)$Ending$");
-	} else if (ServerOnlyStreaming(method)) {
-		printer->Print(vars, "$Method$(*$Request$, $Service$_$Method$Server) error$Ending$");
-	} else {
-		printer->Print(vars, "$Method$($Service$_$Method$Server) error$Ending$");
-	}
+  vars["Request"] = method->get_input_type_name();
+  vars["Response"] = (vars["CustomMethodIO"] == "")
+                         ? method->get_output_type_name()
+                         : vars["CustomMethodIO"];
+  if (method->NoStreaming()) {
+    printer->Print(
+        vars,
+        "$Method$($context$.Context, *$Request$) (*$Response$, error)$Ending$");
+  } else if (ServerOnlyStreaming(method)) {
+    printer->Print(
+        vars, "$Method$(*$Request$, $Service$_$Method$Server) error$Ending$");
+  } else {
+    printer->Print(vars, "$Method$($Service$_$Method$Server) error$Ending$");
+  }
 }
 
-void GenerateServerMethod(const grpc_generator::Method *method, grpc_generator::Printer *printer,
+void GenerateServerMethod(const grpc_generator::Method *method,
+                          grpc_generator::Printer *printer,
                           std::map<grpc::string, grpc::string> vars) {
-	vars["Method"] = exportName(method->name());
-	vars["Request"] = method->get_input_type_name();
-	vars["Response"] = (vars["CustomMethodIO"] == "") ? method->get_output_type_name() : vars["CustomMethodIO"];
-	vars["FullMethodName"] = "/" + vars["ServicePrefix"] + vars["Service"] + "/" + vars["Method"];
-	vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
-	if (method->NoStreaming()) {
-		printer->Print(vars, "func $Handler$(srv interface{}, ctx $context$.Context,\n\tdec func(interface{}) error, interceptor $grpc$.UnaryServerInterceptor) (interface{}, error) {\n");
-		printer->Indent();
-		printer->Print(vars, "in := new($Request$)\n");
+  vars["Method"] = exportName(method->name());
+  vars["Request"] = method->get_input_type_name();
+  vars["Response"] = (vars["CustomMethodIO"] == "")
+                         ? method->get_output_type_name()
+                         : vars["CustomMethodIO"];
+  vars["FullMethodName"] =
+      "/" + vars["ServicePrefix"] + vars["Service"] + "/" + vars["Method"];
+  vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
+  if (method->NoStreaming()) {
+    printer->Print(
+        vars,
+        "func $Handler$(srv interface{}, ctx $context$.Context,\n\tdec "
+        "func(interface{}) error, interceptor $grpc$.UnaryServerInterceptor) "
+        "(interface{}, error) {\n");
+    printer->Indent();
+    printer->Print(vars, "in := new($Request$)\n");
     vars["Error_Check"] = "err := dec(in); err != nil";
     GenerateError(printer, vars);
     printer->Print("if interceptor == nil {\n");
@@ -133,258 +112,281 @@
     printer->Print(vars, "return srv.($Service$Server).$Method$(ctx, in)\n");
     printer->Outdent();
     printer->Print("}\n");
-		printer->Print(vars, "info := &$grpc$.UnaryServerInfo{\n");
-		printer->Indent();
-		printer->Print("Server:     srv,\n");
-		printer->Print(vars, "FullMethod: \"$FullMethodName$\",\n");
-		printer->Outdent();
-		printer->Print("}\n");
+    printer->Print(vars, "info := &$grpc$.UnaryServerInfo{\n");
+    printer->Indent();
+    printer->Print("Server:     srv,\n");
+    printer->Print(vars, "FullMethod: \"$FullMethodName$\",\n");
+    printer->Outdent();
+    printer->Print("}\n");
     printer->Outdent();
     printer->Print("\n");
     printer->Indent();
-		printer->Print(vars, "handler := func(ctx $context$.Context, req interface{}) (interface{}, error) {\n");
-		printer->Indent();
-		printer->Print(vars, "return srv.($Service$Server).$Method$(ctx, req.(*$Request$))\n");
-		printer->Outdent();
-		printer->Print("}\n");
-		printer->Print("return interceptor(ctx, in, info, handler)\n");
-		printer->Outdent();
-		printer->Print("}\n");
-		return;
-	}
-	vars["StreamType"] = vars["ServiceUnexported"] + vars["Method"] + "Server";
-	printer->Print(vars, "func $Handler$(srv interface{}, stream $grpc$.ServerStream) error {\n");
-	printer->Indent();
-	if (ServerOnlyStreaming(method)) {
-		printer->Print(vars, "m := new($Request$)\n");
+    printer->Print(vars,
+                   "handler := func(ctx $context$.Context, req interface{}) "
+                   "(interface{}, error) {\n");
+    printer->Indent();
+    printer->Print(
+        vars, "return srv.($Service$Server).$Method$(ctx, req.(*$Request$))\n");
+    printer->Outdent();
+    printer->Print("}\n");
+    printer->Print("return interceptor(ctx, in, info, handler)\n");
+    printer->Outdent();
+    printer->Print("}\n");
+    return;
+  }
+  vars["StreamType"] = vars["ServiceUnexported"] + vars["Method"] + "Server";
+  printer->Print(
+      vars,
+      "func $Handler$(srv interface{}, stream $grpc$.ServerStream) error {\n");
+  printer->Indent();
+  if (ServerOnlyStreaming(method)) {
+    printer->Print(vars, "m := new($Request$)\n");
     vars["Error_Check"] = "err := stream.RecvMsg(m); err != nil";
     GenerateError(printer, vars, false);
-		printer->Print(vars, "return srv.($Service$Server).$Method$(m, &$StreamType${stream})\n");
-	} else {
-		printer->Print(vars, "return srv.($Service$Server).$Method$(&$StreamType${stream})\n");
-	}
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	bool genSend = method->BidiStreaming() || ServerOnlyStreaming(method);
-	bool genRecv = method->BidiStreaming() || ClientOnlyStreaming(method);
-	bool genSendAndClose = ClientOnlyStreaming(method);
-
-	printer->Print(vars, "type $Service$_$Method$Server interface {\n");
-	printer->Indent();
-	if (genSend) {
-		printer->Print(vars, "Send(*$Response$) error\n");
-	}
-	if (genRecv) {
-		printer->Print(vars, "Recv() (*$Request$, error)\n");
-	}
-	if (genSendAndClose) {
-		printer->Print(vars, "SendAndClose(*$Response$) error\n");
-	}
-	printer->Print(vars, "$grpc$.ServerStream\n");
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	printer->Print(vars, "type $StreamType$ struct {\n");
-	printer->Indent();
-	printer->Print(vars, "$grpc$.ServerStream\n");
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	if (genSend) {
-		printer->Print(vars, "func (x *$StreamType$) Send(m *$Response$) error {\n");
-		printer->Indent();
-		printer->Print("return x.ServerStream.SendMsg(m)\n");
-		printer->Outdent();
-		printer->Print("}\n\n");
-	}
-	if (genRecv) {
-		printer->Print(vars, "func (x *$StreamType$) Recv() (*$Request$, error) {\n");
-		printer->Indent();
-		printer->Print(vars, "m := new($Request$)\n");
+    printer->Print(
+        vars,
+        "return srv.($Service$Server).$Method$(m, &$StreamType${stream})\n");
+  } else {
+    printer->Print(
+        vars, "return srv.($Service$Server).$Method$(&$StreamType${stream})\n");
+  }
+  printer->Outdent();
+  printer->Print("}\n\n");
+
+  bool genSend = method->BidiStreaming() || ServerOnlyStreaming(method);
+  bool genRecv = method->BidiStreaming() || ClientOnlyStreaming(method);
+  bool genSendAndClose = ClientOnlyStreaming(method);
+
+  printer->Print(vars, "type $Service$_$Method$Server interface {\n");
+  printer->Indent();
+  if (genSend) { printer->Print(vars, "Send(*$Response$) error\n"); }
+  if (genRecv) { printer->Print(vars, "Recv() (*$Request$, error)\n"); }
+  if (genSendAndClose) {
+    printer->Print(vars, "SendAndClose(*$Response$) error\n");
+  }
+  printer->Print(vars, "$grpc$.ServerStream\n");
+  printer->Outdent();
+  printer->Print("}\n\n");
+
+  printer->Print(vars, "type $StreamType$ struct {\n");
+  printer->Indent();
+  printer->Print(vars, "$grpc$.ServerStream\n");
+  printer->Outdent();
+  printer->Print("}\n\n");
+
+  if (genSend) {
+    printer->Print(vars,
+                   "func (x *$StreamType$) Send(m *$Response$) error {\n");
+    printer->Indent();
+    printer->Print("return x.ServerStream.SendMsg(m)\n");
+    printer->Outdent();
+    printer->Print("}\n\n");
+  }
+  if (genRecv) {
+    printer->Print(vars,
+                   "func (x *$StreamType$) Recv() (*$Request$, error) {\n");
+    printer->Indent();
+    printer->Print(vars, "m := new($Request$)\n");
     vars["Error_Check"] = "err := x.ServerStream.RecvMsg(m); err != nil";
     GenerateError(printer, vars);
-		printer->Print("return m, nil\n");
-		printer->Outdent();
-		printer->Print("}\n\n");
-	}
-	if (genSendAndClose) {
-		printer->Print(vars, "func (x *$StreamType$) SendAndClose(m *$Response$) error {\n");
-		printer->Indent();
-		printer->Print("return x.ServerStream.SendMsg(m)\n");
-		printer->Outdent();
-		printer->Print("}\n\n");
-	}
-
+    printer->Print("return m, nil\n");
+    printer->Outdent();
+    printer->Print("}\n\n");
+  }
+  if (genSendAndClose) {
+    printer->Print(
+        vars, "func (x *$StreamType$) SendAndClose(m *$Response$) error {\n");
+    printer->Indent();
+    printer->Print("return x.ServerStream.SendMsg(m)\n");
+    printer->Outdent();
+    printer->Print("}\n\n");
+  }
 }
 
 // Generates Client method signature source
-void GenerateClientMethodSignature(const grpc_generator::Method *method, grpc_generator::Printer *printer,
+void GenerateClientMethodSignature(const grpc_generator::Method *method,
+                                   grpc_generator::Printer *printer,
                                    std::map<grpc::string, grpc::string> vars) {
-	vars["Method"] = exportName(method->name());
-	vars["Request"] = ", in *" + ((vars["CustomMethodIO"] == "") ? method->get_input_type_name() : vars["CustomMethodIO"]);
-	if (ClientOnlyStreaming(method) || method->BidiStreaming()) {
-		vars["Request"] = "";
-	}
-	vars["Response"] = "*" + method->get_output_type_name();
-	if (ClientOnlyStreaming(method) || method->BidiStreaming() || ServerOnlyStreaming(method)) {
-		vars["Response"] = vars["Service"] + "_" + vars["Method"] + "Client" ;
-	}
-	printer->Print(vars, "$Method$(ctx $context$.Context$Request$,\n\topts ...$grpc$.CallOption) ($Response$, error)$Ending$");
+  vars["Method"] = exportName(method->name());
+  vars["Request"] =
+      ", in *" + ((vars["CustomMethodIO"] == "") ? method->get_input_type_name()
+                                                 : vars["CustomMethodIO"]);
+  if (ClientOnlyStreaming(method) || method->BidiStreaming()) {
+    vars["Request"] = "";
+  }
+  vars["Response"] = "*" + method->get_output_type_name();
+  if (ClientOnlyStreaming(method) || method->BidiStreaming() ||
+      ServerOnlyStreaming(method)) {
+    vars["Response"] = vars["Service"] + "_" + vars["Method"] + "Client";
+  }
+  printer->Print(vars,
+                 "$Method$(ctx $context$.Context$Request$,\n\topts "
+                 "...$grpc$.CallOption) ($Response$, error)$Ending$");
 }
 
 // Generates Client method source
-void GenerateClientMethod(const grpc_generator::Method *method, grpc_generator::Printer *printer,
+void GenerateClientMethod(const grpc_generator::Method *method,
+                          grpc_generator::Printer *printer,
                           std::map<grpc::string, grpc::string> vars) {
-	printer->Print(vars, "func (c *$ServiceUnexported$Client) ");
+  printer->Print(vars, "func (c *$ServiceUnexported$Client) ");
   vars["Ending"] = " {\n";
-	GenerateClientMethodSignature(method, printer, vars);
-	printer->Indent();
-	vars["Method"] = exportName(method->name());
-	vars["Request"] = (vars["CustomMethodIO"] == "") ? method->get_input_type_name() : vars["CustomMethodIO"];
-	vars["Response"] = method->get_output_type_name();
-	vars["FullMethodName"] = "/" + vars["ServicePrefix"] + vars["Service"] + "/" + vars["Method"];
-	if (method->NoStreaming()) {
-		printer->Print(vars, "out := new($Response$)\n");
-		printer->Print(vars, "err := c.cc.Invoke(ctx, \"$FullMethodName$\", in, out, opts...)\n");
+  GenerateClientMethodSignature(method, printer, vars);
+  printer->Indent();
+  vars["Method"] = exportName(method->name());
+  vars["Request"] = (vars["CustomMethodIO"] == "")
+                        ? method->get_input_type_name()
+                        : vars["CustomMethodIO"];
+  vars["Response"] = method->get_output_type_name();
+  vars["FullMethodName"] =
+      "/" + vars["ServicePrefix"] + vars["Service"] + "/" + vars["Method"];
+  if (method->NoStreaming()) {
+    printer->Print(vars, "out := new($Response$)\n");
+    printer->Print(
+        vars,
+        "err := c.cc.Invoke(ctx, \"$FullMethodName$\", in, out, opts...)\n");
     vars["Error_Check"] = "err != nil";
     GenerateError(printer, vars);
-		printer->Print("return out, nil\n");
-		printer->Outdent();
-		printer->Print("}\n\n");
-		return;
-	}
-	vars["StreamType"] = vars["ServiceUnexported"] + vars["Method"] + "Client";
-	printer->Print(vars, "stream, err := c.cc.NewStream(ctx, &$MethodDesc$, \"$FullMethodName$\", opts...)\n");
+    printer->Print("return out, nil\n");
+    printer->Outdent();
+    printer->Print("}\n\n");
+    return;
+  }
+  vars["StreamType"] = vars["ServiceUnexported"] + vars["Method"] + "Client";
+  printer->Print(vars,
+                 "stream, err := c.cc.NewStream(ctx, &$MethodDesc$, "
+                 "\"$FullMethodName$\", opts...)\n");
   vars["Error_Check"] = "err != nil";
   GenerateError(printer, vars);
 
-	printer->Print(vars, "x := &$StreamType${stream}\n");
-	if (ServerOnlyStreaming(method)) {
+  printer->Print(vars, "x := &$StreamType${stream}\n");
+  if (ServerOnlyStreaming(method)) {
     vars["Error_Check"] = "err := x.ClientStream.SendMsg(in); err != nil";
     GenerateError(printer, vars);
     vars["Error_Check"] = "err := x.ClientStream.CloseSend(); err != nil";
     GenerateError(printer, vars);
-	}
-	printer->Print("return x, nil\n");
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	bool genSend = method->BidiStreaming() || ClientOnlyStreaming(method);
-	bool genRecv = method->BidiStreaming() || ServerOnlyStreaming(method);
-	bool genCloseAndRecv = ClientOnlyStreaming(method);
-
-	//Stream interface
-	printer->Print(vars, "type $Service$_$Method$Client interface {\n");
-	printer->Indent();
-	if (genSend) {
-		printer->Print(vars, "Send(*$Request$) error\n");
-	}
-	if (genRecv) {
-		printer->Print(vars, "Recv() (*$Response$, error)\n");
-	}
-	if (genCloseAndRecv) {
-		printer->Print(vars, "CloseAndRecv() (*$Response$, error)\n");
-	}
-	printer->Print(vars, "$grpc$.ClientStream\n");
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	//Stream Client
-	printer->Print(vars, "type $StreamType$ struct {\n");
-	printer->Indent();
-	printer->Print(vars, "$grpc$.ClientStream\n");
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	if (genSend) {
-		printer->Print(vars, "func (x *$StreamType$) Send(m *$Request$) error {\n");
-		printer->Indent();
-		printer->Print("return x.ClientStream.SendMsg(m)\n");
-		printer->Outdent();
-		printer->Print("}\n\n");
-	}
-
-	if (genRecv) {
-		printer->Print(vars, "func (x *$StreamType$) Recv() (*$Response$, error) {\n");
-		printer->Indent();
-		printer->Print(vars, "m := new($Response$)\n");
+  }
+  printer->Print("return x, nil\n");
+  printer->Outdent();
+  printer->Print("}\n\n");
+
+  bool genSend = method->BidiStreaming() || ClientOnlyStreaming(method);
+  bool genRecv = method->BidiStreaming() || ServerOnlyStreaming(method);
+  bool genCloseAndRecv = ClientOnlyStreaming(method);
+
+  // Stream interface
+  printer->Print(vars, "type $Service$_$Method$Client interface {\n");
+  printer->Indent();
+  if (genSend) { printer->Print(vars, "Send(*$Request$) error\n"); }
+  if (genRecv) { printer->Print(vars, "Recv() (*$Response$, error)\n"); }
+  if (genCloseAndRecv) {
+    printer->Print(vars, "CloseAndRecv() (*$Response$, error)\n");
+  }
+  printer->Print(vars, "$grpc$.ClientStream\n");
+  printer->Outdent();
+  printer->Print("}\n\n");
+
+  // Stream Client
+  printer->Print(vars, "type $StreamType$ struct {\n");
+  printer->Indent();
+  printer->Print(vars, "$grpc$.ClientStream\n");
+  printer->Outdent();
+  printer->Print("}\n\n");
+
+  if (genSend) {
+    printer->Print(vars, "func (x *$StreamType$) Send(m *$Request$) error {\n");
+    printer->Indent();
+    printer->Print("return x.ClientStream.SendMsg(m)\n");
+    printer->Outdent();
+    printer->Print("}\n\n");
+  }
+
+  if (genRecv) {
+    printer->Print(vars,
+                   "func (x *$StreamType$) Recv() (*$Response$, error) {\n");
+    printer->Indent();
+    printer->Print(vars, "m := new($Response$)\n");
     vars["Error_Check"] = "err := x.ClientStream.RecvMsg(m); err != nil";
     GenerateError(printer, vars);
-		printer->Print("return m, nil\n");
-		printer->Outdent();
-		printer->Print("}\n\n");
-	}
-
-	if (genCloseAndRecv) {
-		printer->Print(vars, "func (x *$StreamType$) CloseAndRecv() (*$Response$, error) {\n");
-		printer->Indent();
+    printer->Print("return m, nil\n");
+    printer->Outdent();
+    printer->Print("}\n\n");
+  }
+
+  if (genCloseAndRecv) {
+    printer->Print(
+        vars, "func (x *$StreamType$) CloseAndRecv() (*$Response$, error) {\n");
+    printer->Indent();
     vars["Error_Check"] = "err := x.ClientStream.CloseSend(); err != nil";
     GenerateError(printer, vars);
-		printer->Print(vars, "m := new($Response$)\n");
+    printer->Print(vars, "m := new($Response$)\n");
     vars["Error_Check"] = "err := x.ClientStream.RecvMsg(m); err != nil";
     GenerateError(printer, vars);
-		printer->Print("return m, nil\n");
-		printer->Outdent();
-		printer->Print("}\n\n");
-	}
+    printer->Print("return m, nil\n");
+    printer->Outdent();
+    printer->Print("}\n\n");
+  }
 }
 
 // Generates client API for the service
-void GenerateService(const grpc_generator::Service *service, grpc_generator::Printer* printer,
+void GenerateService(const grpc_generator::Service *service,
+                     grpc_generator::Printer *printer,
                      std::map<grpc::string, grpc::string> vars) {
-	vars["Service"] = exportName(service->name());
-	// Client Interface
-	printer->Print(vars, "// Client API for $Service$ service\n");
-	printer->Print(vars, "type $Service$Client interface {\n");
-	printer->Indent();
+  vars["Service"] = exportName(service->name());
+  // Client Interface
+  printer->Print(vars, "// Client API for $Service$ service\n");
+  printer->Print(vars, "type $Service$Client interface {\n");
+  printer->Indent();
   vars["Ending"] = "\n";
-	for (int i = 0; i < service->method_count(); i++) {
-		GenerateClientMethodSignature(service->method(i).get(), printer, vars);
-	}
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	// Client structure
-	vars["ServiceUnexported"] = unexportName(vars["Service"]);
-	printer->Print(vars, "type $ServiceUnexported$Client struct {\n");
-	printer->Indent();
-	printer->Print(vars, "cc $grpc$.ClientConnInterface\n");
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	// NewClient
-	printer->Print(vars, "func New$Service$Client(cc $grpc$.ClientConnInterface) $Service$Client {\n");
-	printer->Indent();
-	printer->Print(vars, "return &$ServiceUnexported$Client{cc}");
-	printer->Outdent();
-	printer->Print("\n}\n\n");
-
-	int unary_methods = 0, streaming_methods = 0;
-	vars["ServiceDesc"] = "_" + vars["Service"] + "_serviceDesc";
-	for (int i = 0; i < service->method_count(); i++) {
-		auto method = service->method(i);
-		if (method->NoStreaming()) {
-			vars["MethodDesc"] = vars["ServiceDesc"] + ".Method[" + as_string(unary_methods) + "]";
-			unary_methods++;
-		} else {
-			vars["MethodDesc"] = vars["ServiceDesc"] + ".Streams[" + as_string(streaming_methods) + "]";
-			streaming_methods++;
-		}
-		GenerateClientMethod(method.get(), printer, vars);
-	}
-
-	//Server Interface
-	printer->Print(vars, "// Server API for $Service$ service\n");
-	printer->Print(vars, "type $Service$Server interface {\n");
-	printer->Indent();
+  for (int i = 0; i < service->method_count(); i++) {
+    GenerateClientMethodSignature(service->method(i).get(), printer, vars);
+  }
+  printer->Outdent();
+  printer->Print("}\n\n");
+
+  // Client structure
+  vars["ServiceUnexported"] = unexportName(vars["Service"]);
+  printer->Print(vars, "type $ServiceUnexported$Client struct {\n");
+  printer->Indent();
+  printer->Print(vars, "cc $grpc$.ClientConnInterface\n");
+  printer->Outdent();
+  printer->Print("}\n\n");
+
+  // NewClient
+  printer->Print(vars,
+                 "func New$Service$Client(cc $grpc$.ClientConnInterface) "
+                 "$Service$Client {\n");
+  printer->Indent();
+  printer->Print(vars, "return &$ServiceUnexported$Client{cc}");
+  printer->Outdent();
+  printer->Print("\n}\n\n");
+
+  int unary_methods = 0, streaming_methods = 0;
+  vars["ServiceDesc"] = "_" + vars["Service"] + "_serviceDesc";
+  for (int i = 0; i < service->method_count(); i++) {
+    auto method = service->method(i);
+    if (method->NoStreaming()) {
+      vars["MethodDesc"] =
+          vars["ServiceDesc"] + ".Method[" + as_string(unary_methods) + "]";
+      unary_methods++;
+    } else {
+      vars["MethodDesc"] = vars["ServiceDesc"] + ".Streams[" +
+                           as_string(streaming_methods) + "]";
+      streaming_methods++;
+    }
+    GenerateClientMethod(method.get(), printer, vars);
+  }
+
+  // Server Interface
+  printer->Print(vars, "// Server API for $Service$ service\n");
+  printer->Print(vars, "type $Service$Server interface {\n");
+  printer->Indent();
   vars["Ending"] = "\n";
-	for (int i = 0; i < service->method_count(); i++) {
-		GenerateServerMethodSignature(service->method(i).get(), printer, vars);
-	}
+  for (int i = 0; i < service->method_count(); i++) {
+    GenerateServerMethodSignature(service->method(i).get(), printer, vars);
+  }
   printer->Print(vars, "mustEmbedUnimplemented$Service$Server()\n");
-	printer->Outdent();
-	printer->Print("}\n\n");
+  printer->Outdent();
+  printer->Print("}\n\n");
 
   printer->Print(vars, "type Unimplemented$Service$Server struct {\n");
   printer->Print("}\n\n");
@@ -397,13 +399,17 @@
     printer->Print(vars, "func (Unimplemented$Service$Server) ");
     GenerateServerMethodSignature(method.get(), printer, vars);
     printer->Indent();
-    printer->Print(vars, "return $Nil$status.Errorf(codes.Unimplemented, \"method $Method$ not implemented\")\n");
+    printer->Print(vars,
+                   "return $Nil$status.Errorf(codes.Unimplemented, \"method "
+                   "$Method$ not implemented\")\n");
     printer->Outdent();
     printer->Print("}\n");
     printer->Print("\n");
   }
 
-  printer->Print(vars, "func (Unimplemented$Service$Server) mustEmbedUnimplemented$Service$Server() {}");
+  printer->Print(vars,
+                 "func (Unimplemented$Service$Server) "
+                 "mustEmbedUnimplemented$Service$Server() {}");
   printer->Print("\n\n");
 
   printer->Print(vars, "type Unsafe$Service$Server interface {\n");
@@ -411,91 +417,89 @@
   printer->Print(vars, "mustEmbedUnimplemented$Service$Server()\n");
   printer->Outdent();
   printer->Print("}\n\n");
-	// Server registration.
-	printer->Print(vars, "func Register$Service$Server(s $grpc$.ServiceRegistrar, srv $Service$Server) {\n");
-	printer->Indent();
-	printer->Print(vars, "s.RegisterService(&$ServiceDesc$, srv)\n");
-	printer->Outdent();
-	printer->Print("}\n\n");
-
-	for (int i = 0; i < service->method_count(); i++) {
-		GenerateServerMethod(service->method(i).get(), printer, vars);
-	}
-
-
-	//Service Descriptor
-	printer->Print(vars, "var $ServiceDesc$ = $grpc$.ServiceDesc{\n");
-	printer->Indent();
-	printer->Print(vars, "ServiceName: \"$ServicePrefix$$Service$\",\n");
-	printer->Print(vars, "HandlerType: (*$Service$Server)(nil),\n");
-	printer->Print(vars, "Methods: []$grpc$.MethodDesc{\n");
-	printer->Indent();
-	for (int i = 0; i < service->method_count(); i++) {
-		auto method = service->method(i);
-		vars["Method"] = exportName(method->name());
-		vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
-		if (method->NoStreaming()) {
-			printer->Print("{\n");
-			printer->Indent();
-			printer->Print(vars, "MethodName: \"$Method$\",\n");
-			printer->Print(vars, "Handler:    $Handler$,\n");
-			printer->Outdent();
-			printer->Print("},\n");
-		}
-	}
-	printer->Outdent();
-	printer->Print("},\n");
-	printer->Print(vars, "Streams: []$grpc$.StreamDesc{\n");
-	printer->Indent();
-	for (int i = 0; i < service->method_count(); i++) {
-		auto method = service->method(i);
-		vars["Method"] = exportName(method->name());
-		vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
-		if (!method->NoStreaming()) {
-			printer->Print("{\n");
-			printer->Indent();
-			printer->Print(vars, "StreamName:    \"$Method$\",\n");
-			printer->Print(vars, "Handler:       $Handler$,\n");
-			if (ClientOnlyStreaming(method.get())) {
-				printer->Print("ClientStreams: true,\n");
-			} else if (ServerOnlyStreaming(method.get())) {
-				printer->Print("ServerStreams: true,\n");
-			} else {
-				printer->Print("ServerStreams: true,\n");
-				printer->Print("ClientStreams: true,\n");
-			}
-			printer->Outdent();
-			printer->Print("},\n");
-		}
-	}
-	printer->Outdent();
-	printer->Print("},\n");
-	printer->Outdent();
-	printer->Print("}\n");
+  // Server registration.
+  printer->Print(vars,
+                 "func Register$Service$Server(s $grpc$.ServiceRegistrar, srv "
+                 "$Service$Server) {\n");
+  printer->Indent();
+  printer->Print(vars, "s.RegisterService(&$ServiceDesc$, srv)\n");
+  printer->Outdent();
+  printer->Print("}\n\n");
 
-}
+  for (int i = 0; i < service->method_count(); i++) {
+    GenerateServerMethod(service->method(i).get(), printer, vars);
+  }
 
+  // Service Descriptor
+  printer->Print(vars, "var $ServiceDesc$ = $grpc$.ServiceDesc{\n");
+  printer->Indent();
+  printer->Print(vars, "ServiceName: \"$ServicePrefix$$Service$\",\n");
+  printer->Print(vars, "HandlerType: (*$Service$Server)(nil),\n");
+  printer->Print(vars, "Methods: []$grpc$.MethodDesc{\n");
+  printer->Indent();
+  for (int i = 0; i < service->method_count(); i++) {
+    auto method = service->method(i);
+    vars["Method"] = exportName(method->name());
+    vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
+    if (method->NoStreaming()) {
+      printer->Print("{\n");
+      printer->Indent();
+      printer->Print(vars, "MethodName: \"$Method$\",\n");
+      printer->Print(vars, "Handler:    $Handler$,\n");
+      printer->Outdent();
+      printer->Print("},\n");
+    }
+  }
+  printer->Outdent();
+  printer->Print("},\n");
+  printer->Print(vars, "Streams: []$grpc$.StreamDesc{\n");
+  printer->Indent();
+  for (int i = 0; i < service->method_count(); i++) {
+    auto method = service->method(i);
+    vars["Method"] = exportName(method->name());
+    vars["Handler"] = "_" + vars["Service"] + "_" + vars["Method"] + "_Handler";
+    if (!method->NoStreaming()) {
+      printer->Print("{\n");
+      printer->Indent();
+      printer->Print(vars, "StreamName:    \"$Method$\",\n");
+      printer->Print(vars, "Handler:       $Handler$,\n");
+      if (ClientOnlyStreaming(method.get())) {
+        printer->Print("ClientStreams: true,\n");
+      } else if (ServerOnlyStreaming(method.get())) {
+        printer->Print("ServerStreams: true,\n");
+      } else {
+        printer->Print("ServerStreams: true,\n");
+        printer->Print("ClientStreams: true,\n");
+      }
+      printer->Outdent();
+      printer->Print("},\n");
+    }
+  }
+  printer->Outdent();
+  printer->Print("},\n");
+  printer->Outdent();
+  printer->Print("}\n");
+}
 
 // Returns source for the service
 grpc::string GenerateServiceSource(grpc_generator::File *file,
                                    const grpc_generator::Service *service,
                                    grpc_go_generator::Parameters *parameters) {
-	grpc::string out;
-	auto p = file->CreatePrinter(&out, '\t');
+  grpc::string out;
+  auto p = file->CreatePrinter(&out, '\t');
   p->SetIndentationSize(1);
-	auto printer = p.get();
-	std::map<grpc::string, grpc::string> vars;
-	vars["Package"] = parameters->package_name;
-	vars["ServicePrefix"] = parameters->service_prefix;
-  if (!parameters->service_prefix.empty())
-    vars["ServicePrefix"].append(".");
-	vars["grpc"] = "grpc";
-	vars["context"] = "context";
-	GenerateImports(file, printer, vars);
-	if (parameters->custom_method_io_type != "") {
-		vars["CustomMethodIO"] = parameters->custom_method_io_type;
-	}
-	GenerateService(service, printer, vars);
-	return out;
+  auto printer = p.get();
+  std::map<grpc::string, grpc::string> vars;
+  vars["Package"] = parameters->package_name;
+  vars["ServicePrefix"] = parameters->service_prefix;
+  if (!parameters->service_prefix.empty()) vars["ServicePrefix"].append(".");
+  vars["grpc"] = "grpc";
+  vars["context"] = "context";
+  GenerateImports(file, printer, vars);
+  if (parameters->custom_method_io_type != "") {
+    vars["CustomMethodIO"] = parameters->custom_method_io_type;
+  }
+  GenerateService(service, printer, vars);
+  return out;
 }
-}// Namespace grpc_go_generator
+}  // Namespace grpc_go_generator
diff -urN a/grpc/src/compiler/go_generator.h b/grpc/src/compiler/go_generator.h
--- a/grpc/src/compiler/go_generator.h	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/go_generator.h	2023-01-13 07:46:52.838103910 +0000
@@ -1,40 +1,8 @@
-/*
- *
- * Copyright 2015, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
 #ifndef GRPC_INTERNAL_COMPILER_GO_GENERATOR_H
 #define GRPC_INTERNAL_COMPILER_GO_GENERATOR_H
 
-//go generator is used to generate GRPC code for serialization system, such as flatbuffers
+// go generator is used to generate GRPC code for serialization system, such as
+// flatbuffers
 #include <memory>
 #include <vector>
 
@@ -43,14 +11,15 @@
 namespace grpc_go_generator {
 
 struct Parameters {
-  //Defines the custom parameter types for methods
-  //eg: flatbuffers uses flatbuffers.Builder as input for the client and output for the server
+  // Defines the custom parameter types for methods
+  // eg: flatbuffers uses flatbuffers.Builder as input for the client and output
+  // for the server
   grpc::string custom_method_io_type;
 
-  //Package name for the service
+  // Package name for the service
   grpc::string package_name;
 
-  //Prefix for RPC Calls
+  // Prefix for RPC Calls
   grpc::string service_prefix;
 };
 
@@ -59,6 +28,6 @@
                                    const grpc_generator::Service *service,
                                    grpc_go_generator::Parameters *parameters);
 
-}
+}  // namespace grpc_go_generator
 
 #endif  // GRPC_INTERNAL_COMPILER_GO_GENERATOR_H
diff -urN a/grpc/src/compiler/java_generator.cc b/grpc/src/compiler/java_generator.cc
--- a/grpc/src/compiler/java_generator.cc	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/java_generator.cc	2023-01-13 07:46:52.852104040 +0000
@@ -23,21 +23,18 @@
 #include <utility>
 #include <vector>
 
-// just to get flatbuffer_version_string()
-#include <flatbuffers/flatbuffers.h>
-#include <flatbuffers/util.h>
+#include "flatbuffers/util.h"
 #define to_string flatbuffers::NumToString
 
 // Stringify helpers used solely to cast GRPC_VERSION
 #ifndef STR
-#define STR(s) #s
+#  define STR(s) #  s
 #endif
 
 #ifndef XSTR
-#define XSTR(s) STR(s)
+#  define XSTR(s) STR(s)
 #endif
 
-
 typedef grpc_generator::Printer Printer;
 typedef std::map<grpc::string, grpc::string> VARS;
 typedef grpc_generator::Service ServiceDescriptor;
@@ -48,12 +45,11 @@
 namespace grpc_java_generator {
 typedef std::string string;
 // Generates imports for the service
-void GenerateImports(grpc_generator::File* file,
-                     grpc_generator::Printer* printer, VARS& vars) {
+void GenerateImports(grpc_generator::File *file,
+                     grpc_generator::Printer *printer, VARS &vars) {
   vars["filename"] = file->filename();
-  printer->Print(
-      vars,
-      "//Generated by flatc compiler (version $flatc_version$)\n");
+  printer->Print(vars,
+                 "//Generated by flatc compiler (version $flatc_version$)\n");
   printer->Print("//If you make any local changes, they will be lost\n");
   printer->Print(vars, "//source: $filename$.fbs\n\n");
   printer->Print(vars, "package $Package$;\n\n");
@@ -67,7 +63,7 @@
 // Adjust a method name prefix identifier to follow the JavaBean spec:
 //   - decapitalize the first letter
 //   - remove embedded underscores & capitalize the following letter
-static string MixedLower(const string& word) {
+static string MixedLower(const string &word) {
   string w;
   w += static_cast<string::value_type>(tolower(word[0]));
   bool after_underscore = false;
@@ -87,7 +83,7 @@
 //   - An underscore is inserted where a lower case letter is followed by an
 //     upper case letter.
 //   - All letters are converted to upper case
-static string ToAllUpperCase(const string& word) {
+static string ToAllUpperCase(const string &word) {
   string w;
   for (size_t i = 0; i < word.length(); ++i) {
     w += static_cast<string::value_type>(toupper(word[i]));
@@ -98,47 +94,47 @@
   return w;
 }
 
-static inline string LowerMethodName(const MethodDescriptor* method) {
+static inline string LowerMethodName(const MethodDescriptor *method) {
   return MixedLower(method->name());
 }
 
-static inline string MethodPropertiesFieldName(const MethodDescriptor* method) {
+static inline string MethodPropertiesFieldName(const MethodDescriptor *method) {
   return "METHOD_" + ToAllUpperCase(method->name());
 }
 
 static inline string MethodPropertiesGetterName(
-    const MethodDescriptor* method) {
+    const MethodDescriptor *method) {
   return MixedLower("get_" + method->name() + "_method");
 }
 
-static inline string MethodIdFieldName(const MethodDescriptor* method) {
+static inline string MethodIdFieldName(const MethodDescriptor *method) {
   return "METHODID_" + ToAllUpperCase(method->name());
 }
 
-static inline string JavaClassName(VARS& vars, const string& name) {
+static inline string JavaClassName(VARS &vars, const string &name) {
   // string name = google::protobuf::compiler::java::ClassName(desc);
   return vars["Package"] + name;
 }
 
-static inline string ServiceClassName(const string& service_name) {
+static inline string ServiceClassName(const string &service_name) {
   return service_name + "Grpc";
 }
 
 // TODO(nmittler): Remove once protobuf includes javadoc methods in
 // distribution.
-template <typename ITR>
-static void GrpcSplitStringToIteratorUsing(const string& full,
-                                           const char* delim, ITR& result) {
+template<typename ITR>
+static void GrpcSplitStringToIteratorUsing(const string &full,
+                                           const char *delim, ITR &result) {
   // Optimize the common case where delim is a single character.
   if (delim[0] != '\0' && delim[1] == '\0') {
     char c = delim[0];
-    const char* p = full.data();
-    const char* end = p + full.size();
+    const char *p = full.data();
+    const char *end = p + full.size();
     while (p != end) {
       if (*p == c) {
         ++p;
       } else {
-        const char* start = p;
+        const char *start = p;
         while (++p != end && *p != c)
           ;
         *result++ = string(start, p - start);
@@ -160,13 +156,13 @@
   }
 }
 
-static void GrpcSplitStringUsing(const string& full, const char* delim,
-                                 std::vector<string>* result) {
+static void GrpcSplitStringUsing(const string &full, const char *delim,
+                                 std::vector<string> *result) {
   std::back_insert_iterator<std::vector<string>> it(*result);
   GrpcSplitStringToIteratorUsing(full, delim, it);
 }
 
-static std::vector<string> GrpcSplit(const string& full, const char* delim) {
+static std::vector<string> GrpcSplit(const string &full, const char *delim) {
   std::vector<string> result;
   GrpcSplitStringUsing(full, delim, &result);
   return result;
@@ -174,7 +170,7 @@
 
 // TODO(nmittler): Remove once protobuf includes javadoc methods in
 // distribution.
-static string GrpcEscapeJavadoc(const string& input) {
+static string GrpcEscapeJavadoc(const string &input) {
   string result;
   result.reserve(input.size() * 2);
 
@@ -221,9 +217,7 @@
         // Java interprets Unicode escape sequences anywhere!
         result.append("&#92;");
         break;
-      default:
-        result.push_back(c);
-        break;
+      default: result.push_back(c); break;
     }
 
     prev = c;
@@ -232,7 +226,7 @@
   return result;
 }
 
-static std::vector<string> GrpcGetDocLines(const string& comments) {
+static std::vector<string> GrpcGetDocLines(const string &comments) {
   if (!comments.empty()) {
     // TODO(kenton):  Ideally we should parse the comment text as Markdown and
     //   write it back as HTML, but this requires a Markdown parser.  For now
@@ -243,27 +237,23 @@
     string escapedComments = GrpcEscapeJavadoc(comments);
 
     std::vector<string> lines = GrpcSplit(escapedComments, "\n");
-    while (!lines.empty() && lines.back().empty()) {
-      lines.pop_back();
-    }
+    while (!lines.empty() && lines.back().empty()) { lines.pop_back(); }
     return lines;
   }
   return std::vector<string>();
 }
 
 static std::vector<string> GrpcGetDocLinesForDescriptor(
-    const DescriptorType* descriptor) {
+    const DescriptorType *descriptor) {
   return descriptor->GetAllComments();
   // return GrpcGetDocLines(descriptor->GetLeadingComments("///"));
 }
 
-static void GrpcWriteDocCommentBody(Printer* printer, VARS& vars,
-                                    const std::vector<string>& lines,
+static void GrpcWriteDocCommentBody(Printer *printer, VARS &vars,
+                                    const std::vector<string> &lines,
                                     bool surroundWithPreTag) {
   if (!lines.empty()) {
-    if (surroundWithPreTag) {
-      printer->Print(" * <pre>\n");
-    }
+    if (surroundWithPreTag) { printer->Print(" * <pre>\n"); }
 
     for (size_t i = 0; i < lines.size(); i++) {
       // Most lines should start with a space.  Watch out for lines that start
@@ -277,73 +267,72 @@
       }
     }
 
-    if (surroundWithPreTag) {
-      printer->Print(" * </pre>\n");
-    }
+    if (surroundWithPreTag) { printer->Print(" * </pre>\n"); }
   }
 }
 
-static void GrpcWriteDocComment(Printer* printer, VARS& vars,
-                                const string& comments) {
+static void GrpcWriteDocComment(Printer *printer, VARS &vars,
+                                const string &comments) {
   printer->Print("/**\n");
   std::vector<string> lines = GrpcGetDocLines(comments);
   GrpcWriteDocCommentBody(printer, vars, lines, false);
   printer->Print(" */\n");
 }
 
-static void GrpcWriteServiceDocComment(Printer* printer, VARS& vars,
-                                       const ServiceDescriptor* service) {
+static void GrpcWriteServiceDocComment(Printer *printer, VARS &vars,
+                                       const ServiceDescriptor *service) {
   printer->Print("/**\n");
   std::vector<string> lines = GrpcGetDocLinesForDescriptor(service);
   GrpcWriteDocCommentBody(printer, vars, lines, true);
   printer->Print(" */\n");
 }
 
-void GrpcWriteMethodDocComment(Printer* printer, VARS& vars,
-                               const MethodDescriptor* method) {
+void GrpcWriteMethodDocComment(Printer *printer, VARS &vars,
+                               const MethodDescriptor *method) {
   printer->Print("/**\n");
   std::vector<string> lines = GrpcGetDocLinesForDescriptor(method);
   GrpcWriteDocCommentBody(printer, vars, lines, true);
   printer->Print(" */\n");
 }
 
-//outputs static singleton extractor for type stored in "extr_type" and "extr_type_name" vars
-static void PrintTypeExtractor(Printer* p, VARS& vars) {
-  p->Print(
-    vars,
-    "private static volatile FlatbuffersUtils.FBExtactor<$extr_type$> "
-    "extractorOf$extr_type_name$;\n"
-    "private static FlatbuffersUtils.FBExtactor<$extr_type$> "
-    "getExtractorOf$extr_type_name$() {\n"
-    "    if (extractorOf$extr_type_name$ != null) return "
-    "extractorOf$extr_type_name$;\n"
-    "    synchronized ($service_class_name$.class) {\n"
-    "        if (extractorOf$extr_type_name$ != null) return "
-    "extractorOf$extr_type_name$;\n"
-    "        extractorOf$extr_type_name$ = new "
-    "FlatbuffersUtils.FBExtactor<$extr_type$>() {\n"
-    "            public $extr_type$ extract (ByteBuffer buffer) {\n"
-    "                return "
-    "$extr_type$.getRootAs$extr_type_name$(buffer);\n"
-    "            }\n"
-    "        };\n"
-    "        return extractorOf$extr_type_name$;\n"
-    "    }\n"
-    "}\n\n");
+// outputs static singleton extractor for type stored in "extr_type" and
+// "extr_type_name" vars
+static void PrintTypeExtractor(Printer *p, VARS &vars) {
+  p->Print(vars,
+           "private static volatile FlatbuffersUtils.FBExtactor<$extr_type$> "
+           "extractorOf$extr_type_name$;\n"
+           "private static FlatbuffersUtils.FBExtactor<$extr_type$> "
+           "getExtractorOf$extr_type_name$() {\n"
+           "    if (extractorOf$extr_type_name$ != null) return "
+           "extractorOf$extr_type_name$;\n"
+           "    synchronized ($service_class_name$.class) {\n"
+           "        if (extractorOf$extr_type_name$ != null) return "
+           "extractorOf$extr_type_name$;\n"
+           "        extractorOf$extr_type_name$ = new "
+           "FlatbuffersUtils.FBExtactor<$extr_type$>() {\n"
+           "            public $extr_type$ extract (ByteBuffer buffer) {\n"
+           "                return "
+           "$extr_type$.getRootAs$extr_type_name$(buffer);\n"
+           "            }\n"
+           "        };\n"
+           "        return extractorOf$extr_type_name$;\n"
+           "    }\n"
+           "}\n\n");
 }
-static void PrintMethodFields(Printer* p, VARS& vars,
-                              const ServiceDescriptor* service) {
+static void PrintMethodFields(Printer *p, VARS &vars,
+                              const ServiceDescriptor *service) {
   p->Print("// Static method descriptors that strictly reflect the proto.\n");
   vars["service_name"] = service->name();
 
-  //set of names of rpc input- and output- types that were already encountered.
-  //this is needed to avoid duplicating type extractor since it's possible that
-  //the same type is used as an input or output type of more than a single RPC method
+  // set of names of rpc input- and output- types that were already encountered.
+  // this is needed to avoid duplicating type extractor since it's possible that
+  // the same type is used as an input or output type of more than a single RPC
+  // method
   std::set<std::string> encounteredTypes;
 
   for (int i = 0; i < service->method_count(); ++i) {
     auto method = service->method(i);
-    vars["arg_in_id"] = to_string(2L * i); //trying to make msvc 10 happy
+    vars["arg_in_id"] = to_string(2L * i);  // trying to make msvc 10 happy
     vars["arg_out_id"] = to_string(2L * i + 1);
     vars["method_name"] = method->name();
     vars["input_type_name"] = method->get_input_type_name();
@@ -353,8 +342,10 @@
     vars["method_field_name"] = MethodPropertiesFieldName(method.get());
     vars["method_new_field_name"] = MethodPropertiesGetterName(method.get());
     vars["method_method_name"] = MethodPropertiesGetterName(method.get());
-    bool client_streaming = method->ClientStreaming() || method->BidiStreaming();
-    bool server_streaming = method->ServerStreaming() || method->BidiStreaming();
+    bool client_streaming =
+        method->ClientStreaming() || method->BidiStreaming();
+    bool server_streaming =
+        method->ServerStreaming() || method->BidiStreaming();
     if (client_streaming) {
       if (server_streaming) {
         vars["method_type"] = "BIDI_STREAMING";
@@ -394,32 +385,32 @@
     }
 
     p->Print(
-      vars,
-      "@$ExperimentalApi$(\"https://github.com/grpc/grpc-java/issues/"
-      "1901\")\n"
-      "public static $MethodDescriptor$<$input_type$,\n"
-      "    $output_type$> $method_method_name$() {\n"
-      "  $MethodDescriptor$<$input_type$, $output_type$> "
-      "$method_new_field_name$;\n"
-      "  if (($method_new_field_name$ = "
-      "$service_class_name$.$method_new_field_name$) == null) {\n"
-      "    synchronized ($service_class_name$.class) {\n"
-      "      if (($method_new_field_name$ = "
-      "$service_class_name$.$method_new_field_name$) == null) {\n"
-      "        $service_class_name$.$method_new_field_name$ = "
-      "$method_new_field_name$ = \n"
-      "            $MethodDescriptor$.<$input_type$, "
-      "$output_type$>newBuilder()\n"
-      "            .setType($MethodType$.$method_type$)\n"
-      "            .setFullMethodName(generateFullMethodName(\n"
-      "                \"$Package$$service_name$\", \"$method_name$\"))\n"
-      "            .setSampledToLocalTracing(true)\n"
-      "            .setRequestMarshaller(FlatbuffersUtils.marshaller(\n"
-      "                $input_type$.class, "
-      "getExtractorOf$input_type_name$()))\n"
-      "            .setResponseMarshaller(FlatbuffersUtils.marshaller(\n"
-      "                $output_type$.class, "
-      "getExtractorOf$output_type_name$()))\n");
+        vars,
+        "@$ExperimentalApi$(\"https://github.com/grpc/grpc-java/issues/"
+        "1901\")\n"
+        "public static $MethodDescriptor$<$input_type$,\n"
+        "    $output_type$> $method_method_name$() {\n"
+        "  $MethodDescriptor$<$input_type$, $output_type$> "
+        "$method_new_field_name$;\n"
+        "  if (($method_new_field_name$ = "
+        "$service_class_name$.$method_new_field_name$) == null) {\n"
+        "    synchronized ($service_class_name$.class) {\n"
+        "      if (($method_new_field_name$ = "
+        "$service_class_name$.$method_new_field_name$) == null) {\n"
+        "        $service_class_name$.$method_new_field_name$ = "
+        "$method_new_field_name$ = \n"
+        "            $MethodDescriptor$.<$input_type$, "
+        "$output_type$>newBuilder()\n"
+        "            .setType($MethodType$.$method_type$)\n"
+        "            .setFullMethodName(generateFullMethodName(\n"
+        "                \"$Package$$service_name$\", \"$method_name$\"))\n"
+        "            .setSampledToLocalTracing(true)\n"
+        "            .setRequestMarshaller(FlatbuffersUtils.marshaller(\n"
+        "                $input_type$.class, "
+        "getExtractorOf$input_type_name$()))\n"
+        "            .setResponseMarshaller(FlatbuffersUtils.marshaller(\n"
+        "                $output_type$.class, "
+        "getExtractorOf$output_type_name$()))\n");
 
     //            vars["proto_method_descriptor_supplier"] = service->name() +
     //            "MethodDescriptorSupplier";
@@ -451,11 +442,11 @@
 
 enum CallType { ASYNC_CALL = 0, BLOCKING_CALL = 1, FUTURE_CALL = 2 };
 
-static void PrintBindServiceMethodBody(Printer* p, VARS& vars,
-                                       const ServiceDescriptor* service);
+static void PrintBindServiceMethodBody(Printer *p, VARS &vars,
+                                       const ServiceDescriptor *service);
 
 // Prints a client interface or implementation class, or a server interface.
-static void PrintStub(Printer* p, VARS& vars, const ServiceDescriptor* service,
+static void PrintStub(Printer *p, VARS &vars, const ServiceDescriptor *service,
                       StubType type) {
   const string service_name = service->name();
   vars["service_name"] = service_name;
@@ -476,7 +467,7 @@
       break;
     case BLOCKING_CLIENT_INTERFACE:
       interface = true;
-      FLATBUFFERS_FALLTHROUGH(); // fall thru
+      FLATBUFFERS_FALLTHROUGH();  // fall thru
     case BLOCKING_CLIENT_IMPL:
       call_type = BLOCKING_CALL;
       stub_name += "BlockingStub";
@@ -484,7 +475,7 @@
       break;
     case FUTURE_CLIENT_INTERFACE:
       interface = true;
-      FLATBUFFERS_FALLTHROUGH(); // fall thru
+      FLATBUFFERS_FALLTHROUGH();  // fall thru
     case FUTURE_CLIENT_IMPL:
       call_type = FUTURE_CALL;
       stub_name += "FutureStub";
@@ -501,9 +492,7 @@
   vars["client_name"] = client_name;
 
   // Class head
-  if (!interface) {
-    GrpcWriteServiceDocComment(p, vars, service);
-  }
+  if (!interface) { GrpcWriteServiceDocComment(p, vars, service); }
   if (impl_base) {
     p->Print(vars,
              "public static abstract class $abstract_name$ implements "
@@ -546,8 +535,10 @@
     vars["output_type"] = JavaClassName(vars, method->get_output_type_name());
     vars["lower_method_name"] = LowerMethodName(&*method);
     vars["method_method_name"] = MethodPropertiesGetterName(&*method);
-    bool client_streaming = method->ClientStreaming() || method->BidiStreaming();
-    bool server_streaming = method->ServerStreaming() || method->BidiStreaming();
+    bool client_streaming =
+        method->ClientStreaming() || method->BidiStreaming();
+    bool server_streaming =
+        method->ServerStreaming() || method->BidiStreaming();
 
     if (call_type == BLOCKING_CALL && client_streaming) {
       // Blocking client interface with client streaming is not available
@@ -563,9 +554,7 @@
     p->Print("\n");
     // TODO(nmittler): Replace with WriteMethodDocComment once included by the
     // protobuf distro.
-    if (!interface) {
-      GrpcWriteMethodDocComment(p, vars, &*method);
-    }
+    if (!interface) { GrpcWriteMethodDocComment(p, vars, &*method); }
     p->Print("public ");
     switch (call_type) {
       case BLOCKING_CALL:
@@ -630,8 +619,7 @@
                      "responseObserver);\n");
           }
           break;
-        default:
-          break;
+        default: break;
       }
     } else if (!interface) {
       switch (call_type) {
@@ -706,15 +694,15 @@
 }
 
 static bool CompareMethodClientStreaming(
-    const std::unique_ptr<const grpc_generator::Method>& method1,
-    const std::unique_ptr<const grpc_generator::Method>& method2) {
+    const std::unique_ptr<const grpc_generator::Method> &method1,
+    const std::unique_ptr<const grpc_generator::Method> &method2) {
   return method1->ClientStreaming() < method2->ClientStreaming();
 }
 
 // Place all method invocations into a single class to reduce memory footprint
 // on Android.
-static void PrintMethodHandlerClass(Printer* p, VARS& vars,
-                                    const ServiceDescriptor* service) {
+static void PrintMethodHandlerClass(Printer *p, VARS &vars,
+                                    const ServiceDescriptor *service) {
   // Sort method ids based on ClientStreaming() so switch tables are compact.
   std::vector<std::unique_ptr<const grpc_generator::Method>> sorted_methods(
       service->method_count());
@@ -724,7 +712,7 @@
   stable_sort(sorted_methods.begin(), sorted_methods.end(),
               CompareMethodClientStreaming);
   for (size_t i = 0; i < sorted_methods.size(); i++) {
-    auto& method = sorted_methods[i];
+    auto &method = sorted_methods[i];
     vars["method_id"] = to_string(i);
     vars["method_id_name"] = MethodIdFieldName(&*method);
     p->Print(vars,
@@ -757,9 +745,7 @@
 
   for (int i = 0; i < service->method_count(); ++i) {
     auto method = service->method(i);
-    if (method->ClientStreaming() || method->BidiStreaming()) {
-      continue;
-    }
+    if (method->ClientStreaming() || method->BidiStreaming()) { continue; }
     vars["method_id_name"] = MethodIdFieldName(&*method);
     vars["lower_method_name"] = LowerMethodName(&*method);
     vars["input_type"] = JavaClassName(vars, method->get_input_type_name());
@@ -791,9 +777,7 @@
 
   for (int i = 0; i < service->method_count(); ++i) {
     auto method = service->method(i);
-    if (!(method->ClientStreaming() || method->BidiStreaming())) {
-      continue;
-    }
+    if (!(method->ClientStreaming() || method->BidiStreaming())) { continue; }
     vars["method_id_name"] = MethodIdFieldName(&*method);
     vars["lower_method_name"] = LowerMethodName(&*method);
     vars["input_type"] = JavaClassName(vars, method->get_input_type_name());
@@ -818,8 +802,8 @@
   p->Print("}\n\n");
 }
 
-static void PrintGetServiceDescriptorMethod(Printer* p, VARS& vars,
-                                            const ServiceDescriptor* service) {
+static void PrintGetServiceDescriptorMethod(Printer *p, VARS &vars,
+                                            const ServiceDescriptor *service) {
   vars["service_name"] = service->name();
   //        vars["proto_base_descriptor_supplier"] = service->name() +
   //        "BaseDescriptorSupplier"; vars["proto_file_descriptor_supplier"] =
@@ -911,8 +895,8 @@
   p->Print("}\n");
 }
 
-static void PrintBindServiceMethodBody(Printer* p, VARS& vars,
-                                       const ServiceDescriptor* service) {
+static void PrintBindServiceMethodBody(Printer *p, VARS &vars,
+                                       const ServiceDescriptor *service) {
   vars["service_name"] = service->name();
   p->Indent();
   p->Print(vars,
@@ -927,8 +911,10 @@
     vars["input_type"] = JavaClassName(vars, method->get_input_type_name());
     vars["output_type"] = JavaClassName(vars, method->get_output_type_name());
     vars["method_id_name"] = MethodIdFieldName(&*method);
-    bool client_streaming = method->ClientStreaming() || method->BidiStreaming();
-    bool server_streaming = method->ServerStreaming() || method->BidiStreaming();
+    bool client_streaming =
+        method->ClientStreaming() || method->BidiStreaming();
+    bool server_streaming =
+        method->ServerStreaming() || method->BidiStreaming();
     if (client_streaming) {
       if (server_streaming) {
         vars["calls_method"] = "asyncBidiStreamingCall";
@@ -962,8 +948,8 @@
   p->Outdent();
 }
 
-static void PrintService(Printer* p, VARS& vars,
-                         const ServiceDescriptor* service,
+static void PrintService(Printer *p, VARS &vars,
+                         const ServiceDescriptor *service,
                          bool disable_version) {
   vars["service_name"] = service->name();
   vars["service_class_name"] = ServiceClassName(service->name());
@@ -1043,7 +1029,7 @@
   p->Print("}\n");
 }
 
-void PrintStaticImports(Printer* p) {
+void PrintStaticImports(Printer *p) {
   p->Print(
       "import java.nio.ByteBuffer;\n"
       "import static "
@@ -1076,8 +1062,8 @@
       "io.grpc.stub.ServerCalls.asyncUnimplementedUnaryCall;\n\n");
 }
 
-void GenerateService(const grpc_generator::Service* service,
-                     grpc_generator::Printer* printer, VARS& vars,
+void GenerateService(const grpc_generator::Service *service,
+                     grpc_generator::Printer *printer, VARS &vars,
                      bool disable_version) {
   // All non-generated classes must be referred by fully qualified names to
   // avoid collision with generated classes.
@@ -1113,8 +1099,8 @@
 }
 
 grpc::string GenerateServiceSource(
-    grpc_generator::File* file, const grpc_generator::Service* service,
-    grpc_java_generator::Parameters* parameters) {
+    grpc_generator::File *file, const grpc_generator::Service *service,
+    grpc_java_generator::Parameters *parameters) {
   grpc::string out;
   auto printer = file->CreatePrinter(&out);
   VARS vars;
diff -urN a/grpc/src/compiler/python_generator.h b/grpc/src/compiler/python_generator.h
--- a/grpc/src/compiler/python_generator.h	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/python_generator.h	2023-01-13 07:46:52.933104788 +0000
@@ -21,7 +21,6 @@
 
 #include <utility>
 
-#include "src/compiler/config.h"
 #include "src/compiler/schema_interface.h"
 
 namespace grpc_python_generator {
diff -urN a/grpc/src/compiler/schema_interface.h b/grpc/src/compiler/schema_interface.h
--- a/grpc/src/compiler/schema_interface.h	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/schema_interface.h	2023-01-13 07:46:52.952104963 +0000
@@ -19,11 +19,10 @@
 #ifndef GRPC_INTERNAL_COMPILER_SCHEMA_INTERFACE_H
 #define GRPC_INTERNAL_COMPILER_SCHEMA_INTERFACE_H
 
+#include <map>
 #include <memory>
 #include <vector>
 
-#include "src/compiler/config.h"
-
 #ifndef GRPC_CUSTOM_STRING
 #  include <string>
 #  define GRPC_CUSTOM_STRING std::string
@@ -93,7 +92,7 @@
   virtual void Print(const std::map<grpc::string, grpc::string> &vars,
                      const char *template_string) = 0;
   virtual void Print(const char *string) = 0;
-  virtual void SetIndentationSize(const int size) = 0;
+  virtual void SetIndentationSize(const size_t size) = 0;
   virtual void Indent() = 0;
   virtual void Outdent() = 0;
 };
@@ -108,6 +107,8 @@
   virtual grpc::string package() const = 0;
   virtual std::vector<grpc::string> package_parts() const = 0;
   virtual grpc::string additional_headers() const = 0;
+  virtual std::string message_header_ext() const = 0;
+  virtual std::string service_header_ext() const = 0;
 
   virtual int service_count() const = 0;
   virtual std::unique_ptr<const Service> service(int i) const = 0;
diff -urN a/grpc/src/compiler/swift_generator.h b/grpc/src/compiler/swift_generator.h
--- a/grpc/src/compiler/swift_generator.h	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/swift_generator.h	2023-01-13 07:46:52.964105074 +0000
@@ -1,40 +1,22 @@
 /*
+ * Copyright 2020 Google Inc. All rights reserved.
  *
- * Copyright 2020, Google Inc.
- * All rights reserved.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include <memory>
 #include <vector>
 
-#include "src/compiler/config.h"
 #include "src/compiler/schema_interface.h"
 
 #ifndef GRPC_CUSTOM_STRING
diff -urN a/grpc/src/compiler/ts_generator.cc b/grpc/src/compiler/ts_generator.cc
--- a/grpc/src/compiler/ts_generator.cc	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/ts_generator.cc	2023-01-13 07:46:52.965105084 +0000
@@ -46,13 +46,14 @@
   return dasherized_case;
 }
 
-grpc::string GenerateNamespace(const std::vector<std::string> namepsace,
+
+grpc::string GenerateNamespace(const std::vector<std::string> ns,
                                const std::string filename,
                                const bool include_separator) {
   grpc::string path = "";
   if (include_separator) path += ".";
 
-  for (auto it = namepsace.begin(); it < namepsace.end(); it++) {
+  for (auto it = ns.begin(); it < ns.end(); it++) {
     if (include_separator) path += "/";
     path += include_separator ? ToDasherizedCase(*it) : *it + "_";
   }
@@ -105,9 +106,9 @@
   }
   printer->Print("\n");
   if (grpc_var_import)
-    printer->Print("var grpc = require('grpc');\n");
+    printer->Print("var grpc = require('@grpc/grpc-js');\n");
   else
-    printer->Print("import * as grpc from 'grpc';\n");
+    printer->Print("import * as grpc from '@grpc/grpc-js';\n");
   printer->Print("\n");
 }
 
@@ -136,7 +137,7 @@
                  "throw new Error('Expected argument of type $VALUE$');\n");
   printer->Outdent();
   printer->Print("}\n");
-  printer->Print(vars, "return buffer_args.serialize();\n");
+  printer->Print(vars, "return Buffer.from(buffer_args.serialize());\n");
   printer->Outdent();
   printer->Print("}\n\n");
 }
@@ -288,7 +289,9 @@
     const grpc_generator::Service *service, grpc_generator::Printer *printer,
     std::map<grpc::string, grpc::string> *dictonary) {
   auto vars = *dictonary;
-  printer->Print(vars, "export interface I$ServiceName$Server {\n");
+  printer->Print(vars,
+                 "export interface I$ServiceName$Server extends "
+                 "grpc.UntypedServiceImplementation {\n");
   printer->Indent();
   for (auto it = 0; it < service->method_count(); it++) {
     auto method = service->method(it);
@@ -463,7 +466,7 @@
   printer->Indent();
   printer->Print(
       "constructor(address: string, credentials: grpc.ChannelCredentials, "
-      "options?: object);");
+      "options?: object);\n");
   for (auto it = 0; it < service->method_count(); it++) {
     auto method = service->method(it);
     vars["MethodName"] = method->name();
diff -urN a/grpc/src/compiler/ts_generator.h b/grpc/src/compiler/ts_generator.h
--- a/grpc/src/compiler/ts_generator.h	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/src/compiler/ts_generator.h	2023-01-13 07:46:53.145106745 +0000
@@ -1,41 +1,7 @@
-/*
- *
- * Copyright 2020, Google Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- *     * Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- * copyright notice, this list of conditions and the following disclaimer
- * in the documentation and/or other materials provided with the
- * distribution.
- *     * Neither the name of Google Inc. nor the names of its
- * contributors may be used to endorse or promote products derived from
- * this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
 #include <memory>
-#include <vector>
 #include <set>
+#include <vector>
 
-#include "src/compiler/config.h"
 #include "src/compiler/schema_interface.h"
 
 #ifndef GRPC_CUSTOM_STRING
@@ -58,4 +24,3 @@
                                const grpc_generator::Service *service,
                                const grpc::string &filename);
 }  // namespace grpc_ts_generator
-
diff -urN a/grpc/tests/go_test.go b/grpc/tests/go_test.go
--- a/grpc/tests/go_test.go	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/tests/go_test.go	2023-01-13 07:46:49.797075827 +0000
@@ -1,8 +1,8 @@
 package testing
 
 import (
-	"../../tests/MyGame/Example"
 	flatbuffers "github.com/google/flatbuffers/go"
+	"github.com/google/flatbuffers/tests/MyGame/Example"
 
 	"context"
 	"net"
@@ -12,7 +12,9 @@
 	"google.golang.org/grpc/encoding"
 )
 
-type server struct{}
+type server struct {
+	Example.UnimplementedMonsterStorageServer
+}
 
 // test used to send and receive in grpc methods
 var test = "Flatbuffers"
@@ -65,8 +67,12 @@
 	if err != nil {
 		t.Fatalf("Retrieve client failed: %v", err)
 	}
-	if string(out.Name()) != test {
-		t.Errorf("RetrieveClient failed: expected=%s, got=%s\n", test, out.Name())
+	monster, err := out.Recv()
+	if err != nil {
+		t.Fatalf("Recv failed: %v", err)
+	}
+	if string(monster.Name()) != test {
+		t.Errorf("RetrieveClient failed: expected=%s, got=%s\n", test, monster.Name())
 		t.Fail()
 	}
 }
diff -urN a/grpc/tests/grpctest.py b/grpc/tests/grpctest.py
--- a/grpc/tests/grpctest.py	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/tests/grpctest.py	2023-01-13 07:46:49.797075827 +0000
@@ -126,16 +126,16 @@
     Monster.MonsterStartInventoryVector(b, len(test_inventory))
     for i in range(0, len(test_inventory)):
         b.PrependByte(test_inventory[i])
-    inv = b.EndVector(len(test_inventory))
+    inv = b.EndVector()
 
     Monster.MonsterStartTest4Vector(b, 2)
     Test.CreateTest(b, 10, 20)
     Test.CreateTest(b, 30, 40)
-    test4 = b.EndVector(2)
+    test4 = b.EndVector()
 
     Monster.MonsterStartTestarrayofstringVector(b, 1)
     b.PrependUOffsetTRelative(test1)
-    test_array_of_string = b.EndVector(1)
+    test_array_of_string = b.EndVector()
 
     Monster.MonsterStart(b)
 
diff -urN a/grpc/tests/message_builder_test.cpp b/grpc/tests/message_builder_test.cpp
--- a/grpc/tests/message_builder_test.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/tests/message_builder_test.cpp	2023-01-13 07:46:49.798075836 +0000
@@ -28,7 +28,7 @@
   auto root_offset1 = populate1(dst);
   dst.Finish(root_offset1);
   size_t size, offset;
-  grpc_slice slice;
+  ::grpc::Slice slice;
   dst.ReleaseRaw(size, offset, slice);
   flatbuffers::FlatBufferBuilder src;
   auto root_offset2 = populate2(src);
@@ -39,7 +39,6 @@
   TEST_EQ(dst.GetSize(), src_size);
   TEST_ASSERT(release_n_verify(dst, m2_name(), m2_color()));
   TEST_EQ(src.GetSize(), 0);
-  grpc_slice_unref(slice);
 }
 
 template<class SrcBuilder>
@@ -82,10 +81,9 @@
       auto root_offset1 = populate1(mb);
       mb.Finish(root_offset1);
       size_t size, offset;
-      grpc_slice slice;
+      ::grpc::Slice slice;
       const uint8_t *buf = mb.ReleaseRaw(size, offset, slice);
       TEST_ASSERT_FUNC(verify(buf, offset, m1_name(), m1_color()));
-      grpc_slice_unref(slice);
     }
   }
 
@@ -146,10 +144,9 @@
       auto root_offset1 = populate1(dst);
       dst.Finish(root_offset1);
       size_t size, offset;
-      grpc_slice slice = grpc_empty_slice();
+      ::grpc::Slice slice;
       const uint8_t *buf = dst.ReleaseRaw(size, offset, slice);
       TEST_ASSERT_FUNC(verify(buf, offset, m1_name(), m1_color()));
-      grpc_slice_unref(slice);
 
       SrcBuilder src;
       dst = std::move(src);
diff -urN a/grpc/tests/pom.xml b/grpc/tests/pom.xml
--- a/grpc/tests/pom.xml	2021-05-10 18:45:16.000000000 +0000
+++ b/grpc/tests/pom.xml	2023-01-13 07:46:49.798075836 +0000
@@ -4,13 +4,13 @@
     <parent>
         <groupId>com.google.flatbuffers</groupId>
         <artifactId>flatbuffers-parent</artifactId>
-        <version>2.0.0</version>
+        <version>2.0.3</version>
     </parent>
     <artifactId>grpc-test</artifactId>
     <description>Example/Test project demonstrating usage of flatbuffers with GRPC-Java instead of protobufs
     </description>
     <properties>
-        <gRPC.version>2.0.0</gRPC.version>
+        <gRPC.version>2.0.3</gRPC.version>
     </properties>
     <dependencies>
         <dependency>
diff -urN a/include/flatbuffers/allocator.h b/include/flatbuffers/allocator.h
--- a/include/flatbuffers/allocator.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/allocator.h	2023-01-13 07:47:06.299228228 +0000
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_ALLOCATOR_H_
+#define FLATBUFFERS_ALLOCATOR_H_
+
+#include "flatbuffers/base.h"
+
+namespace flatbuffers {
+
+// Allocator interface. This is flatbuffers-specific and meant only for
+// `vector_downward` usage.
+class Allocator {
+ public:
+  virtual ~Allocator() {}
+
+  // Allocate `size` bytes of memory.
+  virtual uint8_t *allocate(size_t size) = 0;
+
+  // Deallocate `size` bytes of memory at `p` allocated by this allocator.
+  virtual void deallocate(uint8_t *p, size_t size) = 0;
+
+  // Reallocate `new_size` bytes of memory, replacing the old region of size
+  // `old_size` at `p`. In contrast to a normal realloc, this grows downwards,
+  // and is intended specifcally for `vector_downward` use.
+  // `in_use_back` and `in_use_front` indicate how much of `old_size` is
+  // actually in use at each end, and needs to be copied.
+  virtual uint8_t *reallocate_downward(uint8_t *old_p, size_t old_size,
+                                       size_t new_size, size_t in_use_back,
+                                       size_t in_use_front) {
+    FLATBUFFERS_ASSERT(new_size > old_size);  // vector_downward only grows
+    uint8_t *new_p = allocate(new_size);
+    memcpy_downward(old_p, old_size, new_p, new_size, in_use_back,
+                    in_use_front);
+    deallocate(old_p, old_size);
+    return new_p;
+  }
+
+ protected:
+  // Called by `reallocate_downward` to copy memory from `old_p` of `old_size`
+  // to `new_p` of `new_size`. Only memory of size `in_use_front` and
+  // `in_use_back` will be copied from the front and back of the old memory
+  // allocation.
+  void memcpy_downward(uint8_t *old_p, size_t old_size, uint8_t *new_p,
+                       size_t new_size, size_t in_use_back,
+                       size_t in_use_front) {
+    memcpy(new_p + new_size - in_use_back, old_p + old_size - in_use_back,
+           in_use_back);
+    memcpy(new_p, old_p, in_use_front);
+  }
+};
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_ALLOCATOR_H_
\ No newline at end of file
diff -urN a/include/flatbuffers/array.h b/include/flatbuffers/array.h
--- a/include/flatbuffers/array.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/array.h	2023-01-13 07:47:06.299228228 +0000
@@ -0,0 +1,243 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_ARRAY_H_
+#define FLATBUFFERS_ARRAY_H_
+
+#include "flatbuffers/base.h"
+#include "flatbuffers/stl_emulation.h"
+#include "flatbuffers/vector.h"
+
+namespace flatbuffers {
+
+// This is used as a helper type for accessing arrays.
+template<typename T, uint16_t length> class Array {
+  // Array<T> can carry only POD data types (scalars or structs).
+  typedef typename flatbuffers::bool_constant<flatbuffers::is_scalar<T>::value>
+      scalar_tag;
+  typedef
+      typename flatbuffers::conditional<scalar_tag::value, T, const T *>::type
+          IndirectHelperType;
+
+ public:
+  typedef uint16_t size_type;
+  typedef typename IndirectHelper<IndirectHelperType>::return_type return_type;
+  typedef VectorIterator<T, return_type> const_iterator;
+  typedef VectorReverseIterator<const_iterator> const_reverse_iterator;
+
+  // If T is a LE-scalar or a struct (!scalar_tag::value).
+  static FLATBUFFERS_CONSTEXPR bool is_span_observable =
+      (scalar_tag::value && (FLATBUFFERS_LITTLEENDIAN || sizeof(T) == 1)) ||
+      !scalar_tag::value;
+
+  FLATBUFFERS_CONSTEXPR uint16_t size() const { return length; }
+
+  return_type Get(uoffset_t i) const {
+    FLATBUFFERS_ASSERT(i < size());
+    return IndirectHelper<IndirectHelperType>::Read(Data(), i);
+  }
+
+  return_type operator[](uoffset_t i) const { return Get(i); }
+
+  // If this is a Vector of enums, T will be its storage type, not the enum
+  // type. This function makes it convenient to retrieve value with enum
+  // type E.
+  template<typename E> E GetEnum(uoffset_t i) const {
+    return static_cast<E>(Get(i));
+  }
+
+  const_iterator begin() const { return const_iterator(Data(), 0); }
+  const_iterator end() const { return const_iterator(Data(), size()); }
+
+  const_reverse_iterator rbegin() const {
+    return const_reverse_iterator(end());
+  }
+  const_reverse_iterator rend() const {
+    return const_reverse_iterator(begin());
+  }
+
+  const_iterator cbegin() const { return begin(); }
+  const_iterator cend() const { return end(); }
+
+  const_reverse_iterator crbegin() const { return rbegin(); }
+  const_reverse_iterator crend() const { return rend(); }
+
+  // Get a mutable pointer to elements inside this array.
+  // This method used to mutate arrays of structs followed by a @p Mutate
+  // operation. For primitive types use @p Mutate directly.
+  // @warning Assignments and reads to/from the dereferenced pointer are not
+  //  automatically converted to the correct endianness.
+  typename flatbuffers::conditional<scalar_tag::value, void, T *>::type
+  GetMutablePointer(uoffset_t i) const {
+    FLATBUFFERS_ASSERT(i < size());
+    return const_cast<T *>(&data()[i]);
+  }
+
+  // Change elements if you have a non-const pointer to this object.
+  void Mutate(uoffset_t i, const T &val) { MutateImpl(scalar_tag(), i, val); }
+
+  // The raw data in little endian format. Use with care.
+  const uint8_t *Data() const { return data_; }
+
+  uint8_t *Data() { return data_; }
+
+  // Similarly, but typed, much like std::vector::data
+  const T *data() const { return reinterpret_cast<const T *>(Data()); }
+  T *data() { return reinterpret_cast<T *>(Data()); }
+
+  // Copy data from a span with endian conversion.
+  // If this Array and the span overlap, the behavior is undefined.
+  void CopyFromSpan(flatbuffers::span<const T, length> src) {
+    const auto p1 = reinterpret_cast<const uint8_t *>(src.data());
+    const auto p2 = Data();
+    FLATBUFFERS_ASSERT(!(p1 >= p2 && p1 < (p2 + length)) &&
+                       !(p2 >= p1 && p2 < (p1 + length)));
+    (void)p1;
+    (void)p2;
+    CopyFromSpanImpl(flatbuffers::bool_constant<is_span_observable>(), src);
+  }
+
+ protected:
+  void MutateImpl(flatbuffers::true_type, uoffset_t i, const T &val) {
+    FLATBUFFERS_ASSERT(i < size());
+    WriteScalar(data() + i, val);
+  }
+
+  void MutateImpl(flatbuffers::false_type, uoffset_t i, const T &val) {
+    *(GetMutablePointer(i)) = val;
+  }
+
+  void CopyFromSpanImpl(flatbuffers::true_type,
+                        flatbuffers::span<const T, length> src) {
+    // Use std::memcpy() instead of std::copy() to avoid performance degradation
+    // due to aliasing if T is char or unsigned char.
+    // The size is known at compile time, so memcpy would be inlined.
+    std::memcpy(data(), src.data(), length * sizeof(T));
+  }
+
+  // Copy data from flatbuffers::span with endian conversion.
+  void CopyFromSpanImpl(flatbuffers::false_type,
+                        flatbuffers::span<const T, length> src) {
+    for (size_type k = 0; k < length; k++) { Mutate(k, src[k]); }
+  }
+
+  // This class is only used to access pre-existing data. Don't ever
+  // try to construct these manually.
+  // 'constexpr' allows us to use 'size()' at compile time.
+  // @note Must not use 'FLATBUFFERS_CONSTEXPR' here, as const is not allowed on
+  //  a constructor.
+#if defined(__cpp_constexpr)
+  constexpr Array();
+#else
+  Array();
+#endif
+
+  uint8_t data_[length * sizeof(T)];
+
+ private:
+  // This class is a pointer. Copying will therefore create an invalid object.
+  // Private and unimplemented copy constructor.
+  Array(const Array &);
+  Array &operator=(const Array &);
+};
+
+// Specialization for Array[struct] with access using Offset<void> pointer.
+// This specialization used by idl_gen_text.cpp.
+template<typename T, uint16_t length> class Array<Offset<T>, length> {
+  static_assert(flatbuffers::is_same<T, void>::value, "unexpected type T");
+
+ public:
+  typedef const void *return_type;
+
+  const uint8_t *Data() const { return data_; }
+
+  // Make idl_gen_text.cpp::PrintContainer happy.
+  return_type operator[](uoffset_t) const {
+    FLATBUFFERS_ASSERT(false);
+    return nullptr;
+  }
+
+ private:
+  // This class is only used to access pre-existing data.
+  Array();
+  Array(const Array &);
+  Array &operator=(const Array &);
+
+  uint8_t data_[1];
+};
+
+template<class U, uint16_t N>
+FLATBUFFERS_CONSTEXPR_CPP11 flatbuffers::span<U, N> make_span(Array<U, N> &arr)
+    FLATBUFFERS_NOEXCEPT {
+  static_assert(
+      Array<U, N>::is_span_observable,
+      "wrong type U, only plain struct, LE-scalar, or byte types are allowed");
+  return span<U, N>(arr.data(), N);
+}
+
+template<class U, uint16_t N>
+FLATBUFFERS_CONSTEXPR_CPP11 flatbuffers::span<const U, N> make_span(
+    const Array<U, N> &arr) FLATBUFFERS_NOEXCEPT {
+  static_assert(
+      Array<U, N>::is_span_observable,
+      "wrong type U, only plain struct, LE-scalar, or byte types are allowed");
+  return span<const U, N>(arr.data(), N);
+}
+
+template<class U, uint16_t N>
+FLATBUFFERS_CONSTEXPR_CPP11 flatbuffers::span<uint8_t, sizeof(U) * N>
+make_bytes_span(Array<U, N> &arr) FLATBUFFERS_NOEXCEPT {
+  static_assert(Array<U, N>::is_span_observable,
+                "internal error, Array<T> might hold only scalars or structs");
+  return span<uint8_t, sizeof(U) * N>(arr.Data(), sizeof(U) * N);
+}
+
+template<class U, uint16_t N>
+FLATBUFFERS_CONSTEXPR_CPP11 flatbuffers::span<const uint8_t, sizeof(U) * N>
+make_bytes_span(const Array<U, N> &arr) FLATBUFFERS_NOEXCEPT {
+  static_assert(Array<U, N>::is_span_observable,
+                "internal error, Array<T> might hold only scalars or structs");
+  return span<const uint8_t, sizeof(U) * N>(arr.Data(), sizeof(U) * N);
+}
+
+// Cast a raw T[length] to a raw flatbuffers::Array<T, length>
+// without endian conversion. Use with care.
+// TODO: move these Cast-methods to `internal` namespace.
+template<typename T, uint16_t length>
+Array<T, length> &CastToArray(T (&arr)[length]) {
+  return *reinterpret_cast<Array<T, length> *>(arr);
+}
+
+template<typename T, uint16_t length>
+const Array<T, length> &CastToArray(const T (&arr)[length]) {
+  return *reinterpret_cast<const Array<T, length> *>(arr);
+}
+
+template<typename E, typename T, uint16_t length>
+Array<E, length> &CastToArrayOfEnum(T (&arr)[length]) {
+  static_assert(sizeof(E) == sizeof(T), "invalid enum type E");
+  return *reinterpret_cast<Array<E, length> *>(arr);
+}
+
+template<typename E, typename T, uint16_t length>
+const Array<E, length> &CastToArrayOfEnum(const T (&arr)[length]) {
+  static_assert(sizeof(E) == sizeof(T), "invalid enum type E");
+  return *reinterpret_cast<const Array<E, length> *>(arr);
+}
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_ARRAY_H_
diff -urN a/include/flatbuffers/base.h b/include/flatbuffers/base.h
--- a/include/flatbuffers/base.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/base.h	2023-01-13 07:47:06.299228228 +0000
@@ -50,10 +50,6 @@
   #include <unistd.h>
 #endif
 
-#ifdef _STLPORT_VERSION
-  #define FLATBUFFERS_CPP98_STL
-#endif
-
 #ifdef __ANDROID__
   #include <android/api-level.h>
 #endif
@@ -144,7 +140,7 @@
 
 #define FLATBUFFERS_VERSION_MAJOR 2
 #define FLATBUFFERS_VERSION_MINOR 0
-#define FLATBUFFERS_VERSION_REVISION 0
+#define FLATBUFFERS_VERSION_REVISION 6
 #define FLATBUFFERS_STRING_EXPAND(X) #X
 #define FLATBUFFERS_STRING(X) FLATBUFFERS_STRING_EXPAND(X)
 namespace flatbuffers {
@@ -247,6 +243,11 @@
   #endif // __has_include
 #endif // !FLATBUFFERS_HAS_STRING_VIEW
 
+#ifndef FLATBUFFERS_GENERAL_HEAP_ALLOC_OK
+  // Allow heap allocations to be used
+  #define FLATBUFFERS_GENERAL_HEAP_ALLOC_OK 1
+#endif // !FLATBUFFERS_GENERAL_HEAP_ALLOC_OK
+
 #ifndef FLATBUFFERS_HAS_NEW_STRTOD
   // Modern (C++11) strtod and strtof functions are available for use.
   // 1) nan/inf strings as argument of strtod;
@@ -289,7 +290,7 @@
 #if ((__cplusplus >= 201703L) \
     || (defined(_MSVC_LANG) &&  (_MSVC_LANG >= 201703L)))
   // All attributes unknown to an implementation are ignored without causing an error.
-  #define FLATBUFFERS_ATTRIBUTE(attr) [[attr]]
+  #define FLATBUFFERS_ATTRIBUTE(attr) attr
 
   #define FLATBUFFERS_FALLTHROUGH() [[fallthrough]]
 #else
@@ -330,6 +331,9 @@
 // We support aligning the contents of buffers up to this size.
 #define FLATBUFFERS_MAX_ALIGNMENT 16
 
+/// @brief The length of a FlatBuffer file header.
+static const size_t kFileIdentifierLength = 4;
+
 inline bool VerifyAlignmentRequirements(size_t align, size_t min_align = 1) {
   return (min_align <= align) && (align <= (FLATBUFFERS_MAX_ALIGNMENT)) &&
          (align & (align - 1)) == 0;  // must be power of 2
@@ -433,5 +437,38 @@
   return ((~buf_size) + 1) & (scalar_size - 1);
 }
 
+// Generic 'operator==' with conditional specialisations.
+// T e - new value of a scalar field.
+// T def - default of scalar (is known at compile-time).
+template<typename T> inline bool IsTheSameAs(T e, T def) { return e == def; }
+
+#if defined(FLATBUFFERS_NAN_DEFAULTS) && \
+    defined(FLATBUFFERS_HAS_NEW_STRTOD) && (FLATBUFFERS_HAS_NEW_STRTOD > 0)
+// Like `operator==(e, def)` with weak NaN if T=(float|double).
+template<typename T> inline bool IsFloatTheSameAs(T e, T def) {
+  return (e == def) || ((def != def) && (e != e));
+}
+template<> inline bool IsTheSameAs<float>(float e, float def) {
+  return IsFloatTheSameAs(e, def);
+}
+template<> inline bool IsTheSameAs<double>(double e, double def) {
+  return IsFloatTheSameAs(e, def);
+}
+#endif
+
+// Check 'v' is out of closed range [low; high].
+// Workaround for GCC warning [-Werror=type-limits]:
+// comparison is always true due to limited range of data type.
+template<typename T>
+inline bool IsOutRange(const T &v, const T &low, const T &high) {
+  return (v < low) || (high < v);
+}
+
+// Check 'v' is in closed range [low; high].
+template<typename T>
+inline bool IsInRange(const T &v, const T &low, const T &high) {
+  return !IsOutRange(v, low, high);
+}
+
 }  // namespace flatbuffers
 #endif  // FLATBUFFERS_BASE_H_
diff -urN a/include/flatbuffers/bfbs_generator.h b/include/flatbuffers/bfbs_generator.h
--- a/include/flatbuffers/bfbs_generator.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/bfbs_generator.h	2023-01-13 07:47:06.299228228 +0000
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_BFBS_GENERATOR_H_
+#define FLATBUFFERS_BFBS_GENERATOR_H_
+
+#include <cstdint>
+
+namespace flatbuffers {
+
+enum GeneratorStatus {
+  OK,
+  FAILED,
+  FAILED_VERIFICATION,
+};
+
+// A Flatbuffer Code Generator that receives a binary serialized reflection.fbs
+// and generates code from it.
+class BfbsGenerator {
+ public:
+  virtual ~BfbsGenerator() {}
+
+  // Generate code from the provided `buffer` of given `length`. The buffer is
+  // a serialized reflection.fbs.
+  virtual GeneratorStatus Generate(const uint8_t *buffer, int64_t length) = 0;
+};
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_BFBS_GENERATOR_H_
diff -urN a/include/flatbuffers/buffer.h b/include/flatbuffers/buffer.h
--- a/include/flatbuffers/buffer.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/buffer.h	2023-01-13 07:47:06.299228228 +0000
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_BUFFER_H_
+#define FLATBUFFERS_BUFFER_H_
+
+#include "flatbuffers/base.h"
+
+namespace flatbuffers {
+
+// Wrapper for uoffset_t to allow safe template specialization.
+// Value is allowed to be 0 to indicate a null object (see e.g. AddOffset).
+template<typename T> struct Offset {
+  uoffset_t o;
+  Offset() : o(0) {}
+  Offset(uoffset_t _o) : o(_o) {}
+  Offset<void> Union() const { return Offset<void>(o); }
+  bool IsNull() const { return !o; }
+};
+
+inline void EndianCheck() {
+  int endiantest = 1;
+  // If this fails, see FLATBUFFERS_LITTLEENDIAN above.
+  FLATBUFFERS_ASSERT(*reinterpret_cast<char *>(&endiantest) ==
+                     FLATBUFFERS_LITTLEENDIAN);
+  (void)endiantest;
+}
+
+template<typename T> FLATBUFFERS_CONSTEXPR size_t AlignOf() {
+  // clang-format off
+  #ifdef _MSC_VER
+    return __alignof(T);
+  #else
+    #ifndef alignof
+      return __alignof__(T);
+    #else
+      return alignof(T);
+    #endif
+  #endif
+  // clang-format on
+}
+
+// Lexicographically compare two strings (possibly containing nulls), and
+// return true if the first is less than the second.
+static inline bool StringLessThan(const char *a_data, uoffset_t a_size,
+                                  const char *b_data, uoffset_t b_size) {
+  const auto cmp = memcmp(a_data, b_data, (std::min)(a_size, b_size));
+  return cmp == 0 ? a_size < b_size : cmp < 0;
+}
+
+// When we read serialized data from memory, in the case of most scalars,
+// we want to just read T, but in the case of Offset, we want to actually
+// perform the indirection and return a pointer.
+// The template specialization below does just that.
+// It is wrapped in a struct since function templates can't overload on the
+// return type like this.
+// The typedef is for the convenience of callers of this function
+// (avoiding the need for a trailing return decltype)
+template<typename T> struct IndirectHelper {
+  typedef T return_type;
+  typedef T mutable_return_type;
+  static const size_t element_stride = sizeof(T);
+  static return_type Read(const uint8_t *p, uoffset_t i) {
+    return EndianScalar((reinterpret_cast<const T *>(p))[i]);
+  }
+};
+template<typename T> struct IndirectHelper<Offset<T>> {
+  typedef const T *return_type;
+  typedef T *mutable_return_type;
+  static const size_t element_stride = sizeof(uoffset_t);
+  static return_type Read(const uint8_t *p, uoffset_t i) {
+    p += i * sizeof(uoffset_t);
+    return reinterpret_cast<return_type>(p + ReadScalar<uoffset_t>(p));
+  }
+};
+template<typename T> struct IndirectHelper<const T *> {
+  typedef const T *return_type;
+  typedef T *mutable_return_type;
+  static const size_t element_stride = sizeof(T);
+  static return_type Read(const uint8_t *p, uoffset_t i) {
+    return reinterpret_cast<const T *>(p + i * sizeof(T));
+  }
+};
+
+/// @brief Get a pointer to the the file_identifier section of the buffer.
+/// @return Returns a const char pointer to the start of the file_identifier
+/// characters in the buffer.  The returned char * has length
+/// 'flatbuffers::FlatBufferBuilder::kFileIdentifierLength'.
+/// This function is UNDEFINED for FlatBuffers whose schema does not include
+/// a file_identifier (likely points at padding or the start of a the root
+/// vtable).
+inline const char *GetBufferIdentifier(const void *buf,
+                                       bool size_prefixed = false) {
+  return reinterpret_cast<const char *>(buf) +
+         ((size_prefixed) ? 2 * sizeof(uoffset_t) : sizeof(uoffset_t));
+}
+
+// Helper to see if the identifier in a buffer has the expected value.
+inline bool BufferHasIdentifier(const void *buf, const char *identifier,
+                                bool size_prefixed = false) {
+  return strncmp(GetBufferIdentifier(buf, size_prefixed), identifier,
+                 flatbuffers::kFileIdentifierLength) == 0;
+}
+
+/// @cond FLATBUFFERS_INTERNAL
+// Helpers to get a typed pointer to the root object contained in the buffer.
+template<typename T> T *GetMutableRoot(void *buf) {
+  EndianCheck();
+  return reinterpret_cast<T *>(
+      reinterpret_cast<uint8_t *>(buf) +
+      EndianScalar(*reinterpret_cast<uoffset_t *>(buf)));
+}
+
+template<typename T> T *GetMutableSizePrefixedRoot(void *buf) {
+  return GetMutableRoot<T>(reinterpret_cast<uint8_t *>(buf) +
+                           sizeof(uoffset_t));
+}
+
+template<typename T> const T *GetRoot(const void *buf) {
+  return GetMutableRoot<T>(const_cast<void *>(buf));
+}
+
+template<typename T> const T *GetSizePrefixedRoot(const void *buf) {
+  return GetRoot<T>(reinterpret_cast<const uint8_t *>(buf) + sizeof(uoffset_t));
+}
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_BUFFER_H_
\ No newline at end of file
diff -urN a/include/flatbuffers/buffer_ref.h b/include/flatbuffers/buffer_ref.h
--- a/include/flatbuffers/buffer_ref.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/buffer_ref.h	2023-01-13 07:47:06.299228228 +0000
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_BUFFER_REF_H_
+#define FLATBUFFERS_BUFFER_REF_H_
+
+#include "flatbuffers/base.h"
+#include "flatbuffers/verifier.h"
+
+namespace flatbuffers {
+
+// Convenient way to bundle a buffer and its length, to pass it around
+// typed by its root.
+// A BufferRef does not own its buffer.
+struct BufferRefBase {};  // for std::is_base_of
+
+template<typename T> struct BufferRef : BufferRefBase {
+  BufferRef() : buf(nullptr), len(0), must_free(false) {}
+  BufferRef(uint8_t *_buf, uoffset_t _len)
+      : buf(_buf), len(_len), must_free(false) {}
+
+  ~BufferRef() {
+    if (must_free) free(buf);
+  }
+
+  const T *GetRoot() const { return flatbuffers::GetRoot<T>(buf); }
+
+  bool Verify() {
+    Verifier verifier(buf, len);
+    return verifier.VerifyBuffer<T>(nullptr);
+  }
+
+  uint8_t *buf;
+  uoffset_t len;
+  bool must_free;
+};
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_BUFFER_REF_H_
\ No newline at end of file
diff -urN a/include/flatbuffers/default_allocator.h b/include/flatbuffers/default_allocator.h
--- a/include/flatbuffers/default_allocator.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/default_allocator.h	2023-01-13 07:47:06.299228228 +0000
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_DEFAULT_ALLOCATOR_H_
+#define FLATBUFFERS_DEFAULT_ALLOCATOR_H_
+
+#include "flatbuffers/allocator.h"
+#include "flatbuffers/base.h"
+
+namespace flatbuffers {
+
+// DefaultAllocator uses new/delete to allocate memory regions
+class DefaultAllocator : public Allocator {
+ public:
+  uint8_t *allocate(size_t size) FLATBUFFERS_OVERRIDE {
+    return new uint8_t[size];
+  }
+
+  void deallocate(uint8_t *p, size_t) FLATBUFFERS_OVERRIDE { delete[] p; }
+
+  static void dealloc(void *p, size_t) { delete[] static_cast<uint8_t *>(p); }
+};
+
+// These functions allow for a null allocator to mean use the default allocator,
+// as used by DetachedBuffer and vector_downward below.
+// This is to avoid having a statically or dynamically allocated default
+// allocator, or having to move it between the classes that may own it.
+inline uint8_t *Allocate(Allocator *allocator, size_t size) {
+  return allocator ? allocator->allocate(size)
+                   : DefaultAllocator().allocate(size);
+}
+
+inline void Deallocate(Allocator *allocator, uint8_t *p, size_t size) {
+  if (allocator)
+    allocator->deallocate(p, size);
+  else
+    DefaultAllocator().deallocate(p, size);
+}
+
+inline uint8_t *ReallocateDownward(Allocator *allocator, uint8_t *old_p,
+                                   size_t old_size, size_t new_size,
+                                   size_t in_use_back, size_t in_use_front) {
+  return allocator ? allocator->reallocate_downward(old_p, old_size, new_size,
+                                                    in_use_back, in_use_front)
+                   : DefaultAllocator().reallocate_downward(
+                         old_p, old_size, new_size, in_use_back, in_use_front);
+}
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_DEFAULT_ALLOCATOR_H_
\ No newline at end of file
diff -urN a/include/flatbuffers/detached_buffer.h b/include/flatbuffers/detached_buffer.h
--- a/include/flatbuffers/detached_buffer.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/detached_buffer.h	2023-01-13 07:47:06.299228228 +0000
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_DETACHED_BUFFER_H_
+#define FLATBUFFERS_DETACHED_BUFFER_H_
+
+#include "flatbuffers/allocator.h"
+#include "flatbuffers/base.h"
+#include "flatbuffers/default_allocator.h"
+
+namespace flatbuffers {
+
+// DetachedBuffer is a finished flatbuffer memory region, detached from its
+// builder. The original memory region and allocator are also stored so that
+// the DetachedBuffer can manage the memory lifetime.
+class DetachedBuffer {
+ public:
+  DetachedBuffer()
+      : allocator_(nullptr),
+        own_allocator_(false),
+        buf_(nullptr),
+        reserved_(0),
+        cur_(nullptr),
+        size_(0) {}
+
+  DetachedBuffer(Allocator *allocator, bool own_allocator, uint8_t *buf,
+                 size_t reserved, uint8_t *cur, size_t sz)
+      : allocator_(allocator),
+        own_allocator_(own_allocator),
+        buf_(buf),
+        reserved_(reserved),
+        cur_(cur),
+        size_(sz) {}
+
+  DetachedBuffer(DetachedBuffer &&other)
+      : allocator_(other.allocator_),
+        own_allocator_(other.own_allocator_),
+        buf_(other.buf_),
+        reserved_(other.reserved_),
+        cur_(other.cur_),
+        size_(other.size_) {
+    other.reset();
+  }
+
+  DetachedBuffer &operator=(DetachedBuffer &&other) {
+    if (this == &other) return *this;
+
+    destroy();
+
+    allocator_ = other.allocator_;
+    own_allocator_ = other.own_allocator_;
+    buf_ = other.buf_;
+    reserved_ = other.reserved_;
+    cur_ = other.cur_;
+    size_ = other.size_;
+
+    other.reset();
+
+    return *this;
+  }
+
+  ~DetachedBuffer() { destroy(); }
+
+  const uint8_t *data() const { return cur_; }
+
+  uint8_t *data() { return cur_; }
+
+  size_t size() const { return size_; }
+
+  // These may change access mode, leave these at end of public section
+  FLATBUFFERS_DELETE_FUNC(DetachedBuffer(const DetachedBuffer &other));
+  FLATBUFFERS_DELETE_FUNC(
+      DetachedBuffer &operator=(const DetachedBuffer &other));
+
+ protected:
+  Allocator *allocator_;
+  bool own_allocator_;
+  uint8_t *buf_;
+  size_t reserved_;
+  uint8_t *cur_;
+  size_t size_;
+
+  inline void destroy() {
+    if (buf_) Deallocate(allocator_, buf_, reserved_);
+    if (own_allocator_ && allocator_) { delete allocator_; }
+    reset();
+  }
+
+  inline void reset() {
+    allocator_ = nullptr;
+    own_allocator_ = false;
+    buf_ = nullptr;
+    reserved_ = 0;
+    cur_ = nullptr;
+    size_ = 0;
+  }
+};
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_DETACHED_BUFFER_H_
diff -urN a/include/flatbuffers/flatbuffer_builder.h b/include/flatbuffers/flatbuffer_builder.h
--- a/include/flatbuffers/flatbuffer_builder.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/flatbuffer_builder.h	2023-01-13 07:47:06.299228228 +0000
@@ -0,0 +1,1197 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_FLATBUFFER_BUILDER_H_
+#define FLATBUFFERS_FLATBUFFER_BUILDER_H_
+
+#include <functional>
+
+#include "flatbuffers/allocator.h"
+#include "flatbuffers/array.h"
+#include "flatbuffers/base.h"
+#include "flatbuffers/buffer_ref.h"
+#include "flatbuffers/default_allocator.h"
+#include "flatbuffers/detached_buffer.h"
+#include "flatbuffers/stl_emulation.h"
+#include "flatbuffers/string.h"
+#include "flatbuffers/struct.h"
+#include "flatbuffers/table.h"
+#include "flatbuffers/vector.h"
+#include "flatbuffers/vector_downward.h"
+#include "flatbuffers/verifier.h"
+
+namespace flatbuffers {
+
+// Converts a Field ID to a virtual table offset.
+inline voffset_t FieldIndexToOffset(voffset_t field_id) {
+  // Should correspond to what EndTable() below builds up.
+  const int fixed_fields = 2;  // Vtable size and Object Size.
+  return static_cast<voffset_t>((field_id + fixed_fields) * sizeof(voffset_t));
+}
+
+template<typename T, typename Alloc = std::allocator<T>>
+const T *data(const std::vector<T, Alloc> &v) {
+  // Eventually the returned pointer gets passed down to memcpy, so
+  // we need it to be non-null to avoid undefined behavior.
+  static uint8_t t;
+  return v.empty() ? reinterpret_cast<const T *>(&t) : &v.front();
+}
+template<typename T, typename Alloc = std::allocator<T>>
+T *data(std::vector<T, Alloc> &v) {
+  // Eventually the returned pointer gets passed down to memcpy, so
+  // we need it to be non-null to avoid undefined behavior.
+  static uint8_t t;
+  return v.empty() ? reinterpret_cast<T *>(&t) : &v.front();
+}
+
+/// @addtogroup flatbuffers_cpp_api
+/// @{
+/// @class FlatBufferBuilder
+/// @brief Helper class to hold data needed in creation of a FlatBuffer.
+/// To serialize data, you typically call one of the `Create*()` functions in
+/// the generated code, which in turn call a sequence of `StartTable`/
+/// `PushElement`/`AddElement`/`EndTable`, or the builtin `CreateString`/
+/// `CreateVector` functions. Do this is depth-first order to build up a tree to
+/// the root. `Finish()` wraps up the buffer ready for transport.
+class FlatBufferBuilder {
+ public:
+  /// @brief Default constructor for FlatBufferBuilder.
+  /// @param[in] initial_size The initial size of the buffer, in bytes. Defaults
+  /// to `1024`.
+  /// @param[in] allocator An `Allocator` to use. If null will use
+  /// `DefaultAllocator`.
+  /// @param[in] own_allocator Whether the builder/vector should own the
+  /// allocator. Defaults to / `false`.
+  /// @param[in] buffer_minalign Force the buffer to be aligned to the given
+  /// minimum alignment upon reallocation. Only needed if you intend to store
+  /// types with custom alignment AND you wish to read the buffer in-place
+  /// directly after creation.
+  explicit FlatBufferBuilder(
+      size_t initial_size = 1024, Allocator *allocator = nullptr,
+      bool own_allocator = false,
+      size_t buffer_minalign = AlignOf<largest_scalar_t>())
+      : buf_(initial_size, allocator, own_allocator, buffer_minalign),
+        num_field_loc(0),
+        max_voffset_(0),
+        nested(false),
+        finished(false),
+        minalign_(1),
+        force_defaults_(false),
+        dedup_vtables_(true),
+        string_pool(nullptr) {
+    EndianCheck();
+  }
+
+  /// @brief Move constructor for FlatBufferBuilder.
+  FlatBufferBuilder(FlatBufferBuilder &&other)
+      : buf_(1024, nullptr, false, AlignOf<largest_scalar_t>()),
+        num_field_loc(0),
+        max_voffset_(0),
+        nested(false),
+        finished(false),
+        minalign_(1),
+        force_defaults_(false),
+        dedup_vtables_(true),
+        string_pool(nullptr) {
+    EndianCheck();
+    // Default construct and swap idiom.
+    // Lack of delegating constructors in vs2010 makes it more verbose than
+    // needed.
+    Swap(other);
+  }
+
+  /// @brief Move assignment operator for FlatBufferBuilder.
+  FlatBufferBuilder &operator=(FlatBufferBuilder &&other) {
+    // Move construct a temporary and swap idiom
+    FlatBufferBuilder temp(std::move(other));
+    Swap(temp);
+    return *this;
+  }
+
+  void Swap(FlatBufferBuilder &other) {
+    using std::swap;
+    buf_.swap(other.buf_);
+    swap(num_field_loc, other.num_field_loc);
+    swap(max_voffset_, other.max_voffset_);
+    swap(nested, other.nested);
+    swap(finished, other.finished);
+    swap(minalign_, other.minalign_);
+    swap(force_defaults_, other.force_defaults_);
+    swap(dedup_vtables_, other.dedup_vtables_);
+    swap(string_pool, other.string_pool);
+  }
+
+  ~FlatBufferBuilder() {
+    if (string_pool) delete string_pool;
+  }
+
+  void Reset() {
+    Clear();       // clear builder state
+    buf_.reset();  // deallocate buffer
+  }
+
+  /// @brief Reset all the state in this FlatBufferBuilder so it can be reused
+  /// to construct another buffer.
+  void Clear() {
+    ClearOffsets();
+    buf_.clear();
+    nested = false;
+    finished = false;
+    minalign_ = 1;
+    if (string_pool) string_pool->clear();
+  }
+
+  /// @brief The current size of the serialized buffer, counting from the end.
+  /// @return Returns an `uoffset_t` with the current size of the buffer.
+  uoffset_t GetSize() const { return buf_.size(); }
+
+  /// @brief Get the serialized buffer (after you call `Finish()`).
+  /// @return Returns an `uint8_t` pointer to the FlatBuffer data inside the
+  /// buffer.
+  uint8_t *GetBufferPointer() const {
+    Finished();
+    return buf_.data();
+  }
+
+  /// @brief Get the serialized buffer (after you call `Finish()`) as a span.
+  /// @return Returns a constructed flatbuffers::span that is a view over the
+  /// FlatBuffer data inside the buffer.
+  flatbuffers::span<uint8_t> GetBufferSpan() const {
+    Finished();
+    return flatbuffers::span<uint8_t>(buf_.data(), buf_.size());
+  }
+
+  /// @brief Get a pointer to an unfinished buffer.
+  /// @return Returns a `uint8_t` pointer to the unfinished buffer.
+  uint8_t *GetCurrentBufferPointer() const { return buf_.data(); }
+
+  /// @brief Get the released pointer to the serialized buffer.
+  /// @warning Do NOT attempt to use this FlatBufferBuilder afterwards!
+  /// @return A `FlatBuffer` that owns the buffer and its allocator and
+  /// behaves similar to a `unique_ptr` with a deleter.
+  FLATBUFFERS_ATTRIBUTE([[deprecated("use Release() instead")]])
+  DetachedBuffer ReleaseBufferPointer() {
+    Finished();
+    return buf_.release();
+  }
+
+  /// @brief Get the released DetachedBuffer.
+  /// @return A `DetachedBuffer` that owns the buffer and its allocator.
+  DetachedBuffer Release() {
+    Finished();
+    return buf_.release();
+  }
+
+  /// @brief Get the released pointer to the serialized buffer.
+  /// @param size The size of the memory block containing
+  /// the serialized `FlatBuffer`.
+  /// @param offset The offset from the released pointer where the finished
+  /// `FlatBuffer` starts.
+  /// @return A raw pointer to the start of the memory block containing
+  /// the serialized `FlatBuffer`.
+  /// @remark If the allocator is owned, it gets deleted when the destructor is
+  /// called..
+  uint8_t *ReleaseRaw(size_t &size, size_t &offset) {
+    Finished();
+    return buf_.release_raw(size, offset);
+  }
+
+  /// @brief get the minimum alignment this buffer needs to be accessed
+  /// properly. This is only known once all elements have been written (after
+  /// you call Finish()). You can use this information if you need to embed
+  /// a FlatBuffer in some other buffer, such that you can later read it
+  /// without first having to copy it into its own buffer.
+  size_t GetBufferMinAlignment() const {
+    Finished();
+    return minalign_;
+  }
+
+  /// @cond FLATBUFFERS_INTERNAL
+  void Finished() const {
+    // If you get this assert, you're attempting to get access a buffer
+    // which hasn't been finished yet. Be sure to call
+    // FlatBufferBuilder::Finish with your root table.
+    // If you really need to access an unfinished buffer, call
+    // GetCurrentBufferPointer instead.
+    FLATBUFFERS_ASSERT(finished);
+  }
+  /// @endcond
+
+  /// @brief In order to save space, fields that are set to their default value
+  /// don't get serialized into the buffer.
+  /// @param[in] fd When set to `true`, always serializes default values that
+  /// are set. Optional fields which are not set explicitly, will still not be
+  /// serialized.
+  void ForceDefaults(bool fd) { force_defaults_ = fd; }
+
+  /// @brief By default vtables are deduped in order to save space.
+  /// @param[in] dedup When set to `true`, dedup vtables.
+  void DedupVtables(bool dedup) { dedup_vtables_ = dedup; }
+
+  /// @cond FLATBUFFERS_INTERNAL
+  void Pad(size_t num_bytes) { buf_.fill(num_bytes); }
+
+  void TrackMinAlign(size_t elem_size) {
+    if (elem_size > minalign_) minalign_ = elem_size;
+  }
+
+  void Align(size_t elem_size) {
+    TrackMinAlign(elem_size);
+    buf_.fill(PaddingBytes(buf_.size(), elem_size));
+  }
+
+  void PushFlatBuffer(const uint8_t *bytes, size_t size) {
+    PushBytes(bytes, size);
+    finished = true;
+  }
+
+  void PushBytes(const uint8_t *bytes, size_t size) { buf_.push(bytes, size); }
+
+  void PopBytes(size_t amount) { buf_.pop(amount); }
+
+  template<typename T> void AssertScalarT() {
+    // The code assumes power of 2 sizes and endian-swap-ability.
+    static_assert(flatbuffers::is_scalar<T>::value, "T must be a scalar type");
+  }
+
+  // Write a single aligned scalar to the buffer
+  template<typename T> uoffset_t PushElement(T element) {
+    AssertScalarT<T>();
+    Align(sizeof(T));
+    buf_.push_small(EndianScalar(element));
+    return GetSize();
+  }
+
+  template<typename T> uoffset_t PushElement(Offset<T> off) {
+    // Special case for offsets: see ReferTo below.
+    return PushElement(ReferTo(off.o));
+  }
+
+  // When writing fields, we track where they are, so we can create correct
+  // vtables later.
+  void TrackField(voffset_t field, uoffset_t off) {
+    FieldLoc fl = { off, field };
+    buf_.scratch_push_small(fl);
+    num_field_loc++;
+    if (field > max_voffset_) { max_voffset_ = field; }
+  }
+
+  // Like PushElement, but additionally tracks the field this represents.
+  template<typename T> void AddElement(voffset_t field, T e, T def) {
+    // We don't serialize values equal to the default.
+    if (IsTheSameAs(e, def) && !force_defaults_) return;
+    TrackField(field, PushElement(e));
+  }
+
+  template<typename T> void AddElement(voffset_t field, T e) {
+    TrackField(field, PushElement(e));
+  }
+
+  template<typename T> void AddOffset(voffset_t field, Offset<T> off) {
+    if (off.IsNull()) return;  // Don't store.
+    AddElement(field, ReferTo(off.o), static_cast<uoffset_t>(0));
+  }
+
+  template<typename T> void AddStruct(voffset_t field, const T *structptr) {
+    if (!structptr) return;  // Default, don't store.
+    Align(AlignOf<T>());
+    buf_.push_small(*structptr);
+    TrackField(field, GetSize());
+  }
+
+  void AddStructOffset(voffset_t field, uoffset_t off) {
+    TrackField(field, off);
+  }
+
+  // Offsets initially are relative to the end of the buffer (downwards).
+  // This function converts them to be relative to the current location
+  // in the buffer (when stored here), pointing upwards.
+  uoffset_t ReferTo(uoffset_t off) {
+    // Align to ensure GetSize() below is correct.
+    Align(sizeof(uoffset_t));
+    // Offset must refer to something already in buffer.
+    const uoffset_t size = GetSize();
+    FLATBUFFERS_ASSERT(off && off <= size);
+    return size - off + static_cast<uoffset_t>(sizeof(uoffset_t));
+  }
+
+  void NotNested() {
+    // If you hit this, you're trying to construct a Table/Vector/String
+    // during the construction of its parent table (between the MyTableBuilder
+    // and table.Finish().
+    // Move the creation of these sub-objects to above the MyTableBuilder to
+    // not get this assert.
+    // Ignoring this assert may appear to work in simple cases, but the reason
+    // it is here is that storing objects in-line may cause vtable offsets
+    // to not fit anymore. It also leads to vtable duplication.
+    FLATBUFFERS_ASSERT(!nested);
+    // If you hit this, fields were added outside the scope of a table.
+    FLATBUFFERS_ASSERT(!num_field_loc);
+  }
+
+  // From generated code (or from the parser), we call StartTable/EndTable
+  // with a sequence of AddElement calls in between.
+  uoffset_t StartTable() {
+    NotNested();
+    nested = true;
+    return GetSize();
+  }
+
+  // This finishes one serialized object by generating the vtable if it's a
+  // table, comparing it against existing vtables, and writing the
+  // resulting vtable offset.
+  uoffset_t EndTable(uoffset_t start) {
+    // If you get this assert, a corresponding StartTable wasn't called.
+    FLATBUFFERS_ASSERT(nested);
+    // Write the vtable offset, which is the start of any Table.
+    // We fill it's value later.
+    auto vtableoffsetloc = PushElement<soffset_t>(0);
+    // Write a vtable, which consists entirely of voffset_t elements.
+    // It starts with the number of offsets, followed by a type id, followed
+    // by the offsets themselves. In reverse:
+    // Include space for the last offset and ensure empty tables have a
+    // minimum size.
+    max_voffset_ =
+        (std::max)(static_cast<voffset_t>(max_voffset_ + sizeof(voffset_t)),
+                   FieldIndexToOffset(0));
+    buf_.fill_big(max_voffset_);
+    auto table_object_size = vtableoffsetloc - start;
+    // Vtable use 16bit offsets.
+    FLATBUFFERS_ASSERT(table_object_size < 0x10000);
+    WriteScalar<voffset_t>(buf_.data() + sizeof(voffset_t),
+                           static_cast<voffset_t>(table_object_size));
+    WriteScalar<voffset_t>(buf_.data(), max_voffset_);
+    // Write the offsets into the table
+    for (auto it = buf_.scratch_end() - num_field_loc * sizeof(FieldLoc);
+         it < buf_.scratch_end(); it += sizeof(FieldLoc)) {
+      auto field_location = reinterpret_cast<FieldLoc *>(it);
+      auto pos = static_cast<voffset_t>(vtableoffsetloc - field_location->off);
+      // If this asserts, it means you've set a field twice.
+      FLATBUFFERS_ASSERT(
+          !ReadScalar<voffset_t>(buf_.data() + field_location->id));
+      WriteScalar<voffset_t>(buf_.data() + field_location->id, pos);
+    }
+    ClearOffsets();
+    auto vt1 = reinterpret_cast<voffset_t *>(buf_.data());
+    auto vt1_size = ReadScalar<voffset_t>(vt1);
+    auto vt_use = GetSize();
+    // See if we already have generated a vtable with this exact same
+    // layout before. If so, make it point to the old one, remove this one.
+    if (dedup_vtables_) {
+      for (auto it = buf_.scratch_data(); it < buf_.scratch_end();
+           it += sizeof(uoffset_t)) {
+        auto vt_offset_ptr = reinterpret_cast<uoffset_t *>(it);
+        auto vt2 = reinterpret_cast<voffset_t *>(buf_.data_at(*vt_offset_ptr));
+        auto vt2_size = ReadScalar<voffset_t>(vt2);
+        if (vt1_size != vt2_size || 0 != memcmp(vt2, vt1, vt1_size)) continue;
+        vt_use = *vt_offset_ptr;
+        buf_.pop(GetSize() - vtableoffsetloc);
+        break;
+      }
+    }
+    // If this is a new vtable, remember it.
+    if (vt_use == GetSize()) { buf_.scratch_push_small(vt_use); }
+    // Fill the vtable offset we created above.
+    // The offset points from the beginning of the object to where the
+    // vtable is stored.
+    // Offsets default direction is downward in memory for future format
+    // flexibility (storing all vtables at the start of the file).
+    WriteScalar(buf_.data_at(vtableoffsetloc),
+                static_cast<soffset_t>(vt_use) -
+                    static_cast<soffset_t>(vtableoffsetloc));
+
+    nested = false;
+    return vtableoffsetloc;
+  }
+
+  FLATBUFFERS_ATTRIBUTE([[deprecated("call the version above instead")]])
+  uoffset_t EndTable(uoffset_t start, voffset_t /*numfields*/) {
+    return EndTable(start);
+  }
+
+  // This checks a required field has been set in a given table that has
+  // just been constructed.
+  template<typename T> void Required(Offset<T> table, voffset_t field);
+
+  uoffset_t StartStruct(size_t alignment) {
+    Align(alignment);
+    return GetSize();
+  }
+
+  uoffset_t EndStruct() { return GetSize(); }
+
+  void ClearOffsets() {
+    buf_.scratch_pop(num_field_loc * sizeof(FieldLoc));
+    num_field_loc = 0;
+    max_voffset_ = 0;
+  }
+
+  // Aligns such that when "len" bytes are written, an object can be written
+  // after it with "alignment" without padding.
+  void PreAlign(size_t len, size_t alignment) {
+    TrackMinAlign(alignment);
+    buf_.fill(PaddingBytes(GetSize() + len, alignment));
+  }
+  template<typename T> void PreAlign(size_t len) {
+    AssertScalarT<T>();
+    PreAlign(len, sizeof(T));
+  }
+  /// @endcond
+
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// @param[in] str A const char pointer to the data to be stored as a string.
+  /// @param[in] len The number of bytes that should be stored from `str`.
+  /// @return Returns the offset in the buffer where the string starts.
+  Offset<String> CreateString(const char *str, size_t len) {
+    NotNested();
+    PreAlign<uoffset_t>(len + 1);  // Always 0-terminated.
+    buf_.fill(1);
+    PushBytes(reinterpret_cast<const uint8_t *>(str), len);
+    PushElement(static_cast<uoffset_t>(len));
+    return Offset<String>(GetSize());
+  }
+
+  /// @brief Store a string in the buffer, which is null-terminated.
+  /// @param[in] str A const char pointer to a C-string to add to the buffer.
+  /// @return Returns the offset in the buffer where the string starts.
+  Offset<String> CreateString(const char *str) {
+    return CreateString(str, strlen(str));
+  }
+
+  /// @brief Store a string in the buffer, which is null-terminated.
+  /// @param[in] str A char pointer to a C-string to add to the buffer.
+  /// @return Returns the offset in the buffer where the string starts.
+  Offset<String> CreateString(char *str) {
+    return CreateString(str, strlen(str));
+  }
+
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// @param[in] str A const reference to a std::string to store in the buffer.
+  /// @return Returns the offset in the buffer where the string starts.
+  Offset<String> CreateString(const std::string &str) {
+    return CreateString(str.c_str(), str.length());
+  }
+
+  // clang-format off
+  #ifdef FLATBUFFERS_HAS_STRING_VIEW
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// @param[in] str A const string_view to copy in to the buffer.
+  /// @return Returns the offset in the buffer where the string starts.
+  Offset<String> CreateString(flatbuffers::string_view str) {
+    return CreateString(str.data(), str.size());
+  }
+  #endif // FLATBUFFERS_HAS_STRING_VIEW
+  // clang-format on
+
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// @param[in] str A const pointer to a `String` struct to add to the buffer.
+  /// @return Returns the offset in the buffer where the string starts
+  Offset<String> CreateString(const String *str) {
+    return str ? CreateString(str->c_str(), str->size()) : 0;
+  }
+
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// @param[in] str A const reference to a std::string like type with support
+  /// of T::c_str() and T::length() to store in the buffer.
+  /// @return Returns the offset in the buffer where the string starts.
+  template<typename T> Offset<String> CreateString(const T &str) {
+    return CreateString(str.c_str(), str.length());
+  }
+
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// If a string with this exact contents has already been serialized before,
+  /// instead simply returns the offset of the existing string. This uses a map
+  /// stored on the heap, but only stores the numerical offsets.
+  /// @param[in] str A const char pointer to the data to be stored as a string.
+  /// @param[in] len The number of bytes that should be stored from `str`.
+  /// @return Returns the offset in the buffer where the string starts.
+  Offset<String> CreateSharedString(const char *str, size_t len) {
+    FLATBUFFERS_ASSERT(FLATBUFFERS_GENERAL_HEAP_ALLOC_OK);
+    if (!string_pool)
+      string_pool = new StringOffsetMap(StringOffsetCompare(buf_));
+    auto size_before_string = buf_.size();
+    // Must first serialize the string, since the set is all offsets into
+    // buffer.
+    auto off = CreateString(str, len);
+    auto it = string_pool->find(off);
+    // If it exists we reuse existing serialized data!
+    if (it != string_pool->end()) {
+      // We can remove the string we serialized.
+      buf_.pop(buf_.size() - size_before_string);
+      return *it;
+    }
+    // Record this string for future use.
+    string_pool->insert(off);
+    return off;
+  }
+
+#ifdef FLATBUFFERS_HAS_STRING_VIEW
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// If a string with this exact contents has already been serialized before,
+  /// instead simply returns the offset of the existing string. This uses a map
+  /// stored on the heap, but only stores the numerical offsets.
+  /// @param[in] str A const std::string_view to store in the buffer.
+  /// @return Returns the offset in the buffer where the string starts
+  Offset<String> CreateSharedString(const flatbuffers::string_view str) {
+    return CreateSharedString(str.data(), str.size());
+  }
+#else
+  /// @brief Store a string in the buffer, which null-terminated.
+  /// If a string with this exact contents has already been serialized before,
+  /// instead simply returns the offset of the existing string. This uses a map
+  /// stored on the heap, but only stores the numerical offsets.
+  /// @param[in] str A const char pointer to a C-string to add to the buffer.
+  /// @return Returns the offset in the buffer where the string starts.
+  Offset<String> CreateSharedString(const char *str) {
+    return CreateSharedString(str, strlen(str));
+  }
+
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// If a string with this exact contents has already been serialized before,
+  /// instead simply returns the offset of the existing string. This uses a map
+  /// stored on the heap, but only stores the numerical offsets.
+  /// @param[in] str A const reference to a std::string to store in the buffer.
+  /// @return Returns the offset in the buffer where the string starts.
+  Offset<String> CreateSharedString(const std::string &str) {
+    return CreateSharedString(str.c_str(), str.length());
+  }
+#endif
+
+  /// @brief Store a string in the buffer, which can contain any binary data.
+  /// If a string with this exact contents has already been serialized before,
+  /// instead simply returns the offset of the existing string. This uses a map
+  /// stored on the heap, but only stores the numerical offsets.
+  /// @param[in] str A const pointer to a `String` struct to add to the buffer.
+  /// @return Returns the offset in the buffer where the string starts
+  Offset<String> CreateSharedString(const String *str) {
+    return CreateSharedString(str->c_str(), str->size());
+  }
+
+  /// @cond FLATBUFFERS_INTERNAL
+  uoffset_t EndVector(size_t len) {
+    FLATBUFFERS_ASSERT(nested);  // Hit if no corresponding StartVector.
+    nested = false;
+    return PushElement(static_cast<uoffset_t>(len));
+  }
+
+  void StartVector(size_t len, size_t elemsize) {
+    NotNested();
+    nested = true;
+    PreAlign<uoffset_t>(len * elemsize);
+    PreAlign(len * elemsize, elemsize);  // Just in case elemsize > uoffset_t.
+  }
+
+  // Call this right before StartVector/CreateVector if you want to force the
+  // alignment to be something different than what the element size would
+  // normally dictate.
+  // This is useful when storing a nested_flatbuffer in a vector of bytes,
+  // or when storing SIMD floats, etc.
+  void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {
+    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));
+    PreAlign(len * elemsize, alignment);
+  }
+
+  // Similar to ForceVectorAlignment but for String fields.
+  void ForceStringAlignment(size_t len, size_t alignment) {
+    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));
+    PreAlign((len + 1) * sizeof(char), alignment);
+  }
+
+  /// @endcond
+
+  /// @brief Serialize an array into a FlatBuffer `vector`.
+  /// @tparam T The data type of the array elements.
+  /// @param[in] v A pointer to the array of type `T` to serialize into the
+  /// buffer as a `vector`.
+  /// @param[in] len The number of elements to serialize.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T> Offset<Vector<T>> CreateVector(const T *v, size_t len) {
+    // If this assert hits, you're specifying a template argument that is
+    // causing the wrong overload to be selected, remove it.
+    AssertScalarT<T>();
+    StartVector(len, sizeof(T));
+    if (len == 0) { return Offset<Vector<T>>(EndVector(len)); }
+    // clang-format off
+    #if FLATBUFFERS_LITTLEENDIAN
+      PushBytes(reinterpret_cast<const uint8_t *>(v), len * sizeof(T));
+    #else
+      if (sizeof(T) == 1) {
+        PushBytes(reinterpret_cast<const uint8_t *>(v), len);
+      } else {
+        for (auto i = len; i > 0; ) {
+          PushElement(v[--i]);
+        }
+      }
+    #endif
+    // clang-format on
+    return Offset<Vector<T>>(EndVector(len));
+  }
+
+  /// @brief Serialize an array like object into a FlatBuffer `vector`.
+  /// @tparam T The data type of the array elements.
+  /// @tparam C The type of the array.
+  /// @param[in] array A reference to an array like object of type `T` to
+  /// serialize into the buffer as a `vector`.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, class C> Offset<Vector<T>> CreateVector(const C &array) {
+    return CreateVector(array.data(), array.size());
+  }
+
+  template<typename T>
+  Offset<Vector<Offset<T>>> CreateVector(const Offset<T> *v, size_t len) {
+    StartVector(len, sizeof(Offset<T>));
+    for (auto i = len; i > 0;) { PushElement(v[--i]); }
+    return Offset<Vector<Offset<T>>>(EndVector(len));
+  }
+
+  /// @brief Serialize a `std::vector` into a FlatBuffer `vector`.
+  /// @tparam T The data type of the `std::vector` elements.
+  /// @param v A const reference to the `std::vector` to serialize into the
+  /// buffer as a `vector`.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename Alloc = std::allocator<T>>
+  Offset<Vector<T>> CreateVector(const std::vector<T, Alloc> &v) {
+    return CreateVector(data(v), v.size());
+  }
+
+  // vector<bool> may be implemented using a bit-set, so we can't access it as
+  // an array. Instead, read elements manually.
+  // Background: https://isocpp.org/blog/2012/11/on-vectorbool
+  Offset<Vector<uint8_t>> CreateVector(const std::vector<bool> &v) {
+    StartVector(v.size(), sizeof(uint8_t));
+    for (auto i = v.size(); i > 0;) {
+      PushElement(static_cast<uint8_t>(v[--i]));
+    }
+    return Offset<Vector<uint8_t>>(EndVector(v.size()));
+  }
+
+  /// @brief Serialize values returned by a function into a FlatBuffer `vector`.
+  /// This is a convenience function that takes care of iteration for you.
+  /// @tparam T The data type of the `std::vector` elements.
+  /// @param f A function that takes the current iteration 0..vector_size-1 and
+  /// returns any type that you can construct a FlatBuffers vector out of.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T>
+  Offset<Vector<T>> CreateVector(size_t vector_size,
+                                 const std::function<T(size_t i)> &f) {
+    FLATBUFFERS_ASSERT(FLATBUFFERS_GENERAL_HEAP_ALLOC_OK);
+    std::vector<T> elems(vector_size);
+    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i);
+    return CreateVector(elems);
+  }
+
+  /// @brief Serialize values returned by a function into a FlatBuffer `vector`.
+  /// This is a convenience function that takes care of iteration for you. This
+  /// uses a vector stored on the heap to store the intermediate results of the
+  /// iteration.
+  /// @tparam T The data type of the `std::vector` elements.
+  /// @param f A function that takes the current iteration 0..vector_size-1,
+  /// and the state parameter returning any type that you can construct a
+  /// FlatBuffers vector out of.
+  /// @param state State passed to f.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename F, typename S>
+  Offset<Vector<T>> CreateVector(size_t vector_size, F f, S *state) {
+    FLATBUFFERS_ASSERT(FLATBUFFERS_GENERAL_HEAP_ALLOC_OK);
+    std::vector<T> elems(vector_size);
+    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i, state);
+    return CreateVector(elems);
+  }
+
+  /// @brief Serialize a `std::vector<std::string>` into a FlatBuffer `vector`.
+  /// This is a convenience function for a common case.
+  /// @param v A const reference to the `std::vector` to serialize into the
+  /// buffer as a `vector`.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename Alloc = std::allocator<std::string>>
+  Offset<Vector<Offset<String>>> CreateVectorOfStrings(
+      const std::vector<std::string, Alloc> &v) {
+    return CreateVectorOfStrings(v.cbegin(), v.cend());
+  }
+
+  /// @brief Serialize a collection of Strings into a FlatBuffer `vector`.
+  /// This is a convenience function for a common case.
+  /// @param begin The begining iterator of the collection
+  /// @param end The ending iterator of the collection
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<class It>
+  Offset<Vector<Offset<String>>> CreateVectorOfStrings(It begin, It end) {
+    auto size = std::distance(begin, end);
+    auto scratch_buffer_usage = size * sizeof(Offset<String>);
+    // If there is not enough space to store the offsets, there definitely won't
+    // be enough space to store all the strings. So ensuring space for the
+    // scratch region is OK, for it it fails, it would have failed later.
+    buf_.ensure_space(scratch_buffer_usage);
+    for (auto it = begin; it != end; ++it) {
+      buf_.scratch_push_small(CreateString(*it));
+    }
+    StartVector(size, sizeof(Offset<String>));
+    for (auto i = 1; i <= size; i++) {
+      // Note we re-evaluate the buf location each iteration to account for any
+      // underlying buffer resizing that may occur.
+      PushElement(*reinterpret_cast<Offset<String> *>(
+          buf_.scratch_end() - i * sizeof(Offset<String>)));
+    }
+    buf_.scratch_pop(scratch_buffer_usage);
+    return Offset<Vector<Offset<String>>>(EndVector(size));
+  }
+
+  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
+  /// @tparam T The data type of the struct array elements.
+  /// @param[in] v A pointer to the array of type `T` to serialize into the
+  /// buffer as a `vector`.
+  /// @param[in] len The number of elements to serialize.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T>
+  Offset<Vector<const T *>> CreateVectorOfStructs(const T *v, size_t len) {
+    StartVector(len * sizeof(T) / AlignOf<T>(), AlignOf<T>());
+    if (len > 0) {
+      PushBytes(reinterpret_cast<const uint8_t *>(v), sizeof(T) * len);
+    }
+    return Offset<Vector<const T *>>(EndVector(len));
+  }
+
+  /// @brief Serialize an array of native structs into a FlatBuffer `vector`.
+  /// @tparam T The data type of the struct array elements.
+  /// @tparam S The data type of the native struct array elements.
+  /// @param[in] v A pointer to the array of type `S` to serialize into the
+  /// buffer as a `vector`.
+  /// @param[in] len The number of elements to serialize.
+  /// @param[in] pack_func Pointer to a function to convert the native struct
+  /// to the FlatBuffer struct.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename S>
+  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
+      const S *v, size_t len, T (*const pack_func)(const S &)) {
+    FLATBUFFERS_ASSERT(pack_func);
+    auto structs = StartVectorOfStructs<T>(len);
+    for (size_t i = 0; i < len; i++) { structs[i] = pack_func(v[i]); }
+    return EndVectorOfStructs<T>(len);
+  }
+
+  /// @brief Serialize an array of native structs into a FlatBuffer `vector`.
+  /// @tparam T The data type of the struct array elements.
+  /// @tparam S The data type of the native struct array elements.
+  /// @param[in] v A pointer to the array of type `S` to serialize into the
+  /// buffer as a `vector`.
+  /// @param[in] len The number of elements to serialize.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename S>
+  Offset<Vector<const T *>> CreateVectorOfNativeStructs(const S *v,
+                                                        size_t len) {
+    extern T Pack(const S &);
+    return CreateVectorOfNativeStructs(v, len, Pack);
+  }
+
+  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
+  /// @tparam T The data type of the struct array elements.
+  /// @param[in] filler A function that takes the current iteration
+  /// 0..vector_size-1 and a pointer to the struct that must be filled.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  /// This is mostly useful when flatbuffers are generated with mutation
+  /// accessors.
+  template<typename T>
+  Offset<Vector<const T *>> CreateVectorOfStructs(
+      size_t vector_size, const std::function<void(size_t i, T *)> &filler) {
+    T *structs = StartVectorOfStructs<T>(vector_size);
+    for (size_t i = 0; i < vector_size; i++) {
+      filler(i, structs);
+      structs++;
+    }
+    return EndVectorOfStructs<T>(vector_size);
+  }
+
+  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
+  /// @tparam T The data type of the struct array elements.
+  /// @param[in] f A function that takes the current iteration 0..vector_size-1,
+  /// a pointer to the struct that must be filled and the state argument.
+  /// @param[in] state Arbitrary state to pass to f.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  /// This is mostly useful when flatbuffers are generated with mutation
+  /// accessors.
+  template<typename T, typename F, typename S>
+  Offset<Vector<const T *>> CreateVectorOfStructs(size_t vector_size, F f,
+                                                  S *state) {
+    T *structs = StartVectorOfStructs<T>(vector_size);
+    for (size_t i = 0; i < vector_size; i++) {
+      f(i, structs, state);
+      structs++;
+    }
+    return EndVectorOfStructs<T>(vector_size);
+  }
+
+  /// @brief Serialize a `std::vector` of structs into a FlatBuffer `vector`.
+  /// @tparam T The data type of the `std::vector` struct elements.
+  /// @param[in] v A const reference to the `std::vector` of structs to
+  /// serialize into the buffer as a `vector`.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename Alloc = std::allocator<T>>
+  Offset<Vector<const T *>> CreateVectorOfStructs(
+      const std::vector<T, Alloc> &v) {
+    return CreateVectorOfStructs(data(v), v.size());
+  }
+
+  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
+  /// `vector`.
+  /// @tparam T The data type of the `std::vector` struct elements.
+  /// @tparam S The data type of the `std::vector` native struct elements.
+  /// @param[in] v A const reference to the `std::vector` of structs to
+  /// serialize into the buffer as a `vector`.
+  /// @param[in] pack_func Pointer to a function to convert the native struct
+  /// to the FlatBuffer struct.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename S, typename Alloc = std::allocator<T>>
+  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
+      const std::vector<S, Alloc> &v, T (*const pack_func)(const S &)) {
+    return CreateVectorOfNativeStructs<T, S>(data(v), v.size(), pack_func);
+  }
+
+  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
+  /// `vector`.
+  /// @tparam T The data type of the `std::vector` struct elements.
+  /// @tparam S The data type of the `std::vector` native struct elements.
+  /// @param[in] v A const reference to the `std::vector` of structs to
+  /// serialize into the buffer as a `vector`.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename S, typename Alloc = std::allocator<S>>
+  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
+      const std::vector<S, Alloc> &v) {
+    return CreateVectorOfNativeStructs<T, S>(data(v), v.size());
+  }
+
+  /// @cond FLATBUFFERS_INTERNAL
+  template<typename T> struct StructKeyComparator {
+    bool operator()(const T &a, const T &b) const {
+      return a.KeyCompareLessThan(&b);
+    }
+  };
+  /// @endcond
+
+  /// @brief Serialize a `std::vector` of structs into a FlatBuffer `vector`
+  /// in sorted order.
+  /// @tparam T The data type of the `std::vector` struct elements.
+  /// @param[in] v A const reference to the `std::vector` of structs to
+  /// serialize into the buffer as a `vector`.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename Alloc = std::allocator<T>>
+  Offset<Vector<const T *>> CreateVectorOfSortedStructs(
+      std::vector<T, Alloc> *v) {
+    return CreateVectorOfSortedStructs(data(*v), v->size());
+  }
+
+  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
+  /// `vector` in sorted order.
+  /// @tparam T The data type of the `std::vector` struct elements.
+  /// @tparam S The data type of the `std::vector` native struct elements.
+  /// @param[in] v A const reference to the `std::vector` of structs to
+  /// serialize into the buffer as a `vector`.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename S, typename Alloc = std::allocator<T>>
+  Offset<Vector<const T *>> CreateVectorOfSortedNativeStructs(
+      std::vector<S, Alloc> *v) {
+    return CreateVectorOfSortedNativeStructs<T, S>(data(*v), v->size());
+  }
+
+  /// @brief Serialize an array of structs into a FlatBuffer `vector` in sorted
+  /// order.
+  /// @tparam T The data type of the struct array elements.
+  /// @param[in] v A pointer to the array of type `T` to serialize into the
+  /// buffer as a `vector`.
+  /// @param[in] len The number of elements to serialize.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T>
+  Offset<Vector<const T *>> CreateVectorOfSortedStructs(T *v, size_t len) {
+    std::stable_sort(v, v + len, StructKeyComparator<T>());
+    return CreateVectorOfStructs(v, len);
+  }
+
+  /// @brief Serialize an array of native structs into a FlatBuffer `vector` in
+  /// sorted order.
+  /// @tparam T The data type of the struct array elements.
+  /// @tparam S The data type of the native struct array elements.
+  /// @param[in] v A pointer to the array of type `S` to serialize into the
+  /// buffer as a `vector`.
+  /// @param[in] len The number of elements to serialize.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename S>
+  Offset<Vector<const T *>> CreateVectorOfSortedNativeStructs(S *v,
+                                                              size_t len) {
+    extern T Pack(const S &);
+    auto structs = StartVectorOfStructs<T>(len);
+    for (size_t i = 0; i < len; i++) { structs[i] = Pack(v[i]); }
+    std::stable_sort(structs, structs + len, StructKeyComparator<T>());
+    return EndVectorOfStructs<T>(len);
+  }
+
+  /// @cond FLATBUFFERS_INTERNAL
+  template<typename T> struct TableKeyComparator {
+    TableKeyComparator(vector_downward &buf) : buf_(buf) {}
+    TableKeyComparator(const TableKeyComparator &other) : buf_(other.buf_) {}
+    bool operator()(const Offset<T> &a, const Offset<T> &b) const {
+      auto table_a = reinterpret_cast<T *>(buf_.data_at(a.o));
+      auto table_b = reinterpret_cast<T *>(buf_.data_at(b.o));
+      return table_a->KeyCompareLessThan(table_b);
+    }
+    vector_downward &buf_;
+
+   private:
+    FLATBUFFERS_DELETE_FUNC(
+        TableKeyComparator &operator=(const TableKeyComparator &other));
+  };
+  /// @endcond
+
+  /// @brief Serialize an array of `table` offsets as a `vector` in the buffer
+  /// in sorted order.
+  /// @tparam T The data type that the offset refers to.
+  /// @param[in] v An array of type `Offset<T>` that contains the `table`
+  /// offsets to store in the buffer in sorted order.
+  /// @param[in] len The number of elements to store in the `vector`.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T>
+  Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(Offset<T> *v,
+                                                       size_t len) {
+    std::stable_sort(v, v + len, TableKeyComparator<T>(buf_));
+    return CreateVector(v, len);
+  }
+
+  /// @brief Serialize an array of `table` offsets as a `vector` in the buffer
+  /// in sorted order.
+  /// @tparam T The data type that the offset refers to.
+  /// @param[in] v An array of type `Offset<T>` that contains the `table`
+  /// offsets to store in the buffer in sorted order.
+  /// @return Returns a typed `Offset` into the serialized data indicating
+  /// where the vector is stored.
+  template<typename T, typename Alloc = std::allocator<T>>
+  Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(
+      std::vector<Offset<T>, Alloc> *v) {
+    return CreateVectorOfSortedTables(data(*v), v->size());
+  }
+
+  /// @brief Specialized version of `CreateVector` for non-copying use cases.
+  /// Write the data any time later to the returned buffer pointer `buf`.
+  /// @param[in] len The number of elements to store in the `vector`.
+  /// @param[in] elemsize The size of each element in the `vector`.
+  /// @param[out] buf A pointer to a `uint8_t` pointer that can be
+  /// written to at a later time to serialize the data into a `vector`
+  /// in the buffer.
+  uoffset_t CreateUninitializedVector(size_t len, size_t elemsize,
+                                      uint8_t **buf) {
+    NotNested();
+    StartVector(len, elemsize);
+    buf_.make_space(len * elemsize);
+    auto vec_start = GetSize();
+    auto vec_end = EndVector(len);
+    *buf = buf_.data_at(vec_start);
+    return vec_end;
+  }
+
+  /// @brief Specialized version of `CreateVector` for non-copying use cases.
+  /// Write the data any time later to the returned buffer pointer `buf`.
+  /// @tparam T The data type of the data that will be stored in the buffer
+  /// as a `vector`.
+  /// @param[in] len The number of elements to store in the `vector`.
+  /// @param[out] buf A pointer to a pointer of type `T` that can be
+  /// written to at a later time to serialize the data into a `vector`
+  /// in the buffer.
+  template<typename T>
+  Offset<Vector<T>> CreateUninitializedVector(size_t len, T **buf) {
+    AssertScalarT<T>();
+    return CreateUninitializedVector(len, sizeof(T),
+                                     reinterpret_cast<uint8_t **>(buf));
+  }
+
+  template<typename T>
+  Offset<Vector<const T *>> CreateUninitializedVectorOfStructs(size_t len,
+                                                               T **buf) {
+    return CreateUninitializedVector(len, sizeof(T),
+                                     reinterpret_cast<uint8_t **>(buf));
+  }
+
+  // @brief Create a vector of scalar type T given as input a vector of scalar
+  // type U, useful with e.g. pre "enum class" enums, or any existing scalar
+  // data of the wrong type.
+  template<typename T, typename U>
+  Offset<Vector<T>> CreateVectorScalarCast(const U *v, size_t len) {
+    AssertScalarT<T>();
+    AssertScalarT<U>();
+    StartVector(len, sizeof(T));
+    for (auto i = len; i > 0;) { PushElement(static_cast<T>(v[--i])); }
+    return Offset<Vector<T>>(EndVector(len));
+  }
+
+  /// @brief Write a struct by itself, typically to be part of a union.
+  template<typename T> Offset<const T *> CreateStruct(const T &structobj) {
+    NotNested();
+    Align(AlignOf<T>());
+    buf_.push_small(structobj);
+    return Offset<const T *>(GetSize());
+  }
+
+  /// @brief Finish serializing a buffer by writing the root offset.
+  /// @param[in] file_identifier If a `file_identifier` is given, the buffer
+  /// will be prefixed with a standard FlatBuffers file header.
+  template<typename T>
+  void Finish(Offset<T> root, const char *file_identifier = nullptr) {
+    Finish(root.o, file_identifier, false);
+  }
+
+  /// @brief Finish a buffer with a 32 bit size field pre-fixed (size of the
+  /// buffer following the size field). These buffers are NOT compatible
+  /// with standard buffers created by Finish, i.e. you can't call GetRoot
+  /// on them, you have to use GetSizePrefixedRoot instead.
+  /// All >32 bit quantities in this buffer will be aligned when the whole
+  /// size pre-fixed buffer is aligned.
+  /// These kinds of buffers are useful for creating a stream of FlatBuffers.
+  template<typename T>
+  void FinishSizePrefixed(Offset<T> root,
+                          const char *file_identifier = nullptr) {
+    Finish(root.o, file_identifier, true);
+  }
+
+  void SwapBufAllocator(FlatBufferBuilder &other) {
+    buf_.swap_allocator(other.buf_);
+  }
+
+  /// @brief The length of a FlatBuffer file header.
+  static const size_t kFileIdentifierLength =
+      ::flatbuffers::kFileIdentifierLength;
+
+ protected:
+  // You shouldn't really be copying instances of this class.
+  FlatBufferBuilder(const FlatBufferBuilder &);
+  FlatBufferBuilder &operator=(const FlatBufferBuilder &);
+
+  void Finish(uoffset_t root, const char *file_identifier, bool size_prefix) {
+    NotNested();
+    buf_.clear_scratch();
+    // This will cause the whole buffer to be aligned.
+    PreAlign((size_prefix ? sizeof(uoffset_t) : 0) + sizeof(uoffset_t) +
+                 (file_identifier ? kFileIdentifierLength : 0),
+             minalign_);
+    if (file_identifier) {
+      FLATBUFFERS_ASSERT(strlen(file_identifier) == kFileIdentifierLength);
+      PushBytes(reinterpret_cast<const uint8_t *>(file_identifier),
+                kFileIdentifierLength);
+    }
+    PushElement(ReferTo(root));  // Location of root.
+    if (size_prefix) { PushElement(GetSize()); }
+    finished = true;
+  }
+
+  struct FieldLoc {
+    uoffset_t off;
+    voffset_t id;
+  };
+
+  vector_downward buf_;
+
+  // Accumulating offsets of table members while it is being built.
+  // We store these in the scratch pad of buf_, after the vtable offsets.
+  uoffset_t num_field_loc;
+  // Track how much of the vtable is in use, so we can output the most compact
+  // possible vtable.
+  voffset_t max_voffset_;
+
+  // Ensure objects are not nested.
+  bool nested;
+
+  // Ensure the buffer is finished before it is being accessed.
+  bool finished;
+
+  size_t minalign_;
+
+  bool force_defaults_;  // Serialize values equal to their defaults anyway.
+
+  bool dedup_vtables_;
+
+  struct StringOffsetCompare {
+    StringOffsetCompare(const vector_downward &buf) : buf_(&buf) {}
+    bool operator()(const Offset<String> &a, const Offset<String> &b) const {
+      auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));
+      auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));
+      return StringLessThan(stra->data(), stra->size(), strb->data(),
+                            strb->size());
+    }
+    const vector_downward *buf_;
+  };
+
+  // For use with CreateSharedString. Instantiated on first use only.
+  typedef std::set<Offset<String>, StringOffsetCompare> StringOffsetMap;
+  StringOffsetMap *string_pool;
+
+ private:
+  // Allocates space for a vector of structures.
+  // Must be completed with EndVectorOfStructs().
+  template<typename T> T *StartVectorOfStructs(size_t vector_size) {
+    StartVector(vector_size * sizeof(T) / AlignOf<T>(), AlignOf<T>());
+    return reinterpret_cast<T *>(buf_.make_space(vector_size * sizeof(T)));
+  }
+
+  // End the vector of structures in the flatbuffers.
+  // Vector should have previously be started with StartVectorOfStructs().
+  template<typename T>
+  Offset<Vector<const T *>> EndVectorOfStructs(size_t vector_size) {
+    return Offset<Vector<const T *>>(EndVector(vector_size));
+  }
+};
+/// @}
+
+/// Helpers to get a typed pointer to objects that are currently being built.
+/// @warning Creating new objects will lead to reallocations and invalidates
+/// the pointer!
+template<typename T>
+T *GetMutableTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
+  return reinterpret_cast<T *>(fbb.GetCurrentBufferPointer() + fbb.GetSize() -
+                               offset.o);
+}
+
+template<typename T>
+const T *GetTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
+  return GetMutableTemporaryPointer<T>(fbb, offset);
+}
+
+template<typename T>
+void FlatBufferBuilder::Required(Offset<T> table, voffset_t field) {
+  auto table_ptr = reinterpret_cast<const Table *>(buf_.data_at(table.o));
+  bool ok = table_ptr->GetOptionalFieldOffset(field) != 0;
+  // If this fails, the caller will show what field needs to be set.
+  FLATBUFFERS_ASSERT(ok);
+  (void)ok;
+}
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_VECTOR_DOWNWARD_H_
diff -urN a/include/flatbuffers/flatbuffers.h b/include/flatbuffers/flatbuffers.h
--- a/include/flatbuffers/flatbuffers.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/flatbuffers.h	2023-01-13 07:47:06.299228228 +0000
@@ -17,2686 +17,23 @@
 #ifndef FLATBUFFERS_H_
 #define FLATBUFFERS_H_
 
+// TODO: These includes are for mitigating the pains of users editing their
+// source because they relied on flatbuffers.h to include everything for them.
+#include "flatbuffers/array.h"
 #include "flatbuffers/base.h"
+#include "flatbuffers/buffer.h"
+#include "flatbuffers/buffer_ref.h"
+#include "flatbuffers/detached_buffer.h"
+#include "flatbuffers/flatbuffer_builder.h"
 #include "flatbuffers/stl_emulation.h"
-
-#ifndef FLATBUFFERS_CPP98_STL
-#  include <functional>
-#endif
-
-#if defined(FLATBUFFERS_NAN_DEFAULTS)
-#  include <cmath>
-#endif
+#include "flatbuffers/string.h"
+#include "flatbuffers/struct.h"
+#include "flatbuffers/table.h"
+#include "flatbuffers/vector.h"
+#include "flatbuffers/vector_downward.h"
+#include "flatbuffers/verifier.h"
 
 namespace flatbuffers {
-// Generic 'operator==' with conditional specialisations.
-// T e - new value of a scalar field.
-// T def - default of scalar (is known at compile-time).
-template<typename T> inline bool IsTheSameAs(T e, T def) { return e == def; }
-
-#if defined(FLATBUFFERS_NAN_DEFAULTS) && \
-    defined(FLATBUFFERS_HAS_NEW_STRTOD) && (FLATBUFFERS_HAS_NEW_STRTOD > 0)
-// Like `operator==(e, def)` with weak NaN if T=(float|double).
-template<typename T> inline bool IsFloatTheSameAs(T e, T def) {
-  return (e == def) || ((def != def) && (e != e));
-}
-template<> inline bool IsTheSameAs<float>(float e, float def) {
-  return IsFloatTheSameAs(e, def);
-}
-template<> inline bool IsTheSameAs<double>(double e, double def) {
-  return IsFloatTheSameAs(e, def);
-}
-#endif
-
-// Check 'v' is out of closed range [low; high].
-// Workaround for GCC warning [-Werror=type-limits]:
-// comparison is always true due to limited range of data type.
-template<typename T>
-inline bool IsOutRange(const T &v, const T &low, const T &high) {
-  return (v < low) || (high < v);
-}
-
-// Check 'v' is in closed range [low; high].
-template<typename T>
-inline bool IsInRange(const T &v, const T &low, const T &high) {
-  return !IsOutRange(v, low, high);
-}
-
-// Wrapper for uoffset_t to allow safe template specialization.
-// Value is allowed to be 0 to indicate a null object (see e.g. AddOffset).
-template<typename T> struct Offset {
-  uoffset_t o;
-  Offset() : o(0) {}
-  Offset(uoffset_t _o) : o(_o) {}
-  Offset<void> Union() const { return Offset<void>(o); }
-  bool IsNull() const { return !o; }
-};
-
-inline void EndianCheck() {
-  int endiantest = 1;
-  // If this fails, see FLATBUFFERS_LITTLEENDIAN above.
-  FLATBUFFERS_ASSERT(*reinterpret_cast<char *>(&endiantest) ==
-                     FLATBUFFERS_LITTLEENDIAN);
-  (void)endiantest;
-}
-
-template<typename T> FLATBUFFERS_CONSTEXPR size_t AlignOf() {
-  // clang-format off
-  #ifdef _MSC_VER
-    return __alignof(T);
-  #else
-    #ifndef alignof
-      return __alignof__(T);
-    #else
-      return alignof(T);
-    #endif
-  #endif
-  // clang-format on
-}
-
-// When we read serialized data from memory, in the case of most scalars,
-// we want to just read T, but in the case of Offset, we want to actually
-// perform the indirection and return a pointer.
-// The template specialization below does just that.
-// It is wrapped in a struct since function templates can't overload on the
-// return type like this.
-// The typedef is for the convenience of callers of this function
-// (avoiding the need for a trailing return decltype)
-template<typename T> struct IndirectHelper {
-  typedef T return_type;
-  typedef T mutable_return_type;
-  static const size_t element_stride = sizeof(T);
-  static return_type Read(const uint8_t *p, uoffset_t i) {
-    return EndianScalar((reinterpret_cast<const T *>(p))[i]);
-  }
-};
-template<typename T> struct IndirectHelper<Offset<T>> {
-  typedef const T *return_type;
-  typedef T *mutable_return_type;
-  static const size_t element_stride = sizeof(uoffset_t);
-  static return_type Read(const uint8_t *p, uoffset_t i) {
-    p += i * sizeof(uoffset_t);
-    return reinterpret_cast<return_type>(p + ReadScalar<uoffset_t>(p));
-  }
-};
-template<typename T> struct IndirectHelper<const T *> {
-  typedef const T *return_type;
-  typedef T *mutable_return_type;
-  static const size_t element_stride = sizeof(T);
-  static return_type Read(const uint8_t *p, uoffset_t i) {
-    return reinterpret_cast<const T *>(p + i * sizeof(T));
-  }
-};
-
-// An STL compatible iterator implementation for Vector below, effectively
-// calling Get() for every element.
-template<typename T, typename IT> struct VectorIterator {
-  typedef std::random_access_iterator_tag iterator_category;
-  typedef IT value_type;
-  typedef ptrdiff_t difference_type;
-  typedef IT *pointer;
-  typedef IT &reference;
-
-  VectorIterator(const uint8_t *data, uoffset_t i)
-      : data_(data + IndirectHelper<T>::element_stride * i) {}
-  VectorIterator(const VectorIterator &other) : data_(other.data_) {}
-  VectorIterator() : data_(nullptr) {}
-
-  VectorIterator &operator=(const VectorIterator &other) {
-    data_ = other.data_;
-    return *this;
-  }
-
-  // clang-format off
-  #if !defined(FLATBUFFERS_CPP98_STL)
-  VectorIterator &operator=(VectorIterator &&other) {
-    data_ = other.data_;
-    return *this;
-  }
-  #endif  // !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-
-  bool operator==(const VectorIterator &other) const {
-    return data_ == other.data_;
-  }
-
-  bool operator<(const VectorIterator &other) const {
-    return data_ < other.data_;
-  }
-
-  bool operator!=(const VectorIterator &other) const {
-    return data_ != other.data_;
-  }
-
-  difference_type operator-(const VectorIterator &other) const {
-    return (data_ - other.data_) / IndirectHelper<T>::element_stride;
-  }
-
-  // Note: return type is incompatible with the standard
-  // `reference operator*()`.
-  IT operator*() const { return IndirectHelper<T>::Read(data_, 0); }
-
-  // Note: return type is incompatible with the standard
-  // `pointer operator->()`.
-  IT operator->() const { return IndirectHelper<T>::Read(data_, 0); }
-
-  VectorIterator &operator++() {
-    data_ += IndirectHelper<T>::element_stride;
-    return *this;
-  }
-
-  VectorIterator operator++(int) {
-    VectorIterator temp(data_, 0);
-    data_ += IndirectHelper<T>::element_stride;
-    return temp;
-  }
-
-  VectorIterator operator+(const uoffset_t &offset) const {
-    return VectorIterator(data_ + offset * IndirectHelper<T>::element_stride,
-                          0);
-  }
-
-  VectorIterator &operator+=(const uoffset_t &offset) {
-    data_ += offset * IndirectHelper<T>::element_stride;
-    return *this;
-  }
-
-  VectorIterator &operator--() {
-    data_ -= IndirectHelper<T>::element_stride;
-    return *this;
-  }
-
-  VectorIterator operator--(int) {
-    VectorIterator temp(data_, 0);
-    data_ -= IndirectHelper<T>::element_stride;
-    return temp;
-  }
-
-  VectorIterator operator-(const uoffset_t &offset) const {
-    return VectorIterator(data_ - offset * IndirectHelper<T>::element_stride,
-                          0);
-  }
-
-  VectorIterator &operator-=(const uoffset_t &offset) {
-    data_ -= offset * IndirectHelper<T>::element_stride;
-    return *this;
-  }
-
- private:
-  const uint8_t *data_;
-};
-
-template<typename Iterator>
-struct VectorReverseIterator : public std::reverse_iterator<Iterator> {
-  explicit VectorReverseIterator(Iterator iter)
-      : std::reverse_iterator<Iterator>(iter) {}
-
-  // Note: return type is incompatible with the standard
-  // `reference operator*()`.
-  typename Iterator::value_type operator*() const {
-    auto tmp = std::reverse_iterator<Iterator>::current;
-    return *--tmp;
-  }
-
-  // Note: return type is incompatible with the standard
-  // `pointer operator->()`.
-  typename Iterator::value_type operator->() const {
-    auto tmp = std::reverse_iterator<Iterator>::current;
-    return *--tmp;
-  }
-};
-
-struct String;
-
-// This is used as a helper type for accessing vectors.
-// Vector::data() assumes the vector elements start after the length field.
-template<typename T> class Vector {
- public:
-  typedef VectorIterator<T, typename IndirectHelper<T>::mutable_return_type>
-      iterator;
-  typedef VectorIterator<T, typename IndirectHelper<T>::return_type>
-      const_iterator;
-  typedef VectorReverseIterator<iterator> reverse_iterator;
-  typedef VectorReverseIterator<const_iterator> const_reverse_iterator;
-
-  uoffset_t size() const { return EndianScalar(length_); }
-
-  // Deprecated: use size(). Here for backwards compatibility.
-  FLATBUFFERS_ATTRIBUTE(deprecated("use size() instead"))
-  uoffset_t Length() const { return size(); }
-
-  typedef typename IndirectHelper<T>::return_type return_type;
-  typedef typename IndirectHelper<T>::mutable_return_type mutable_return_type;
-  typedef return_type value_type;
-
-  return_type Get(uoffset_t i) const {
-    FLATBUFFERS_ASSERT(i < size());
-    return IndirectHelper<T>::Read(Data(), i);
-  }
-
-  return_type operator[](uoffset_t i) const { return Get(i); }
-
-  // If this is a Vector of enums, T will be its storage type, not the enum
-  // type. This function makes it convenient to retrieve value with enum
-  // type E.
-  template<typename E> E GetEnum(uoffset_t i) const {
-    return static_cast<E>(Get(i));
-  }
-
-  // If this a vector of unions, this does the cast for you. There's no check
-  // to make sure this is the right type!
-  template<typename U> const U *GetAs(uoffset_t i) const {
-    return reinterpret_cast<const U *>(Get(i));
-  }
-
-  // If this a vector of unions, this does the cast for you. There's no check
-  // to make sure this is actually a string!
-  const String *GetAsString(uoffset_t i) const {
-    return reinterpret_cast<const String *>(Get(i));
-  }
-
-  const void *GetStructFromOffset(size_t o) const {
-    return reinterpret_cast<const void *>(Data() + o);
-  }
-
-  iterator begin() { return iterator(Data(), 0); }
-  const_iterator begin() const { return const_iterator(Data(), 0); }
-
-  iterator end() { return iterator(Data(), size()); }
-  const_iterator end() const { return const_iterator(Data(), size()); }
-
-  reverse_iterator rbegin() { return reverse_iterator(end()); }
-  const_reverse_iterator rbegin() const {
-    return const_reverse_iterator(end());
-  }
-
-  reverse_iterator rend() { return reverse_iterator(begin()); }
-  const_reverse_iterator rend() const {
-    return const_reverse_iterator(begin());
-  }
-
-  const_iterator cbegin() const { return begin(); }
-
-  const_iterator cend() const { return end(); }
-
-  const_reverse_iterator crbegin() const { return rbegin(); }
-
-  const_reverse_iterator crend() const { return rend(); }
-
-  // Change elements if you have a non-const pointer to this object.
-  // Scalars only. See reflection.h, and the documentation.
-  void Mutate(uoffset_t i, const T &val) {
-    FLATBUFFERS_ASSERT(i < size());
-    WriteScalar(data() + i, val);
-  }
-
-  // Change an element of a vector of tables (or strings).
-  // "val" points to the new table/string, as you can obtain from
-  // e.g. reflection::AddFlatBuffer().
-  void MutateOffset(uoffset_t i, const uint8_t *val) {
-    FLATBUFFERS_ASSERT(i < size());
-    static_assert(sizeof(T) == sizeof(uoffset_t), "Unrelated types");
-    WriteScalar(data() + i,
-                static_cast<uoffset_t>(val - (Data() + i * sizeof(uoffset_t))));
-  }
-
-  // Get a mutable pointer to tables/strings inside this vector.
-  mutable_return_type GetMutableObject(uoffset_t i) const {
-    FLATBUFFERS_ASSERT(i < size());
-    return const_cast<mutable_return_type>(IndirectHelper<T>::Read(Data(), i));
-  }
-
-  // The raw data in little endian format. Use with care.
-  const uint8_t *Data() const {
-    return reinterpret_cast<const uint8_t *>(&length_ + 1);
-  }
-
-  uint8_t *Data() { return reinterpret_cast<uint8_t *>(&length_ + 1); }
-
-  // Similarly, but typed, much like std::vector::data
-  const T *data() const { return reinterpret_cast<const T *>(Data()); }
-  T *data() { return reinterpret_cast<T *>(Data()); }
-
-  template<typename K> return_type LookupByKey(K key) const {
-    void *search_result = std::bsearch(
-        &key, Data(), size(), IndirectHelper<T>::element_stride, KeyCompare<K>);
-
-    if (!search_result) {
-      return nullptr;  // Key not found.
-    }
-
-    const uint8_t *element = reinterpret_cast<const uint8_t *>(search_result);
-
-    return IndirectHelper<T>::Read(element, 0);
-  }
-
- protected:
-  // This class is only used to access pre-existing data. Don't ever
-  // try to construct these manually.
-  Vector();
-
-  uoffset_t length_;
-
- private:
-  // This class is a pointer. Copying will therefore create an invalid object.
-  // Private and unimplemented copy constructor.
-  Vector(const Vector &);
-  Vector &operator=(const Vector &);
-
-  template<typename K> static int KeyCompare(const void *ap, const void *bp) {
-    const K *key = reinterpret_cast<const K *>(ap);
-    const uint8_t *data = reinterpret_cast<const uint8_t *>(bp);
-    auto table = IndirectHelper<T>::Read(data, 0);
-
-    // std::bsearch compares with the operands transposed, so we negate the
-    // result here.
-    return -table->KeyCompareWithValue(*key);
-  }
-};
-
-// Represent a vector much like the template above, but in this case we
-// don't know what the element types are (used with reflection.h).
-class VectorOfAny {
- public:
-  uoffset_t size() const { return EndianScalar(length_); }
-
-  const uint8_t *Data() const {
-    return reinterpret_cast<const uint8_t *>(&length_ + 1);
-  }
-  uint8_t *Data() { return reinterpret_cast<uint8_t *>(&length_ + 1); }
-
- protected:
-  VectorOfAny();
-
-  uoffset_t length_;
-
- private:
-  VectorOfAny(const VectorOfAny &);
-  VectorOfAny &operator=(const VectorOfAny &);
-};
-
-#ifndef FLATBUFFERS_CPP98_STL
-template<typename T, typename U>
-Vector<Offset<T>> *VectorCast(Vector<Offset<U>> *ptr) {
-  static_assert(std::is_base_of<T, U>::value, "Unrelated types");
-  return reinterpret_cast<Vector<Offset<T>> *>(ptr);
-}
-
-template<typename T, typename U>
-const Vector<Offset<T>> *VectorCast(const Vector<Offset<U>> *ptr) {
-  static_assert(std::is_base_of<T, U>::value, "Unrelated types");
-  return reinterpret_cast<const Vector<Offset<T>> *>(ptr);
-}
-#endif
-
-// Convenient helper function to get the length of any vector, regardless
-// of whether it is null or not (the field is not set).
-template<typename T> static inline size_t VectorLength(const Vector<T> *v) {
-  return v ? v->size() : 0;
-}
-
-// This is used as a helper type for accessing arrays.
-template<typename T, uint16_t length> class Array {
-  typedef
-      typename flatbuffers::integral_constant<bool,
-                                              flatbuffers::is_scalar<T>::value>
-          scalar_tag;
-  typedef
-      typename flatbuffers::conditional<scalar_tag::value, T, const T *>::type
-          IndirectHelperType;
-
- public:
-  typedef uint16_t size_type;
-  typedef typename IndirectHelper<IndirectHelperType>::return_type return_type;
-  typedef VectorIterator<T, return_type> const_iterator;
-  typedef VectorReverseIterator<const_iterator> const_reverse_iterator;
-
-  FLATBUFFERS_CONSTEXPR uint16_t size() const { return length; }
-
-  return_type Get(uoffset_t i) const {
-    FLATBUFFERS_ASSERT(i < size());
-    return IndirectHelper<IndirectHelperType>::Read(Data(), i);
-  }
-
-  return_type operator[](uoffset_t i) const { return Get(i); }
-
-  // If this is a Vector of enums, T will be its storage type, not the enum
-  // type. This function makes it convenient to retrieve value with enum
-  // type E.
-  template<typename E> E GetEnum(uoffset_t i) const {
-    return static_cast<E>(Get(i));
-  }
-
-  const_iterator begin() const { return const_iterator(Data(), 0); }
-  const_iterator end() const { return const_iterator(Data(), size()); }
-
-  const_reverse_iterator rbegin() const {
-    return const_reverse_iterator(end());
-  }
-  const_reverse_iterator rend() const {
-    return const_reverse_iterator(begin());
-  }
-
-  const_iterator cbegin() const { return begin(); }
-  const_iterator cend() const { return end(); }
-
-  const_reverse_iterator crbegin() const { return rbegin(); }
-  const_reverse_iterator crend() const { return rend(); }
-
-  // Get a mutable pointer to elements inside this array.
-  // This method used to mutate arrays of structs followed by a @p Mutate
-  // operation. For primitive types use @p Mutate directly.
-  // @warning Assignments and reads to/from the dereferenced pointer are not
-  //  automatically converted to the correct endianness.
-  typename flatbuffers::conditional<scalar_tag::value, void, T *>::type
-  GetMutablePointer(uoffset_t i) const {
-    FLATBUFFERS_ASSERT(i < size());
-    return const_cast<T *>(&data()[i]);
-  }
-
-  // Change elements if you have a non-const pointer to this object.
-  void Mutate(uoffset_t i, const T &val) { MutateImpl(scalar_tag(), i, val); }
-
-  // The raw data in little endian format. Use with care.
-  const uint8_t *Data() const { return data_; }
-
-  uint8_t *Data() { return data_; }
-
-  // Similarly, but typed, much like std::vector::data
-  const T *data() const { return reinterpret_cast<const T *>(Data()); }
-  T *data() { return reinterpret_cast<T *>(Data()); }
-
-  // Copy data from a span with endian conversion.
-  // If this Array and the span overlap, the behavior is undefined.
-  void CopyFromSpan(flatbuffers::span<const T, length> src) {
-    const auto p1 = reinterpret_cast<const uint8_t *>(src.data());
-    const auto p2 = Data();
-    FLATBUFFERS_ASSERT(!(p1 >= p2 && p1 < (p2 + length)) &&
-                       !(p2 >= p1 && p2 < (p1 + length)));
-    (void)p1;
-    (void)p2;
-
-    CopyFromSpanImpl(
-        flatbuffers::integral_constant < bool,
-        !scalar_tag::value || sizeof(T) == 1 || FLATBUFFERS_LITTLEENDIAN > (),
-        src);
-  }
-
- protected:
-  void MutateImpl(flatbuffers::integral_constant<bool, true>, uoffset_t i,
-                  const T &val) {
-    FLATBUFFERS_ASSERT(i < size());
-    WriteScalar(data() + i, val);
-  }
-
-  void MutateImpl(flatbuffers::integral_constant<bool, false>, uoffset_t i,
-                  const T &val) {
-    *(GetMutablePointer(i)) = val;
-  }
-
-  void CopyFromSpanImpl(flatbuffers::integral_constant<bool, true>,
-                        flatbuffers::span<const T, length> src) {
-    // Use std::memcpy() instead of std::copy() to avoid preformance degradation
-    // due to aliasing if T is char or unsigned char.
-    // The size is known at compile time, so memcpy would be inlined.
-    std::memcpy(data(), src.data(), length * sizeof(T));
-  }
-
-  // Copy data from flatbuffers::span with endian conversion.
-  void CopyFromSpanImpl(flatbuffers::integral_constant<bool, false>,
-                        flatbuffers::span<const T, length> src) {
-    for (size_type k = 0; k < length; k++) { Mutate(k, src[k]); }
-  }
-
-  // This class is only used to access pre-existing data. Don't ever
-  // try to construct these manually.
-  // 'constexpr' allows us to use 'size()' at compile time.
-  // @note Must not use 'FLATBUFFERS_CONSTEXPR' here, as const is not allowed on
-  //  a constructor.
-#if defined(__cpp_constexpr)
-  constexpr Array();
-#else
-  Array();
-#endif
-
-  uint8_t data_[length * sizeof(T)];
-
- private:
-  // This class is a pointer. Copying will therefore create an invalid object.
-  // Private and unimplemented copy constructor.
-  Array(const Array &);
-  Array &operator=(const Array &);
-};
-
-// Specialization for Array[struct] with access using Offset<void> pointer.
-// This specialization used by idl_gen_text.cpp.
-template<typename T, uint16_t length> class Array<Offset<T>, length> {
-  static_assert(flatbuffers::is_same<T, void>::value, "unexpected type T");
-
- public:
-  typedef const void *return_type;
-
-  const uint8_t *Data() const { return data_; }
-
-  // Make idl_gen_text.cpp::PrintContainer happy.
-  return_type operator[](uoffset_t) const {
-    FLATBUFFERS_ASSERT(false);
-    return nullptr;
-  }
-
- private:
-  // This class is only used to access pre-existing data.
-  Array();
-  Array(const Array &);
-  Array &operator=(const Array &);
-
-  uint8_t data_[1];
-};
-
-// Cast a raw T[length] to a raw flatbuffers::Array<T, length>
-// without endian conversion. Use with care.
-template<typename T, uint16_t length>
-Array<T, length> &CastToArray(T (&arr)[length]) {
-  return *reinterpret_cast<Array<T, length> *>(arr);
-}
-
-template<typename T, uint16_t length>
-const Array<T, length> &CastToArray(const T (&arr)[length]) {
-  return *reinterpret_cast<const Array<T, length> *>(arr);
-}
-
-template<typename E, typename T, uint16_t length>
-Array<E, length> &CastToArrayOfEnum(T (&arr)[length]) {
-  static_assert(sizeof(E) == sizeof(T), "invalid enum type E");
-  return *reinterpret_cast<Array<E, length> *>(arr);
-}
-
-template<typename E, typename T, uint16_t length>
-const Array<E, length> &CastToArrayOfEnum(const T (&arr)[length]) {
-  static_assert(sizeof(E) == sizeof(T), "invalid enum type E");
-  return *reinterpret_cast<const Array<E, length> *>(arr);
-}
-
-// Lexicographically compare two strings (possibly containing nulls), and
-// return true if the first is less than the second.
-static inline bool StringLessThan(const char *a_data, uoffset_t a_size,
-                                  const char *b_data, uoffset_t b_size) {
-  const auto cmp = memcmp(a_data, b_data, (std::min)(a_size, b_size));
-  return cmp == 0 ? a_size < b_size : cmp < 0;
-}
-
-struct String : public Vector<char> {
-  const char *c_str() const { return reinterpret_cast<const char *>(Data()); }
-  std::string str() const { return std::string(c_str(), size()); }
-
-  // clang-format off
-  #ifdef FLATBUFFERS_HAS_STRING_VIEW
-  flatbuffers::string_view string_view() const {
-    return flatbuffers::string_view(c_str(), size());
-  }
-  #endif // FLATBUFFERS_HAS_STRING_VIEW
-  // clang-format on
-
-  bool operator<(const String &o) const {
-    return StringLessThan(this->data(), this->size(), o.data(), o.size());
-  }
-};
-
-// Convenience function to get std::string from a String returning an empty
-// string on null pointer.
-static inline std::string GetString(const String *str) {
-  return str ? str->str() : "";
-}
-
-// Convenience function to get char* from a String returning an empty string on
-// null pointer.
-static inline const char *GetCstring(const String *str) {
-  return str ? str->c_str() : "";
-}
-
-#ifdef FLATBUFFERS_HAS_STRING_VIEW
-// Convenience function to get string_view from a String returning an empty
-// string_view on null pointer.
-static inline flatbuffers::string_view GetStringView(const String *str) {
-  return str ? str->string_view() : flatbuffers::string_view();
-}
-#endif  // FLATBUFFERS_HAS_STRING_VIEW
-
-// Allocator interface. This is flatbuffers-specific and meant only for
-// `vector_downward` usage.
-class Allocator {
- public:
-  virtual ~Allocator() {}
-
-  // Allocate `size` bytes of memory.
-  virtual uint8_t *allocate(size_t size) = 0;
-
-  // Deallocate `size` bytes of memory at `p` allocated by this allocator.
-  virtual void deallocate(uint8_t *p, size_t size) = 0;
-
-  // Reallocate `new_size` bytes of memory, replacing the old region of size
-  // `old_size` at `p`. In contrast to a normal realloc, this grows downwards,
-  // and is intended specifcally for `vector_downward` use.
-  // `in_use_back` and `in_use_front` indicate how much of `old_size` is
-  // actually in use at each end, and needs to be copied.
-  virtual uint8_t *reallocate_downward(uint8_t *old_p, size_t old_size,
-                                       size_t new_size, size_t in_use_back,
-                                       size_t in_use_front) {
-    FLATBUFFERS_ASSERT(new_size > old_size);  // vector_downward only grows
-    uint8_t *new_p = allocate(new_size);
-    memcpy_downward(old_p, old_size, new_p, new_size, in_use_back,
-                    in_use_front);
-    deallocate(old_p, old_size);
-    return new_p;
-  }
-
- protected:
-  // Called by `reallocate_downward` to copy memory from `old_p` of `old_size`
-  // to `new_p` of `new_size`. Only memory of size `in_use_front` and
-  // `in_use_back` will be copied from the front and back of the old memory
-  // allocation.
-  void memcpy_downward(uint8_t *old_p, size_t old_size, uint8_t *new_p,
-                       size_t new_size, size_t in_use_back,
-                       size_t in_use_front) {
-    memcpy(new_p + new_size - in_use_back, old_p + old_size - in_use_back,
-           in_use_back);
-    memcpy(new_p, old_p, in_use_front);
-  }
-};
-
-// DefaultAllocator uses new/delete to allocate memory regions
-class DefaultAllocator : public Allocator {
- public:
-  uint8_t *allocate(size_t size) FLATBUFFERS_OVERRIDE {
-    return new uint8_t[size];
-  }
-
-  void deallocate(uint8_t *p, size_t) FLATBUFFERS_OVERRIDE { delete[] p; }
-
-  static void dealloc(void *p, size_t) { delete[] static_cast<uint8_t *>(p); }
-};
-
-// These functions allow for a null allocator to mean use the default allocator,
-// as used by DetachedBuffer and vector_downward below.
-// This is to avoid having a statically or dynamically allocated default
-// allocator, or having to move it between the classes that may own it.
-inline uint8_t *Allocate(Allocator *allocator, size_t size) {
-  return allocator ? allocator->allocate(size)
-                   : DefaultAllocator().allocate(size);
-}
-
-inline void Deallocate(Allocator *allocator, uint8_t *p, size_t size) {
-  if (allocator)
-    allocator->deallocate(p, size);
-  else
-    DefaultAllocator().deallocate(p, size);
-}
-
-inline uint8_t *ReallocateDownward(Allocator *allocator, uint8_t *old_p,
-                                   size_t old_size, size_t new_size,
-                                   size_t in_use_back, size_t in_use_front) {
-  return allocator ? allocator->reallocate_downward(old_p, old_size, new_size,
-                                                    in_use_back, in_use_front)
-                   : DefaultAllocator().reallocate_downward(
-                         old_p, old_size, new_size, in_use_back, in_use_front);
-}
-
-// DetachedBuffer is a finished flatbuffer memory region, detached from its
-// builder. The original memory region and allocator are also stored so that
-// the DetachedBuffer can manage the memory lifetime.
-class DetachedBuffer {
- public:
-  DetachedBuffer()
-      : allocator_(nullptr),
-        own_allocator_(false),
-        buf_(nullptr),
-        reserved_(0),
-        cur_(nullptr),
-        size_(0) {}
-
-  DetachedBuffer(Allocator *allocator, bool own_allocator, uint8_t *buf,
-                 size_t reserved, uint8_t *cur, size_t sz)
-      : allocator_(allocator),
-        own_allocator_(own_allocator),
-        buf_(buf),
-        reserved_(reserved),
-        cur_(cur),
-        size_(sz) {}
-
-  // clang-format off
-  #if !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-  DetachedBuffer(DetachedBuffer &&other)
-      : allocator_(other.allocator_),
-        own_allocator_(other.own_allocator_),
-        buf_(other.buf_),
-        reserved_(other.reserved_),
-        cur_(other.cur_),
-        size_(other.size_) {
-    other.reset();
-  }
-  // clang-format off
-  #endif  // !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-
-  // clang-format off
-  #if !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-  DetachedBuffer &operator=(DetachedBuffer &&other) {
-    if (this == &other) return *this;
-
-    destroy();
-
-    allocator_ = other.allocator_;
-    own_allocator_ = other.own_allocator_;
-    buf_ = other.buf_;
-    reserved_ = other.reserved_;
-    cur_ = other.cur_;
-    size_ = other.size_;
-
-    other.reset();
-
-    return *this;
-  }
-  // clang-format off
-  #endif  // !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-
-  ~DetachedBuffer() { destroy(); }
-
-  const uint8_t *data() const { return cur_; }
-
-  uint8_t *data() { return cur_; }
-
-  size_t size() const { return size_; }
-
-  // clang-format off
-  #if 0  // disabled for now due to the ordering of classes in this header
-  template <class T>
-  bool Verify() const {
-    Verifier verifier(data(), size());
-    return verifier.Verify<T>(nullptr);
-  }
-
-  template <class T>
-  const T* GetRoot() const {
-    return flatbuffers::GetRoot<T>(data());
-  }
-
-  template <class T>
-  T* GetRoot() {
-    return flatbuffers::GetRoot<T>(data());
-  }
-  #endif
-  // clang-format on
-
-  // clang-format off
-  #if !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-  // These may change access mode, leave these at end of public section
-  FLATBUFFERS_DELETE_FUNC(DetachedBuffer(const DetachedBuffer &other));
-  FLATBUFFERS_DELETE_FUNC(
-      DetachedBuffer &operator=(const DetachedBuffer &other));
-  // clang-format off
-  #endif  // !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-
- protected:
-  Allocator *allocator_;
-  bool own_allocator_;
-  uint8_t *buf_;
-  size_t reserved_;
-  uint8_t *cur_;
-  size_t size_;
-
-  inline void destroy() {
-    if (buf_) Deallocate(allocator_, buf_, reserved_);
-    if (own_allocator_ && allocator_) { delete allocator_; }
-    reset();
-  }
-
-  inline void reset() {
-    allocator_ = nullptr;
-    own_allocator_ = false;
-    buf_ = nullptr;
-    reserved_ = 0;
-    cur_ = nullptr;
-    size_ = 0;
-  }
-};
-
-// This is a minimal replication of std::vector<uint8_t> functionality,
-// except growing from higher to lower addresses. i.e push_back() inserts data
-// in the lowest address in the vector.
-// Since this vector leaves the lower part unused, we support a "scratch-pad"
-// that can be stored there for temporary data, to share the allocated space.
-// Essentially, this supports 2 std::vectors in a single buffer.
-class vector_downward {
- public:
-  explicit vector_downward(size_t initial_size, Allocator *allocator,
-                           bool own_allocator, size_t buffer_minalign)
-      : allocator_(allocator),
-        own_allocator_(own_allocator),
-        initial_size_(initial_size),
-        buffer_minalign_(buffer_minalign),
-        reserved_(0),
-        buf_(nullptr),
-        cur_(nullptr),
-        scratch_(nullptr) {}
-
-  // clang-format off
-  #if !defined(FLATBUFFERS_CPP98_STL)
-  vector_downward(vector_downward &&other)
-  #else
-  vector_downward(vector_downward &other)
-  #endif  // defined(FLATBUFFERS_CPP98_STL)
-      // clang-format on
-      : allocator_(other.allocator_),
-        own_allocator_(other.own_allocator_),
-        initial_size_(other.initial_size_),
-        buffer_minalign_(other.buffer_minalign_),
-        reserved_(other.reserved_),
-        buf_(other.buf_),
-        cur_(other.cur_),
-        scratch_(other.scratch_) {
-    // No change in other.allocator_
-    // No change in other.initial_size_
-    // No change in other.buffer_minalign_
-    other.own_allocator_ = false;
-    other.reserved_ = 0;
-    other.buf_ = nullptr;
-    other.cur_ = nullptr;
-    other.scratch_ = nullptr;
-  }
-
-  // clang-format off
-  #if !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-  vector_downward &operator=(vector_downward &&other) {
-    // Move construct a temporary and swap idiom
-    vector_downward temp(std::move(other));
-    swap(temp);
-    return *this;
-  }
-  // clang-format off
-  #endif  // defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-
-  ~vector_downward() {
-    clear_buffer();
-    clear_allocator();
-  }
-
-  void reset() {
-    clear_buffer();
-    clear();
-  }
-
-  void clear() {
-    if (buf_) {
-      cur_ = buf_ + reserved_;
-    } else {
-      reserved_ = 0;
-      cur_ = nullptr;
-    }
-    clear_scratch();
-  }
-
-  void clear_scratch() { scratch_ = buf_; }
-
-  void clear_allocator() {
-    if (own_allocator_ && allocator_) { delete allocator_; }
-    allocator_ = nullptr;
-    own_allocator_ = false;
-  }
-
-  void clear_buffer() {
-    if (buf_) Deallocate(allocator_, buf_, reserved_);
-    buf_ = nullptr;
-  }
-
-  // Relinquish the pointer to the caller.
-  uint8_t *release_raw(size_t &allocated_bytes, size_t &offset) {
-    auto *buf = buf_;
-    allocated_bytes = reserved_;
-    offset = static_cast<size_t>(cur_ - buf_);
-
-    // release_raw only relinquishes the buffer ownership.
-    // Does not deallocate or reset the allocator. Destructor will do that.
-    buf_ = nullptr;
-    clear();
-    return buf;
-  }
-
-  // Relinquish the pointer to the caller.
-  DetachedBuffer release() {
-    // allocator ownership (if any) is transferred to DetachedBuffer.
-    DetachedBuffer fb(allocator_, own_allocator_, buf_, reserved_, cur_,
-                      size());
-    if (own_allocator_) {
-      allocator_ = nullptr;
-      own_allocator_ = false;
-    }
-    buf_ = nullptr;
-    clear();
-    return fb;
-  }
-
-  size_t ensure_space(size_t len) {
-    FLATBUFFERS_ASSERT(cur_ >= scratch_ && scratch_ >= buf_);
-    if (len > static_cast<size_t>(cur_ - scratch_)) { reallocate(len); }
-    // Beyond this, signed offsets may not have enough range:
-    // (FlatBuffers > 2GB not supported).
-    FLATBUFFERS_ASSERT(size() < FLATBUFFERS_MAX_BUFFER_SIZE);
-    return len;
-  }
-
-  inline uint8_t *make_space(size_t len) {
-    size_t space = ensure_space(len);
-    cur_ -= space;
-    return cur_;
-  }
-
-  // Returns nullptr if using the DefaultAllocator.
-  Allocator *get_custom_allocator() { return allocator_; }
-
-  uoffset_t size() const {
-    return static_cast<uoffset_t>(reserved_ - static_cast<size_t>(cur_ - buf_));
-  }
-
-  uoffset_t scratch_size() const {
-    return static_cast<uoffset_t>(scratch_ - buf_);
-  }
-
-  size_t capacity() const { return reserved_; }
-
-  uint8_t *data() const {
-    FLATBUFFERS_ASSERT(cur_);
-    return cur_;
-  }
-
-  uint8_t *scratch_data() const {
-    FLATBUFFERS_ASSERT(buf_);
-    return buf_;
-  }
-
-  uint8_t *scratch_end() const {
-    FLATBUFFERS_ASSERT(scratch_);
-    return scratch_;
-  }
-
-  uint8_t *data_at(size_t offset) const { return buf_ + reserved_ - offset; }
-
-  void push(const uint8_t *bytes, size_t num) {
-    if (num > 0) { memcpy(make_space(num), bytes, num); }
-  }
-
-  // Specialized version of push() that avoids memcpy call for small data.
-  template<typename T> void push_small(const T &little_endian_t) {
-    make_space(sizeof(T));
-    *reinterpret_cast<T *>(cur_) = little_endian_t;
-  }
-
-  template<typename T> void scratch_push_small(const T &t) {
-    ensure_space(sizeof(T));
-    *reinterpret_cast<T *>(scratch_) = t;
-    scratch_ += sizeof(T);
-  }
-
-  // fill() is most frequently called with small byte counts (<= 4),
-  // which is why we're using loops rather than calling memset.
-  void fill(size_t zero_pad_bytes) {
-    make_space(zero_pad_bytes);
-    for (size_t i = 0; i < zero_pad_bytes; i++) cur_[i] = 0;
-  }
-
-  // Version for when we know the size is larger.
-  // Precondition: zero_pad_bytes > 0
-  void fill_big(size_t zero_pad_bytes) {
-    memset(make_space(zero_pad_bytes), 0, zero_pad_bytes);
-  }
-
-  void pop(size_t bytes_to:remove) { cur_ += bytes_to:remove; }
-  void scratch_pop(size_t bytes_to:remove) { scratch_ -= bytes_to:remove; }
-
-  void swap(vector_downward &other) {
-    using std::swap;
-    swap(allocator_, other.allocator_);
-    swap(own_allocator_, other.own_allocator_);
-    swap(initial_size_, other.initial_size_);
-    swap(buffer_minalign_, other.buffer_minalign_);
-    swap(reserved_, other.reserved_);
-    swap(buf_, other.buf_);
-    swap(cur_, other.cur_);
-    swap(scratch_, other.scratch_);
-  }
-
-  void swap_allocator(vector_downward &other) {
-    using std::swap;
-    swap(allocator_, other.allocator_);
-    swap(own_allocator_, other.own_allocator_);
-  }
-
- private:
-  // You shouldn't really be copying instances of this class.
-  FLATBUFFERS_DELETE_FUNC(vector_downward(const vector_downward &));
-  FLATBUFFERS_DELETE_FUNC(vector_downward &operator=(const vector_downward &));
-
-  Allocator *allocator_;
-  bool own_allocator_;
-  size_t initial_size_;
-  size_t buffer_minalign_;
-  size_t reserved_;
-  uint8_t *buf_;
-  uint8_t *cur_;  // Points at location between empty (below) and used (above).
-  uint8_t *scratch_;  // Points to the end of the scratchpad in use.
-
-  void reallocate(size_t len) {
-    auto old_reserved = reserved_;
-    auto old_size = size();
-    auto old_scratch_size = scratch_size();
-    reserved_ +=
-        (std::max)(len, old_reserved ? old_reserved / 2 : initial_size_);
-    reserved_ = (reserved_ + buffer_minalign_ - 1) & ~(buffer_minalign_ - 1);
-    if (buf_) {
-      buf_ = ReallocateDownward(allocator_, buf_, old_reserved, reserved_,
-                                old_size, old_scratch_size);
-    } else {
-      buf_ = Allocate(allocator_, reserved_);
-    }
-    cur_ = buf_ + reserved_ - old_size;
-    scratch_ = buf_ + old_scratch_size;
-  }
-};
-
-// Converts a Field ID to a virtual table offset.
-inline voffset_t FieldIndexToOffset(voffset_t field_id) {
-  // Should correspond to what EndTable() below builds up.
-  const int fixed_fields = 2;  // Vtable size and Object Size.
-  return static_cast<voffset_t>((field_id + fixed_fields) * sizeof(voffset_t));
-}
-
-template<typename T, typename Alloc>
-const T *data(const std::vector<T, Alloc> &v) {
-  // Eventually the returned pointer gets passed down to memcpy, so
-  // we need it to be non-null to avoid undefined behavior.
-  static uint8_t t;
-  return v.empty() ? reinterpret_cast<const T *>(&t) : &v.front();
-}
-template<typename T, typename Alloc> T *data(std::vector<T, Alloc> &v) {
-  // Eventually the returned pointer gets passed down to memcpy, so
-  // we need it to be non-null to avoid undefined behavior.
-  static uint8_t t;
-  return v.empty() ? reinterpret_cast<T *>(&t) : &v.front();
-}
-
-/// @endcond
-
-/// @addtogroup flatbuffers_cpp_api
-/// @{
-/// @class FlatBufferBuilder
-/// @brief Helper class to hold data needed in creation of a FlatBuffer.
-/// To serialize data, you typically call one of the `Create*()` functions in
-/// the generated code, which in turn call a sequence of `StartTable`/
-/// `PushElement`/`AddElement`/`EndTable`, or the builtin `CreateString`/
-/// `CreateVector` functions. Do this is depth-first order to build up a tree to
-/// the root. `Finish()` wraps up the buffer ready for transport.
-class FlatBufferBuilder {
- public:
-  /// @brief Default constructor for FlatBufferBuilder.
-  /// @param[in] initial_size The initial size of the buffer, in bytes. Defaults
-  /// to `1024`.
-  /// @param[in] allocator An `Allocator` to use. If null will use
-  /// `DefaultAllocator`.
-  /// @param[in] own_allocator Whether the builder/vector should own the
-  /// allocator. Defaults to / `false`.
-  /// @param[in] buffer_minalign Force the buffer to be aligned to the given
-  /// minimum alignment upon reallocation. Only needed if you intend to store
-  /// types with custom alignment AND you wish to read the buffer in-place
-  /// directly after creation.
-  explicit FlatBufferBuilder(
-      size_t initial_size = 1024, Allocator *allocator = nullptr,
-      bool own_allocator = false,
-      size_t buffer_minalign = AlignOf<largest_scalar_t>())
-      : buf_(initial_size, allocator, own_allocator, buffer_minalign),
-        num_field_loc(0),
-        max_voffset_(0),
-        nested(false),
-        finished(false),
-        minalign_(1),
-        force_defaults_(false),
-        dedup_vtables_(true),
-        string_pool(nullptr) {
-    EndianCheck();
-  }
-
-  // clang-format off
-  /// @brief Move constructor for FlatBufferBuilder.
-  #if !defined(FLATBUFFERS_CPP98_STL)
-  FlatBufferBuilder(FlatBufferBuilder &&other)
-  #else
-  FlatBufferBuilder(FlatBufferBuilder &other)
-  #endif  // #if !defined(FLATBUFFERS_CPP98_STL)
-    : buf_(1024, nullptr, false, AlignOf<largest_scalar_t>()),
-      num_field_loc(0),
-      max_voffset_(0),
-      nested(false),
-      finished(false),
-      minalign_(1),
-      force_defaults_(false),
-      dedup_vtables_(true),
-      string_pool(nullptr) {
-    EndianCheck();
-    // Default construct and swap idiom.
-    // Lack of delegating constructors in vs2010 makes it more verbose than needed.
-    Swap(other);
-  }
-  // clang-format on
-
-  // clang-format off
-  #if !defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-  /// @brief Move assignment operator for FlatBufferBuilder.
-  FlatBufferBuilder &operator=(FlatBufferBuilder &&other) {
-    // Move construct a temporary and swap idiom
-    FlatBufferBuilder temp(std::move(other));
-    Swap(temp);
-    return *this;
-  }
-  // clang-format off
-  #endif  // defined(FLATBUFFERS_CPP98_STL)
-  // clang-format on
-
-  void Swap(FlatBufferBuilder &other) {
-    using std::swap;
-    buf_.swap(other.buf_);
-    swap(num_field_loc, other.num_field_loc);
-    swap(max_voffset_, other.max_voffset_);
-    swap(nested, other.nested);
-    swap(finished, other.finished);
-    swap(minalign_, other.minalign_);
-    swap(force_defaults_, other.force_defaults_);
-    swap(dedup_vtables_, other.dedup_vtables_);
-    swap(string_pool, other.string_pool);
-  }
-
-  ~FlatBufferBuilder() {
-    if (string_pool) delete string_pool;
-  }
-
-  void Reset() {
-    Clear();       // clear builder state
-    buf_.reset();  // deallocate buffer
-  }
-
-  /// @brief Reset all the state in this FlatBufferBuilder so it can be reused
-  /// to construct another buffer.
-  void Clear() {
-    ClearOffsets();
-    buf_.clear();
-    nested = false;
-    finished = false;
-    minalign_ = 1;
-    if (string_pool) string_pool->clear();
-  }
-
-  /// @brief The current size of the serialized buffer, counting from the end.
-  /// @return Returns an `uoffset_t` with the current size of the buffer.
-  uoffset_t GetSize() const { return buf_.size(); }
-
-  /// @brief Get the serialized buffer (after you call `Finish()`).
-  /// @return Returns an `uint8_t` pointer to the FlatBuffer data inside the
-  /// buffer.
-  uint8_t *GetBufferPointer() const {
-    Finished();
-    return buf_.data();
-  }
-
-  /// @brief Get the serialized buffer (after you call `Finish()`) as a span.
-  /// @return Returns a constructed flatbuffers::span that is a view over the
-  /// FlatBuffer data inside the buffer.
-  flatbuffers::span<uint8_t> GetBufferSpan() const {
-    Finished();
-    return flatbuffers::span<uint8_t>(buf_.data(), buf_.size());
-  }
-
-  /// @brief Get a pointer to an unfinished buffer.
-  /// @return Returns a `uint8_t` pointer to the unfinished buffer.
-  uint8_t *GetCurrentBufferPointer() const { return buf_.data(); }
-
-  /// @brief Get the released pointer to the serialized buffer.
-  /// @warning Do NOT attempt to use this FlatBufferBuilder afterwards!
-  /// @return A `FlatBuffer` that owns the buffer and its allocator and
-  /// behaves similar to a `unique_ptr` with a deleter.
-  FLATBUFFERS_ATTRIBUTE(deprecated("use Release() instead"))
-  DetachedBuffer ReleaseBufferPointer() {
-    Finished();
-    return buf_.release();
-  }
-
-  /// @brief Get the released DetachedBuffer.
-  /// @return A `DetachedBuffer` that owns the buffer and its allocator.
-  DetachedBuffer Release() {
-    Finished();
-    return buf_.release();
-  }
-
-  /// @brief Get the released pointer to the serialized buffer.
-  /// @param size The size of the memory block containing
-  /// the serialized `FlatBuffer`.
-  /// @param offset The offset from the released pointer where the finished
-  /// `FlatBuffer` starts.
-  /// @return A raw pointer to the start of the memory block containing
-  /// the serialized `FlatBuffer`.
-  /// @remark If the allocator is owned, it gets deleted when the destructor is
-  /// called..
-  uint8_t *ReleaseRaw(size_t &size, size_t &offset) {
-    Finished();
-    return buf_.release_raw(size, offset);
-  }
-
-  /// @brief get the minimum alignment this buffer needs to be accessed
-  /// properly. This is only known once all elements have been written (after
-  /// you call Finish()). You can use this information if you need to embed
-  /// a FlatBuffer in some other buffer, such that you can later read it
-  /// without first having to copy it into its own buffer.
-  size_t GetBufferMinAlignment() const {
-    Finished();
-    return minalign_;
-  }
-
-  /// @cond FLATBUFFERS_INTERNAL
-  void Finished() const {
-    // If you get this assert, you're attempting to get access a buffer
-    // which hasn't been finished yet. Be sure to call
-    // FlatBufferBuilder::Finish with your root table.
-    // If you really need to access an unfinished buffer, call
-    // GetCurrentBufferPointer instead.
-    FLATBUFFERS_ASSERT(finished);
-  }
-  /// @endcond
-
-  /// @brief In order to save space, fields that are set to their default value
-  /// don't get serialized into the buffer.
-  /// @param[in] fd When set to `true`, always serializes default values that
-  /// are set. Optional fields which are not set explicitly, will still not be
-  /// serialized.
-  void ForceDefaults(bool fd) { force_defaults_ = fd; }
-
-  /// @brief By default vtables are deduped in order to save space.
-  /// @param[in] dedup When set to `true`, dedup vtables.
-  void DedupVtables(bool dedup) { dedup_vtables_ = dedup; }
-
-  /// @cond FLATBUFFERS_INTERNAL
-  void Pad(size_t num_bytes) { buf_.fill(num_bytes); }
-
-  void TrackMinAlign(size_t elem_size) {
-    if (elem_size > minalign_) minalign_ = elem_size;
-  }
-
-  void Align(size_t elem_size) {
-    TrackMinAlign(elem_size);
-    buf_.fill(PaddingBytes(buf_.size(), elem_size));
-  }
-
-  void PushFlatBuffer(const uint8_t *bytes, size_t size) {
-    PushBytes(bytes, size);
-    finished = true;
-  }
-
-  void PushBytes(const uint8_t *bytes, size_t size) { buf_.push(bytes, size); }
-
-  void PopBytes(size_t amount) { buf_.pop(amount); }
-
-  template<typename T> void AssertScalarT() {
-    // The code assumes power of 2 sizes and endian-swap-ability.
-    static_assert(flatbuffers::is_scalar<T>::value, "T must be a scalar type");
-  }
-
-  // Write a single aligned scalar to the buffer
-  template<typename T> uoffset_t PushElement(T element) {
-    AssertScalarT<T>();
-    T litle_endian_element = EndianScalar(element);
-    Align(sizeof(T));
-    buf_.push_small(litle_endian_element);
-    return GetSize();
-  }
-
-  template<typename T> uoffset_t PushElement(Offset<T> off) {
-    // Special case for offsets: see ReferTo below.
-    return PushElement(ReferTo(off.o));
-  }
-
-  // When writing fields, we track where they are, so we can create correct
-  // vtables later.
-  void TrackField(voffset_t field, uoffset_t off) {
-    FieldLoc fl = { off, field };
-    buf_.scratch_push_small(fl);
-    num_field_loc++;
-    max_voffset_ = (std::max)(max_voffset_, field);
-  }
-
-  // Like PushElement, but additionally tracks the field this represents.
-  template<typename T> void AddElement(voffset_t field, T e, T def) {
-    // We don't serialize values equal to the default.
-    if (IsTheSameAs(e, def) && !force_defaults_) return;
-    auto off = PushElement(e);
-    TrackField(field, off);
-  }
-
-  template<typename T> void AddElement(voffset_t field, T e) {
-    auto off = PushElement(e);
-    TrackField(field, off);
-  }
-
-  template<typename T> void AddOffset(voffset_t field, Offset<T> off) {
-    if (off.IsNull()) return;  // Don't store.
-    AddElement(field, ReferTo(off.o), static_cast<uoffset_t>(0));
-  }
-
-  template<typename T> void AddStruct(voffset_t field, const T *structptr) {
-    if (!structptr) return;  // Default, don't store.
-    Align(AlignOf<T>());
-    buf_.push_small(*structptr);
-    TrackField(field, GetSize());
-  }
-
-  void AddStructOffset(voffset_t field, uoffset_t off) {
-    TrackField(field, off);
-  }
-
-  // Offsets initially are relative to the end of the buffer (downwards).
-  // This function converts them to be relative to the current location
-  // in the buffer (when stored here), pointing upwards.
-  uoffset_t ReferTo(uoffset_t off) {
-    // Align to ensure GetSize() below is correct.
-    Align(sizeof(uoffset_t));
-    // Offset must refer to something already in buffer.
-    FLATBUFFERS_ASSERT(off && off <= GetSize());
-    return GetSize() - off + static_cast<uoffset_t>(sizeof(uoffset_t));
-  }
-
-  void NotNested() {
-    // If you hit this, you're trying to construct a Table/Vector/String
-    // during the construction of its parent table (between the MyTableBuilder
-    // and table.Finish().
-    // Move the creation of these sub-objects to above the MyTableBuilder to
-    // not get this assert.
-    // Ignoring this assert may appear to work in simple cases, but the reason
-    // it is here is that storing objects in-line may cause vtable offsets
-    // to not fit anymore. It also leads to vtable duplication.
-    FLATBUFFERS_ASSERT(!nested);
-    // If you hit this, fields were added outside the scope of a table.
-    FLATBUFFERS_ASSERT(!num_field_loc);
-  }
-
-  // From generated code (or from the parser), we call StartTable/EndTable
-  // with a sequence of AddElement calls in between.
-  uoffset_t StartTable() {
-    NotNested();
-    nested = true;
-    return GetSize();
-  }
-
-  // This finishes one serialized object by generating the vtable if it's a
-  // table, comparing it against existing vtables, and writing the
-  // resulting vtable offset.
-  uoffset_t EndTable(uoffset_t start) {
-    // If you get this assert, a corresponding StartTable wasn't called.
-    FLATBUFFERS_ASSERT(nested);
-    // Write the vtable offset, which is the start of any Table.
-    // We fill it's value later.
-    auto vtableoffsetloc = PushElement<soffset_t>(0);
-    // Write a vtable, which consists entirely of voffset_t elements.
-    // It starts with the number of offsets, followed by a type id, followed
-    // by the offsets themselves. In reverse:
-    // Include space for the last offset and ensure empty tables have a
-    // minimum size.
-    max_voffset_ =
-        (std::max)(static_cast<voffset_t>(max_voffset_ + sizeof(voffset_t)),
-                   FieldIndexToOffset(0));
-    buf_.fill_big(max_voffset_);
-    auto table_object_size = vtableoffsetloc - start;
-    // Vtable use 16bit offsets.
-    FLATBUFFERS_ASSERT(table_object_size < 0x10000);
-    WriteScalar<voffset_t>(buf_.data() + sizeof(voffset_t),
-                           static_cast<voffset_t>(table_object_size));
-    WriteScalar<voffset_t>(buf_.data(), max_voffset_);
-    // Write the offsets into the table
-    for (auto it = buf_.scratch_end() - num_field_loc * sizeof(FieldLoc);
-         it < buf_.scratch_end(); it += sizeof(FieldLoc)) {
-      auto field_location = reinterpret_cast<FieldLoc *>(it);
-      auto pos = static_cast<voffset_t>(vtableoffsetloc - field_location->off);
-      // If this asserts, it means you've set a field twice.
-      FLATBUFFERS_ASSERT(
-          !ReadScalar<voffset_t>(buf_.data() + field_location->id));
-      WriteScalar<voffset_t>(buf_.data() + field_location->id, pos);
-    }
-    ClearOffsets();
-    auto vt1 = reinterpret_cast<voffset_t *>(buf_.data());
-    auto vt1_size = ReadScalar<voffset_t>(vt1);
-    auto vt_use = GetSize();
-    // See if we already have generated a vtable with this exact same
-    // layout before. If so, make it point to the old one, remove this one.
-    if (dedup_vtables_) {
-      for (auto it = buf_.scratch_data(); it < buf_.scratch_end();
-           it += sizeof(uoffset_t)) {
-        auto vt_offset_ptr = reinterpret_cast<uoffset_t *>(it);
-        auto vt2 = reinterpret_cast<voffset_t *>(buf_.data_at(*vt_offset_ptr));
-        auto vt2_size = ReadScalar<voffset_t>(vt2);
-        if (vt1_size != vt2_size || 0 != memcmp(vt2, vt1, vt1_size)) continue;
-        vt_use = *vt_offset_ptr;
-        buf_.pop(GetSize() - vtableoffsetloc);
-        break;
-      }
-    }
-    // If this is a new vtable, remember it.
-    if (vt_use == GetSize()) { buf_.scratch_push_small(vt_use); }
-    // Fill the vtable offset we created above.
-    // The offset points from the beginning of the object to where the
-    // vtable is stored.
-    // Offsets default direction is downward in memory for future format
-    // flexibility (storing all vtables at the start of the file).
-    WriteScalar(buf_.data_at(vtableoffsetloc),
-                static_cast<soffset_t>(vt_use) -
-                    static_cast<soffset_t>(vtableoffsetloc));
-
-    nested = false;
-    return vtableoffsetloc;
-  }
-
-  FLATBUFFERS_ATTRIBUTE(deprecated("call the version above instead"))
-  uoffset_t EndTable(uoffset_t start, voffset_t /*numfields*/) {
-    return EndTable(start);
-  }
-
-  // This checks a required field has been set in a given table that has
-  // just been constructed.
-  template<typename T> void Required(Offset<T> table, voffset_t field);
-
-  uoffset_t StartStruct(size_t alignment) {
-    Align(alignment);
-    return GetSize();
-  }
-
-  uoffset_t EndStruct() { return GetSize(); }
-
-  void ClearOffsets() {
-    buf_.scratch_pop(num_field_loc * sizeof(FieldLoc));
-    num_field_loc = 0;
-    max_voffset_ = 0;
-  }
-
-  // Aligns such that when "len" bytes are written, an object can be written
-  // after it with "alignment" without padding.
-  void PreAlign(size_t len, size_t alignment) {
-    TrackMinAlign(alignment);
-    buf_.fill(PaddingBytes(GetSize() + len, alignment));
-  }
-  template<typename T> void PreAlign(size_t len) {
-    AssertScalarT<T>();
-    PreAlign(len, sizeof(T));
-  }
-  /// @endcond
-
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// @param[in] str A const char pointer to the data to be stored as a string.
-  /// @param[in] len The number of bytes that should be stored from `str`.
-  /// @return Returns the offset in the buffer where the string starts.
-  Offset<String> CreateString(const char *str, size_t len) {
-    NotNested();
-    PreAlign<uoffset_t>(len + 1);  // Always 0-terminated.
-    buf_.fill(1);
-    PushBytes(reinterpret_cast<const uint8_t *>(str), len);
-    PushElement(static_cast<uoffset_t>(len));
-    return Offset<String>(GetSize());
-  }
-
-  /// @brief Store a string in the buffer, which is null-terminated.
-  /// @param[in] str A const char pointer to a C-string to add to the buffer.
-  /// @return Returns the offset in the buffer where the string starts.
-  Offset<String> CreateString(const char *str) {
-    return CreateString(str, strlen(str));
-  }
-
-  /// @brief Store a string in the buffer, which is null-terminated.
-  /// @param[in] str A char pointer to a C-string to add to the buffer.
-  /// @return Returns the offset in the buffer where the string starts.
-  Offset<String> CreateString(char *str) {
-    return CreateString(str, strlen(str));
-  }
-
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// @param[in] str A const reference to a std::string to store in the buffer.
-  /// @return Returns the offset in the buffer where the string starts.
-  Offset<String> CreateString(const std::string &str) {
-    return CreateString(str.c_str(), str.length());
-  }
-
-  // clang-format off
-  #ifdef FLATBUFFERS_HAS_STRING_VIEW
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// @param[in] str A const string_view to copy in to the buffer.
-  /// @return Returns the offset in the buffer where the string starts.
-  Offset<String> CreateString(flatbuffers::string_view str) {
-    return CreateString(str.data(), str.size());
-  }
-  #endif // FLATBUFFERS_HAS_STRING_VIEW
-  // clang-format on
-
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// @param[in] str A const pointer to a `String` struct to add to the buffer.
-  /// @return Returns the offset in the buffer where the string starts
-  Offset<String> CreateString(const String *str) {
-    return str ? CreateString(str->c_str(), str->size()) : 0;
-  }
-
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// @param[in] str A const reference to a std::string like type with support
-  /// of T::c_str() and T::length() to store in the buffer.
-  /// @return Returns the offset in the buffer where the string starts.
-  template<typename T> Offset<String> CreateString(const T &str) {
-    return CreateString(str.c_str(), str.length());
-  }
-
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// If a string with this exact contents has already been serialized before,
-  /// instead simply returns the offset of the existing string.
-  /// @param[in] str A const char pointer to the data to be stored as a string.
-  /// @param[in] len The number of bytes that should be stored from `str`.
-  /// @return Returns the offset in the buffer where the string starts.
-  Offset<String> CreateSharedString(const char *str, size_t len) {
-    if (!string_pool)
-      string_pool = new StringOffsetMap(StringOffsetCompare(buf_));
-    auto size_before_string = buf_.size();
-    // Must first serialize the string, since the set is all offsets into
-    // buffer.
-    auto off = CreateString(str, len);
-    auto it = string_pool->find(off);
-    // If it exists we reuse existing serialized data!
-    if (it != string_pool->end()) {
-      // We can remove the string we serialized.
-      buf_.pop(buf_.size() - size_before_string);
-      return *it;
-    }
-    // Record this string for future use.
-    string_pool->insert(off);
-    return off;
-  }
-
-#ifdef FLATBUFFERS_HAS_STRING_VIEW
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// If a string with this exact contents has already been serialized before,
-  /// instead simply returns the offset of the existing string.
-  /// @param[in] str A const std::string_view to store in the buffer.
-  /// @return Returns the offset in the buffer where the string starts
-  Offset<String> CreateSharedString(const flatbuffers::string_view str) {
-    return CreateSharedString(str.data(), str.size());
-  }
-#else
-  /// @brief Store a string in the buffer, which null-terminated.
-  /// If a string with this exact contents has already been serialized before,
-  /// instead simply returns the offset of the existing string.
-  /// @param[in] str A const char pointer to a C-string to add to the buffer.
-  /// @return Returns the offset in the buffer where the string starts.
-  Offset<String> CreateSharedString(const char *str) {
-    return CreateSharedString(str, strlen(str));
-  }
-
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// If a string with this exact contents has already been serialized before,
-  /// instead simply returns the offset of the existing string.
-  /// @param[in] str A const reference to a std::string to store in the buffer.
-  /// @return Returns the offset in the buffer where the string starts.
-  Offset<String> CreateSharedString(const std::string &str) {
-    return CreateSharedString(str.c_str(), str.length());
-  }
-#endif
-
-  /// @brief Store a string in the buffer, which can contain any binary data.
-  /// If a string with this exact contents has already been serialized before,
-  /// instead simply returns the offset of the existing string.
-  /// @param[in] str A const pointer to a `String` struct to add to the buffer.
-  /// @return Returns the offset in the buffer where the string starts
-  Offset<String> CreateSharedString(const String *str) {
-    return CreateSharedString(str->c_str(), str->size());
-  }
-
-  /// @cond FLATBUFFERS_INTERNAL
-  uoffset_t EndVector(size_t len) {
-    FLATBUFFERS_ASSERT(nested);  // Hit if no corresponding StartVector.
-    nested = false;
-    return PushElement(static_cast<uoffset_t>(len));
-  }
-
-  void StartVector(size_t len, size_t elemsize) {
-    NotNested();
-    nested = true;
-    PreAlign<uoffset_t>(len * elemsize);
-    PreAlign(len * elemsize, elemsize);  // Just in case elemsize > uoffset_t.
-  }
-
-  // Call this right before StartVector/CreateVector if you want to force the
-  // alignment to be something different than what the element size would
-  // normally dictate.
-  // This is useful when storing a nested_flatbuffer in a vector of bytes,
-  // or when storing SIMD floats, etc.
-  void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {
-    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));
-    PreAlign(len * elemsize, alignment);
-  }
-
-  // Similar to ForceVectorAlignment but for String fields.
-  void ForceStringAlignment(size_t len, size_t alignment) {
-    FLATBUFFERS_ASSERT(VerifyAlignmentRequirements(alignment));
-    PreAlign((len + 1) * sizeof(char), alignment);
-  }
-
-  /// @endcond
-
-  /// @brief Serialize an array into a FlatBuffer `vector`.
-  /// @tparam T The data type of the array elements.
-  /// @param[in] v A pointer to the array of type `T` to serialize into the
-  /// buffer as a `vector`.
-  /// @param[in] len The number of elements to serialize.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T> Offset<Vector<T>> CreateVector(const T *v, size_t len) {
-    // If this assert hits, you're specifying a template argument that is
-    // causing the wrong overload to be selected, remove it.
-    AssertScalarT<T>();
-    StartVector(len, sizeof(T));
-    if (len == 0) { return Offset<Vector<T>>(EndVector(len)); }
-    // clang-format off
-    #if FLATBUFFERS_LITTLEENDIAN
-      PushBytes(reinterpret_cast<const uint8_t *>(v), len * sizeof(T));
-    #else
-      if (sizeof(T) == 1) {
-        PushBytes(reinterpret_cast<const uint8_t *>(v), len);
-      } else {
-        for (auto i = len; i > 0; ) {
-          PushElement(v[--i]);
-        }
-      }
-    #endif
-    // clang-format on
-    return Offset<Vector<T>>(EndVector(len));
-  }
-
-  template<typename T>
-  Offset<Vector<Offset<T>>> CreateVector(const Offset<T> *v, size_t len) {
-    StartVector(len, sizeof(Offset<T>));
-    for (auto i = len; i > 0;) { PushElement(v[--i]); }
-    return Offset<Vector<Offset<T>>>(EndVector(len));
-  }
-
-  /// @brief Serialize a `std::vector` into a FlatBuffer `vector`.
-  /// @tparam T The data type of the `std::vector` elements.
-  /// @param v A const reference to the `std::vector` to serialize into the
-  /// buffer as a `vector`.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T> Offset<Vector<T>> CreateVector(const std::vector<T> &v) {
-    return CreateVector(data(v), v.size());
-  }
-
-  // vector<bool> may be implemented using a bit-set, so we can't access it as
-  // an array. Instead, read elements manually.
-  // Background: https://isocpp.org/blog/2012/11/on-vectorbool
-  Offset<Vector<uint8_t>> CreateVector(const std::vector<bool> &v) {
-    StartVector(v.size(), sizeof(uint8_t));
-    for (auto i = v.size(); i > 0;) {
-      PushElement(static_cast<uint8_t>(v[--i]));
-    }
-    return Offset<Vector<uint8_t>>(EndVector(v.size()));
-  }
-
-  // clang-format off
-  #ifndef FLATBUFFERS_CPP98_STL
-  /// @brief Serialize values returned by a function into a FlatBuffer `vector`.
-  /// This is a convenience function that takes care of iteration for you.
-  /// @tparam T The data type of the `std::vector` elements.
-  /// @param f A function that takes the current iteration 0..vector_size-1 and
-  /// returns any type that you can construct a FlatBuffers vector out of.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T> Offset<Vector<T>> CreateVector(size_t vector_size,
-      const std::function<T (size_t i)> &f) {
-    std::vector<T> elems(vector_size);
-    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i);
-    return CreateVector(elems);
-  }
-  #endif
-  // clang-format on
-
-  /// @brief Serialize values returned by a function into a FlatBuffer `vector`.
-  /// This is a convenience function that takes care of iteration for you.
-  /// @tparam T The data type of the `std::vector` elements.
-  /// @param f A function that takes the current iteration 0..vector_size-1,
-  /// and the state parameter returning any type that you can construct a
-  /// FlatBuffers vector out of.
-  /// @param state State passed to f.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T, typename F, typename S>
-  Offset<Vector<T>> CreateVector(size_t vector_size, F f, S *state) {
-    std::vector<T> elems(vector_size);
-    for (size_t i = 0; i < vector_size; i++) elems[i] = f(i, state);
-    return CreateVector(elems);
-  }
-
-  /// @brief Serialize a `std::vector<std::string>` into a FlatBuffer `vector`.
-  /// This is a convenience function for a common case.
-  /// @param v A const reference to the `std::vector` to serialize into the
-  /// buffer as a `vector`.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  Offset<Vector<Offset<String>>> CreateVectorOfStrings(
-      const std::vector<std::string> &v) {
-    std::vector<Offset<String>> offsets(v.size());
-    for (size_t i = 0; i < v.size(); i++) offsets[i] = CreateString(v[i]);
-    return CreateVector(offsets);
-  }
-
-  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
-  /// @tparam T The data type of the struct array elements.
-  /// @param[in] v A pointer to the array of type `T` to serialize into the
-  /// buffer as a `vector`.
-  /// @param[in] len The number of elements to serialize.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T>
-  Offset<Vector<const T *>> CreateVectorOfStructs(const T *v, size_t len) {
-    StartVector(len * sizeof(T) / AlignOf<T>(), AlignOf<T>());
-    PushBytes(reinterpret_cast<const uint8_t *>(v), sizeof(T) * len);
-    return Offset<Vector<const T *>>(EndVector(len));
-  }
-
-  /// @brief Serialize an array of native structs into a FlatBuffer `vector`.
-  /// @tparam T The data type of the struct array elements.
-  /// @tparam S The data type of the native struct array elements.
-  /// @param[in] v A pointer to the array of type `S` to serialize into the
-  /// buffer as a `vector`.
-  /// @param[in] len The number of elements to serialize.
-  /// @param[in] pack_func Pointer to a function to convert the native struct
-  /// to the FlatBuffer struct.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T, typename S>
-  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
-      const S *v, size_t len, T((*const pack_func)(const S &))) {
-    FLATBUFFERS_ASSERT(pack_func);
-    std::vector<T> vv(len);
-    std::transform(v, v + len, vv.begin(), pack_func);
-    return CreateVectorOfStructs<T>(data(vv), vv.size());
-  }
-
-  /// @brief Serialize an array of native structs into a FlatBuffer `vector`.
-  /// @tparam T The data type of the struct array elements.
-  /// @tparam S The data type of the native struct array elements.
-  /// @param[in] v A pointer to the array of type `S` to serialize into the
-  /// buffer as a `vector`.
-  /// @param[in] len The number of elements to serialize.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T, typename S>
-  Offset<Vector<const T *>> CreateVectorOfNativeStructs(const S *v,
-                                                        size_t len) {
-    extern T Pack(const S &);
-    return CreateVectorOfNativeStructs(v, len, Pack);
-  }
-
-  // clang-format off
-  #ifndef FLATBUFFERS_CPP98_STL
-  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
-  /// @tparam T The data type of the struct array elements.
-  /// @param[in] filler A function that takes the current iteration 0..vector_size-1
-  /// and a pointer to the struct that must be filled.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  /// This is mostly useful when flatbuffers are generated with mutation
-  /// accessors.
-  template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(
-      size_t vector_size, const std::function<void(size_t i, T *)> &filler) {
-    T* structs = StartVectorOfStructs<T>(vector_size);
-    for (size_t i = 0; i < vector_size; i++) {
-      filler(i, structs);
-      structs++;
-    }
-    return EndVectorOfStructs<T>(vector_size);
-  }
-  #endif
-  // clang-format on
-
-  /// @brief Serialize an array of structs into a FlatBuffer `vector`.
-  /// @tparam T The data type of the struct array elements.
-  /// @param[in] f A function that takes the current iteration 0..vector_size-1,
-  /// a pointer to the struct that must be filled and the state argument.
-  /// @param[in] state Arbitrary state to pass to f.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  /// This is mostly useful when flatbuffers are generated with mutation
-  /// accessors.
-  template<typename T, typename F, typename S>
-  Offset<Vector<const T *>> CreateVectorOfStructs(size_t vector_size, F f,
-                                                  S *state) {
-    T *structs = StartVectorOfStructs<T>(vector_size);
-    for (size_t i = 0; i < vector_size; i++) {
-      f(i, structs, state);
-      structs++;
-    }
-    return EndVectorOfStructs<T>(vector_size);
-  }
-
-  /// @brief Serialize a `std::vector` of structs into a FlatBuffer `vector`.
-  /// @tparam T The data type of the `std::vector` struct elements.
-  /// @param[in] v A const reference to the `std::vector` of structs to
-  /// serialize into the buffer as a `vector`.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T, typename Alloc>
-  Offset<Vector<const T *>> CreateVectorOfStructs(
-      const std::vector<T, Alloc> &v) {
-    return CreateVectorOfStructs(data(v), v.size());
-  }
-
-  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
-  /// `vector`.
-  /// @tparam T The data type of the `std::vector` struct elements.
-  /// @tparam S The data type of the `std::vector` native struct elements.
-  /// @param[in] v A const reference to the `std::vector` of structs to
-  /// serialize into the buffer as a `vector`.
-  /// @param[in] pack_func Pointer to a function to convert the native struct
-  /// to the FlatBuffer struct.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T, typename S>
-  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
-      const std::vector<S> &v, T((*const pack_func)(const S &))) {
-    return CreateVectorOfNativeStructs<T, S>(data(v), v.size(), pack_func);
-  }
-
-  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
-  /// `vector`.
-  /// @tparam T The data type of the `std::vector` struct elements.
-  /// @tparam S The data type of the `std::vector` native struct elements.
-  /// @param[in] v A const reference to the `std::vector` of structs to
-  /// serialize into the buffer as a `vector`.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T, typename S>
-  Offset<Vector<const T *>> CreateVectorOfNativeStructs(
-      const std::vector<S> &v) {
-    return CreateVectorOfNativeStructs<T, S>(data(v), v.size());
-  }
-
-  /// @cond FLATBUFFERS_INTERNAL
-  template<typename T> struct StructKeyComparator {
-    bool operator()(const T &a, const T &b) const {
-      return a.KeyCompareLessThan(&b);
-    }
-
-    FLATBUFFERS_DELETE_FUNC(
-        StructKeyComparator &operator=(const StructKeyComparator &));
-  };
-  /// @endcond
-
-  /// @brief Serialize a `std::vector` of structs into a FlatBuffer `vector`
-  /// in sorted order.
-  /// @tparam T The data type of the `std::vector` struct elements.
-  /// @param[in] v A const reference to the `std::vector` of structs to
-  /// serialize into the buffer as a `vector`.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T>
-  Offset<Vector<const T *>> CreateVectorOfSortedStructs(std::vector<T> *v) {
-    return CreateVectorOfSortedStructs(data(*v), v->size());
-  }
-
-  /// @brief Serialize a `std::vector` of native structs into a FlatBuffer
-  /// `vector` in sorted order.
-  /// @tparam T The data type of the `std::vector` struct elements.
-  /// @tparam S The data type of the `std::vector` native struct elements.
-  /// @param[in] v A const reference to the `std::vector` of structs to
-  /// serialize into the buffer as a `vector`.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T, typename S>
-  Offset<Vector<const T *>> CreateVectorOfSortedNativeStructs(
-      std::vector<S> *v) {
-    return CreateVectorOfSortedNativeStructs<T, S>(data(*v), v->size());
-  }
-
-  /// @brief Serialize an array of structs into a FlatBuffer `vector` in sorted
-  /// order.
-  /// @tparam T The data type of the struct array elements.
-  /// @param[in] v A pointer to the array of type `T` to serialize into the
-  /// buffer as a `vector`.
-  /// @param[in] len The number of elements to serialize.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T>
-  Offset<Vector<const T *>> CreateVectorOfSortedStructs(T *v, size_t len) {
-    std::sort(v, v + len, StructKeyComparator<T>());
-    return CreateVectorOfStructs(v, len);
-  }
-
-  /// @brief Serialize an array of native structs into a FlatBuffer `vector` in
-  /// sorted order.
-  /// @tparam T The data type of the struct array elements.
-  /// @tparam S The data type of the native struct array elements.
-  /// @param[in] v A pointer to the array of type `S` to serialize into the
-  /// buffer as a `vector`.
-  /// @param[in] len The number of elements to serialize.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T, typename S>
-  Offset<Vector<const T *>> CreateVectorOfSortedNativeStructs(S *v,
-                                                              size_t len) {
-    extern T Pack(const S &);
-    typedef T (*Pack_t)(const S &);
-    std::vector<T> vv(len);
-    std::transform(v, v + len, vv.begin(), static_cast<Pack_t &>(Pack));
-    return CreateVectorOfSortedStructs<T>(vv, len);
-  }
-
-  /// @cond FLATBUFFERS_INTERNAL
-  template<typename T> struct TableKeyComparator {
-    TableKeyComparator(vector_downward &buf) : buf_(buf) {}
-    TableKeyComparator(const TableKeyComparator &other) : buf_(other.buf_) {}
-    bool operator()(const Offset<T> &a, const Offset<T> &b) const {
-      auto table_a = reinterpret_cast<T *>(buf_.data_at(a.o));
-      auto table_b = reinterpret_cast<T *>(buf_.data_at(b.o));
-      return table_a->KeyCompareLessThan(table_b);
-    }
-    vector_downward &buf_;
-
-   private:
-    FLATBUFFERS_DELETE_FUNC(
-        TableKeyComparator &operator=(const TableKeyComparator &other));
-  };
-  /// @endcond
-
-  /// @brief Serialize an array of `table` offsets as a `vector` in the buffer
-  /// in sorted order.
-  /// @tparam T The data type that the offset refers to.
-  /// @param[in] v An array of type `Offset<T>` that contains the `table`
-  /// offsets to store in the buffer in sorted order.
-  /// @param[in] len The number of elements to store in the `vector`.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T>
-  Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(Offset<T> *v,
-                                                       size_t len) {
-    std::sort(v, v + len, TableKeyComparator<T>(buf_));
-    return CreateVector(v, len);
-  }
-
-  /// @brief Serialize an array of `table` offsets as a `vector` in the buffer
-  /// in sorted order.
-  /// @tparam T The data type that the offset refers to.
-  /// @param[in] v An array of type `Offset<T>` that contains the `table`
-  /// offsets to store in the buffer in sorted order.
-  /// @return Returns a typed `Offset` into the serialized data indicating
-  /// where the vector is stored.
-  template<typename T>
-  Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(
-      std::vector<Offset<T>> *v) {
-    return CreateVectorOfSortedTables(data(*v), v->size());
-  }
-
-  /// @brief Specialized version of `CreateVector` for non-copying use cases.
-  /// Write the data any time later to the returned buffer pointer `buf`.
-  /// @param[in] len The number of elements to store in the `vector`.
-  /// @param[in] elemsize The size of each element in the `vector`.
-  /// @param[out] buf A pointer to a `uint8_t` pointer that can be
-  /// written to at a later time to serialize the data into a `vector`
-  /// in the buffer.
-  uoffset_t CreateUninitializedVector(size_t len, size_t elemsize,
-                                      uint8_t **buf) {
-    NotNested();
-    StartVector(len, elemsize);
-    buf_.make_space(len * elemsize);
-    auto vec_start = GetSize();
-    auto vec_end = EndVector(len);
-    *buf = buf_.data_at(vec_start);
-    return vec_end;
-  }
-
-  /// @brief Specialized version of `CreateVector` for non-copying use cases.
-  /// Write the data any time later to the returned buffer pointer `buf`.
-  /// @tparam T The data type of the data that will be stored in the buffer
-  /// as a `vector`.
-  /// @param[in] len The number of elements to store in the `vector`.
-  /// @param[out] buf A pointer to a pointer of type `T` that can be
-  /// written to at a later time to serialize the data into a `vector`
-  /// in the buffer.
-  template<typename T>
-  Offset<Vector<T>> CreateUninitializedVector(size_t len, T **buf) {
-    AssertScalarT<T>();
-    return CreateUninitializedVector(len, sizeof(T),
-                                     reinterpret_cast<uint8_t **>(buf));
-  }
-
-  template<typename T>
-  Offset<Vector<const T *>> CreateUninitializedVectorOfStructs(size_t len,
-                                                               T **buf) {
-    return CreateUninitializedVector(len, sizeof(T),
-                                     reinterpret_cast<uint8_t **>(buf));
-  }
-
-  // @brief Create a vector of scalar type T given as input a vector of scalar
-  // type U, useful with e.g. pre "enum class" enums, or any existing scalar
-  // data of the wrong type.
-  template<typename T, typename U>
-  Offset<Vector<T>> CreateVectorScalarCast(const U *v, size_t len) {
-    AssertScalarT<T>();
-    AssertScalarT<U>();
-    StartVector(len, sizeof(T));
-    for (auto i = len; i > 0;) { PushElement(static_cast<T>(v[--i])); }
-    return Offset<Vector<T>>(EndVector(len));
-  }
-
-  /// @brief Write a struct by itself, typically to be part of a union.
-  template<typename T> Offset<const T *> CreateStruct(const T &structobj) {
-    NotNested();
-    Align(AlignOf<T>());
-    buf_.push_small(structobj);
-    return Offset<const T *>(GetSize());
-  }
-
-  /// @brief The length of a FlatBuffer file header.
-  static const size_t kFileIdentifierLength = 4;
-
-  /// @brief Finish serializing a buffer by writing the root offset.
-  /// @param[in] file_identifier If a `file_identifier` is given, the buffer
-  /// will be prefixed with a standard FlatBuffers file header.
-  template<typename T>
-  void Finish(Offset<T> root, const char *file_identifier = nullptr) {
-    Finish(root.o, file_identifier, false);
-  }
-
-  /// @brief Finish a buffer with a 32 bit size field pre-fixed (size of the
-  /// buffer following the size field). These buffers are NOT compatible
-  /// with standard buffers created by Finish, i.e. you can't call GetRoot
-  /// on them, you have to use GetSizePrefixedRoot instead.
-  /// All >32 bit quantities in this buffer will be aligned when the whole
-  /// size pre-fixed buffer is aligned.
-  /// These kinds of buffers are useful for creating a stream of FlatBuffers.
-  template<typename T>
-  void FinishSizePrefixed(Offset<T> root,
-                          const char *file_identifier = nullptr) {
-    Finish(root.o, file_identifier, true);
-  }
-
-  void SwapBufAllocator(FlatBufferBuilder &other) {
-    buf_.swap_allocator(other.buf_);
-  }
-
- protected:
-  // You shouldn't really be copying instances of this class.
-  FlatBufferBuilder(const FlatBufferBuilder &);
-  FlatBufferBuilder &operator=(const FlatBufferBuilder &);
-
-  void Finish(uoffset_t root, const char *file_identifier, bool size_prefix) {
-    NotNested();
-    buf_.clear_scratch();
-    // This will cause the whole buffer to be aligned.
-    PreAlign((size_prefix ? sizeof(uoffset_t) : 0) + sizeof(uoffset_t) +
-                 (file_identifier ? kFileIdentifierLength : 0),
-             minalign_);
-    if (file_identifier) {
-      FLATBUFFERS_ASSERT(strlen(file_identifier) == kFileIdentifierLength);
-      PushBytes(reinterpret_cast<const uint8_t *>(file_identifier),
-                kFileIdentifierLength);
-    }
-    PushElement(ReferTo(root));  // Location of root.
-    if (size_prefix) { PushElement(GetSize()); }
-    finished = true;
-  }
-
-  struct FieldLoc {
-    uoffset_t off;
-    voffset_t id;
-  };
-
-  vector_downward buf_;
-
-  // Accumulating offsets of table members while it is being built.
-  // We store these in the scratch pad of buf_, after the vtable offsets.
-  uoffset_t num_field_loc;
-  // Track how much of the vtable is in use, so we can output the most compact
-  // possible vtable.
-  voffset_t max_voffset_;
-
-  // Ensure objects are not nested.
-  bool nested;
-
-  // Ensure the buffer is finished before it is being accessed.
-  bool finished;
-
-  size_t minalign_;
-
-  bool force_defaults_;  // Serialize values equal to their defaults anyway.
-
-  bool dedup_vtables_;
-
-  struct StringOffsetCompare {
-    StringOffsetCompare(const vector_downward &buf) : buf_(&buf) {}
-    bool operator()(const Offset<String> &a, const Offset<String> &b) const {
-      auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));
-      auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));
-      return StringLessThan(stra->data(), stra->size(), strb->data(),
-                            strb->size());
-    }
-    const vector_downward *buf_;
-  };
-
-  // For use with CreateSharedString. Instantiated on first use only.
-  typedef std::set<Offset<String>, StringOffsetCompare> StringOffsetMap;
-  StringOffsetMap *string_pool;
-
- private:
-  // Allocates space for a vector of structures.
-  // Must be completed with EndVectorOfStructs().
-  template<typename T> T *StartVectorOfStructs(size_t vector_size) {
-    StartVector(vector_size * sizeof(T) / AlignOf<T>(), AlignOf<T>());
-    return reinterpret_cast<T *>(buf_.make_space(vector_size * sizeof(T)));
-  }
-
-  // End the vector of structues in the flatbuffers.
-  // Vector should have previously be started with StartVectorOfStructs().
-  template<typename T>
-  Offset<Vector<const T *>> EndVectorOfStructs(size_t vector_size) {
-    return Offset<Vector<const T *>>(EndVector(vector_size));
-  }
-};
-/// @}
-
-/// @cond FLATBUFFERS_INTERNAL
-// Helpers to get a typed pointer to the root object contained in the buffer.
-template<typename T> T *GetMutableRoot(void *buf) {
-  EndianCheck();
-  return reinterpret_cast<T *>(
-      reinterpret_cast<uint8_t *>(buf) +
-      EndianScalar(*reinterpret_cast<uoffset_t *>(buf)));
-}
-
-template<typename T> const T *GetRoot(const void *buf) {
-  return GetMutableRoot<T>(const_cast<void *>(buf));
-}
-
-template<typename T> const T *GetSizePrefixedRoot(const void *buf) {
-  return GetRoot<T>(reinterpret_cast<const uint8_t *>(buf) + sizeof(uoffset_t));
-}
-
-/// Helpers to get a typed pointer to objects that are currently being built.
-/// @warning Creating new objects will lead to reallocations and invalidates
-/// the pointer!
-template<typename T>
-T *GetMutableTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
-  return reinterpret_cast<T *>(fbb.GetCurrentBufferPointer() + fbb.GetSize() -
-                               offset.o);
-}
-
-template<typename T>
-const T *GetTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
-  return GetMutableTemporaryPointer<T>(fbb, offset);
-}
-
-/// @brief Get a pointer to the the file_identifier section of the buffer.
-/// @return Returns a const char pointer to the start of the file_identifier
-/// characters in the buffer.  The returned char * has length
-/// 'flatbuffers::FlatBufferBuilder::kFileIdentifierLength'.
-/// This function is UNDEFINED for FlatBuffers whose schema does not include
-/// a file_identifier (likely points at padding or the start of a the root
-/// vtable).
-inline const char *GetBufferIdentifier(const void *buf,
-                                       bool size_prefixed = false) {
-  return reinterpret_cast<const char *>(buf) +
-         ((size_prefixed) ? 2 * sizeof(uoffset_t) : sizeof(uoffset_t));
-}
-
-// Helper to see if the identifier in a buffer has the expected value.
-inline bool BufferHasIdentifier(const void *buf, const char *identifier,
-                                bool size_prefixed = false) {
-  return strncmp(GetBufferIdentifier(buf, size_prefixed), identifier,
-                 FlatBufferBuilder::kFileIdentifierLength) == 0;
-}
-
-// Helper class to verify the integrity of a FlatBuffer
-class Verifier FLATBUFFERS_FINAL_CLASS {
- public:
-  Verifier(const uint8_t *buf, size_t buf_len, uoffset_t _max_depth = 64,
-           uoffset_t _max_tables = 1000000, bool _check_alignment = true)
-      : buf_(buf),
-        size_(buf_len),
-        depth_(0),
-        max_depth_(_max_depth),
-        num_tables_(0),
-        max_tables_(_max_tables),
-        upper_bound_(0),
-        check_alignment_(_check_alignment) {
-    FLATBUFFERS_ASSERT(size_ < FLATBUFFERS_MAX_BUFFER_SIZE);
-  }
-
-  // Central location where any verification failures register.
-  bool Check(bool ok) const {
-    // clang-format off
-    #ifdef FLATBUFFERS_DEBUG_VERIFICATION_FAILURE
-      FLATBUFFERS_ASSERT(ok);
-    #endif
-    #ifdef FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE
-      if (!ok)
-        upper_bound_ = 0;
-    #endif
-    // clang-format on
-    return ok;
-  }
-
-  // Verify any range within the buffer.
-  bool Verify(size_t elem, size_t elem_len) const {
-    // clang-format off
-    #ifdef FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE
-      auto upper_bound = elem + elem_len;
-      if (upper_bound_ < upper_bound)
-        upper_bound_ =  upper_bound;
-    #endif
-    // clang-format on
-    return Check(elem_len < size_ && elem <= size_ - elem_len);
-  }
-
-  template<typename T> bool VerifyAlignment(size_t elem) const {
-    return Check((elem & (sizeof(T) - 1)) == 0 || !check_alignment_);
-  }
-
-  // Verify a range indicated by sizeof(T).
-  template<typename T> bool Verify(size_t elem) const {
-    return VerifyAlignment<T>(elem) && Verify(elem, sizeof(T));
-  }
-
-  bool VerifyFromPointer(const uint8_t *p, size_t len) {
-    auto o = static_cast<size_t>(p - buf_);
-    return Verify(o, len);
-  }
-
-  // Verify relative to a known-good base pointer.
-  bool Verify(const uint8_t *base, voffset_t elem_off, size_t elem_len) const {
-    return Verify(static_cast<size_t>(base - buf_) + elem_off, elem_len);
-  }
-
-  template<typename T>
-  bool Verify(const uint8_t *base, voffset_t elem_off) const {
-    return Verify(static_cast<size_t>(base - buf_) + elem_off, sizeof(T));
-  }
-
-  // Verify a pointer (may be NULL) of a table type.
-  template<typename T> bool VerifyTable(const T *table) {
-    return !table || table->Verify(*this);
-  }
-
-  // Verify a pointer (may be NULL) of any vector type.
-  template<typename T> bool VerifyVector(const Vector<T> *vec) const {
-    return !vec || VerifyVectorOrString(reinterpret_cast<const uint8_t *>(vec),
-                                        sizeof(T));
-  }
-
-  // Verify a pointer (may be NULL) of a vector to struct.
-  template<typename T> bool VerifyVector(const Vector<const T *> *vec) const {
-    return VerifyVector(reinterpret_cast<const Vector<T> *>(vec));
-  }
-
-  // Verify a pointer (may be NULL) to string.
-  bool VerifyString(const String *str) const {
-    size_t end;
-    return !str || (VerifyVectorOrString(reinterpret_cast<const uint8_t *>(str),
-                                         1, &end) &&
-                    Verify(end, 1) &&           // Must have terminator
-                    Check(buf_[end] == '\0'));  // Terminating byte must be 0.
-  }
-
-  // Common code between vectors and strings.
-  bool VerifyVectorOrString(const uint8_t *vec, size_t elem_size,
-                            size_t *end = nullptr) const {
-    auto veco = static_cast<size_t>(vec - buf_);
-    // Check we can read the size field.
-    if (!Verify<uoffset_t>(veco)) return false;
-    // Check the whole array. If this is a string, the byte past the array
-    // must be 0.
-    auto size = ReadScalar<uoffset_t>(vec);
-    auto max_elems = FLATBUFFERS_MAX_BUFFER_SIZE / elem_size;
-    if (!Check(size < max_elems))
-      return false;  // Protect against byte_size overflowing.
-    auto byte_size = sizeof(size) + elem_size * size;
-    if (end) *end = veco + byte_size;
-    return Verify(veco, byte_size);
-  }
-
-  // Special case for string contents, after the above has been called.
-  bool VerifyVectorOfStrings(const Vector<Offset<String>> *vec) const {
-    if (vec) {
-      for (uoffset_t i = 0; i < vec->size(); i++) {
-        if (!VerifyString(vec->Get(i))) return false;
-      }
-    }
-    return true;
-  }
-
-  // Special case for table contents, after the above has been called.
-  template<typename T> bool VerifyVectorOfTables(const Vector<Offset<T>> *vec) {
-    if (vec) {
-      for (uoffset_t i = 0; i < vec->size(); i++) {
-        if (!vec->Get(i)->Verify(*this)) return false;
-      }
-    }
-    return true;
-  }
-
-  __supress_ubsan__("unsigned-integer-overflow") bool VerifyTableStart(
-      const uint8_t *table) {
-    // Check the vtable offset.
-    auto tableo = static_cast<size_t>(table - buf_);
-    if (!Verify<soffset_t>(tableo)) return false;
-    // This offset may be signed, but doing the subtraction unsigned always
-    // gives the result we want.
-    auto vtableo = tableo - static_cast<size_t>(ReadScalar<soffset_t>(table));
-    // Check the vtable size field, then check vtable fits in its entirety.
-    return VerifyComplexity() && Verify<voffset_t>(vtableo) &&
-           VerifyAlignment<voffset_t>(ReadScalar<voffset_t>(buf_ + vtableo)) &&
-           Verify(vtableo, ReadScalar<voffset_t>(buf_ + vtableo));
-  }
-
-  template<typename T>
-  bool VerifyBufferFromStart(const char *identifier, size_t start) {
-    if (identifier && !Check((size_ >= 2 * sizeof(flatbuffers::uoffset_t) &&
-                              BufferHasIdentifier(buf_ + start, identifier)))) {
-      return false;
-    }
-
-    // Call T::Verify, which must be in the generated code for this type.
-    auto o = VerifyOffset(start);
-    return o && reinterpret_cast<const T *>(buf_ + start + o)->Verify(*this)
-    // clang-format off
-    #ifdef FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE
-           && GetComputedSize()
-    #endif
-        ;
-    // clang-format on
-  }
-
-  // Verify this whole buffer, starting with root type T.
-  template<typename T> bool VerifyBuffer() { return VerifyBuffer<T>(nullptr); }
-
-  template<typename T> bool VerifyBuffer(const char *identifier) {
-    return VerifyBufferFromStart<T>(identifier, 0);
-  }
-
-  template<typename T> bool VerifySizePrefixedBuffer(const char *identifier) {
-    return Verify<uoffset_t>(0U) &&
-           ReadScalar<uoffset_t>(buf_) == size_ - sizeof(uoffset_t) &&
-           VerifyBufferFromStart<T>(identifier, sizeof(uoffset_t));
-  }
-
-  uoffset_t VerifyOffset(size_t start) const {
-    if (!Verify<uoffset_t>(start)) return 0;
-    auto o = ReadScalar<uoffset_t>(buf_ + start);
-    // May not point to itself.
-    if (!Check(o != 0)) return 0;
-    // Can't wrap around / buffers are max 2GB.
-    if (!Check(static_cast<soffset_t>(o) >= 0)) return 0;
-    // Must be inside the buffer to create a pointer from it (pointer outside
-    // buffer is UB).
-    if (!Verify(start + o, 1)) return 0;
-    return o;
-  }
-
-  uoffset_t VerifyOffset(const uint8_t *base, voffset_t start) const {
-    return VerifyOffset(static_cast<size_t>(base - buf_) + start);
-  }
-
-  // Called at the start of a table to increase counters measuring data
-  // structure depth and amount, and possibly bails out with false if
-  // limits set by the constructor have been hit. Needs to be balanced
-  // with EndTable().
-  bool VerifyComplexity() {
-    depth_++;
-    num_tables_++;
-    return Check(depth_ <= max_depth_ && num_tables_ <= max_tables_);
-  }
-
-  // Called at the end of a table to pop the depth count.
-  bool EndTable() {
-    depth_--;
-    return true;
-  }
-
-  // Returns the message size in bytes
-  size_t GetComputedSize() const {
-    // clang-format off
-    #ifdef FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE
-      uintptr_t size = upper_bound_;
-      // Align the size to uoffset_t
-      size = (size - 1 + sizeof(uoffset_t)) & ~(sizeof(uoffset_t) - 1);
-      return (size > size_) ?  0 : size;
-    #else
-      // Must turn on FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE for this to work.
-      (void)upper_bound_;
-      FLATBUFFERS_ASSERT(false);
-      return 0;
-    #endif
-    // clang-format on
-  }
-
- private:
-  const uint8_t *buf_;
-  size_t size_;
-  uoffset_t depth_;
-  uoffset_t max_depth_;
-  uoffset_t num_tables_;
-  uoffset_t max_tables_;
-  mutable size_t upper_bound_;
-  bool check_alignment_;
-};
-
-// Convenient way to bundle a buffer and its length, to pass it around
-// typed by its root.
-// A BufferRef does not own its buffer.
-struct BufferRefBase {};  // for std::is_base_of
-template<typename T> struct BufferRef : BufferRefBase {
-  BufferRef() : buf(nullptr), len(0), must_free(false) {}
-  BufferRef(uint8_t *_buf, uoffset_t _len)
-      : buf(_buf), len(_len), must_free(false) {}
-
-  ~BufferRef() {
-    if (must_free) free(buf);
-  }
-
-  const T *GetRoot() const { return flatbuffers::GetRoot<T>(buf); }
-
-  bool Verify() {
-    Verifier verifier(buf, len);
-    return verifier.VerifyBuffer<T>(nullptr);
-  }
-
-  uint8_t *buf;
-  uoffset_t len;
-  bool must_free;
-};
-
-// "structs" are flat structures that do not have an offset table, thus
-// always have all members present and do not support forwards/backwards
-// compatible extensions.
-
-class Struct FLATBUFFERS_FINAL_CLASS {
- public:
-  template<typename T> T GetField(uoffset_t o) const {
-    return ReadScalar<T>(&data_[o]);
-  }
-
-  template<typename T> T GetStruct(uoffset_t o) const {
-    return reinterpret_cast<T>(&data_[o]);
-  }
-
-  const uint8_t *GetAddressOf(uoffset_t o) const { return &data_[o]; }
-  uint8_t *GetAddressOf(uoffset_t o) { return &data_[o]; }
-
- private:
-  // private constructor & copy constructor: you obtain instances of this
-  // class by pointing to existing data only
-  Struct();
-  Struct(const Struct &);
-  Struct &operator=(const Struct &);
-
-  uint8_t data_[1];
-};
-
-// "tables" use an offset table (possibly shared) that allows fields to be
-// omitted and added at will, but uses an extra indirection to read.
-class Table {
- public:
-  const uint8_t *GetVTable() const {
-    return data_ - ReadScalar<soffset_t>(data_);
-  }
-
-  // This gets the field offset for any of the functions below it, or 0
-  // if the field was not present.
-  voffset_t GetOptionalFieldOffset(voffset_t field) const {
-    // The vtable offset is always at the start.
-    auto vtable = GetVTable();
-    // The first element is the size of the vtable (fields + type id + itself).
-    auto vtsize = ReadScalar<voffset_t>(vtable);
-    // If the field we're accessing is outside the vtable, we're reading older
-    // data, so it's the same as if the offset was 0 (not present).
-    return field < vtsize ? ReadScalar<voffset_t>(vtable + field) : 0;
-  }
-
-  template<typename T> T GetField(voffset_t field, T defaultval) const {
-    auto field_offset = GetOptionalFieldOffset(field);
-    return field_offset ? ReadScalar<T>(data_ + field_offset) : defaultval;
-  }
-
-  template<typename P> P GetPointer(voffset_t field) {
-    auto field_offset = GetOptionalFieldOffset(field);
-    auto p = data_ + field_offset;
-    return field_offset ? reinterpret_cast<P>(p + ReadScalar<uoffset_t>(p))
-                        : nullptr;
-  }
-  template<typename P> P GetPointer(voffset_t field) const {
-    return const_cast<Table *>(this)->GetPointer<P>(field);
-  }
-
-  template<typename P> P GetStruct(voffset_t field) const {
-    auto field_offset = GetOptionalFieldOffset(field);
-    auto p = const_cast<uint8_t *>(data_ + field_offset);
-    return field_offset ? reinterpret_cast<P>(p) : nullptr;
-  }
-
-  template<typename Raw, typename Face>
-  flatbuffers::Optional<Face> GetOptional(voffset_t field) const {
-    auto field_offset = GetOptionalFieldOffset(field);
-    auto p = data_ + field_offset;
-    return field_offset ? Optional<Face>(static_cast<Face>(ReadScalar<Raw>(p)))
-                        : Optional<Face>();
-  }
-
-  template<typename T> bool SetField(voffset_t field, T val, T def) {
-    auto field_offset = GetOptionalFieldOffset(field);
-    if (!field_offset) return IsTheSameAs(val, def);
-    WriteScalar(data_ + field_offset, val);
-    return true;
-  }
-  template<typename T> bool SetField(voffset_t field, T val) {
-    auto field_offset = GetOptionalFieldOffset(field);
-    if (!field_offset) return false;
-    WriteScalar(data_ + field_offset, val);
-    return true;
-  }
-
-  bool SetPointer(voffset_t field, const uint8_t *val) {
-    auto field_offset = GetOptionalFieldOffset(field);
-    if (!field_offset) return false;
-    WriteScalar(data_ + field_offset,
-                static_cast<uoffset_t>(val - (data_ + field_offset)));
-    return true;
-  }
-
-  uint8_t *GetAddressOf(voffset_t field) {
-    auto field_offset = GetOptionalFieldOffset(field);
-    return field_offset ? data_ + field_offset : nullptr;
-  }
-  const uint8_t *GetAddressOf(voffset_t field) const {
-    return const_cast<Table *>(this)->GetAddressOf(field);
-  }
-
-  bool CheckField(voffset_t field) const {
-    return GetOptionalFieldOffset(field) != 0;
-  }
-
-  // Verify the vtable of this table.
-  // Call this once per table, followed by VerifyField once per field.
-  bool VerifyTableStart(Verifier &verifier) const {
-    return verifier.VerifyTableStart(data_);
-  }
-
-  // Verify a particular field.
-  template<typename T>
-  bool VerifyField(const Verifier &verifier, voffset_t field) const {
-    // Calling GetOptionalFieldOffset should be safe now thanks to
-    // VerifyTable().
-    auto field_offset = GetOptionalFieldOffset(field);
-    // Check the actual field.
-    return !field_offset || verifier.Verify<T>(data_, field_offset);
-  }
-
-  // VerifyField for required fields.
-  template<typename T>
-  bool VerifyFieldRequired(const Verifier &verifier, voffset_t field) const {
-    auto field_offset = GetOptionalFieldOffset(field);
-    return verifier.Check(field_offset != 0) &&
-           verifier.Verify<T>(data_, field_offset);
-  }
-
-  // Versions for offsets.
-  bool VerifyOffset(const Verifier &verifier, voffset_t field) const {
-    auto field_offset = GetOptionalFieldOffset(field);
-    return !field_offset || verifier.VerifyOffset(data_, field_offset);
-  }
-
-  bool VerifyOffsetRequired(const Verifier &verifier, voffset_t field) const {
-    auto field_offset = GetOptionalFieldOffset(field);
-    return verifier.Check(field_offset != 0) &&
-           verifier.VerifyOffset(data_, field_offset);
-  }
-
- private:
-  // private constructor & copy constructor: you obtain instances of this
-  // class by pointing to existing data only
-  Table();
-  Table(const Table &other);
-  Table &operator=(const Table &);
-
-  uint8_t data_[1];
-};
-
-// This specialization allows avoiding warnings like:
-// MSVC C4800: type: forcing value to bool 'true' or 'false'.
-template<>
-inline flatbuffers::Optional<bool> Table::GetOptional<uint8_t, bool>(
-    voffset_t field) const {
-  auto field_offset = GetOptionalFieldOffset(field);
-  auto p = data_ + field_offset;
-  return field_offset ? Optional<bool>(ReadScalar<uint8_t>(p) != 0)
-                      : Optional<bool>();
-}
-
-template<typename T>
-void FlatBufferBuilder::Required(Offset<T> table, voffset_t field) {
-  auto table_ptr = reinterpret_cast<const Table *>(buf_.data_at(table.o));
-  bool ok = table_ptr->GetOptionalFieldOffset(field) != 0;
-  // If this fails, the caller will show what field needs to be set.
-  FLATBUFFERS_ASSERT(ok);
-  (void)ok;
-}
 
 /// @brief This can compute the start of a FlatBuffer from a root pointer, i.e.
 /// it is the opposite transformation of GetRoot().
@@ -2719,7 +56,7 @@
   // file_identifier, and alignment padding) to see which points to the root.
   // None of the other values can "impersonate" the root since they will either
   // be 0 or four ASCII characters.
-  static_assert(FlatBufferBuilder::kFileIdentifierLength == sizeof(uoffset_t),
+  static_assert(flatbuffers::kFileIdentifierLength == sizeof(uoffset_t),
                 "file_identifier is assumed to be the same size as uoffset_t");
   for (auto possible_roots = FLATBUFFERS_MAX_ALIGNMENT / sizeof(uoffset_t) + 1;
        possible_roots; possible_roots--) {
@@ -2755,16 +92,9 @@
 /// if you wish. The resolver does the opposite lookup, for when the object
 /// is being serialized again.
 typedef uint64_t hash_value_t;
-// clang-format off
-#ifdef FLATBUFFERS_CPP98_STL
-  typedef void (*resolver_function_t)(void **pointer_adr, hash_value_t hash);
-  typedef hash_value_t (*rehasher_function_t)(void *pointer);
-#else
-  typedef std::function<void (void **pointer_adr, hash_value_t hash)>
-          resolver_function_t;
-  typedef std::function<hash_value_t (void *pointer)> rehasher_function_t;
-#endif
-// clang-format on
+typedef std::function<void(void **pointer_adr, hash_value_t hash)>
+    resolver_function_t;
+typedef std::function<hash_value_t(void *pointer)> rehasher_function_t;
 
 // Helper function to test if a field is present, using any of the field
 // enums in the generated code.
@@ -2821,7 +151,7 @@
 
 // Minimal reflection via code generation.
 // Besides full-fat reflection (see reflection.h) and parsing/printing by
-// loading schemas (see idl.h), we can also have code generation for mimimal
+// loading schemas (see idl.h), we can also have code generation for minimal
 // reflection data which allows pretty-printing and other uses without needing
 // a schema or a parser.
 // Generate code with --reflect-types (types only) or --reflect-names (names
@@ -2896,27 +226,13 @@
 };
 
 // String which identifies the current version of FlatBuffers.
-// flatbuffer_version_string is used by Google developers to identify which
-// applications uploaded to Google Play are using this library.  This allows
-// the development team at Google to determine the popularity of the library.
-// How it works: Applications that are uploaded to the Google Play Store are
-// scanned for this version string.  We track which applications are using it
-// to measure popularity.  You are free to remove it (of course) but we would
-// appreciate if you left it in.
+inline const char *flatbuffers_version_string() {
+  return "FlatBuffers " FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MAJOR) "."
+      FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MINOR) "."
+      FLATBUFFERS_STRING(FLATBUFFERS_VERSION_REVISION);
+}
 
-// Weak linkage is culled by VS & doesn't work on cygwin.
 // clang-format off
-#if !defined(_WIN32) && !defined(__CYGWIN__)
-
-extern volatile __attribute__((weak)) const char *flatbuffer_version_string;
-volatile __attribute__((weak)) const char *flatbuffer_version_string =
-  "FlatBuffers "
-  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MAJOR) "."
-  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_MINOR) "."
-  FLATBUFFERS_STRING(FLATBUFFERS_VERSION_REVISION);
-
-#endif  // !defined(_WIN32) && !defined(__CYGWIN__)
-
 #define FLATBUFFERS_DEFINE_BITMASK_OPERATORS(E, T)\
     inline E operator | (E lhs, E rhs){\
         return E(T(lhs) | T(rhs));\
diff -urN a/include/flatbuffers/flatc.h b/include/flatbuffers/flatc.h
--- a/include/flatbuffers/flatc.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/flatc.h	2023-01-13 07:47:06.300228238 +0000
@@ -21,6 +21,7 @@
 #include <limits>
 #include <string>
 
+#include "flatbuffers/bfbs_generator.h"
 #include "flatbuffers/flatbuffers.h"
 #include "flatbuffers/idl.h"
 #include "flatbuffers/util.h"
@@ -30,6 +31,13 @@
 extern void LogCompilerWarn(const std::string &warn);
 extern void LogCompilerError(const std::string &err);
 
+struct FlatCOption {
+  std::string short_opt;
+  std::string long_opt;
+  std::string parameter;
+  std::string description;
+};
+
 class FlatCompiler {
  public:
   // Output generator for the various programming languages and formats we
@@ -41,16 +49,18 @@
     typedef std::string (*MakeRuleFn)(const flatbuffers::Parser &parser,
                                       const std::string &path,
                                       const std::string &file_name);
+    typedef bool (*ParsingCompletedFn)(const flatbuffers::Parser &parser,
+                                       const std::string &output_path);
 
     GenerateFn generate;
-    const char *generator_opt_short;
-    const char *generator_opt_long;
     const char *lang_name;
     bool schema_only;
     GenerateFn generateGRPC;
     flatbuffers::IDLOptions::Language lang;
-    const char *generator_help;
+    FlatCOption option;
     MakeRuleFn make_rule;
+    BfbsGenerator *bfbs_generator;
+    ParsingCompletedFn parsing_completed;
   };
 
   typedef void (*WarnFn)(const FlatCompiler *flatc, const std::string &warn,
@@ -77,6 +87,7 @@
 
   int Compile(int argc, const char **argv);
 
+  std::string GetShortUsageString(const char *program_name) const;
   std::string GetUsageString(const char *program_name) const;
 
  private:
diff -urN a/include/flatbuffers/flexbuffers.h b/include/flatbuffers/flexbuffers.h
--- a/include/flatbuffers/flexbuffers.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/flexbuffers.h	2023-01-13 07:47:06.300228238 +0000
@@ -53,7 +53,7 @@
   FBT_INT = 1,
   FBT_UINT = 2,
   FBT_FLOAT = 3,
-  // Types above stored inline, types below store an offset.
+  // Types above stored inline, types below (except FBT_BOOL) store an offset.
   FBT_KEY = 4,
   FBT_STRING = 5,
   FBT_INDIRECT_INT = 6,
@@ -81,6 +81,8 @@
   FBT_BOOL = 26,
   FBT_VECTOR_BOOL =
       36,  // To Allow the same type of conversion of type to vector type
+
+  FBT_MAX_TYPE = 37
 };
 
 inline bool IsInline(Type t) { return t <= FBT_FLOAT || t == FBT_BOOL; }
@@ -155,7 +157,8 @@
   // constant, which here it isn't. Test if memcpy is still faster than
   // the conditionals in ReadSizedScalar. Can also use inline asm.
   // clang-format off
-  #if defined(_MSC_VER) && ((defined(_M_X64) && !defined(_M_ARM64EC)) || defined _M_IX86)
+  #if defined(_MSC_VER) && defined(_M_X64) && !defined(_M_ARM64EC)
+  // This is 64-bit Windows only, __movsb does not work on 32-bit Windows.
     uint64_t u = 0;
     __movsb(reinterpret_cast<uint8_t *>(&u),
             reinterpret_cast<const uint8_t *>(data), byte_width);
@@ -319,8 +322,8 @@
     return data_ == FixedTypedVector::EmptyFixedTypedVector().data_;
   }
 
-  Type ElementType() { return type_; }
-  uint8_t size() { return len_; }
+  Type ElementType() const { return type_; }
+  uint8_t size() const { return len_; }
 
  private:
   Type type_;
@@ -368,10 +371,7 @@
 class Reference {
  public:
   Reference()
-      : data_(nullptr),
-        parent_width_(0),
-        byte_width_(BIT_WIDTH_8),
-        type_(FBT_NULL) {}
+      : data_(nullptr), parent_width_(0), byte_width_(0), type_(FBT_NULL) {}
 
   Reference(const uint8_t *data, uint8_t parent_width, uint8_t byte_width,
             Type type)
@@ -572,7 +572,23 @@
       auto keys = m.Keys();
       auto vals = m.Values();
       for (size_t i = 0; i < keys.size(); i++) {
-        keys[i].ToString(true, keys_quoted, s);
+        bool kq = keys_quoted;
+        if (!kq) {
+          // FlexBuffers keys may contain arbitrary characters, only allow
+          // unquoted if it looks like an "identifier":
+          const char *p = keys[i].AsKey();
+          if (!flatbuffers::is_alpha(*p) && *p != '_') {
+              kq = true;
+          } else {
+            while (*++p) {
+              if (!flatbuffers::is_alnum(*p) && *p != '_') {
+                kq = true;
+                break;
+              }
+            }
+          }
+        }
+        keys[i].ToString(true, kq, s);
         s += ": ";
         vals[i].ToString(true, keys_quoted, s);
         if (i < keys.size() - 1) s += ", ";
@@ -756,6 +772,8 @@
     return false;
   }
 
+  friend class Verifier;
+
   const uint8_t *data_;
   uint8_t parent_width_;
   uint8_t byte_width_;
@@ -850,6 +868,7 @@
     case 2: comp = KeyCompare<uint16_t>; break;
     case 4: comp = KeyCompare<uint32_t>; break;
     case 8: comp = KeyCompare<uint64_t>; break;
+    default: FLATBUFFERS_ASSERT(false); return Reference();
   }
   auto res = std::bsearch(key, keys.data_, keys.size(), keys.byte_width_, comp);
   if (!res) return Reference(nullptr, 1, NullPackedType());
@@ -872,7 +891,7 @@
 }
 
 inline Reference GetRoot(const std::vector<uint8_t> &buffer) {
-  return GetRoot(flatbuffers::vector_data(buffer), buffer.size());
+  return GetRoot(buffer.data(), buffer.size());
 }
 
 // Flags that configure how the Builder behaves.
@@ -1068,7 +1087,16 @@
     return CreateBlob(data, len, 0, FBT_BLOB);
   }
   size_t Blob(const std::vector<uint8_t> &v) {
-    return CreateBlob(flatbuffers::vector_data(v), v.size(), 0, FBT_BLOB);
+    return CreateBlob(v.data(), v.size(), 0, FBT_BLOB);
+  }
+
+  void Blob(const char *key, const void *data, size_t len) {
+    Key(key);
+    Blob(data, len);
+  }
+  void Blob(const char *key, const std::vector<uint8_t> &v) {
+    Key(key);
+    Blob(v);
   }
 
   // TODO(wvo): support all the FlexBuffer types (like flexbuffers::String),
@@ -1086,7 +1114,7 @@
     return stack_.size();
   }
 
-  // TODO(wvo): allow this to specify an aligment greater than the natural
+  // TODO(wvo): allow this to specify an alignment greater than the natural
   // alignment.
   size_t EndVector(size_t start, bool typed, bool fixed) {
     auto vec = CreateVector(start, stack_.size() - start, 1, typed, fixed);
@@ -1121,27 +1149,24 @@
     // step automatically when appliccable, and encourage people to write in
     // sorted fashion.
     // std::sort is typically already a lot faster on sorted data though.
-    auto dict =
-        reinterpret_cast<TwoValue *>(flatbuffers::vector_data(stack_) + start);
-    std::sort(dict, dict + len,
-              [&](const TwoValue &a, const TwoValue &b) -> bool {
-                auto as = reinterpret_cast<const char *>(
-                    flatbuffers::vector_data(buf_) + a.key.u_);
-                auto bs = reinterpret_cast<const char *>(
-                    flatbuffers::vector_data(buf_) + b.key.u_);
-                auto comp = strcmp(as, bs);
-                // We want to disallow duplicate keys, since this results in a
-                // map where values cannot be found.
-                // But we can't assert here (since we don't want to fail on
-                // random JSON input) or have an error mechanism.
-                // Instead, we set has_duplicate_keys_ in the builder to
-                // signal this.
-                // TODO: Have to check for pointer equality, as some sort
-                // implementation apparently call this function with the same
-                // element?? Why?
-                if (!comp && &a != &b) has_duplicate_keys_ = true;
-                return comp < 0;
-              });
+    auto dict = reinterpret_cast<TwoValue *>(stack_.data() + start);
+    std::sort(
+        dict, dict + len, [&](const TwoValue &a, const TwoValue &b) -> bool {
+          auto as = reinterpret_cast<const char *>(buf_.data() + a.key.u_);
+          auto bs = reinterpret_cast<const char *>(buf_.data() + b.key.u_);
+          auto comp = strcmp(as, bs);
+          // We want to disallow duplicate keys, since this results in a
+          // map where values cannot be found.
+          // But we can't assert here (since we don't want to fail on
+          // random JSON input) or have an error mechanism.
+          // Instead, we set has_duplicate_keys_ in the builder to
+          // signal this.
+          // TODO: Have to check for pointer equality, as some sort
+          // implementation apparently call this function with the same
+          // element?? Why?
+          if (!comp && &a != &b) has_duplicate_keys_ = true;
+          return comp < 0;
+        });
     // First create a vector out of all keys.
     // TODO(wvo): if kBuilderFlagShareKeyVectors is true, see if we can share
     // the first vector.
@@ -1195,7 +1220,7 @@
     Vector(elems, len);
   }
   template<typename T> void Vector(const std::vector<T> &vec) {
-    Vector(flatbuffers::vector_data(vec), vec.size());
+    Vector(vec.data(), vec.size());
   }
 
   template<typename F> size_t TypedVector(F f) {
@@ -1397,12 +1422,10 @@
 
   template<typename T> static Type GetScalarType() {
     static_assert(flatbuffers::is_scalar<T>::value, "Unrelated types");
-    return flatbuffers::is_floating_point<T>::value
-               ? FBT_FLOAT
-               : flatbuffers::is_same<T, bool>::value
-                     ? FBT_BOOL
-                     : (flatbuffers::is_unsigned<T>::value ? FBT_UINT
-                                                           : FBT_INT);
+    return flatbuffers::is_floating_point<T>::value ? FBT_FLOAT
+           : flatbuffers::is_same<T, bool>::value
+               ? FBT_BOOL
+               : (flatbuffers::is_unsigned<T>::value ? FBT_UINT : FBT_INT);
   }
 
  public:
@@ -1552,9 +1575,9 @@
         }
       }
     }
-    // If you get this assert, your fixed types are not one of:
+    // If you get this assert, your typed types are not one of:
     // Int / UInt / Float / Key.
-    FLATBUFFERS_ASSERT(!fixed || IsTypedVectorElementType(vector_type));
+    FLATBUFFERS_ASSERT(!typed || IsTypedVectorElementType(vector_type));
     auto byte_width = Align(bit_width);
     // Write vector. First the keys width/offset if available, and size.
     if (keys) {
@@ -1597,10 +1620,8 @@
   struct KeyOffsetCompare {
     explicit KeyOffsetCompare(const std::vector<uint8_t> &buf) : buf_(&buf) {}
     bool operator()(size_t a, size_t b) const {
-      auto stra =
-          reinterpret_cast<const char *>(flatbuffers::vector_data(*buf_) + a);
-      auto strb =
-          reinterpret_cast<const char *>(flatbuffers::vector_data(*buf_) + b);
+      auto stra = reinterpret_cast<const char *>(buf_->data() + a);
+      auto strb = reinterpret_cast<const char *>(buf_->data() + b);
       return strcmp(stra, strb) < 0;
     }
     const std::vector<uint8_t> *buf_;
@@ -1611,11 +1632,10 @@
     explicit StringOffsetCompare(const std::vector<uint8_t> &buf)
         : buf_(&buf) {}
     bool operator()(const StringOffset &a, const StringOffset &b) const {
-      auto stra = reinterpret_cast<const char *>(
-          flatbuffers::vector_data(*buf_) + a.first);
-      auto strb = reinterpret_cast<const char *>(
-          flatbuffers::vector_data(*buf_) + b.first);
-      return strncmp(stra, strb, (std::min)(a.second, b.second) + 1) < 0;
+      auto stra = buf_->data() + a.first;
+      auto strb = buf_->data() + b.first;
+      auto cr = memcmp(stra, strb, (std::min)(a.second, b.second) + 1);
+      return cr < 0 || (cr == 0 && a.second < b.second);
     }
     const std::vector<uint8_t> *buf_;
   };
@@ -1625,8 +1645,249 @@
 
   KeyOffsetMap key_pool;
   StringOffsetMap string_pool;
+
+  friend class Verifier;
 };
 
+// Helper class to verify the integrity of a FlexBuffer
+class Verifier FLATBUFFERS_FINAL_CLASS {
+ public:
+  Verifier(const uint8_t *buf, size_t buf_len,
+           // Supplying this vector likely results in faster verification
+           // of larger buffers with many shared keys/strings, but
+           // comes at the cost of using additional memory the same size of
+           // the buffer being verified, so it is by default off.
+           std::vector<uint8_t> *reuse_tracker = nullptr,
+           bool _check_alignment = true, size_t max_depth = 64)
+      : buf_(buf),
+        size_(buf_len),
+        depth_(0),
+        max_depth_(max_depth),
+        num_vectors_(0),
+        max_vectors_(buf_len),
+        check_alignment_(_check_alignment),
+        reuse_tracker_(reuse_tracker) {
+    FLATBUFFERS_ASSERT(size_ < FLATBUFFERS_MAX_BUFFER_SIZE);
+    if (reuse_tracker_) {
+      reuse_tracker_->clear();
+      reuse_tracker_->resize(size_, PackedType(BIT_WIDTH_8, FBT_NULL));
+    }
+  }
+
+ private:
+  // Central location where any verification failures register.
+  bool Check(bool ok) const {
+    // clang-format off
+    #ifdef FLATBUFFERS_DEBUG_VERIFICATION_FAILURE
+      FLATBUFFERS_ASSERT(ok);
+    #endif
+    // clang-format on
+    return ok;
+  }
+
+  // Verify any range within the buffer.
+  bool VerifyFrom(size_t elem, size_t elem_len) const {
+    return Check(elem_len < size_ && elem <= size_ - elem_len);
+  }
+  bool VerifyBefore(size_t elem, size_t elem_len) const {
+    return Check(elem_len <= elem);
+  }
+
+  bool VerifyFromPointer(const uint8_t *p, size_t len) {
+    auto o = static_cast<size_t>(p - buf_);
+    return VerifyFrom(o, len);
+  }
+  bool VerifyBeforePointer(const uint8_t *p, size_t len) {
+    auto o = static_cast<size_t>(p - buf_);
+    return VerifyBefore(o, len);
+  }
+
+  bool VerifyByteWidth(size_t width) {
+    return Check(width == 1 || width == 2 || width == 4 || width == 8);
+  }
+
+  bool VerifyType(int type) { return Check(type >= 0 && type < FBT_MAX_TYPE); }
+
+  bool VerifyOffset(uint64_t off, const uint8_t *p) {
+    return Check(off <= static_cast<uint64_t>(size_)) &&
+           off <= static_cast<uint64_t>(p - buf_);
+  }
+
+  bool VerifyAlignment(const uint8_t *p, size_t size) const {
+    auto o = static_cast<size_t>(p - buf_);
+    return Check((o & (size - 1)) == 0 || !check_alignment_);
+  }
+
+// Macro, since we want to escape from parent function & use lazy args.
+#define FLEX_CHECK_VERIFIED(P, PACKED_TYPE)                     \
+  if (reuse_tracker_) {                                         \
+    auto packed_type = PACKED_TYPE;                             \
+    auto existing = (*reuse_tracker_)[P - buf_];                \
+    if (existing == packed_type) return true;                   \
+    /* Fail verification if already set with different type! */ \
+    if (!Check(existing == 0)) return false;                    \
+    (*reuse_tracker_)[P - buf_] = packed_type;                  \
+  }
+
+  bool VerifyVector(Reference r, const uint8_t *p, Type elem_type) {
+    // Any kind of nesting goes thru this function, so guard against that
+    // here, both with simple nesting checks, and the reuse tracker if on.
+    depth_++;
+    num_vectors_++;
+    if (!Check(depth_ <= max_depth_ && num_vectors_ <= max_vectors_))
+      return false;
+    auto size_byte_width = r.byte_width_;
+    FLEX_CHECK_VERIFIED(p,
+                        PackedType(Builder::WidthB(size_byte_width), r.type_));
+    if (!VerifyBeforePointer(p, size_byte_width)) return false;
+    auto sized = Sized(p, size_byte_width);
+    auto num_elems = sized.size();
+    auto elem_byte_width = r.type_ == FBT_STRING || r.type_ == FBT_BLOB
+                               ? uint8_t(1)
+                               : r.byte_width_;
+    auto max_elems = SIZE_MAX / elem_byte_width;
+    if (!Check(num_elems < max_elems))
+      return false;  // Protect against byte_size overflowing.
+    auto byte_size = num_elems * elem_byte_width;
+    if (!VerifyFromPointer(p, byte_size)) return false;
+    if (elem_type == FBT_NULL) {
+      // Verify type bytes after the vector.
+      if (!VerifyFromPointer(p + byte_size, num_elems)) return false;
+      auto v = Vector(p, size_byte_width);
+      for (size_t i = 0; i < num_elems; i++)
+        if (!VerifyRef(v[i])) return false;
+    } else if (elem_type == FBT_KEY) {
+      auto v = TypedVector(p, elem_byte_width, FBT_KEY);
+      for (size_t i = 0; i < num_elems; i++)
+        if (!VerifyRef(v[i])) return false;
+    } else {
+      FLATBUFFERS_ASSERT(IsInline(elem_type));
+    }
+    depth_--;
+    return true;
+  }
+
+  bool VerifyKeys(const uint8_t *p, uint8_t byte_width) {
+    // The vector part of the map has already been verified.
+    const size_t num_prefixed_fields = 3;
+    if (!VerifyBeforePointer(p, byte_width * num_prefixed_fields)) return false;
+    p -= byte_width * num_prefixed_fields;
+    auto off = ReadUInt64(p, byte_width);
+    if (!VerifyOffset(off, p)) return false;
+    auto key_byte_with =
+        static_cast<uint8_t>(ReadUInt64(p + byte_width, byte_width));
+    if (!VerifyByteWidth(key_byte_with)) return false;
+    return VerifyVector(Reference(p, byte_width, key_byte_with, FBT_VECTOR_KEY),
+                        p - off, FBT_KEY);
+  }
+
+  bool VerifyKey(const uint8_t *p) {
+    FLEX_CHECK_VERIFIED(p, PackedType(BIT_WIDTH_8, FBT_KEY));
+    while (p < buf_ + size_)
+      if (*p++) return true;
+    return false;
+  }
+
+#undef FLEX_CHECK_VERIFIED
+
+  bool VerifyTerminator(const String &s) {
+    return VerifyFromPointer(reinterpret_cast<const uint8_t *>(s.c_str()),
+                             s.size() + 1);
+  }
+
+  bool VerifyRef(Reference r) {
+    // r.parent_width_ and r.data_ already verified.
+    if (!VerifyByteWidth(r.byte_width_) || !VerifyType(r.type_)) {
+      return false;
+    }
+    if (IsInline(r.type_)) {
+      // Inline scalars, don't require further verification.
+      return true;
+    }
+    // All remaining types are an offset.
+    auto off = ReadUInt64(r.data_, r.parent_width_);
+    if (!VerifyOffset(off, r.data_)) return false;
+    auto p = r.Indirect();
+    if (!VerifyAlignment(p, r.byte_width_)) return false;
+    switch (r.type_) {
+      case FBT_INDIRECT_INT:
+      case FBT_INDIRECT_UINT:
+      case FBT_INDIRECT_FLOAT: return VerifyFromPointer(p, r.byte_width_);
+      case FBT_KEY: return VerifyKey(p);
+      case FBT_MAP:
+        return VerifyVector(r, p, FBT_NULL) && VerifyKeys(p, r.byte_width_);
+      case FBT_VECTOR: return VerifyVector(r, p, FBT_NULL);
+      case FBT_VECTOR_INT: return VerifyVector(r, p, FBT_INT);
+      case FBT_VECTOR_BOOL:
+      case FBT_VECTOR_UINT: return VerifyVector(r, p, FBT_UINT);
+      case FBT_VECTOR_FLOAT: return VerifyVector(r, p, FBT_FLOAT);
+      case FBT_VECTOR_KEY: return VerifyVector(r, p, FBT_KEY);
+      case FBT_VECTOR_STRING_DEPRECATED:
+        // Use of FBT_KEY here intentional, see elsewhere.
+        return VerifyVector(r, p, FBT_KEY);
+      case FBT_BLOB: return VerifyVector(r, p, FBT_UINT);
+      case FBT_STRING:
+        return VerifyVector(r, p, FBT_UINT) &&
+               VerifyTerminator(String(p, r.byte_width_));
+      case FBT_VECTOR_INT2:
+      case FBT_VECTOR_UINT2:
+      case FBT_VECTOR_FLOAT2:
+      case FBT_VECTOR_INT3:
+      case FBT_VECTOR_UINT3:
+      case FBT_VECTOR_FLOAT3:
+      case FBT_VECTOR_INT4:
+      case FBT_VECTOR_UINT4:
+      case FBT_VECTOR_FLOAT4: {
+        uint8_t len = 0;
+        auto vtype = ToFixedTypedVectorElementType(r.type_, &len);
+        if (!VerifyType(vtype)) return false;
+        return VerifyFromPointer(p, r.byte_width_ * len);
+      }
+      default: return false;
+    }
+  }
+
+ public:
+  bool VerifyBuffer() {
+    if (!Check(size_ >= 3)) return false;
+    auto end = buf_ + size_;
+    auto byte_width = *--end;
+    auto packed_type = *--end;
+    return VerifyByteWidth(byte_width) && Check(end - buf_ >= byte_width) &&
+           VerifyRef(Reference(end - byte_width, byte_width, packed_type));
+  }
+
+ private:
+  const uint8_t *buf_;
+  size_t size_;
+  size_t depth_;
+  const size_t max_depth_;
+  size_t num_vectors_;
+  const size_t max_vectors_;
+  bool check_alignment_;
+  std::vector<uint8_t> *reuse_tracker_;
+};
+
+// Utility function that contructs the Verifier for you, see above for
+// parameters.
+inline bool VerifyBuffer(const uint8_t *buf, size_t buf_len,
+                         std::vector<uint8_t> *reuse_tracker = nullptr) {
+  Verifier verifier(buf, buf_len, reuse_tracker);
+  return verifier.VerifyBuffer();
+}
+
+#ifdef FLATBUFFERS_H_
+// This is a verifier utility function that works together with the
+// FlatBuffers verifier, which should only be present if flatbuffer.h
+// has been included (which it typically is in generated code).
+inline bool VerifyNestedFlexBuffer(const flatbuffers::Vector<uint8_t> *nv,
+                                   flatbuffers::Verifier &verifier) {
+  if (!nv) return true;
+  return verifier.Check(flexbuffers::VerifyBuffer(
+      nv->data(), nv->size(), verifier.GetFlexReuseTracker()));
+}
+#endif
+
 }  // namespace flexbuffers
 
 #if defined(_MSC_VER)
diff -urN a/include/flatbuffers/grpc.h b/include/flatbuffers/grpc.h
--- a/include/flatbuffers/grpc.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/grpc.h	2023-01-13 07:47:06.300228238 +0000
@@ -22,6 +22,7 @@
 #include "flatbuffers/flatbuffers.h"
 #include "grpc/byte_buffer_reader.h"
 #include "grpcpp/support/byte_buffer.h"
+#include "grpcpp/support/slice.h"
 
 namespace flatbuffers {
 namespace grpc {
@@ -32,33 +33,23 @@
 // is refcounted and ownership is be managed automatically.
 template<class T> class Message {
  public:
-  Message() : slice_(grpc_empty_slice()) {}
+  Message() {}
 
-  Message(grpc_slice slice, bool add_ref)
-      : slice_(add_ref ? grpc_slice_ref(slice) : slice) {}
+  Message(::grpc::Slice slice) : slice_(slice) {}
 
   Message &operator=(const Message &other) = delete;
 
-  Message(Message &&other) : slice_(other.slice_) {
-    other.slice_ = grpc_empty_slice();
-  }
+  Message(Message &&other) = default;
 
   Message(const Message &other) = delete;
 
-  Message &operator=(Message &&other) {
-    grpc_slice_unref(slice_);
-    slice_ = other.slice_;
-    other.slice_ = grpc_empty_slice();
-    return *this;
-  }
-
-  ~Message() { grpc_slice_unref(slice_); }
+  Message &operator=(Message &&other) = default;
 
-  const uint8_t *mutable_data() const { return GRPC_SLICE_START_PTR(slice_); }
+  const uint8_t *mutable_data() const { return slice_.begin(); }
 
-  const uint8_t *data() const { return GRPC_SLICE_START_PTR(slice_); }
+  const uint8_t *data() const { return slice_.begin(); }
 
-  size_t size() const { return GRPC_SLICE_LENGTH(slice_); }
+  size_t size() const { return slice_.size(); }
 
   bool Verify() const {
     Verifier verifier(data(), size());
@@ -70,10 +61,10 @@
   const T *GetRoot() const { return flatbuffers::GetRoot<T>(data()); }
 
   // This is only intended for serializer use, or if you know what you're doing
-  const grpc_slice &BorrowSlice() const { return slice_; }
+  const ::grpc::Slice &BorrowSlice() const { return slice_; }
 
  private:
-  grpc_slice slice_;
+  ::grpc::Slice slice_;
 };
 
 class MessageBuilder;
@@ -83,12 +74,12 @@
 // efficient to transfer buffers to gRPC.
 class SliceAllocator : public Allocator {
  public:
-  SliceAllocator() : slice_(grpc_empty_slice()) {}
+  SliceAllocator() {}
 
   SliceAllocator(const SliceAllocator &other) = delete;
   SliceAllocator &operator=(const SliceAllocator &other) = delete;
 
-  SliceAllocator(SliceAllocator &&other) : slice_(grpc_empty_slice()) {
+  SliceAllocator(SliceAllocator &&other) {
     // default-construct and swap idiom
     swap(other);
   }
@@ -105,45 +96,43 @@
     swap(slice_, other.slice_);
   }
 
-  virtual ~SliceAllocator() { grpc_slice_unref(slice_); }
+  virtual ~SliceAllocator() {}
 
   virtual uint8_t *allocate(size_t size) override {
-    FLATBUFFERS_ASSERT(GRPC_SLICE_IS_EMPTY(slice_));
-    slice_ = grpc_slice_malloc(size);
-    return GRPC_SLICE_START_PTR(slice_);
+    FLATBUFFERS_ASSERT(slice_.size() == 0);
+    slice_ = ::grpc::Slice(size);
+    return const_cast<uint8_t *>(slice_.begin());
   }
 
   virtual void deallocate(uint8_t *p, size_t size) override {
-    FLATBUFFERS_ASSERT(p == GRPC_SLICE_START_PTR(slice_));
-    FLATBUFFERS_ASSERT(size == GRPC_SLICE_LENGTH(slice_));
-    grpc_slice_unref(slice_);
-    slice_ = grpc_empty_slice();
+    FLATBUFFERS_ASSERT(p == slice_.begin());
+    FLATBUFFERS_ASSERT(size == slice_.size());
+    slice_ = ::grpc::Slice();
   }
 
   virtual uint8_t *reallocate_downward(uint8_t *old_p, size_t old_size,
                                        size_t new_size, size_t in_use_back,
                                        size_t in_use_front) override {
-    FLATBUFFERS_ASSERT(old_p == GRPC_SLICE_START_PTR(slice_));
-    FLATBUFFERS_ASSERT(old_size == GRPC_SLICE_LENGTH(slice_));
+    FLATBUFFERS_ASSERT(old_p == slice_.begin());
+    FLATBUFFERS_ASSERT(old_size == slice_.size());
     FLATBUFFERS_ASSERT(new_size > old_size);
-    grpc_slice old_slice = slice_;
-    grpc_slice new_slice = grpc_slice_malloc(new_size);
-    uint8_t *new_p = GRPC_SLICE_START_PTR(new_slice);
+    ::grpc::Slice old_slice = slice_;
+    ::grpc::Slice new_slice = ::grpc::Slice(new_size);
+    uint8_t *new_p = const_cast<uint8_t *>(new_slice.begin());
     memcpy_downward(old_p, old_size, new_p, new_size, in_use_back,
                     in_use_front);
     slice_ = new_slice;
-    grpc_slice_unref(old_slice);
     return new_p;
   }
 
  private:
-  grpc_slice &get_slice(uint8_t *p, size_t size) {
-    FLATBUFFERS_ASSERT(p == GRPC_SLICE_START_PTR(slice_));
-    FLATBUFFERS_ASSERT(size == GRPC_SLICE_LENGTH(slice_));
+  ::grpc::Slice &get_slice(uint8_t *p, size_t size) {
+    FLATBUFFERS_ASSERT(p == slice_.begin());
+    FLATBUFFERS_ASSERT(size == slice_.size());
     return slice_;
   }
 
-  grpc_slice slice_;
+  ::grpc::Slice slice_;
 
   friend class MessageBuilder;
 };
@@ -184,9 +173,9 @@
     if (buf_.capacity()) {
       uint8_t *buf = buf_.scratch_data();  // pointer to memory
       size_t capacity = buf_.capacity();   // size of memory
-      slice_allocator_.slice_ = grpc_slice_new_with_len(buf, capacity, dealloc);
+      slice_allocator_.slice_ = ::grpc::Slice(buf, capacity, dealloc);
     } else {
-      slice_allocator_.slice_ = grpc_empty_slice();
+      slice_allocator_.slice_ = ::grpc::Slice();
     }
   }
 
@@ -221,10 +210,10 @@
   // Releases the ownership of the buffer pointer.
   // Returns the size, offset, and the original grpc_slice that
   // allocated the buffer. Also see grpc_slice_unref().
-  uint8_t *ReleaseRaw(size_t &size, size_t &offset, grpc_slice &slice) {
+  uint8_t *ReleaseRaw(size_t &size, size_t &offset, ::grpc::Slice &slice) {
     uint8_t *buf = FlatBufferBuilder::ReleaseRaw(size, offset);
     slice = slice_allocator_.slice_;
-    slice_allocator_.slice_ = grpc_empty_slice();
+    slice_allocator_.slice_ = ::grpc::Slice();
     return buf;
   }
 
@@ -247,11 +236,11 @@
     auto begin = msg_data - buf_data;
     auto end = begin + msg_size;
     // Get the slice we are working with (no refcount change)
-    grpc_slice slice = slice_allocator_.get_slice(buf_data, buf_size);
+    ::grpc::Slice slice = slice_allocator_.get_slice(buf_data, buf_size);
     // Extract a subslice of the existing slice (increment refcount)
-    grpc_slice subslice = grpc_slice_sub(slice, begin, end);
+    ::grpc::Slice subslice = slice.sub(begin, end);
     // Wrap the subslice in a `Message<T>`, but don't increment refcount
-    Message<T> msg(subslice, false);
+    Message<T> msg(subslice);
     return msg;
   }
 
@@ -273,15 +262,10 @@
 template<class T> class SerializationTraits<flatbuffers::grpc::Message<T>> {
  public:
   static grpc::Status Serialize(const flatbuffers::grpc::Message<T> &msg,
-                                grpc_byte_buffer **buffer, bool *own_buffer) {
-    // We are passed in a `Message<T>`, which is a wrapper around a
-    // `grpc_slice`. We extract it here using `BorrowSlice()`. The const cast
-    // is necessary because the `grpc_raw_byte_buffer_create` func expects
-    // non-const slices in order to increment their refcounts.
-    grpc_slice *slice = const_cast<grpc_slice *>(&msg.BorrowSlice());
-    // Now use `grpc_raw_byte_buffer_create` to package the single slice into a
-    // `grpc_byte_buffer`, incrementing the refcount in the process.
-    *buffer = grpc_raw_byte_buffer_create(slice, 1);
+                                ByteBuffer *buffer, bool *own_buffer) {
+    // Package the single slice into a `ByteBuffer`,
+    // incrementing the refcount in the process.
+    *buffer = ByteBuffer(&msg.BorrowSlice(), 1);
     *own_buffer = true;
     return grpc::Status::OK;
   }
@@ -289,30 +273,15 @@
   // Deserialize by pulling the
   static grpc::Status Deserialize(ByteBuffer *buf,
                                   flatbuffers::grpc::Message<T> *msg) {
-    grpc_byte_buffer *buffer = *reinterpret_cast<grpc_byte_buffer **>(buf);
-    if (!buffer) {
-      return ::grpc::Status(::grpc::StatusCode::INTERNAL, "No payload");
-    }
-    // Check if this is a single uncompressed slice.
-    if ((buffer->type == GRPC_BB_RAW) &&
-        (buffer->data.raw.compression == GRPC_COMPRESS_NONE) &&
-        (buffer->data.raw.slice_buffer.count == 1)) {
-      // If it is, then we can reference the `grpc_slice` directly.
-      grpc_slice slice = buffer->data.raw.slice_buffer.slices[0];
-      // We wrap a `Message<T>` around the slice, incrementing the refcount.
-      *msg = flatbuffers::grpc::Message<T>(slice, true);
-    } else {
-      // Otherwise, we need to use `grpc_byte_buffer_reader_readall` to read
-      // `buffer` into a single contiguous `grpc_slice`. The gRPC reader gives
-      // us back a new slice with the refcount already incremented.
-      grpc_byte_buffer_reader reader;
-      grpc_byte_buffer_reader_init(&reader, buffer);
-      grpc_slice slice = grpc_byte_buffer_reader_readall(&reader);
-      grpc_byte_buffer_reader_destroy(&reader);
-      // We wrap a `Message<T>` around the slice, but don't increment refcount
-      *msg = flatbuffers::grpc::Message<T>(slice, false);
+    Slice slice;
+    if (!buf->TrySingleSlice(&slice).ok()) {
+      if (!buf->DumpToSingleSlice(&slice).ok()) {
+        buf->Clear();
+        return ::grpc::Status(::grpc::StatusCode::INTERNAL, "No payload");
+      }
     }
-    grpc_byte_buffer_destroy(buffer);
+    *msg = flatbuffers::grpc::Message<T>(slice);
+    buf->Clear();
 #if FLATBUFFERS_GRPC_DISABLE_AUTO_VERIFICATION
     return ::grpc::Status::OK;
 #else
diff -urN a/include/flatbuffers/idl.h b/include/flatbuffers/idl.h
--- a/include/flatbuffers/idl.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/idl.h	2023-01-13 07:47:06.300228238 +0000
@@ -17,6 +17,7 @@
 #ifndef FLATBUFFERS_IDL_H_
 #define FLATBUFFERS_IDL_H_
 
+#include <functional>
 #include <map>
 #include <memory>
 #include <stack>
@@ -27,10 +28,6 @@
 #include "flatbuffers/hash.h"
 #include "flatbuffers/reflection.h"
 
-#if !defined(FLATBUFFERS_CPP98_STL)
-#  include <functional>
-#endif  // !defined(FLATBUFFERS_CPP98_STL)
-
 // This file defines the data types representing a parsed IDL (Interface
 // Definition Language) / schema file.
 
@@ -75,8 +72,8 @@
 // - Go type.
 // - C# / .Net type.
 // - Python type.
-// - Rust type.
 // - Kotlin type.
+// - Rust type.
 
 // using these macros, we can now write code dealing with types just once, e.g.
 
@@ -207,7 +204,7 @@
   }
 
   bool Add(const std::string &name, T *e) {
-    vector_emplace_back(&vec, e);
+    vec.emplace_back(e);
     auto it = dict.find(name);
     if (it != dict.end()) return true;
     dict[name] = e;
@@ -266,7 +263,8 @@
         defined_namespace(nullptr),
         serialized_location(0),
         index(-1),
-        refcount(1) {}
+        refcount(1),
+        declaration_file(nullptr) {}
 
   flatbuffers::Offset<
       flatbuffers::Vector<flatbuffers::Offset<reflection::KeyValue>>>
@@ -286,6 +284,7 @@
   uoffset_t serialized_location;
   int index;  // Inside the vector it is stored.
   int refcount;
+  const std::string *declaration_file;
 };
 
 struct FieldDef : public Definition {
@@ -307,15 +306,9 @@
   bool IsScalarOptional() const {
     return IsScalar(value.type.base_type) && IsOptional();
   }
-  bool IsOptional() const {
-    return presence == kOptional;
-  }
-  bool IsRequired() const {
-    return presence == kRequired;
-  }
-  bool IsDefault() const {
-    return presence == kDefault;
-  }
+  bool IsOptional() const { return presence == kOptional; }
+  bool IsRequired() const { return presence == kRequired; }
+  bool IsDefault() const { return presence == kDefault; }
 
   Value value;
   bool deprecated;  // Field is allowed to be present in old data, but can't be.
@@ -475,6 +468,10 @@
   return type.enum_def != nullptr && type.enum_def->is_union;
 }
 
+inline bool IsUnionType(const Type &type) {
+  return IsUnion(type) && IsInteger(type.base_type);
+}
+
 inline bool IsVector(const Type &type) {
   return type.base_type == BASE_TYPE_VECTOR;
 }
@@ -542,6 +539,9 @@
 
 // Container of options that may apply to any of the source/text generators.
 struct IDLOptions {
+  // field case style options for C++
+  enum CaseStyle { CaseStyle_Unchanged = 0, CaseStyle_Upper, CaseStyle_Lower };
+
   bool gen_jvmstatic;
   // Use flexbuffers instead for binary and text generation
   bool use_flexbuffers;
@@ -564,10 +564,12 @@
   std::string cpp_object_api_pointer_type;
   std::string cpp_object_api_string_type;
   bool cpp_object_api_string_flexible_constructor;
+  CaseStyle cpp_object_api_field_case_style;
   bool cpp_direct_copy;
   bool gen_nullable;
   bool java_checkerframework;
   bool gen_generated;
+  bool gen_json_coders;
   std::string object_prefix;
   std::string object_suffix;
   bool union_value_namespacing;
@@ -593,6 +595,12 @@
   std::string filename_suffix;
   std::string filename_extension;
   bool no_warnings;
+  bool warnings_as_errors;
+  std::string project_root;
+  bool cs_global_alias;
+  bool json_nested_flatbuffers;
+  bool json_nested_flexbuffers;
+  bool json_nested_legacy_flatbuffers;
 
   // Possible options for the more general generator below.
   enum Language {
@@ -615,8 +623,6 @@
     kMAX
   };
 
-  Language lang;
-
   enum MiniReflect { kNone, kTypes, kTypesAndNames };
 
   MiniReflect mini_reflect;
@@ -624,6 +630,12 @@
   // If set, require all fields in a table to be explicitly numbered.
   bool require_explicit_ids;
 
+  // If set, implement serde::Serialize for generated Rust types
+  bool rust_serialize;
+
+  // If set, generate rust types in individual files with a root module file.
+  bool rust_module_root_file;
+
   // The corresponding language bit will be set if a language is included
   // for code generation.
   unsigned long lang_to_generate;
@@ -657,10 +669,12 @@
         gen_compare(false),
         cpp_object_api_pointer_type("std::unique_ptr"),
         cpp_object_api_string_flexible_constructor(false),
+        cpp_object_api_field_case_style(CaseStyle_Unchanged),
         cpp_direct_copy(true),
         gen_nullable(false),
         java_checkerframework(false),
         gen_generated(false),
+        gen_json_coders(false),
         object_suffix("T"),
         union_value_namespacing(true),
         allow_non_utf8(false),
@@ -678,9 +692,16 @@
         filename_suffix("_generated"),
         filename_extension(),
         no_warnings(false),
-        lang(IDLOptions::kJava),
+        warnings_as_errors(false),
+        project_root(""),
+        cs_global_alias(false),
+        json_nested_flatbuffers(true),
+        json_nested_flexbuffers(true),
+        json_nested_legacy_flatbuffers(false),
         mini_reflect(IDLOptions::kNone),
         require_explicit_ids(false),
+        rust_serialize(false),
+        rust_module_root_file(false),
         lang_to_generate(0),
         set_empty_strings_to_null(true),
         set_empty_vectors_to_null(true) {}
@@ -780,6 +801,7 @@
         root_struct_def_(nullptr),
         opts(options),
         uses_flexbuffers_(false),
+        has_warning_(false),
         advanced_features_(0),
         source_(nullptr),
         anonymous_counter_(0),
@@ -942,14 +964,15 @@
   StructDef *LookupCreateStruct(const std::string &name,
                                 bool create_if_new = true,
                                 bool definition = false);
-  FLATBUFFERS_CHECKED_ERROR ParseEnum(bool is_union, EnumDef **dest);
+  FLATBUFFERS_CHECKED_ERROR ParseEnum(bool is_union, EnumDef **dest,
+                                      const char *filename);
   FLATBUFFERS_CHECKED_ERROR ParseNamespace();
   FLATBUFFERS_CHECKED_ERROR StartStruct(const std::string &name,
                                         StructDef **dest);
   FLATBUFFERS_CHECKED_ERROR StartEnum(const std::string &name, bool is_union,
                                       EnumDef **dest);
-  FLATBUFFERS_CHECKED_ERROR ParseDecl();
-  FLATBUFFERS_CHECKED_ERROR ParseService();
+  FLATBUFFERS_CHECKED_ERROR ParseDecl(const char *filename);
+  FLATBUFFERS_CHECKED_ERROR ParseService(const char *filename);
   FLATBUFFERS_CHECKED_ERROR ParseProtoFields(StructDef *struct_def,
                                              bool isextend, bool inside_oneof);
   FLATBUFFERS_CHECKED_ERROR ParseProtoOption();
@@ -986,6 +1009,8 @@
   FLATBUFFERS_CHECKED_ERROR RecurseError();
   template<typename F> CheckedError Recurse(F f);
 
+  const std::string &GetPooledString(const std::string &s) const;
+
  public:
   SymbolTable<Type> types_;
   SymbolTable<StructDef> structs_;
@@ -1011,6 +1036,7 @@
 
   IDLOptions opts;
   bool uses_flexbuffers_;
+  bool has_warning_;
 
   uint64_t advanced_features_;
 
@@ -1021,6 +1047,10 @@
 
   std::vector<std::pair<Value, FieldDef *>> field_stack_;
 
+  // TODO(cneo): Refactor parser to use string_cache more often to save
+  // on memory usage.
+  mutable std::set<std::string> string_cache_;
+
   int anonymous_counter_;
   int parse_depth_counter_;  // stack-overflow guard
 };
@@ -1152,9 +1182,10 @@
 
 // Generate a make rule for generated Java or C# files.
 // See code_generators.cpp.
-extern std::string JavaCSharpMakeRule(const Parser &parser,
-                                      const std::string &path,
-                                      const std::string &file_name);
+extern std::string CSharpMakeRule(const Parser &parser, const std::string &path,
+                                  const std::string &file_name);
+extern std::string JavaMakeRule(const Parser &parser, const std::string &path,
+                                const std::string &file_name);
 
 // Generate a make rule for the generated text (JSON) files.
 // See idl_gen_text.cpp.
@@ -1193,6 +1224,9 @@
 
 extern bool GenerateTSGRPC(const Parser &parser, const std::string &path,
                            const std::string &file_name);
+
+extern bool GenerateRustModuleRootFile(const Parser &parser,
+                                       const std::string &path);
 }  // namespace flatbuffers
 
 #endif  // FLATBUFFERS_IDL_H_
diff -urN a/include/flatbuffers/reflection.h b/include/flatbuffers/reflection.h
--- a/include/flatbuffers/reflection.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/reflection.h	2023-01-13 07:47:06.300228238 +0000
@@ -21,7 +21,7 @@
 // file) is needed to generate this header in the first place.
 // Should normally not be a problem since it can be generated by the
 // previous version of flatc whenever this code needs to change.
-// See reflection/generate_code.sh
+// See scripts/generate_code.py for generation.
 #include "flatbuffers/reflection_generated.h"
 
 // Helper functionality for reflection.
@@ -379,12 +379,12 @@
  public:
   pointer_inside_vector(T *ptr, std::vector<U> &vec)
       : offset_(reinterpret_cast<uint8_t *>(ptr) -
-                reinterpret_cast<uint8_t *>(flatbuffers::vector_data(vec))),
+                reinterpret_cast<uint8_t *>(vec.data())),
         vec_(vec) {}
 
   T *operator*() const {
-    return reinterpret_cast<T *>(
-        reinterpret_cast<uint8_t *>(flatbuffers::vector_data(vec_)) + offset_);
+    return reinterpret_cast<T *>(reinterpret_cast<uint8_t *>(vec_.data()) +
+                                 offset_);
   }
   T *operator->() const { return operator*(); }
 
@@ -412,7 +412,7 @@
   FLATBUFFERS_ASSERT(type_field);
   auto union_type = GetFieldI<uint8_t>(table, *type_field);
   auto enumval = enumdef->values()->LookupByKey(union_type);
-  return *enumval->object();
+  return *schema.objects()->Get(enumval->union_type()->index());
 }
 
 // Changes the contents of a string inside a FlatBuffer. FlatBuffer must
diff -urN a/include/flatbuffers/reflection_generated.h b/include/flatbuffers/reflection_generated.h
--- a/include/flatbuffers/reflection_generated.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/reflection_generated.h	2023-01-13 07:47:06.300228238 +0000
@@ -32,6 +32,9 @@
 struct Service;
 struct ServiceBuilder;
 
+struct SchemaFile;
+struct SchemaFileBuilder;
+
 struct Schema;
 struct SchemaBuilder;
 
@@ -114,6 +117,7 @@
   return EnumNamesBaseType()[index];
 }
 
+/// New schema language features that are not supported by old code generators.
 enum AdvancedFeatures {
   AdvancedArrayFeatures = 1ULL,
   AdvancedUnionFeatures = 2ULL,
@@ -158,7 +162,9 @@
     VT_BASE_TYPE = 4,
     VT_ELEMENT = 6,
     VT_INDEX = 8,
-    VT_FIXED_LENGTH = 10
+    VT_FIXED_LENGTH = 10,
+    VT_BASE_SIZE = 12,
+    VT_ELEMENT_SIZE = 14
   };
   reflection::BaseType base_type() const {
     return static_cast<reflection::BaseType>(GetField<int8_t>(VT_BASE_TYPE, 0));
@@ -172,12 +178,22 @@
   uint16_t fixed_length() const {
     return GetField<uint16_t>(VT_FIXED_LENGTH, 0);
   }
+  /// The size (octets) of the `base_type` field.
+  uint32_t base_size() const {
+    return GetField<uint32_t>(VT_BASE_SIZE, 4);
+  }
+  /// The size (octets) of the `element` field, if present.
+  uint32_t element_size() const {
+    return GetField<uint32_t>(VT_ELEMENT_SIZE, 0);
+  }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
-           VerifyField<int8_t>(verifier, VT_BASE_TYPE) &&
-           VerifyField<int8_t>(verifier, VT_ELEMENT) &&
-           VerifyField<int32_t>(verifier, VT_INDEX) &&
-           VerifyField<uint16_t>(verifier, VT_FIXED_LENGTH) &&
+           VerifyField<int8_t>(verifier, VT_BASE_TYPE, 1) &&
+           VerifyField<int8_t>(verifier, VT_ELEMENT, 1) &&
+           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
+           VerifyField<uint16_t>(verifier, VT_FIXED_LENGTH, 2) &&
+           VerifyField<uint32_t>(verifier, VT_BASE_SIZE, 4) &&
+           VerifyField<uint32_t>(verifier, VT_ELEMENT_SIZE, 4) &&
            verifier.EndTable();
   }
 };
@@ -198,6 +214,12 @@
   void add_fixed_length(uint16_t fixed_length) {
     fbb_.AddElement<uint16_t>(Type::VT_FIXED_LENGTH, fixed_length, 0);
   }
+  void add_base_size(uint32_t base_size) {
+    fbb_.AddElement<uint32_t>(Type::VT_BASE_SIZE, base_size, 4);
+  }
+  void add_element_size(uint32_t element_size) {
+    fbb_.AddElement<uint32_t>(Type::VT_ELEMENT_SIZE, element_size, 0);
+  }
   explicit TypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
@@ -214,8 +236,12 @@
     reflection::BaseType base_type = reflection::None,
     reflection::BaseType element = reflection::None,
     int32_t index = -1,
-    uint16_t fixed_length = 0) {
+    uint16_t fixed_length = 0,
+    uint32_t base_size = 4,
+    uint32_t element_size = 0) {
   TypeBuilder builder_(_fbb);
+  builder_.add_element_size(element_size);
+  builder_.add_base_size(base_size);
   builder_.add_index(index);
   builder_.add_fixed_length(fixed_length);
   builder_.add_element(element);
@@ -235,8 +261,8 @@
   bool KeyCompareLessThan(const KeyValue *o) const {
     return *key() < *o->key();
   }
-  int KeyCompareWithValue(const char *val) const {
-    return strcmp(key()->c_str(), val);
+  int KeyCompareWithValue(const char *_key) const {
+    return strcmp(key()->c_str(), _key);
   }
   const flatbuffers::String *value() const {
     return GetPointer<const flatbuffers::String *>(VT_VALUE);
@@ -300,7 +326,6 @@
   enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
     VT_NAME = 4,
     VT_VALUE = 6,
-    VT_OBJECT = 8,
     VT_UNION_TYPE = 10,
     VT_DOCUMENTATION = 12
   };
@@ -313,11 +338,8 @@
   bool KeyCompareLessThan(const EnumVal *o) const {
     return value() < o->value();
   }
-  int KeyCompareWithValue(int64_t val) const {
-    return static_cast<int>(value() > val) - static_cast<int>(value() < val);
-  }
-  const reflection::Object *object() const {
-    return GetPointer<const reflection::Object *>(VT_OBJECT);
+  int KeyCompareWithValue(int64_t _value) const {
+    return static_cast<int>(value() > _value) - static_cast<int>(value() < _value);
   }
   const reflection::Type *union_type() const {
     return GetPointer<const reflection::Type *>(VT_UNION_TYPE);
@@ -329,9 +351,7 @@
     return VerifyTableStart(verifier) &&
            VerifyOffsetRequired(verifier, VT_NAME) &&
            verifier.VerifyString(name()) &&
-           VerifyField<int64_t>(verifier, VT_VALUE) &&
-           VerifyOffset(verifier, VT_OBJECT) &&
-           verifier.VerifyTable(object()) &&
+           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
            VerifyOffset(verifier, VT_UNION_TYPE) &&
            verifier.VerifyTable(union_type()) &&
            VerifyOffset(verifier, VT_DOCUMENTATION) &&
@@ -351,9 +371,6 @@
   void add_value(int64_t value) {
     fbb_.AddElement<int64_t>(EnumVal::VT_VALUE, value, 0);
   }
-  void add_object(flatbuffers::Offset<reflection::Object> object) {
-    fbb_.AddOffset(EnumVal::VT_OBJECT, object);
-  }
   void add_union_type(flatbuffers::Offset<reflection::Type> union_type) {
     fbb_.AddOffset(EnumVal::VT_UNION_TYPE, union_type);
   }
@@ -376,14 +393,12 @@
     flatbuffers::FlatBufferBuilder &_fbb,
     flatbuffers::Offset<flatbuffers::String> name = 0,
     int64_t value = 0,
-    flatbuffers::Offset<reflection::Object> object = 0,
     flatbuffers::Offset<reflection::Type> union_type = 0,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0) {
   EnumValBuilder builder_(_fbb);
   builder_.add_value(value);
   builder_.add_documentation(documentation);
   builder_.add_union_type(union_type);
-  builder_.add_object(object);
   builder_.add_name(name);
   return builder_.Finish();
 }
@@ -392,7 +407,6 @@
     flatbuffers::FlatBufferBuilder &_fbb,
     const char *name = nullptr,
     int64_t value = 0,
-    flatbuffers::Offset<reflection::Object> object = 0,
     flatbuffers::Offset<reflection::Type> union_type = 0,
     const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr) {
   auto name__ = name ? _fbb.CreateString(name) : 0;
@@ -401,7 +415,6 @@
       _fbb,
       name__,
       value,
-      object,
       union_type,
       documentation__);
 }
@@ -414,7 +427,8 @@
     VT_IS_UNION = 8,
     VT_UNDERLYING_TYPE = 10,
     VT_ATTRIBUTES = 12,
-    VT_DOCUMENTATION = 14
+    VT_DOCUMENTATION = 14,
+    VT_DECLARATION_FILE = 16
   };
   const flatbuffers::String *name() const {
     return GetPointer<const flatbuffers::String *>(VT_NAME);
@@ -422,8 +436,8 @@
   bool KeyCompareLessThan(const Enum *o) const {
     return *name() < *o->name();
   }
-  int KeyCompareWithValue(const char *val) const {
-    return strcmp(name()->c_str(), val);
+  int KeyCompareWithValue(const char *_name) const {
+    return strcmp(name()->c_str(), _name);
   }
   const flatbuffers::Vector<flatbuffers::Offset<reflection::EnumVal>> *values() const {
     return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<reflection::EnumVal>> *>(VT_VALUES);
@@ -440,6 +454,10 @@
   const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *documentation() const {
     return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DOCUMENTATION);
   }
+  /// File that this Enum is declared in.
+  const flatbuffers::String *declaration_file() const {
+    return GetPointer<const flatbuffers::String *>(VT_DECLARATION_FILE);
+  }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffsetRequired(verifier, VT_NAME) &&
@@ -447,7 +465,7 @@
            VerifyOffsetRequired(verifier, VT_VALUES) &&
            verifier.VerifyVector(values()) &&
            verifier.VerifyVectorOfTables(values()) &&
-           VerifyField<uint8_t>(verifier, VT_IS_UNION) &&
+           VerifyField<uint8_t>(verifier, VT_IS_UNION, 1) &&
            VerifyOffsetRequired(verifier, VT_UNDERLYING_TYPE) &&
            verifier.VerifyTable(underlying_type()) &&
            VerifyOffset(verifier, VT_ATTRIBUTES) &&
@@ -456,6 +474,8 @@
            VerifyOffset(verifier, VT_DOCUMENTATION) &&
            verifier.VerifyVector(documentation()) &&
            verifier.VerifyVectorOfStrings(documentation()) &&
+           VerifyOffset(verifier, VT_DECLARATION_FILE) &&
+           verifier.VerifyString(declaration_file()) &&
            verifier.EndTable();
   }
 };
@@ -482,6 +502,9 @@
   void add_documentation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation) {
     fbb_.AddOffset(Enum::VT_DOCUMENTATION, documentation);
   }
+  void add_declaration_file(flatbuffers::Offset<flatbuffers::String> declaration_file) {
+    fbb_.AddOffset(Enum::VT_DECLARATION_FILE, declaration_file);
+  }
   explicit EnumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
@@ -503,8 +526,10 @@
     bool is_union = false,
     flatbuffers::Offset<reflection::Type> underlying_type = 0,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0) {
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0,
+    flatbuffers::Offset<flatbuffers::String> declaration_file = 0) {
   EnumBuilder builder_(_fbb);
+  builder_.add_declaration_file(declaration_file);
   builder_.add_documentation(documentation);
   builder_.add_attributes(attributes);
   builder_.add_underlying_type(underlying_type);
@@ -521,11 +546,13 @@
     bool is_union = false,
     flatbuffers::Offset<reflection::Type> underlying_type = 0,
     std::vector<flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
-    const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr) {
+    const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr,
+    const char *declaration_file = nullptr) {
   auto name__ = name ? _fbb.CreateString(name) : 0;
   auto values__ = values ? _fbb.CreateVectorOfSortedTables<reflection::EnumVal>(values) : 0;
   auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
   auto documentation__ = documentation ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*documentation) : 0;
+  auto declaration_file__ = declaration_file ? _fbb.CreateString(declaration_file) : 0;
   return reflection::CreateEnum(
       _fbb,
       name__,
@@ -533,7 +560,8 @@
       is_union,
       underlying_type,
       attributes__,
-      documentation__);
+      documentation__,
+      declaration_file__);
 }
 
 struct Field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
@@ -550,7 +578,8 @@
     VT_KEY = 20,
     VT_ATTRIBUTES = 22,
     VT_DOCUMENTATION = 24,
-    VT_OPTIONAL = 26
+    VT_OPTIONAL = 26,
+    VT_PADDING = 28
   };
   const flatbuffers::String *name() const {
     return GetPointer<const flatbuffers::String *>(VT_NAME);
@@ -558,8 +587,8 @@
   bool KeyCompareLessThan(const Field *o) const {
     return *name() < *o->name();
   }
-  int KeyCompareWithValue(const char *val) const {
-    return strcmp(name()->c_str(), val);
+  int KeyCompareWithValue(const char *_name) const {
+    return strcmp(name()->c_str(), _name);
   }
   const reflection::Type *type() const {
     return GetPointer<const reflection::Type *>(VT_TYPE);
@@ -594,26 +623,31 @@
   bool optional() const {
     return GetField<uint8_t>(VT_OPTIONAL, 0) != 0;
   }
+  /// Number of padding octets to always add after this field. Structs only.
+  uint16_t padding() const {
+    return GetField<uint16_t>(VT_PADDING, 0);
+  }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffsetRequired(verifier, VT_NAME) &&
            verifier.VerifyString(name()) &&
            VerifyOffsetRequired(verifier, VT_TYPE) &&
            verifier.VerifyTable(type()) &&
-           VerifyField<uint16_t>(verifier, VT_ID) &&
-           VerifyField<uint16_t>(verifier, VT_OFFSET) &&
-           VerifyField<int64_t>(verifier, VT_DEFAULT_INTEGER) &&
-           VerifyField<double>(verifier, VT_DEFAULT_REAL) &&
-           VerifyField<uint8_t>(verifier, VT_DEPRECATED) &&
-           VerifyField<uint8_t>(verifier, VT_REQUIRED) &&
-           VerifyField<uint8_t>(verifier, VT_KEY) &&
+           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
+           VerifyField<uint16_t>(verifier, VT_OFFSET, 2) &&
+           VerifyField<int64_t>(verifier, VT_DEFAULT_INTEGER, 8) &&
+           VerifyField<double>(verifier, VT_DEFAULT_REAL, 8) &&
+           VerifyField<uint8_t>(verifier, VT_DEPRECATED, 1) &&
+           VerifyField<uint8_t>(verifier, VT_REQUIRED, 1) &&
+           VerifyField<uint8_t>(verifier, VT_KEY, 1) &&
            VerifyOffset(verifier, VT_ATTRIBUTES) &&
            verifier.VerifyVector(attributes()) &&
            verifier.VerifyVectorOfTables(attributes()) &&
            VerifyOffset(verifier, VT_DOCUMENTATION) &&
            verifier.VerifyVector(documentation()) &&
            verifier.VerifyVectorOfStrings(documentation()) &&
-           VerifyField<uint8_t>(verifier, VT_OPTIONAL) &&
+           VerifyField<uint8_t>(verifier, VT_OPTIONAL, 1) &&
+           VerifyField<uint16_t>(verifier, VT_PADDING, 2) &&
            verifier.EndTable();
   }
 };
@@ -658,6 +692,9 @@
   void add_optional(bool optional) {
     fbb_.AddElement<uint8_t>(Field::VT_OPTIONAL, static_cast<uint8_t>(optional), 0);
   }
+  void add_padding(uint16_t padding) {
+    fbb_.AddElement<uint16_t>(Field::VT_PADDING, padding, 0);
+  }
   explicit FieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
@@ -684,7 +721,8 @@
     bool key = false,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0,
-    bool optional = false) {
+    bool optional = false,
+    uint16_t padding = 0) {
   FieldBuilder builder_(_fbb);
   builder_.add_default_real(default_real);
   builder_.add_default_integer(default_integer);
@@ -692,6 +730,7 @@
   builder_.add_attributes(attributes);
   builder_.add_type(type);
   builder_.add_name(name);
+  builder_.add_padding(padding);
   builder_.add_offset(offset);
   builder_.add_id(id);
   builder_.add_optional(optional);
@@ -714,7 +753,8 @@
     bool key = false,
     std::vector<flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
     const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr,
-    bool optional = false) {
+    bool optional = false,
+    uint16_t padding = 0) {
   auto name__ = name ? _fbb.CreateString(name) : 0;
   auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
   auto documentation__ = documentation ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*documentation) : 0;
@@ -731,7 +771,8 @@
       key,
       attributes__,
       documentation__,
-      optional);
+      optional,
+      padding);
 }
 
 struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
@@ -743,7 +784,8 @@
     VT_MINALIGN = 10,
     VT_BYTESIZE = 12,
     VT_ATTRIBUTES = 14,
-    VT_DOCUMENTATION = 16
+    VT_DOCUMENTATION = 16,
+    VT_DECLARATION_FILE = 18
   };
   const flatbuffers::String *name() const {
     return GetPointer<const flatbuffers::String *>(VT_NAME);
@@ -751,8 +793,8 @@
   bool KeyCompareLessThan(const Object *o) const {
     return *name() < *o->name();
   }
-  int KeyCompareWithValue(const char *val) const {
-    return strcmp(name()->c_str(), val);
+  int KeyCompareWithValue(const char *_name) const {
+    return strcmp(name()->c_str(), _name);
   }
   const flatbuffers::Vector<flatbuffers::Offset<reflection::Field>> *fields() const {
     return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<reflection::Field>> *>(VT_FIELDS);
@@ -772,6 +814,10 @@
   const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *documentation() const {
     return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DOCUMENTATION);
   }
+  /// File that this Object is declared in.
+  const flatbuffers::String *declaration_file() const {
+    return GetPointer<const flatbuffers::String *>(VT_DECLARATION_FILE);
+  }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffsetRequired(verifier, VT_NAME) &&
@@ -779,15 +825,17 @@
            VerifyOffsetRequired(verifier, VT_FIELDS) &&
            verifier.VerifyVector(fields()) &&
            verifier.VerifyVectorOfTables(fields()) &&
-           VerifyField<uint8_t>(verifier, VT_IS_STRUCT) &&
-           VerifyField<int32_t>(verifier, VT_MINALIGN) &&
-           VerifyField<int32_t>(verifier, VT_BYTESIZE) &&
+           VerifyField<uint8_t>(verifier, VT_IS_STRUCT, 1) &&
+           VerifyField<int32_t>(verifier, VT_MINALIGN, 4) &&
+           VerifyField<int32_t>(verifier, VT_BYTESIZE, 4) &&
            VerifyOffset(verifier, VT_ATTRIBUTES) &&
            verifier.VerifyVector(attributes()) &&
            verifier.VerifyVectorOfTables(attributes()) &&
            VerifyOffset(verifier, VT_DOCUMENTATION) &&
            verifier.VerifyVector(documentation()) &&
            verifier.VerifyVectorOfStrings(documentation()) &&
+           VerifyOffset(verifier, VT_DECLARATION_FILE) &&
+           verifier.VerifyString(declaration_file()) &&
            verifier.EndTable();
   }
 };
@@ -817,6 +865,9 @@
   void add_documentation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation) {
     fbb_.AddOffset(Object::VT_DOCUMENTATION, documentation);
   }
+  void add_declaration_file(flatbuffers::Offset<flatbuffers::String> declaration_file) {
+    fbb_.AddOffset(Object::VT_DECLARATION_FILE, declaration_file);
+  }
   explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
@@ -838,8 +889,10 @@
     int32_t minalign = 0,
     int32_t bytesize = 0,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0) {
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0,
+    flatbuffers::Offset<flatbuffers::String> declaration_file = 0) {
   ObjectBuilder builder_(_fbb);
+  builder_.add_declaration_file(declaration_file);
   builder_.add_documentation(documentation);
   builder_.add_attributes(attributes);
   builder_.add_bytesize(bytesize);
@@ -858,11 +911,13 @@
     int32_t minalign = 0,
     int32_t bytesize = 0,
     std::vector<flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
-    const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr) {
+    const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr,
+    const char *declaration_file = nullptr) {
   auto name__ = name ? _fbb.CreateString(name) : 0;
   auto fields__ = fields ? _fbb.CreateVectorOfSortedTables<reflection::Field>(fields) : 0;
   auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
   auto documentation__ = documentation ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*documentation) : 0;
+  auto declaration_file__ = declaration_file ? _fbb.CreateString(declaration_file) : 0;
   return reflection::CreateObject(
       _fbb,
       name__,
@@ -871,7 +926,8 @@
       minalign,
       bytesize,
       attributes__,
-      documentation__);
+      documentation__,
+      declaration_file__);
 }
 
 struct RPCCall FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
@@ -889,8 +945,8 @@
   bool KeyCompareLessThan(const RPCCall *o) const {
     return *name() < *o->name();
   }
-  int KeyCompareWithValue(const char *val) const {
-    return strcmp(name()->c_str(), val);
+  int KeyCompareWithValue(const char *_name) const {
+    return strcmp(name()->c_str(), _name);
   }
   const reflection::Object *request() const {
     return GetPointer<const reflection::Object *>(VT_REQUEST);
@@ -996,7 +1052,8 @@
     VT_NAME = 4,
     VT_CALLS = 6,
     VT_ATTRIBUTES = 8,
-    VT_DOCUMENTATION = 10
+    VT_DOCUMENTATION = 10,
+    VT_DECLARATION_FILE = 12
   };
   const flatbuffers::String *name() const {
     return GetPointer<const flatbuffers::String *>(VT_NAME);
@@ -1004,8 +1061,8 @@
   bool KeyCompareLessThan(const Service *o) const {
     return *name() < *o->name();
   }
-  int KeyCompareWithValue(const char *val) const {
-    return strcmp(name()->c_str(), val);
+  int KeyCompareWithValue(const char *_name) const {
+    return strcmp(name()->c_str(), _name);
   }
   const flatbuffers::Vector<flatbuffers::Offset<reflection::RPCCall>> *calls() const {
     return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<reflection::RPCCall>> *>(VT_CALLS);
@@ -1016,6 +1073,10 @@
   const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *documentation() const {
     return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DOCUMENTATION);
   }
+  /// File that this Service is declared in.
+  const flatbuffers::String *declaration_file() const {
+    return GetPointer<const flatbuffers::String *>(VT_DECLARATION_FILE);
+  }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffsetRequired(verifier, VT_NAME) &&
@@ -1029,6 +1090,8 @@
            VerifyOffset(verifier, VT_DOCUMENTATION) &&
            verifier.VerifyVector(documentation()) &&
            verifier.VerifyVectorOfStrings(documentation()) &&
+           VerifyOffset(verifier, VT_DECLARATION_FILE) &&
+           verifier.VerifyString(declaration_file()) &&
            verifier.EndTable();
   }
 };
@@ -1049,6 +1112,9 @@
   void add_documentation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation) {
     fbb_.AddOffset(Service::VT_DOCUMENTATION, documentation);
   }
+  void add_declaration_file(flatbuffers::Offset<flatbuffers::String> declaration_file) {
+    fbb_.AddOffset(Service::VT_DECLARATION_FILE, declaration_file);
+  }
   explicit ServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
@@ -1066,8 +1132,10 @@
     flatbuffers::Offset<flatbuffers::String> name = 0,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<reflection::RPCCall>>> calls = 0,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<reflection::KeyValue>>> attributes = 0,
-    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0) {
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> documentation = 0,
+    flatbuffers::Offset<flatbuffers::String> declaration_file = 0) {
   ServiceBuilder builder_(_fbb);
+  builder_.add_declaration_file(declaration_file);
   builder_.add_documentation(documentation);
   builder_.add_attributes(attributes);
   builder_.add_calls(calls);
@@ -1080,17 +1148,98 @@
     const char *name = nullptr,
     std::vector<flatbuffers::Offset<reflection::RPCCall>> *calls = nullptr,
     std::vector<flatbuffers::Offset<reflection::KeyValue>> *attributes = nullptr,
-    const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr) {
+    const std::vector<flatbuffers::Offset<flatbuffers::String>> *documentation = nullptr,
+    const char *declaration_file = nullptr) {
   auto name__ = name ? _fbb.CreateString(name) : 0;
   auto calls__ = calls ? _fbb.CreateVectorOfSortedTables<reflection::RPCCall>(calls) : 0;
   auto attributes__ = attributes ? _fbb.CreateVectorOfSortedTables<reflection::KeyValue>(attributes) : 0;
   auto documentation__ = documentation ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*documentation) : 0;
+  auto declaration_file__ = declaration_file ? _fbb.CreateString(declaration_file) : 0;
   return reflection::CreateService(
       _fbb,
       name__,
       calls__,
       attributes__,
-      documentation__);
+      documentation__,
+      declaration_file__);
+}
+
+/// File specific information.
+/// Symbols declared within a file may be recovered by iterating over all
+/// symbols and examining the `declaration_file` field.
+struct SchemaFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+  typedef SchemaFileBuilder Builder;
+  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
+    VT_FILENAME = 4,
+    VT_INCLUDED_FILENAMES = 6
+  };
+  /// Filename, relative to project root.
+  const flatbuffers::String *filename() const {
+    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
+  }
+  bool KeyCompareLessThan(const SchemaFile *o) const {
+    return *filename() < *o->filename();
+  }
+  int KeyCompareWithValue(const char *_filename) const {
+    return strcmp(filename()->c_str(), _filename);
+  }
+  /// Names of included files, relative to project root.
+  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *included_filenames() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INCLUDED_FILENAMES);
+  }
+  bool Verify(flatbuffers::Verifier &verifier) const {
+    return VerifyTableStart(verifier) &&
+           VerifyOffsetRequired(verifier, VT_FILENAME) &&
+           verifier.VerifyString(filename()) &&
+           VerifyOffset(verifier, VT_INCLUDED_FILENAMES) &&
+           verifier.VerifyVector(included_filenames()) &&
+           verifier.VerifyVectorOfStrings(included_filenames()) &&
+           verifier.EndTable();
+  }
+};
+
+struct SchemaFileBuilder {
+  typedef SchemaFile Table;
+  flatbuffers::FlatBufferBuilder &fbb_;
+  flatbuffers::uoffset_t start_;
+  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
+    fbb_.AddOffset(SchemaFile::VT_FILENAME, filename);
+  }
+  void add_included_filenames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> included_filenames) {
+    fbb_.AddOffset(SchemaFile::VT_INCLUDED_FILENAMES, included_filenames);
+  }
+  explicit SchemaFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+        : fbb_(_fbb) {
+    start_ = fbb_.StartTable();
+  }
+  flatbuffers::Offset<SchemaFile> Finish() {
+    const auto end = fbb_.EndTable(start_);
+    auto o = flatbuffers::Offset<SchemaFile>(end);
+    fbb_.Required(o, SchemaFile::VT_FILENAME);
+    return o;
+  }
+};
+
+inline flatbuffers::Offset<SchemaFile> CreateSchemaFile(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    flatbuffers::Offset<flatbuffers::String> filename = 0,
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> included_filenames = 0) {
+  SchemaFileBuilder builder_(_fbb);
+  builder_.add_included_filenames(included_filenames);
+  builder_.add_filename(filename);
+  return builder_.Finish();
+}
+
+inline flatbuffers::Offset<SchemaFile> CreateSchemaFileDirect(
+    flatbuffers::FlatBufferBuilder &_fbb,
+    const char *filename = nullptr,
+    const std::vector<flatbuffers::Offset<flatbuffers::String>> *included_filenames = nullptr) {
+  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
+  auto included_filenames__ = included_filenames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*included_filenames) : 0;
+  return reflection::CreateSchemaFile(
+      _fbb,
+      filename__,
+      included_filenames__);
 }
 
 struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
@@ -1102,7 +1251,8 @@
     VT_FILE_EXT = 10,
     VT_ROOT_TABLE = 12,
     VT_SERVICES = 14,
-    VT_ADVANCED_FEATURES = 16
+    VT_ADVANCED_FEATURES = 16,
+    VT_FBS_FILES = 18
   };
   const flatbuffers::Vector<flatbuffers::Offset<reflection::Object>> *objects() const {
     return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<reflection::Object>> *>(VT_OBJECTS);
@@ -1125,6 +1275,11 @@
   reflection::AdvancedFeatures advanced_features() const {
     return static_cast<reflection::AdvancedFeatures>(GetField<uint64_t>(VT_ADVANCED_FEATURES, 0));
   }
+  /// All the files used in this compilation. Files are relative to where
+  /// flatc was invoked.
+  const flatbuffers::Vector<flatbuffers::Offset<reflection::SchemaFile>> *fbs_files() const {
+    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<reflection::SchemaFile>> *>(VT_FBS_FILES);
+  }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffsetRequired(verifier, VT_OBJECTS) &&
@@ -1142,7 +1297,10 @@
            VerifyOffset(verifier, VT_SERVICES) &&
            verifier.VerifyVector(services()) &&
            verifier.VerifyVectorOfTables(services()) &&
-           VerifyField<uint64_t>(verifier, VT_ADVANCED_FEATURES) &&
+           VerifyField<uint64_t>(verifier, VT_ADVANCED_FEATURES, 8) &&
+           VerifyOffset(verifier, VT_FBS_FILES) &&
+           verifier.VerifyVector(fbs_files()) &&
+           verifier.VerifyVectorOfTables(fbs_files()) &&
            verifier.EndTable();
   }
 };
@@ -1172,6 +1330,9 @@
   void add_advanced_features(reflection::AdvancedFeatures advanced_features) {
     fbb_.AddElement<uint64_t>(Schema::VT_ADVANCED_FEATURES, static_cast<uint64_t>(advanced_features), 0);
   }
+  void add_fbs_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<reflection::SchemaFile>>> fbs_files) {
+    fbb_.AddOffset(Schema::VT_FBS_FILES, fbs_files);
+  }
   explicit SchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
         : fbb_(_fbb) {
     start_ = fbb_.StartTable();
@@ -1193,9 +1354,11 @@
     flatbuffers::Offset<flatbuffers::String> file_ext = 0,
     flatbuffers::Offset<reflection::Object> root_table = 0,
     flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<reflection::Service>>> services = 0,
-    reflection::AdvancedFeatures advanced_features = static_cast<reflection::AdvancedFeatures>(0)) {
+    reflection::AdvancedFeatures advanced_features = static_cast<reflection::AdvancedFeatures>(0),
+    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<reflection::SchemaFile>>> fbs_files = 0) {
   SchemaBuilder builder_(_fbb);
   builder_.add_advanced_features(advanced_features);
+  builder_.add_fbs_files(fbs_files);
   builder_.add_services(services);
   builder_.add_root_table(root_table);
   builder_.add_file_ext(file_ext);
@@ -1213,12 +1376,14 @@
     const char *file_ext = nullptr,
     flatbuffers::Offset<reflection::Object> root_table = 0,
     std::vector<flatbuffers::Offset<reflection::Service>> *services = nullptr,
-    reflection::AdvancedFeatures advanced_features = static_cast<reflection::AdvancedFeatures>(0)) {
+    reflection::AdvancedFeatures advanced_features = static_cast<reflection::AdvancedFeatures>(0),
+    std::vector<flatbuffers::Offset<reflection::SchemaFile>> *fbs_files = nullptr) {
   auto objects__ = objects ? _fbb.CreateVectorOfSortedTables<reflection::Object>(objects) : 0;
   auto enums__ = enums ? _fbb.CreateVectorOfSortedTables<reflection::Enum>(enums) : 0;
   auto file_ident__ = file_ident ? _fbb.CreateString(file_ident) : 0;
   auto file_ext__ = file_ext ? _fbb.CreateString(file_ext) : 0;
   auto services__ = services ? _fbb.CreateVectorOfSortedTables<reflection::Service>(services) : 0;
+  auto fbs_files__ = fbs_files ? _fbb.CreateVectorOfSortedTables<reflection::SchemaFile>(fbs_files) : 0;
   return reflection::CreateSchema(
       _fbb,
       objects__,
@@ -1227,7 +1392,8 @@
       file_ext__,
       root_table,
       services__,
-      advanced_features);
+      advanced_features,
+      fbs_files__);
 }
 
 inline const reflection::Schema *GetSchema(const void *buf) {
@@ -1247,6 +1413,11 @@
       buf, SchemaIdentifier());
 }
 
+inline bool SizePrefixedSchemaBufferHasIdentifier(const void *buf) {
+  return flatbuffers::BufferHasIdentifier(
+      buf, SchemaIdentifier(), true);
+}
+
 inline bool VerifySchemaBuffer(
     flatbuffers::Verifier &verifier) {
   return verifier.VerifyBuffer<reflection::Schema>(SchemaIdentifier());
diff -urN a/include/flatbuffers/registry.h b/include/flatbuffers/registry.h
--- a/include/flatbuffers/registry.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/registry.h	2023-01-13 07:47:06.300228238 +0000
@@ -17,6 +17,7 @@
 #ifndef FLATBUFFERS_REGISTRY_H_
 #define FLATBUFFERS_REGISTRY_H_
 
+#include "flatbuffers/base.h"
 #include "flatbuffers/idl.h"
 
 namespace flatbuffers {
@@ -40,13 +41,13 @@
   bool FlatBufferToText(const uint8_t *flatbuf, size_t len, std::string *dest) {
     // Get the identifier out of the buffer.
     // If the buffer is truncated, exit.
-    if (len < sizeof(uoffset_t) + FlatBufferBuilder::kFileIdentifierLength) {
+    if (len < sizeof(uoffset_t) + kFileIdentifierLength) {
       lasterror_ = "buffer truncated";
       return false;
     }
     std::string ident(
         reinterpret_cast<const char *>(flatbuf) + sizeof(uoffset_t),
-        FlatBufferBuilder::kFileIdentifierLength);
+        kFileIdentifierLength);
     // Load and parse the schema.
     Parser parser;
     if (!LoadSchema(ident, &parser)) return false;
@@ -103,7 +104,7 @@
     }
     // Parse schema.
     parser->opts = opts_;
-    if (!parser->Parse(schematext.c_str(), vector_data(include_paths_),
+    if (!parser->Parse(schematext.c_str(), include_paths_.data(),
                        schema.path_.c_str())) {
       lasterror_ = parser->error_;
       return false;
diff -urN a/include/flatbuffers/stl_emulation.h b/include/flatbuffers/stl_emulation.h
--- a/include/flatbuffers/stl_emulation.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/stl_emulation.h	2023-01-13 07:47:06.300228238 +0000
@@ -26,14 +26,6 @@
 #include <memory>
 #include <limits>
 
-#if defined(_STLPORT_VERSION) && !defined(FLATBUFFERS_CPP98_STL)
-  #define FLATBUFFERS_CPP98_STL
-#endif  // defined(_STLPORT_VERSION) && !defined(FLATBUFFERS_CPP98_STL)
-
-#if defined(FLATBUFFERS_CPP98_STL)
-  #include <cctype>
-#endif  // defined(FLATBUFFERS_CPP98_STL)
-
 // Detect C++17 compatible compiler.
 // __cplusplus >= 201703L - a compiler has support of 'static inline' variables.
 #if defined(FLATBUFFERS_USE_STD_OPTIONAL) \
@@ -55,7 +47,7 @@
   #endif
 #else
   // Disable non-trivial ctors if FLATBUFFERS_SPAN_MINIMAL defined.
-  #if !defined(FLATBUFFERS_TEMPLATES_ALIASES) || defined(FLATBUFFERS_CPP98_STL)
+  #if !defined(FLATBUFFERS_TEMPLATES_ALIASES)
     #define FLATBUFFERS_SPAN_MINIMAL
   #else
     // Enable implicit construction of a span<T,N> from a std::array<T,N>.
@@ -63,135 +55,32 @@
   #endif
 #endif // defined(FLATBUFFERS_USE_STD_SPAN)
 
-// This header provides backwards compatibility for C++98 STLs like stlport.
+// This header provides backwards compatibility for older versions of the STL.
 namespace flatbuffers {
 
-// Retrieve ::back() from a string in a way that is compatible with pre C++11
-// STLs (e.g stlport).
-inline char& string_back(std::string &value) {
-  return value[value.length() - 1];
-}
-
-inline char string_back(const std::string &value) {
-  return value[value.length() - 1];
-}
-
-// Helper method that retrieves ::data() from a vector in a way that is
-// compatible with pre C++11 STLs (e.g stlport).
-template <typename T> inline T *vector_data(std::vector<T> &vector) {
-  // In some debug environments, operator[] does bounds checking, so &vector[0]
-  // can't be used.
-  return vector.empty() ? nullptr : &vector[0];
-}
-
-template <typename T> inline const T *vector_data(
-    const std::vector<T> &vector) {
-  return vector.empty() ? nullptr : &vector[0];
-}
-
-template <typename T, typename V>
-inline void vector_emplace_back(std::vector<T> *vector, V &&data) {
-  #if defined(FLATBUFFERS_CPP98_STL)
-    vector->push_back(data);
-  #else
-    vector->emplace_back(std::forward<V>(data));
-  #endif  // defined(FLATBUFFERS_CPP98_STL)
-}
-
-#ifndef FLATBUFFERS_CPP98_STL
-  #if defined(FLATBUFFERS_TEMPLATES_ALIASES)
-    template <typename T>
-    using numeric_limits = std::numeric_limits<T>;
-  #else
-    template <typename T> class numeric_limits :
-      public std::numeric_limits<T> {};
-  #endif  // defined(FLATBUFFERS_TEMPLATES_ALIASES)
+#if defined(FLATBUFFERS_TEMPLATES_ALIASES)
+  template <typename T>
+  using numeric_limits = std::numeric_limits<T>;
 #else
   template <typename T> class numeric_limits :
-      public std::numeric_limits<T> {
-    public:
-      // Android NDK fix.
-      static T lowest() {
-        return std::numeric_limits<T>::min();
-      }
-  };
-
-  template <> class numeric_limits<float> :
-      public std::numeric_limits<float> {
-    public:
-      static float lowest() { return -FLT_MAX; }
-  };
-
-  template <> class numeric_limits<double> :
-      public std::numeric_limits<double> {
-    public:
-      static double lowest() { return -DBL_MAX; }
-  };
-
-  template <> class numeric_limits<unsigned long long> {
-   public:
-    static unsigned long long min() { return 0ULL; }
-    static unsigned long long max() { return ~0ULL; }
-    static unsigned long long lowest() {
-      return numeric_limits<unsigned long long>::min();
-    }
-  };
-
-  template <> class numeric_limits<long long> {
-   public:
-    static long long min() {
-      return static_cast<long long>(1ULL << ((sizeof(long long) << 3) - 1));
-    }
-    static long long max() {
-      return static_cast<long long>(
-          (1ULL << ((sizeof(long long) << 3) - 1)) - 1);
-    }
-    static long long lowest() {
-      return numeric_limits<long long>::min();
-    }
-  };
-#endif  // FLATBUFFERS_CPP98_STL
+    public std::numeric_limits<T> {};
+#endif  // defined(FLATBUFFERS_TEMPLATES_ALIASES)
 
 #if defined(FLATBUFFERS_TEMPLATES_ALIASES)
-  #ifndef FLATBUFFERS_CPP98_STL
-    template <typename T> using is_scalar = std::is_scalar<T>;
-    template <typename T, typename U> using is_same = std::is_same<T,U>;
-    template <typename T> using is_floating_point = std::is_floating_point<T>;
-    template <typename T> using is_unsigned = std::is_unsigned<T>;
-    template <typename T> using is_enum = std::is_enum<T>;
-    template <typename T> using make_unsigned = std::make_unsigned<T>;
-    template<bool B, class T, class F>
-    using conditional = std::conditional<B, T, F>;
-    template<class T, T v>
-    using integral_constant = std::integral_constant<T, v>;
-    template <bool B>
-    using bool_constant = integral_constant<bool, B>;
-  #else
-    // Map C++ TR1 templates defined by stlport.
-    template <typename T> using is_scalar = std::tr1::is_scalar<T>;
-    template <typename T, typename U> using is_same = std::tr1::is_same<T,U>;
-    template <typename T> using is_floating_point =
-        std::tr1::is_floating_point<T>;
-    template <typename T> using is_unsigned = std::tr1::is_unsigned<T>;
-    template <typename T> using is_enum = std::tr1::is_enum<T>;
-    // Android NDK doesn't have std::make_unsigned or std::tr1::make_unsigned.
-    template<typename T> struct make_unsigned {
-      static_assert(is_unsigned<T>::value, "Specialization not implemented!");
-      using type = T;
-    };
-    template<> struct make_unsigned<char> { using type = unsigned char; };
-    template<> struct make_unsigned<short> { using type = unsigned short; };
-    template<> struct make_unsigned<int> { using type = unsigned int; };
-    template<> struct make_unsigned<long> { using type = unsigned long; };
-    template<>
-    struct make_unsigned<long long> { using type = unsigned long long; };
-    template<bool B, class T, class F>
-    using conditional = std::tr1::conditional<B, T, F>;
-    template<class T, T v>
-    using integral_constant = std::tr1::integral_constant<T, v>;
-    template <bool B>
-    using bool_constant = integral_constant<bool, B>;
-  #endif  // !FLATBUFFERS_CPP98_STL
+  template <typename T> using is_scalar = std::is_scalar<T>;
+  template <typename T, typename U> using is_same = std::is_same<T,U>;
+  template <typename T> using is_floating_point = std::is_floating_point<T>;
+  template <typename T> using is_unsigned = std::is_unsigned<T>;
+  template <typename T> using is_enum = std::is_enum<T>;
+  template <typename T> using make_unsigned = std::make_unsigned<T>;
+  template<bool B, class T, class F>
+  using conditional = std::conditional<B, T, F>;
+  template<class T, T v>
+  using integral_constant = std::integral_constant<T, v>;
+  template <bool B>
+  using bool_constant = integral_constant<bool, B>;
+  using true_type  = std::true_type;
+  using false_type = std::false_type;
 #else
   // MSVC 2010 doesn't support C++11 aliases.
   template <typename T> struct is_scalar : public std::is_scalar<T> {};
@@ -207,126 +96,37 @@
   struct integral_constant : public std::integral_constant<T, v> {};
   template <bool B>
   struct bool_constant : public integral_constant<bool, B> {};
+  typedef bool_constant<true>  true_type;
+  typedef bool_constant<false> false_type;
 #endif  // defined(FLATBUFFERS_TEMPLATES_ALIASES)
 
-#ifndef FLATBUFFERS_CPP98_STL
-  #if defined(FLATBUFFERS_TEMPLATES_ALIASES)
-    template <class T> using unique_ptr = std::unique_ptr<T>;
-  #else
-    // MSVC 2010 doesn't support C++11 aliases.
-    // We're manually "aliasing" the class here as we want to bring unique_ptr
-    // into the flatbuffers namespace.  We have unique_ptr in the flatbuffers
-    // namespace we have a completely independent implementation (see below)
-    // for C++98 STL implementations.
-    template <class T> class unique_ptr : public std::unique_ptr<T> {
-     public:
-      unique_ptr() {}
-      explicit unique_ptr(T* p) : std::unique_ptr<T>(p) {}
-      unique_ptr(std::unique_ptr<T>&& u) { *this = std::move(u); }
-      unique_ptr(unique_ptr&& u) { *this = std::move(u); }
-      unique_ptr& operator=(std::unique_ptr<T>&& u) {
-        std::unique_ptr<T>::reset(u.release());
-        return *this;
-      }
-      unique_ptr& operator=(unique_ptr&& u) {
-        std::unique_ptr<T>::reset(u.release());
-        return *this;
-      }
-      unique_ptr& operator=(T* p) {
-        return std::unique_ptr<T>::operator=(p);
-      }
-    };
-  #endif  // defined(FLATBUFFERS_TEMPLATES_ALIASES)
+#if defined(FLATBUFFERS_TEMPLATES_ALIASES)
+  template <class T> using unique_ptr = std::unique_ptr<T>;
 #else
-  // Very limited implementation of unique_ptr.
-  // This is provided simply to allow the C++ code generated from the default
-  // settings to function in C++98 environments with no modifications.
-  template <class T> class unique_ptr {
-   public:
-    typedef T element_type;
-
-    unique_ptr() : ptr_(nullptr) {}
-    explicit unique_ptr(T* p) : ptr_(p) {}
-    unique_ptr(unique_ptr&& u) : ptr_(nullptr) { reset(u.release()); }
-    unique_ptr(const unique_ptr& u) : ptr_(nullptr) {
-      reset(const_cast<unique_ptr*>(&u)->release());
-    }
-    ~unique_ptr() { reset(); }
-
-    unique_ptr& operator=(const unique_ptr& u) {
-      reset(const_cast<unique_ptr*>(&u)->release());
+  // MSVC 2010 doesn't support C++11 aliases.
+  // We're manually "aliasing" the class here as we want to bring unique_ptr
+  // into the flatbuffers namespace.  We have unique_ptr in the flatbuffers
+  // namespace we have a completely independent implementation (see below)
+  // for C++98 STL implementations.
+  template <class T> class unique_ptr : public std::unique_ptr<T> {
+    public:
+    unique_ptr() {}
+    explicit unique_ptr(T* p) : std::unique_ptr<T>(p) {}
+    unique_ptr(std::unique_ptr<T>&& u) { *this = std::move(u); }
+    unique_ptr(unique_ptr&& u) { *this = std::move(u); }
+    unique_ptr& operator=(std::unique_ptr<T>&& u) {
+      std::unique_ptr<T>::reset(u.release());
       return *this;
     }
-
     unique_ptr& operator=(unique_ptr&& u) {
-      reset(u.release());
+      std::unique_ptr<T>::reset(u.release());
       return *this;
     }
-
     unique_ptr& operator=(T* p) {
-      reset(p);
-      return *this;
-    }
-
-    const T& operator*() const { return *ptr_; }
-    T* operator->() const { return ptr_; }
-    T* get() const noexcept { return ptr_; }
-    explicit operator bool() const { return ptr_ != nullptr; }
-
-    // modifiers
-    T* release() {
-      T* value = ptr_;
-      ptr_ = nullptr;
-      return value;
+      return std::unique_ptr<T>::operator=(p);
     }
-
-    void reset(T* p = nullptr) {
-      T* value = ptr_;
-      ptr_ = p;
-      if (value) delete value;
-    }
-
-    void swap(unique_ptr& u) {
-      T* temp_ptr = ptr_;
-      ptr_ = u.ptr_;
-      u.ptr_ = temp_ptr;
-    }
-
-   private:
-    T* ptr_;
   };
-
-  template <class T> bool operator==(const unique_ptr<T>& x,
-                                     const unique_ptr<T>& y) {
-    return x.get() == y.get();
-  }
-
-  template <class T, class D> bool operator==(const unique_ptr<T>& x,
-                                              const D* y) {
-    return static_cast<D*>(x.get()) == y;
-  }
-
-  template <class T> bool operator==(const unique_ptr<T>& x, intptr_t y) {
-    return reinterpret_cast<intptr_t>(x.get()) == y;
-  }
-
-  template <class T> bool operator!=(const unique_ptr<T>& x, decltype(nullptr)) {
-    return !!x;
-  }
-
-  template <class T> bool operator!=(decltype(nullptr), const unique_ptr<T>& x) {
-    return !!x;
-  }
-
-  template <class T> bool operator==(const unique_ptr<T>& x, decltype(nullptr)) {
-    return !x;
-  }
-
-  template <class T> bool operator==(decltype(nullptr), const unique_ptr<T>& x) {
-    return !x;
-  }
-
-#endif  // !FLATBUFFERS_CPP98_STL
+#endif  // defined(FLATBUFFERS_TEMPLATES_ALIASES)
 
 #ifdef FLATBUFFERS_USE_STD_OPTIONAL
 template<class T>
@@ -495,6 +295,32 @@
                                 int, void>::type;
   };
 
+  template<typename T>
+  struct SpanIterator {
+    // TODO: upgrade to std::random_access_iterator_tag.
+    using iterator_category = std::forward_iterator_tag;
+    using difference_type  = std::ptrdiff_t;
+    using value_type = typename std::remove:cv<T>::type;
+    using reference = T&;
+    using pointer   = T*;
+
+    // Convince MSVC compiler that this iterator is trusted (it is verified).
+    #ifdef _MSC_VER
+      using _Unchecked_type = pointer;
+    #endif // _MSC_VER
+
+    SpanIterator(pointer ptr) : ptr_(ptr) {}
+    reference operator*() const { return *ptr_; }
+    pointer operator->() { return ptr_; }
+    SpanIterator& operator++() { ptr_++; return *this; }  
+    SpanIterator  operator++(int) { auto tmp = *this; ++(*this); return tmp; }
+
+    friend bool operator== (const SpanIterator& lhs, const SpanIterator& rhs) { return lhs.ptr_ == rhs.ptr_; }
+    friend bool operator!= (const SpanIterator& lhs, const SpanIterator& rhs) { return lhs.ptr_ != rhs.ptr_; }
+
+   private:
+    pointer ptr_;
+  };
 }  // namespace internal
 #endif  // !defined(FLATBUFFERS_SPAN_MINIMAL)
 
@@ -534,6 +360,17 @@
     return data_;
   }
 
+  #if !defined(FLATBUFFERS_SPAN_MINIMAL)
+    using Iterator = internal::SpanIterator<T>;
+    using ConstIterator = internal::SpanIterator<const T>;
+
+    Iterator begin() const { return Iterator(data()); }
+    Iterator end() const   { return Iterator(data() + size()); }
+
+    ConstIterator cbegin() const { return ConstIterator(data()); }
+    ConstIterator cend() const  { return ConstIterator(data() + size()); }
+  #endif
+
   // Returns a reference to the idx-th element of the sequence.
   // The behavior is undefined if the idx is greater than or equal to size().
   FLATBUFFERS_CONSTEXPR_CPP11 reference operator[](size_type idx) const {
@@ -627,46 +464,45 @@
   pointer const data_;
   const size_type count_;
 };
+#endif  // defined(FLATBUFFERS_USE_STD_SPAN)
 
- #if !defined(FLATBUFFERS_SPAN_MINIMAL)
-  template<class U, std::size_t N>
-  FLATBUFFERS_CONSTEXPR_CPP11
-  flatbuffers::span<U, N> make_span(U(&arr)[N]) FLATBUFFERS_NOEXCEPT {
-    return span<U, N>(arr);
-  }
-
-  template<class U, std::size_t N>
-  FLATBUFFERS_CONSTEXPR_CPP11
-  flatbuffers::span<const U, N> make_span(const U(&arr)[N]) FLATBUFFERS_NOEXCEPT {
-    return span<const U, N>(arr);
-  }
+#if !defined(FLATBUFFERS_SPAN_MINIMAL)
+template<class U, std::size_t N>
+FLATBUFFERS_CONSTEXPR_CPP11
+flatbuffers::span<U, N> make_span(U(&arr)[N]) FLATBUFFERS_NOEXCEPT {
+  return span<U, N>(arr);
+}
 
-  template<class U, std::size_t N>
-  FLATBUFFERS_CONSTEXPR_CPP11
-  flatbuffers::span<U, N> make_span(std::array<U, N> &arr) FLATBUFFERS_NOEXCEPT {
-    return span<U, N>(arr);
-  }
+template<class U, std::size_t N>
+FLATBUFFERS_CONSTEXPR_CPP11
+flatbuffers::span<const U, N> make_span(const U(&arr)[N]) FLATBUFFERS_NOEXCEPT {
+  return span<const U, N>(arr);
+}
 
-  template<class U, std::size_t N>
-  FLATBUFFERS_CONSTEXPR_CPP11
-  flatbuffers::span<const U, N> make_span(const std::array<U, N> &arr) FLATBUFFERS_NOEXCEPT {
-    return span<const U, N>(arr);
-  }
+template<class U, std::size_t N>
+FLATBUFFERS_CONSTEXPR_CPP11
+flatbuffers::span<U, N> make_span(std::array<U, N> &arr) FLATBUFFERS_NOEXCEPT {
+  return span<U, N>(arr);
+}
 
-  template<class U, std::size_t N>
-  FLATBUFFERS_CONSTEXPR_CPP11
-  flatbuffers::span<U, dynamic_extent> make_span(U *first, std::size_t count) FLATBUFFERS_NOEXCEPT {
-    return span<U, dynamic_extent>(first, count);
-  }
+template<class U, std::size_t N>
+FLATBUFFERS_CONSTEXPR_CPP11
+flatbuffers::span<const U, N> make_span(const std::array<U, N> &arr) FLATBUFFERS_NOEXCEPT {
+  return span<const U, N>(arr);
+}
 
-  template<class U, std::size_t N>
-  FLATBUFFERS_CONSTEXPR_CPP11
-  flatbuffers::span<const U, dynamic_extent> make_span(const U *first, std::size_t count) FLATBUFFERS_NOEXCEPT {
-    return span<const U, dynamic_extent>(first, count);
-  }
-#endif
+template<class U, std::size_t N>
+FLATBUFFERS_CONSTEXPR_CPP11
+flatbuffers::span<U, dynamic_extent> make_span(U *first, std::size_t count) FLATBUFFERS_NOEXCEPT {
+  return span<U, dynamic_extent>(first, count);
+}
 
-#endif  // defined(FLATBUFFERS_USE_STD_SPAN)
+template<class U, std::size_t N>
+FLATBUFFERS_CONSTEXPR_CPP11
+flatbuffers::span<const U, dynamic_extent> make_span(const U *first, std::size_t count) FLATBUFFERS_NOEXCEPT {
+  return span<const U, dynamic_extent>(first, count);
+}
+#endif // !defined(FLATBUFFERS_SPAN_MINIMAL)
 
 }  // namespace flatbuffers
 
diff -urN a/include/flatbuffers/string.h b/include/flatbuffers/string.h
--- a/include/flatbuffers/string.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/string.h	2023-01-13 07:47:06.301228247 +0000
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_STRING_H_
+#define FLATBUFFERS_STRING_H_
+
+#include "flatbuffers/base.h"
+#include "flatbuffers/vector.h"
+
+namespace flatbuffers {
+
+struct String : public Vector<char> {
+  const char *c_str() const { return reinterpret_cast<const char *>(Data()); }
+  std::string str() const { return std::string(c_str(), size()); }
+
+  // clang-format off
+  #ifdef FLATBUFFERS_HAS_STRING_VIEW
+  flatbuffers::string_view string_view() const {
+    return flatbuffers::string_view(c_str(), size());
+  }
+  #endif // FLATBUFFERS_HAS_STRING_VIEW
+  // clang-format on
+
+  bool operator<(const String &o) const {
+    return StringLessThan(this->data(), this->size(), o.data(), o.size());
+  }
+};
+
+// Convenience function to get std::string from a String returning an empty
+// string on null pointer.
+static inline std::string GetString(const String *str) {
+  return str ? str->str() : "";
+}
+
+// Convenience function to get char* from a String returning an empty string on
+// null pointer.
+static inline const char *GetCstring(const String *str) {
+  return str ? str->c_str() : "";
+}
+
+#ifdef FLATBUFFERS_HAS_STRING_VIEW
+// Convenience function to get string_view from a String returning an empty
+// string_view on null pointer.
+static inline flatbuffers::string_view GetStringView(const String *str) {
+  return str ? str->string_view() : flatbuffers::string_view();
+}
+#endif  // FLATBUFFERS_HAS_STRING_VIEW
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_STRING_H_
\ No newline at end of file
diff -urN a/include/flatbuffers/struct.h b/include/flatbuffers/struct.h
--- a/include/flatbuffers/struct.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/struct.h	2023-01-13 07:47:06.301228247 +0000
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_STRUCT_H_
+#define FLATBUFFERS_STRUCT_H_
+
+#include "flatbuffers/base.h"
+
+namespace flatbuffers {
+
+// "structs" are flat structures that do not have an offset table, thus
+// always have all members present and do not support forwards/backwards
+// compatible extensions.
+
+class Struct FLATBUFFERS_FINAL_CLASS {
+ public:
+  template<typename T> T GetField(uoffset_t o) const {
+    return ReadScalar<T>(&data_[o]);
+  }
+
+  template<typename T> T GetStruct(uoffset_t o) const {
+    return reinterpret_cast<T>(&data_[o]);
+  }
+
+  const uint8_t *GetAddressOf(uoffset_t o) const { return &data_[o]; }
+  uint8_t *GetAddressOf(uoffset_t o) { return &data_[o]; }
+
+ private:
+  // private constructor & copy constructor: you obtain instances of this
+  // class by pointing to existing data only
+  Struct();
+  Struct(const Struct &);
+  Struct &operator=(const Struct &);
+
+  uint8_t data_[1];
+};
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_STRUCT_H_
\ No newline at end of file
diff -urN a/include/flatbuffers/table.h b/include/flatbuffers/table.h
--- a/include/flatbuffers/table.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/table.h	2023-01-13 07:47:06.301228247 +0000
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_TABLE_H_
+#define FLATBUFFERS_TABLE_H_
+
+#include "flatbuffers/base.h"
+#include "flatbuffers/verifier.h"
+
+namespace flatbuffers {
+
+// "tables" use an offset table (possibly shared) that allows fields to be
+// omitted and added at will, but uses an extra indirection to read.
+class Table {
+ public:
+  const uint8_t *GetVTable() const {
+    return data_ - ReadScalar<soffset_t>(data_);
+  }
+
+  // This gets the field offset for any of the functions below it, or 0
+  // if the field was not present.
+  voffset_t GetOptionalFieldOffset(voffset_t field) const {
+    // The vtable offset is always at the start.
+    auto vtable = GetVTable();
+    // The first element is the size of the vtable (fields + type id + itself).
+    auto vtsize = ReadScalar<voffset_t>(vtable);
+    // If the field we're accessing is outside the vtable, we're reading older
+    // data, so it's the same as if the offset was 0 (not present).
+    return field < vtsize ? ReadScalar<voffset_t>(vtable + field) : 0;
+  }
+
+  template<typename T> T GetField(voffset_t field, T defaultval) const {
+    auto field_offset = GetOptionalFieldOffset(field);
+    return field_offset ? ReadScalar<T>(data_ + field_offset) : defaultval;
+  }
+
+  template<typename P> P GetPointer(voffset_t field) {
+    auto field_offset = GetOptionalFieldOffset(field);
+    auto p = data_ + field_offset;
+    return field_offset ? reinterpret_cast<P>(p + ReadScalar<uoffset_t>(p))
+                        : nullptr;
+  }
+  template<typename P> P GetPointer(voffset_t field) const {
+    return const_cast<Table *>(this)->GetPointer<P>(field);
+  }
+
+  template<typename P> P GetStruct(voffset_t field) const {
+    auto field_offset = GetOptionalFieldOffset(field);
+    auto p = const_cast<uint8_t *>(data_ + field_offset);
+    return field_offset ? reinterpret_cast<P>(p) : nullptr;
+  }
+
+  template<typename Raw, typename Face>
+  flatbuffers::Optional<Face> GetOptional(voffset_t field) const {
+    auto field_offset = GetOptionalFieldOffset(field);
+    auto p = data_ + field_offset;
+    return field_offset ? Optional<Face>(static_cast<Face>(ReadScalar<Raw>(p)))
+                        : Optional<Face>();
+  }
+
+  template<typename T> bool SetField(voffset_t field, T val, T def) {
+    auto field_offset = GetOptionalFieldOffset(field);
+    if (!field_offset) return IsTheSameAs(val, def);
+    WriteScalar(data_ + field_offset, val);
+    return true;
+  }
+  template<typename T> bool SetField(voffset_t field, T val) {
+    auto field_offset = GetOptionalFieldOffset(field);
+    if (!field_offset) return false;
+    WriteScalar(data_ + field_offset, val);
+    return true;
+  }
+
+  bool SetPointer(voffset_t field, const uint8_t *val) {
+    auto field_offset = GetOptionalFieldOffset(field);
+    if (!field_offset) return false;
+    WriteScalar(data_ + field_offset,
+                static_cast<uoffset_t>(val - (data_ + field_offset)));
+    return true;
+  }
+
+  uint8_t *GetAddressOf(voffset_t field) {
+    auto field_offset = GetOptionalFieldOffset(field);
+    return field_offset ? data_ + field_offset : nullptr;
+  }
+  const uint8_t *GetAddressOf(voffset_t field) const {
+    return const_cast<Table *>(this)->GetAddressOf(field);
+  }
+
+  bool CheckField(voffset_t field) const {
+    return GetOptionalFieldOffset(field) != 0;
+  }
+
+  // Verify the vtable of this table.
+  // Call this once per table, followed by VerifyField once per field.
+  bool VerifyTableStart(Verifier &verifier) const {
+    return verifier.VerifyTableStart(data_);
+  }
+
+  // Verify a particular field.
+  template<typename T>
+  bool VerifyField(const Verifier &verifier, voffset_t field,
+                   size_t align) const {
+    // Calling GetOptionalFieldOffset should be safe now thanks to
+    // VerifyTable().
+    auto field_offset = GetOptionalFieldOffset(field);
+    // Check the actual field.
+    return !field_offset || verifier.VerifyField<T>(data_, field_offset, align);
+  }
+
+  // VerifyField for required fields.
+  template<typename T>
+  bool VerifyFieldRequired(const Verifier &verifier, voffset_t field,
+                           size_t align) const {
+    auto field_offset = GetOptionalFieldOffset(field);
+    return verifier.Check(field_offset != 0) &&
+           verifier.VerifyField<T>(data_, field_offset, align);
+  }
+
+  // Versions for offsets.
+  bool VerifyOffset(const Verifier &verifier, voffset_t field) const {
+    auto field_offset = GetOptionalFieldOffset(field);
+    return !field_offset || verifier.VerifyOffset(data_, field_offset);
+  }
+
+  bool VerifyOffsetRequired(const Verifier &verifier, voffset_t field) const {
+    auto field_offset = GetOptionalFieldOffset(field);
+    return verifier.Check(field_offset != 0) &&
+           verifier.VerifyOffset(data_, field_offset);
+  }
+
+ private:
+  // private constructor & copy constructor: you obtain instances of this
+  // class by pointing to existing data only
+  Table();
+  Table(const Table &other);
+  Table &operator=(const Table &);
+
+  uint8_t data_[1];
+};
+
+// This specialization allows avoiding warnings like:
+// MSVC C4800: type: forcing value to bool 'true' or 'false'.
+template<>
+inline flatbuffers::Optional<bool> Table::GetOptional<uint8_t, bool>(
+    voffset_t field) const {
+  auto field_offset = GetOptionalFieldOffset(field);
+  auto p = data_ + field_offset;
+  return field_offset ? Optional<bool>(ReadScalar<uint8_t>(p) != 0)
+                      : Optional<bool>();
+}
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_TABLE_H_
diff -urN a/include/flatbuffers/util.h b/include/flatbuffers/util.h
--- a/include/flatbuffers/util.h	2021-05-10 18:45:16.000000000 +0000
+++ b/include/flatbuffers/util.h	2023-01-13 07:47:06.301228247 +0000
@@ -17,19 +17,20 @@
 #ifndef FLATBUFFERS_UTIL_H_
 #define FLATBUFFERS_UTIL_H_
 
+#include <ctype.h>
 #include <errno.h>
 
 #include "flatbuffers/base.h"
 #include "flatbuffers/stl_emulation.h"
 
 #ifndef FLATBUFFERS_PREFER_PRINTF
+#  include <iomanip>
 #  include <sstream>
 #else  // FLATBUFFERS_PREFER_PRINTF
 #  include <float.h>
 #  include <stdio.h>
 #endif  // FLATBUFFERS_PREFER_PRINTF
 
-#include <iomanip>
 #include <string>
 
 namespace flatbuffers {
@@ -94,7 +95,7 @@
   // Count a single 0 left of the dot for fractional numbers
   if (-1 < t && t < 1) digit_count++;
   // Count digits until fractional part
-  T eps = std::numeric_limits<float>::epsilon();
+  T eps = std::numeric_limits<T>::epsilon();
   while (t <= (-1 + eps) || (1 - eps) <= t) {
     t /= 10;
     digit_count++;
@@ -145,20 +146,6 @@
 template<> inline std::string NumToString<char>(char t) {
   return NumToString(static_cast<int>(t));
 }
-#if defined(FLATBUFFERS_CPP98_STL)
-template<> inline std::string NumToString<long long>(long long t) {
-  char buf[21];  // (log((1 << 63) - 1) / log(10)) + 2
-  snprintf(buf, sizeof(buf), "%lld", t);
-  return std::string(buf);
-}
-
-template<>
-inline std::string NumToString<unsigned long long>(unsigned long long t) {
-  char buf[22];  // (log((1 << 63) - 1) / log(10)) + 1
-  snprintf(buf, sizeof(buf), "%llu", t);
-  return std::string(buf);
-}
-#endif  // defined(FLATBUFFERS_CPP98_STL)
 
 // Special versions for floats/doubles.
 template<typename T> std::string FloatToString(T t, int precision) {
@@ -231,13 +218,13 @@
   };
 
   #ifdef _MSC_VER
-    #define __strtoull_impl(s, pe, b) _strtoui64_l(s, pe, b, ClassicLocale::Get())
-    #define __strtoll_impl(s, pe, b) _strtoi64_l(s, pe, b, ClassicLocale::Get())
+  //  #define __strtoull_impl(s, pe, b) _strtoui64_l(s, pe, b, ClassicLocale::Get())
+   // #define __strtoll_impl(s, pe, b) _strtoi64_l(s, pe, b, ClassicLocale::Get())
     #define __strtod_impl(s, pe) _strtod_l(s, pe, ClassicLocale::Get())
     #define __strtof_impl(s, pe) _strtof_l(s, pe, ClassicLocale::Get())
   #else
-    #define __strtoull_impl(s, pe, b) strtoull_l(s, pe, b, ClassicLocale::Get())
-    #define __strtoll_impl(s, pe, b) strtoll_l(s, pe, b, ClassicLocale::Get())
+    //#define __strtoull_impl(s, pe, b) strtoull_l(s, pe, b, ClassicLocale::Get())
+    //#define __strtoll_impl(s, pe, b) strtoll_l(s, pe, b, ClassicLocale::Get())
     #define __strtod_impl(s, pe) strtod_l(s, pe, ClassicLocale::Get())
     #define __strtof_impl(s, pe) strtof_l(s, pe, ClassicLocale::Get())
   #endif
@@ -245,22 +232,22 @@
   #define __strtod_impl(s, pe) strtod(s, pe)
   #define __strtof_impl(s, pe) static_cast<float>(strtod(s, pe))
   #ifdef _MSC_VER
-    #define __strtoull_impl(s, pe, b) _strtoui64(s, pe, b)
-    #define __strtoll_impl(s, pe, b) _strtoi64(s, pe, b)
+    //#define __strtoull_impl(s, pe, b) _strtoui64(s, pe, b)
+    //#define __strtoll_impl(s, pe, b) _strtoi64(s, pe, b)
   #else
-    #define __strtoull_impl(s, pe, b) strtoull(s, pe, b)
-    #define __strtoll_impl(s, pe, b) strtoll(s, pe, b)
+    //#define __strtoull_impl(s, pe, b) strtoull(s, pe, b)
+    //#define __strtoll_impl(s, pe, b) strtoll(s, pe, b)
   #endif
 #endif
 
 inline void strtoval_impl(int64_t *val, const char *str, char **endptr,
                                  int base) {
-    *val = __strtoll_impl(str, endptr, base);
+    //*val = __strtoll_impl(str, endptr, base);
 }
 
 inline void strtoval_impl(uint64_t *val, const char *str, char **endptr,
                                  int base) {
-  *val = __strtoull_impl(str, endptr, base);
+  //*val = __strtoull_impl(str, endptr, base);
 }
 
 inline void strtoval_impl(double *val, const char *str, char **endptr) {
@@ -272,8 +259,8 @@
 inline void strtoval_impl(float *val, const char *str, char **endptr) {
   *val = __strtof_impl(str, endptr);
 }
-#undef __strtoull_impl
-#undef __strtoll_impl
+//#undef __strtoull_impl
+//#undef __strtoll_impl
 #undef __strtod_impl
 #undef __strtof_impl
 // clang-format on
@@ -468,6 +455,7 @@
 
 // Replaces any '\\' separators with '/'
 std::string PosixPath(const char *path);
+std::string PosixPath(const std::string &path);
 
 // This function ensure a directory exists, by recursively
 // creating dirs for any parts of the path that don't exist yet.
@@ -477,6 +465,10 @@
 // Returns the input path if the absolute path couldn't be resolved.
 std::string AbsolutePath(const std::string &filepath);
 
+// Returns files relative to the --project_root path, prefixed with `//`.
+std::string RelativeToRootPath(const std::string &project,
+                               const std::string &filepath);
+
 // To and from UTF-8 unicode conversion functions
 
 // Convert a unicode code point into a UTF-8 representation by appending it
diff -urN a/include/flatbuffers/vector.h b/include/flatbuffers/vector.h
--- a/include/flatbuffers/vector.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/vector.h	2023-01-13 07:47:06.301228247 +0000
@@ -0,0 +1,370 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_VECTOR_H_
+#define FLATBUFFERS_VECTOR_H_
+
+#include "flatbuffers/base.h"
+#include "flatbuffers/buffer.h"
+
+namespace flatbuffers {
+
+struct String;
+
+// An STL compatible iterator implementation for Vector below, effectively
+// calling Get() for every element.
+template<typename T, typename IT> struct VectorIterator {
+  typedef std::random_access_iterator_tag iterator_category;
+  typedef IT value_type;
+  typedef ptrdiff_t difference_type;
+  typedef IT *pointer;
+  typedef IT &reference;
+
+  VectorIterator(const uint8_t *data, uoffset_t i)
+      : data_(data + IndirectHelper<T>::element_stride * i) {}
+  VectorIterator(const VectorIterator &other) : data_(other.data_) {}
+  VectorIterator() : data_(nullptr) {}
+
+  VectorIterator &operator=(const VectorIterator &other) {
+    data_ = other.data_;
+    return *this;
+  }
+
+  VectorIterator &operator=(VectorIterator &&other) {
+    data_ = other.data_;
+    return *this;
+  }
+
+  bool operator==(const VectorIterator &other) const {
+    return data_ == other.data_;
+  }
+
+  bool operator<(const VectorIterator &other) const {
+    return data_ < other.data_;
+  }
+
+  bool operator!=(const VectorIterator &other) const {
+    return data_ != other.data_;
+  }
+
+  difference_type operator-(const VectorIterator &other) const {
+    return (data_ - other.data_) / IndirectHelper<T>::element_stride;
+  }
+
+  // Note: return type is incompatible with the standard
+  // `reference operator*()`.
+  IT operator*() const { return IndirectHelper<T>::Read(data_, 0); }
+
+  // Note: return type is incompatible with the standard
+  // `pointer operator->()`.
+  IT operator->() const { return IndirectHelper<T>::Read(data_, 0); }
+
+  VectorIterator &operator++() {
+    data_ += IndirectHelper<T>::element_stride;
+    return *this;
+  }
+
+  VectorIterator operator++(int) {
+    VectorIterator temp(data_, 0);
+    data_ += IndirectHelper<T>::element_stride;
+    return temp;
+  }
+
+  VectorIterator operator+(const uoffset_t &offset) const {
+    return VectorIterator(data_ + offset * IndirectHelper<T>::element_stride,
+                          0);
+  }
+
+  VectorIterator &operator+=(const uoffset_t &offset) {
+    data_ += offset * IndirectHelper<T>::element_stride;
+    return *this;
+  }
+
+  VectorIterator &operator--() {
+    data_ -= IndirectHelper<T>::element_stride;
+    return *this;
+  }
+
+  VectorIterator operator--(int) {
+    VectorIterator temp(data_, 0);
+    data_ -= IndirectHelper<T>::element_stride;
+    return temp;
+  }
+
+  VectorIterator operator-(const uoffset_t &offset) const {
+    return VectorIterator(data_ - offset * IndirectHelper<T>::element_stride,
+                          0);
+  }
+
+  VectorIterator &operator-=(const uoffset_t &offset) {
+    data_ -= offset * IndirectHelper<T>::element_stride;
+    return *this;
+  }
+
+ private:
+  const uint8_t *data_;
+};
+
+template<typename Iterator>
+struct VectorReverseIterator : public std::reverse_iterator<Iterator> {
+  explicit VectorReverseIterator(Iterator iter)
+      : std::reverse_iterator<Iterator>(iter) {}
+
+  // Note: return type is incompatible with the standard
+  // `reference operator*()`.
+  typename Iterator::value_type operator*() const {
+    auto tmp = std::reverse_iterator<Iterator>::current;
+    return *--tmp;
+  }
+
+  // Note: return type is incompatible with the standard
+  // `pointer operator->()`.
+  typename Iterator::value_type operator->() const {
+    auto tmp = std::reverse_iterator<Iterator>::current;
+    return *--tmp;
+  }
+};
+
+// This is used as a helper type for accessing vectors.
+// Vector::data() assumes the vector elements start after the length field.
+template<typename T> class Vector {
+ public:
+  typedef VectorIterator<T, typename IndirectHelper<T>::mutable_return_type>
+      iterator;
+  typedef VectorIterator<T, typename IndirectHelper<T>::return_type>
+      const_iterator;
+  typedef VectorReverseIterator<iterator> reverse_iterator;
+  typedef VectorReverseIterator<const_iterator> const_reverse_iterator;
+
+  typedef typename flatbuffers::bool_constant<flatbuffers::is_scalar<T>::value>
+      scalar_tag;
+
+  static FLATBUFFERS_CONSTEXPR bool is_span_observable =
+      scalar_tag::value && (FLATBUFFERS_LITTLEENDIAN || sizeof(T) == 1);
+
+  uoffset_t size() const { return EndianScalar(length_); }
+
+  // Deprecated: use size(). Here for backwards compatibility.
+  FLATBUFFERS_ATTRIBUTE([[deprecated("use size() instead")]])
+  uoffset_t Length() const { return size(); }
+
+  typedef typename IndirectHelper<T>::return_type return_type;
+  typedef typename IndirectHelper<T>::mutable_return_type mutable_return_type;
+  typedef return_type value_type;
+
+  return_type Get(uoffset_t i) const {
+    FLATBUFFERS_ASSERT(i < size());
+    return IndirectHelper<T>::Read(Data(), i);
+  }
+
+  return_type operator[](uoffset_t i) const { return Get(i); }
+
+  // If this is a Vector of enums, T will be its storage type, not the enum
+  // type. This function makes it convenient to retrieve value with enum
+  // type E.
+  template<typename E> E GetEnum(uoffset_t i) const {
+    return static_cast<E>(Get(i));
+  }
+
+  // If this a vector of unions, this does the cast for you. There's no check
+  // to make sure this is the right type!
+  template<typename U> const U *GetAs(uoffset_t i) const {
+    return reinterpret_cast<const U *>(Get(i));
+  }
+
+  // If this a vector of unions, this does the cast for you. There's no check
+  // to make sure this is actually a string!
+  const String *GetAsString(uoffset_t i) const {
+    return reinterpret_cast<const String *>(Get(i));
+  }
+
+  const void *GetStructFromOffset(size_t o) const {
+    return reinterpret_cast<const void *>(Data() + o);
+  }
+
+  iterator begin() { return iterator(Data(), 0); }
+  const_iterator begin() const { return const_iterator(Data(), 0); }
+
+  iterator end() { return iterator(Data(), size()); }
+  const_iterator end() const { return const_iterator(Data(), size()); }
+
+  reverse_iterator rbegin() { return reverse_iterator(end()); }
+  const_reverse_iterator rbegin() const {
+    return const_reverse_iterator(end());
+  }
+
+  reverse_iterator rend() { return reverse_iterator(begin()); }
+  const_reverse_iterator rend() const {
+    return const_reverse_iterator(begin());
+  }
+
+  const_iterator cbegin() const { return begin(); }
+
+  const_iterator cend() const { return end(); }
+
+  const_reverse_iterator crbegin() const { return rbegin(); }
+
+  const_reverse_iterator crend() const { return rend(); }
+
+  // Change elements if you have a non-const pointer to this object.
+  // Scalars only. See reflection.h, and the documentation.
+  void Mutate(uoffset_t i, const T &val) {
+    FLATBUFFERS_ASSERT(i < size());
+    WriteScalar(data() + i, val);
+  }
+
+  // Change an element of a vector of tables (or strings).
+  // "val" points to the new table/string, as you can obtain from
+  // e.g. reflection::AddFlatBuffer().
+  void MutateOffset(uoffset_t i, const uint8_t *val) {
+    FLATBUFFERS_ASSERT(i < size());
+    static_assert(sizeof(T) == sizeof(uoffset_t), "Unrelated types");
+    WriteScalar(data() + i,
+                static_cast<uoffset_t>(val - (Data() + i * sizeof(uoffset_t))));
+  }
+
+  // Get a mutable pointer to tables/strings inside this vector.
+  mutable_return_type GetMutableObject(uoffset_t i) const {
+    FLATBUFFERS_ASSERT(i < size());
+    return const_cast<mutable_return_type>(IndirectHelper<T>::Read(Data(), i));
+  }
+
+  // The raw data in little endian format. Use with care.
+  const uint8_t *Data() const {
+    return reinterpret_cast<const uint8_t *>(&length_ + 1);
+  }
+
+  uint8_t *Data() { return reinterpret_cast<uint8_t *>(&length_ + 1); }
+
+  // Similarly, but typed, much like std::vector::data
+  const T *data() const { return reinterpret_cast<const T *>(Data()); }
+  T *data() { return reinterpret_cast<T *>(Data()); }
+
+  template<typename K> return_type LookupByKey(K key) const {
+    void *search_result = std::bsearch(
+        &key, Data(), size(), IndirectHelper<T>::element_stride, KeyCompare<K>);
+
+    if (!search_result) {
+      return nullptr;  // Key not found.
+    }
+
+    const uint8_t *element = reinterpret_cast<const uint8_t *>(search_result);
+
+    return IndirectHelper<T>::Read(element, 0);
+  }
+
+  template<typename K> mutable_return_type MutableLookupByKey(K key) {
+    return const_cast<mutable_return_type>(LookupByKey(key));
+  }
+
+ protected:
+  // This class is only used to access pre-existing data. Don't ever
+  // try to construct these manually.
+  Vector();
+
+  uoffset_t length_;
+
+ private:
+  // This class is a pointer. Copying will therefore create an invalid object.
+  // Private and unimplemented copy constructor.
+  Vector(const Vector &);
+  Vector &operator=(const Vector &);
+
+  template<typename K> static int KeyCompare(const void *ap, const void *bp) {
+    const K *key = reinterpret_cast<const K *>(ap);
+    const uint8_t *data = reinterpret_cast<const uint8_t *>(bp);
+    auto table = IndirectHelper<T>::Read(data, 0);
+
+    // std::bsearch compares with the operands transposed, so we negate the
+    // result here.
+    return -table->KeyCompareWithValue(*key);
+  }
+};
+
+template<class U>
+FLATBUFFERS_CONSTEXPR_CPP11 flatbuffers::span<U> make_span(Vector<U> &vec)
+    FLATBUFFERS_NOEXCEPT {
+  static_assert(Vector<U>::is_span_observable,
+                "wrong type U, only LE-scalar, or byte types are allowed");
+  return span<U>(vec.data(), vec.size());
+}
+
+template<class U>
+FLATBUFFERS_CONSTEXPR_CPP11 flatbuffers::span<const U> make_span(
+    const Vector<U> &vec) FLATBUFFERS_NOEXCEPT {
+  static_assert(Vector<U>::is_span_observable,
+                "wrong type U, only LE-scalar, or byte types are allowed");
+  return span<const U>(vec.data(), vec.size());
+}
+
+template<class U>
+FLATBUFFERS_CONSTEXPR_CPP11 flatbuffers::span<uint8_t> make_bytes_span(
+    Vector<U> &vec) FLATBUFFERS_NOEXCEPT {
+  static_assert(Vector<U>::scalar_tag::value,
+                "wrong type U, only LE-scalar, or byte types are allowed");
+  return span<uint8_t>(vec.Data(), vec.size() * sizeof(U));
+}
+
+template<class U>
+FLATBUFFERS_CONSTEXPR_CPP11 flatbuffers::span<const uint8_t> make_bytes_span(
+    const Vector<U> &vec) FLATBUFFERS_NOEXCEPT {
+  static_assert(Vector<U>::scalar_tag::value,
+                "wrong type U, only LE-scalar, or byte types are allowed");
+  return span<const uint8_t>(vec.Data(), vec.size() * sizeof(U));
+}
+
+// Represent a vector much like the template above, but in this case we
+// don't know what the element types are (used with reflection.h).
+class VectorOfAny {
+ public:
+  uoffset_t size() const { return EndianScalar(length_); }
+
+  const uint8_t *Data() const {
+    return reinterpret_cast<const uint8_t *>(&length_ + 1);
+  }
+  uint8_t *Data() { return reinterpret_cast<uint8_t *>(&length_ + 1); }
+
+ protected:
+  VectorOfAny();
+
+  uoffset_t length_;
+
+ private:
+  VectorOfAny(const VectorOfAny &);
+  VectorOfAny &operator=(const VectorOfAny &);
+};
+
+template<typename T, typename U>
+Vector<Offset<T>> *VectorCast(Vector<Offset<U>> *ptr) {
+  static_assert(std::is_base_of<T, U>::value, "Unrelated types");
+  return reinterpret_cast<Vector<Offset<T>> *>(ptr);
+}
+
+template<typename T, typename U>
+const Vector<Offset<T>> *VectorCast(const Vector<Offset<U>> *ptr) {
+  static_assert(std::is_base_of<T, U>::value, "Unrelated types");
+  return reinterpret_cast<const Vector<Offset<T>> *>(ptr);
+}
+
+// Convenient helper function to get the length of any vector, regardless
+// of whether it is null or not (the field is not set).
+template<typename T> static inline size_t VectorLength(const Vector<T> *v) {
+  return v ? v->size() : 0;
+}
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_VERIFIER_H_
diff -urN a/include/flatbuffers/vector_downward.h b/include/flatbuffers/vector_downward.h
--- a/include/flatbuffers/vector_downward.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/vector_downward.h	2023-01-13 07:47:06.301228247 +0000
@@ -0,0 +1,271 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_VECTOR_DOWNWARD_H_
+#define FLATBUFFERS_VECTOR_DOWNWARD_H_
+
+#include "flatbuffers/base.h"
+#include "flatbuffers/default_allocator.h"
+#include "flatbuffers/detached_buffer.h"
+
+namespace flatbuffers {
+
+// This is a minimal replication of std::vector<uint8_t> functionality,
+// except growing from higher to lower addresses. i.e push_back() inserts data
+// in the lowest address in the vector.
+// Since this vector leaves the lower part unused, we support a "scratch-pad"
+// that can be stored there for temporary data, to share the allocated space.
+// Essentially, this supports 2 std::vectors in a single buffer.
+class vector_downward {
+ public:
+  explicit vector_downward(size_t initial_size, Allocator *allocator,
+                           bool own_allocator, size_t buffer_minalign)
+      : allocator_(allocator),
+        own_allocator_(own_allocator),
+        initial_size_(initial_size),
+        buffer_minalign_(buffer_minalign),
+        reserved_(0),
+        size_(0),
+        buf_(nullptr),
+        cur_(nullptr),
+        scratch_(nullptr) {}
+
+  vector_downward(vector_downward &&other)
+      // clang-format on
+      : allocator_(other.allocator_),
+        own_allocator_(other.own_allocator_),
+        initial_size_(other.initial_size_),
+        buffer_minalign_(other.buffer_minalign_),
+        reserved_(other.reserved_),
+        size_(other.size_),
+        buf_(other.buf_),
+        cur_(other.cur_),
+        scratch_(other.scratch_) {
+    // No change in other.allocator_
+    // No change in other.initial_size_
+    // No change in other.buffer_minalign_
+    other.own_allocator_ = false;
+    other.reserved_ = 0;
+    other.buf_ = nullptr;
+    other.cur_ = nullptr;
+    other.scratch_ = nullptr;
+  }
+
+  vector_downward &operator=(vector_downward &&other) {
+    // Move construct a temporary and swap idiom
+    vector_downward temp(std::move(other));
+    swap(temp);
+    return *this;
+  }
+
+  ~vector_downward() {
+    clear_buffer();
+    clear_allocator();
+  }
+
+  void reset() {
+    clear_buffer();
+    clear();
+  }
+
+  void clear() {
+    if (buf_) {
+      cur_ = buf_ + reserved_;
+    } else {
+      reserved_ = 0;
+      cur_ = nullptr;
+    }
+    size_ = 0;
+    clear_scratch();
+  }
+
+  void clear_scratch() { scratch_ = buf_; }
+
+  void clear_allocator() {
+    if (own_allocator_ && allocator_) { delete allocator_; }
+    allocator_ = nullptr;
+    own_allocator_ = false;
+  }
+
+  void clear_buffer() {
+    if (buf_) Deallocate(allocator_, buf_, reserved_);
+    buf_ = nullptr;
+  }
+
+  // Relinquish the pointer to the caller.
+  uint8_t *release_raw(size_t &allocated_bytes, size_t &offset) {
+    auto *buf = buf_;
+    allocated_bytes = reserved_;
+    offset = static_cast<size_t>(cur_ - buf_);
+
+    // release_raw only relinquishes the buffer ownership.
+    // Does not deallocate or reset the allocator. Destructor will do that.
+    buf_ = nullptr;
+    clear();
+    return buf;
+  }
+
+  // Relinquish the pointer to the caller.
+  DetachedBuffer release() {
+    // allocator ownership (if any) is transferred to DetachedBuffer.
+    DetachedBuffer fb(allocator_, own_allocator_, buf_, reserved_, cur_,
+                      size());
+    if (own_allocator_) {
+      allocator_ = nullptr;
+      own_allocator_ = false;
+    }
+    buf_ = nullptr;
+    clear();
+    return fb;
+  }
+
+  size_t ensure_space(size_t len) {
+    FLATBUFFERS_ASSERT(cur_ >= scratch_ && scratch_ >= buf_);
+    if (len > static_cast<size_t>(cur_ - scratch_)) { reallocate(len); }
+    // Beyond this, signed offsets may not have enough range:
+    // (FlatBuffers > 2GB not supported).
+    FLATBUFFERS_ASSERT(size() < FLATBUFFERS_MAX_BUFFER_SIZE);
+    return len;
+  }
+
+  inline uint8_t *make_space(size_t len) {
+    if (len) {
+      ensure_space(len);
+      cur_ -= len;
+      size_ += static_cast<uoffset_t>(len);
+    }
+    return cur_;
+  }
+
+  // Returns nullptr if using the DefaultAllocator.
+  Allocator *get_custom_allocator() { return allocator_; }
+
+  inline uoffset_t size() const { return size_; }
+
+  uoffset_t scratch_size() const {
+    return static_cast<uoffset_t>(scratch_ - buf_);
+  }
+
+  size_t capacity() const { return reserved_; }
+
+  uint8_t *data() const {
+    FLATBUFFERS_ASSERT(cur_);
+    return cur_;
+  }
+
+  uint8_t *scratch_data() const {
+    FLATBUFFERS_ASSERT(buf_);
+    return buf_;
+  }
+
+  uint8_t *scratch_end() const {
+    FLATBUFFERS_ASSERT(scratch_);
+    return scratch_;
+  }
+
+  uint8_t *data_at(size_t offset) const { return buf_ + reserved_ - offset; }
+
+  void push(const uint8_t *bytes, size_t num) {
+    if (num > 0) { memcpy(make_space(num), bytes, num); }
+  }
+
+  // Specialized version of push() that avoids memcpy call for small data.
+  template<typename T> void push_small(const T &little_endian_t) {
+    make_space(sizeof(T));
+    *reinterpret_cast<T *>(cur_) = little_endian_t;
+  }
+
+  template<typename T> void scratch_push_small(const T &t) {
+    ensure_space(sizeof(T));
+    *reinterpret_cast<T *>(scratch_) = t;
+    scratch_ += sizeof(T);
+  }
+
+  // fill() is most frequently called with small byte counts (<= 4),
+  // which is why we're using loops rather than calling memset.
+  void fill(size_t zero_pad_bytes) {
+    make_space(zero_pad_bytes);
+    for (size_t i = 0; i < zero_pad_bytes; i++) cur_[i] = 0;
+  }
+
+  // Version for when we know the size is larger.
+  // Precondition: zero_pad_bytes > 0
+  void fill_big(size_t zero_pad_bytes) {
+    memset(make_space(zero_pad_bytes), 0, zero_pad_bytes);
+  }
+
+  void pop(size_t bytes_to:remove) {
+    cur_ += bytes_to:remove;
+    size_ -= static_cast<uoffset_t>(bytes_to:remove);
+  }
+
+  void scratch_pop(size_t bytes_to:remove) { scratch_ -= bytes_to:remove; }
+
+  void swap(vector_downward &other) {
+    using std::swap;
+    swap(allocator_, other.allocator_);
+    swap(own_allocator_, other.own_allocator_);
+    swap(initial_size_, other.initial_size_);
+    swap(buffer_minalign_, other.buffer_minalign_);
+    swap(reserved_, other.reserved_);
+    swap(size_, other.size_);
+    swap(buf_, other.buf_);
+    swap(cur_, other.cur_);
+    swap(scratch_, other.scratch_);
+  }
+
+  void swap_allocator(vector_downward &other) {
+    using std::swap;
+    swap(allocator_, other.allocator_);
+    swap(own_allocator_, other.own_allocator_);
+  }
+
+ private:
+  // You shouldn't really be copying instances of this class.
+  FLATBUFFERS_DELETE_FUNC(vector_downward(const vector_downward &));
+  FLATBUFFERS_DELETE_FUNC(vector_downward &operator=(const vector_downward &));
+
+  Allocator *allocator_;
+  bool own_allocator_;
+  size_t initial_size_;
+  size_t buffer_minalign_;
+  size_t reserved_;
+  uoffset_t size_;
+  uint8_t *buf_;
+  uint8_t *cur_;  // Points at location between empty (below) and used (above).
+  uint8_t *scratch_;  // Points to the end of the scratchpad in use.
+
+  void reallocate(size_t len) {
+    auto old_reserved = reserved_;
+    auto old_size = size();
+    auto old_scratch_size = scratch_size();
+    reserved_ +=
+        (std::max)(len, old_reserved ? old_reserved / 2 : initial_size_);
+    reserved_ = (reserved_ + buffer_minalign_ - 1) & ~(buffer_minalign_ - 1);
+    if (buf_) {
+      buf_ = ReallocateDownward(allocator_, buf_, old_reserved, reserved_,
+                                old_size, old_scratch_size);
+    } else {
+      buf_ = Allocate(allocator_, reserved_);
+    }
+    cur_ = buf_ + reserved_ - old_size;
+    scratch_ = buf_ + old_scratch_size;
+  }
+};
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_VECTOR_DOWNWARD_H_
diff -urN a/include/flatbuffers/verifier.h b/include/flatbuffers/verifier.h
--- a/include/flatbuffers/verifier.h	1970-01-01 00:00:00.000000000 +0000
+++ b/include/flatbuffers/verifier.h	2023-01-13 07:47:06.301228247 +0000
@@ -0,0 +1,283 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_VERIFIER_H_
+#define FLATBUFFERS_VERIFIER_H_
+
+#include "flatbuffers/base.h"
+#include "flatbuffers/util.h"
+#include "flatbuffers/vector.h"
+
+namespace flatbuffers {
+
+// Helper class to verify the integrity of a FlatBuffer
+class Verifier FLATBUFFERS_FINAL_CLASS {
+ public:
+  Verifier(const uint8_t *buf, size_t buf_len, uoffset_t _max_depth = 64,
+           uoffset_t _max_tables = 1000000, bool _check_alignment = true)
+      : buf_(buf),
+        size_(buf_len),
+        depth_(0),
+        max_depth_(_max_depth),
+        num_tables_(0),
+        max_tables_(_max_tables),
+        upper_bound_(0),
+        check_alignment_(_check_alignment),
+        flex_reuse_tracker_(nullptr) {
+    FLATBUFFERS_ASSERT(size_ < FLATBUFFERS_MAX_BUFFER_SIZE);
+  }
+
+  // Central location where any verification failures register.
+  bool Check(bool ok) const {
+    // clang-format off
+    #ifdef FLATBUFFERS_DEBUG_VERIFICATION_FAILURE
+      FLATBUFFERS_ASSERT(ok);
+    #endif
+    #ifdef FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE
+      if (!ok)
+        upper_bound_ = 0;
+    #endif
+    // clang-format on
+    return ok;
+  }
+
+  // Verify any range within the buffer.
+  bool Verify(size_t elem, size_t elem_len) const {
+    // clang-format off
+    #ifdef FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE
+      auto upper_bound = elem + elem_len;
+      if (upper_bound_ < upper_bound)
+        upper_bound_ =  upper_bound;
+    #endif
+    // clang-format on
+    return Check(elem_len < size_ && elem <= size_ - elem_len);
+  }
+
+  bool VerifyAlignment(size_t elem, size_t align) const {
+    return Check((elem & (align - 1)) == 0 || !check_alignment_);
+  }
+
+  // Verify a range indicated by sizeof(T).
+  template<typename T> bool Verify(size_t elem) const {
+    return VerifyAlignment(elem, sizeof(T)) && Verify(elem, sizeof(T));
+  }
+
+  bool VerifyFromPointer(const uint8_t *p, size_t len) {
+    auto o = static_cast<size_t>(p - buf_);
+    return Verify(o, len);
+  }
+
+  // Verify relative to a known-good base pointer.
+  bool VerifyFieldStruct(const uint8_t *base, voffset_t elem_off,
+                         size_t elem_len, size_t align) const {
+    auto f = static_cast<size_t>(base - buf_) + elem_off;
+    return VerifyAlignment(f, align) && Verify(f, elem_len);
+  }
+
+  template<typename T>
+  bool VerifyField(const uint8_t *base, voffset_t elem_off,
+                   size_t align) const {
+    auto f = static_cast<size_t>(base - buf_) + elem_off;
+    return VerifyAlignment(f, align) && Verify(f, sizeof(T));
+  }
+
+  // Verify a pointer (may be NULL) of a table type.
+  template<typename T> bool VerifyTable(const T *table) {
+    return !table || table->Verify(*this);
+  }
+
+  // Verify a pointer (may be NULL) of any vector type.
+  template<typename T> bool VerifyVector(const Vector<T> *vec) const {
+    return !vec || VerifyVectorOrString(reinterpret_cast<const uint8_t *>(vec),
+                                        sizeof(T));
+  }
+
+  // Verify a pointer (may be NULL) of a vector to struct.
+  template<typename T> bool VerifyVector(const Vector<const T *> *vec) const {
+    return VerifyVector(reinterpret_cast<const Vector<T> *>(vec));
+  }
+
+  // Verify a pointer (may be NULL) to string.
+  bool VerifyString(const String *str) const {
+    size_t end;
+    return !str || (VerifyVectorOrString(reinterpret_cast<const uint8_t *>(str),
+                                         1, &end) &&
+                    Verify(end, 1) &&           // Must have terminator
+                    Check(buf_[end] == '\0'));  // Terminating byte must be 0.
+  }
+
+  // Common code between vectors and strings.
+  bool VerifyVectorOrString(const uint8_t *vec, size_t elem_size,
+                            size_t *end = nullptr) const {
+    auto veco = static_cast<size_t>(vec - buf_);
+    // Check we can read the size field.
+    if (!Verify<uoffset_t>(veco)) return false;
+    // Check the whole array. If this is a string, the byte past the array
+    // must be 0.
+    auto size = ReadScalar<uoffset_t>(vec);
+    auto max_elems = FLATBUFFERS_MAX_BUFFER_SIZE / elem_size;
+    if (!Check(size < max_elems))
+      return false;  // Protect against byte_size overflowing.
+    auto byte_size = sizeof(size) + elem_size * size;
+    if (end) *end = veco + byte_size;
+    return Verify(veco, byte_size);
+  }
+
+  // Special case for string contents, after the above has been called.
+  bool VerifyVectorOfStrings(const Vector<Offset<String>> *vec) const {
+    if (vec) {
+      for (uoffset_t i = 0; i < vec->size(); i++) {
+        if (!VerifyString(vec->Get(i))) return false;
+      }
+    }
+    return true;
+  }
+
+  // Special case for table contents, after the above has been called.
+  template<typename T> bool VerifyVectorOfTables(const Vector<Offset<T>> *vec) {
+    if (vec) {
+      for (uoffset_t i = 0; i < vec->size(); i++) {
+        if (!vec->Get(i)->Verify(*this)) return false;
+      }
+    }
+    return true;
+  }
+
+  __supress_ubsan__("unsigned-integer-overflow") bool VerifyTableStart(
+      const uint8_t *table) {
+    // Check the vtable offset.
+    auto tableo = static_cast<size_t>(table - buf_);
+    if (!Verify<soffset_t>(tableo)) return false;
+    // This offset may be signed, but doing the subtraction unsigned always
+    // gives the result we want.
+    auto vtableo = tableo - static_cast<size_t>(ReadScalar<soffset_t>(table));
+    // Check the vtable size field, then check vtable fits in its entirety.
+    return VerifyComplexity() && Verify<voffset_t>(vtableo) &&
+           VerifyAlignment(ReadScalar<voffset_t>(buf_ + vtableo),
+                           sizeof(voffset_t)) &&
+           Verify(vtableo, ReadScalar<voffset_t>(buf_ + vtableo));
+  }
+
+  template<typename T>
+  bool VerifyBufferFromStart(const char *identifier, size_t start) {
+    if (identifier && !Check((size_ >= 2 * sizeof(flatbuffers::uoffset_t) &&
+                              BufferHasIdentifier(buf_ + start, identifier)))) {
+      return false;
+    }
+
+    // Call T::Verify, which must be in the generated code for this type.
+    auto o = VerifyOffset(start);
+    return o && reinterpret_cast<const T *>(buf_ + start + o)->Verify(*this)
+    // clang-format off
+    #ifdef FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE
+           && GetComputedSize()
+    #endif
+        ;
+    // clang-format on
+  }
+
+  template<typename T>
+  bool VerifyNestedFlatBuffer(const Vector<uint8_t> *buf,
+                              const char *identifier) {
+    if (!buf) return true;
+    Verifier nested_verifier(buf->data(), buf->size());
+    return nested_verifier.VerifyBuffer<T>(identifier);
+  }
+
+  // Verify this whole buffer, starting with root type T.
+  template<typename T> bool VerifyBuffer() { return VerifyBuffer<T>(nullptr); }
+
+  template<typename T> bool VerifyBuffer(const char *identifier) {
+    return VerifyBufferFromStart<T>(identifier, 0);
+  }
+
+  template<typename T> bool VerifySizePrefixedBuffer(const char *identifier) {
+    return Verify<uoffset_t>(0U) &&
+           ReadScalar<uoffset_t>(buf_) == size_ - sizeof(uoffset_t) &&
+           VerifyBufferFromStart<T>(identifier, sizeof(uoffset_t));
+  }
+
+  uoffset_t VerifyOffset(size_t start) const {
+    if (!Verify<uoffset_t>(start)) return 0;
+    auto o = ReadScalar<uoffset_t>(buf_ + start);
+    // May not point to itself.
+    if (!Check(o != 0)) return 0;
+    // Can't wrap around / buffers are max 2GB.
+    if (!Check(static_cast<soffset_t>(o) >= 0)) return 0;
+    // Must be inside the buffer to create a pointer from it (pointer outside
+    // buffer is UB).
+    if (!Verify(start + o, 1)) return 0;
+    return o;
+  }
+
+  uoffset_t VerifyOffset(const uint8_t *base, voffset_t start) const {
+    return VerifyOffset(static_cast<size_t>(base - buf_) + start);
+  }
+
+  // Called at the start of a table to increase counters measuring data
+  // structure depth and amount, and possibly bails out with false if
+  // limits set by the constructor have been hit. Needs to be balanced
+  // with EndTable().
+  bool VerifyComplexity() {
+    depth_++;
+    num_tables_++;
+    return Check(depth_ <= max_depth_ && num_tables_ <= max_tables_);
+  }
+
+  // Called at the end of a table to pop the depth count.
+  bool EndTable() {
+    depth_--;
+    return true;
+  }
+
+  // Returns the message size in bytes
+  size_t GetComputedSize() const {
+    // clang-format off
+    #ifdef FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE
+      uintptr_t size = upper_bound_;
+      // Align the size to uoffset_t
+      size = (size - 1 + sizeof(uoffset_t)) & ~(sizeof(uoffset_t) - 1);
+      return (size > size_) ?  0 : size;
+    #else
+      // Must turn on FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE for this to work.
+      (void)upper_bound_;
+      FLATBUFFERS_ASSERT(false);
+      return 0;
+    #endif
+    // clang-format on
+  }
+
+  std::vector<uint8_t> *GetFlexReuseTracker() { return flex_reuse_tracker_; }
+
+  void SetFlexReuseTracker(std::vector<uint8_t> *rt) {
+    flex_reuse_tracker_ = rt;
+  }
+
+ private:
+  const uint8_t *buf_;
+  size_t size_;
+  uoffset_t depth_;
+  uoffset_t max_depth_;
+  uoffset_t num_tables_;
+  uoffset_t max_tables_;
+  mutable size_t upper_bound_;
+  bool check_alignment_;
+  std::vector<uint8_t> *flex_reuse_tracker_;
+};
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_VERIFIER_H_
diff -urN a/java/com/google/flatbuffers/FlexBuffers.java b/java/com/google/flatbuffers/FlexBuffers.java
--- a/java/com/google/flatbuffers/FlexBuffers.java	2021-05-10 18:45:16.000000000 +0000
+++ b/java/com/google/flatbuffers/FlexBuffers.java	2023-01-13 07:46:54.187116368 +0000
@@ -655,7 +655,7 @@
 
         Sized(ReadBuf buff, int end, int byteWidth) {
             super(buff, end, byteWidth);
-            size = readInt(bb, end - byteWidth, byteWidth);
+            size = (int) readUInt(bb, end - byteWidth, byteWidth);
         }
 
         public int size() {
@@ -788,7 +788,12 @@
                 if (io == other.length) {
                     // in our buffer we have an additional \0 byte
                     // but this does not exist in regular Java strings, so we return now
-                    return c1 - c2;
+                    int cmp = c1 - c2;
+                    if (cmp != 0 || bb.get(ia) == '\0') {
+                        return cmp;
+                    } else {
+                        return 1;
+                    }
                 }
             }
             while (c1 == c2);
@@ -961,7 +966,12 @@
                 if (l2 == other.length) {
                     // in our buffer we have an additional \0 byte
                     // but this does not exist in regular Java strings, so we return now
-                    return c1 - c2;
+                    int cmp = c1 - c2;
+                    if (cmp != 0 || bb.get(l1) == '\0') {
+                        return cmp;
+                    } else {
+                        return 1;
+                    }
                 }
             }
             while (c1 == c2);
diff -urN a/java/com/google/flatbuffers/FlexBuffersBuilder.java b/java/com/google/flatbuffers/FlexBuffersBuilder.java
--- a/java/com/google/flatbuffers/FlexBuffersBuilder.java	2021-05-10 18:45:16.000000000 +0000
+++ b/java/com/google/flatbuffers/FlexBuffersBuilder.java	2023-01-13 07:46:54.202116507 +0000
@@ -452,8 +452,8 @@
      * Finishes a vector, but writing the information in the buffer
      * @param key   key used to store element in map
      * @param start reference for begining of the vector. Returned by {@link startVector()}
-     * @param typed boolean indicating wether vector is typed
-     * @param fixed boolean indicating wether vector is fixed
+     * @param typed boolean indicating whether vector is typed
+     * @param fixed boolean indicating whether vector is fixed
      * @return      Reference to the vector
      */
     public int endVector(String key, int start, boolean typed, boolean fixed) {
@@ -763,7 +763,7 @@
                     // Compute relative offset.
                     long offset = offsetLoc - iValue;
                     // Does it fit?
-                    int bitWidth = widthUInBits((int) offset);
+                    int bitWidth = widthUInBits(offset);
                     if (((1L) << bitWidth) == byteWidth)
                         return bitWidth;
                 }
diff -urN a/java/com/google/flatbuffers/Utf8Safe.java b/java/com/google/flatbuffers/Utf8Safe.java
--- a/java/com/google/flatbuffers/Utf8Safe.java	2021-05-10 18:45:16.000000000 +0000
+++ b/java/com/google/flatbuffers/Utf8Safe.java	2023-01-13 07:46:54.479119065 +0000
@@ -1,33 +1,3 @@
-// Protocol Buffers - Google's data interchange format
-// Copyright 2008 Google Inc.  All rights reserved.
-// https://developers.google.com/protocol-buffers/
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//     * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//     * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//     * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
 package com.google.flatbuffers;
 
 import java.nio.ByteBuffer;
diff -urN a/net/FlatBuffers/FlatBuffers.csproj b/net/FlatBuffers/FlatBuffers.csproj
--- a/net/FlatBuffers/FlatBuffers.csproj	2021-05-10 18:45:16.000000000 +0000
+++ b/net/FlatBuffers/FlatBuffers.csproj	2023-01-13 07:47:06.829233123 +0000
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk" ToolsVersion="12.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
 
   <PropertyGroup>
     <TargetFrameworks>netstandard2.1;netstandard2.0;net46</TargetFrameworks>
diff -urN a/package.json b/package.json
--- a/package.json	2021-05-10 18:45:16.000000000 +0000
+++ b/package.json	2023-01-13 07:47:06.849233307 +0000
@@ -1,16 +1,16 @@
 {
   "name": "flatbuffers",
-  "version": "2.0.0",
+  "version": "2.0.4",
   "description": "Memory Efficient Serialization Library",
   "files": [
-    "js/*.js",
-    "js/*.d.ts",
-    "mjs/*.js",
-    "mjs/*.d.ts",
-    "ts/*.ts"
+    "js/**/*.js",
+    "js/**/*.d.ts",
+    "mjs/**/*.js",
+    "mjs/**/*.d.ts",
+    "ts/**/*.ts"
   ],
   "main": "js/flatbuffers.js",
-  "module": "mjs/index.mjs",
+  "module": "mjs/flatbuffers.js",
   "directories": {
     "doc": "docs",
     "test": "tests"
@@ -18,7 +18,7 @@
   "scripts": {
     "test": "npm run compile && cd tests && ./TypeScriptTest.sh",
     "compile": "tsc && tsc -p tsconfig.mjs.json",
-    "prepublishOnly": "npm run compile"
+    "prepublishOnly": "npm install --only=dev && npm run compile"
   },
   "repository": {
     "type": "git",
diff -urN a/pom.xml b/pom.xml
--- a/pom.xml	2021-05-10 18:45:16.000000000 +0000
+++ b/pom.xml	2023-01-13 07:47:06.874233538 +0000
@@ -3,7 +3,7 @@
   <modelVersion>4.0.0</modelVersion>
   <groupId>com.google.flatbuffers</groupId>
   <artifactId>flatbuffers-java</artifactId>
-  <version>2.0.0</version>
+  <version>2.0.3</version>
   <packaging>bundle</packaging>
   <name>FlatBuffers Java API</name>
   <description>
@@ -42,103 +42,112 @@
   </distributionManagement>
   <build>
     <sourceDirectory>java</sourceDirectory>
-    <plugins>
-      <plugin>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <configuration>
-          <source>1.8</source>
-          <target>1.8</target>
-        </configuration>
-        <version>3.2</version>
-      </plugin>
-      <plugin>
-        <artifactId>maven-surefire-plugin</artifactId>
-        <configuration>
-          <includes>
-            <include>**/*Test.java</include>
-          </includes>
-        </configuration>
-        <version>2.18.1</version>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-source-plugin</artifactId>
-        <version>2.3</version>
-        <executions>
-          <execution>
-            <id>attach-sources</id>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.9.1</version>
-        <configuration>
-          <additionalparam>-Xdoclint:none</additionalparam>
-          <additionalOptions>-Xdoclint:none</additionalOptions>
-        </configuration>
-        <executions>
-          <execution>
-            <id>attach-javadocs</id>
-            <goals>
-              <goal>jar</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.felix</groupId>
-        <artifactId>maven-bundle-plugin</artifactId>
-        <version>3.0.1</version>
-        <extensions>true</extensions>
-      </plugin>
-      <plugin>
-        <groupId>org.sonatype.plugins</groupId>
-        <artifactId>nexus-staging-maven-plugin</artifactId>
-        <version>1.6.7</version>
-        <extensions>true</extensions>
-        <configuration>
-          <serverId>ossrh</serverId>
-          <nexusUrl>https://oss.sonatype.org/</nexusUrl>
-          <autoReleaseAfterClose>true</autoReleaseAfterClose>
-        </configuration>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-gpg-plugin</artifactId>
-        <version>1.6</version>
-        <executions>
-          <execution>
-            <id>sign-artifacts</id>
-            <phase>verify</phase>
-            <goals>
-              <goal>sign</goal>
-            </goals>
+  </build>
+  <profiles>
+    <profile>
+      <id>jdk9</id>
+      <activation>
+        <jdk>[1.9,)</jdk>
+      </activation>
+      <build>
+        <plugins>
+          <plugin>
+            <artifactId>maven-compiler-plugin</artifactId>
             <configuration>
-                <gpgArguments>
-                    <arg>--pinentry-mode</arg>
-                    <arg>loopback</arg>
-                </gpgArguments>
+              <release>8</release>
             </configuration>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-release-plugin</artifactId>
-        <version>2.5.3</version>
-        <configuration>
-          <autoVersionSubmodules>true</autoVersionSubmodules>
-          <useReleaseProfile>false</useReleaseProfile>
-          <releaseProfiles>release</releaseProfiles>
-          <goals>deploy</goals>
-        </configuration>
-      </plugin>
-    </plugins>
-  </build>
+            <version>3.8.1</version>
+          </plugin>
+          <plugin>
+            <artifactId>maven-surefire-plugin</artifactId>
+            <configuration>
+              <includes>
+                <include>**/*Test.java</include>
+              </includes>
+            </configuration>
+            <version>2.22.2</version>
+          </plugin>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-source-plugin</artifactId>
+            <version>3.2.1</version>
+            <executions>
+              <execution>
+                <id>attach-sources</id>
+                <goals>
+                  <goal>jar</goal>
+                </goals>
+              </execution>
+            </executions>
+          </plugin>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-javadoc-plugin</artifactId>
+            <version>3.3.0</version>
+            <configuration>
+              <additionalparam>-Xdoclint:none</additionalparam>
+              <additionalOptions>-Xdoclint:none</additionalOptions>
+            </configuration>
+            <executions>
+              <execution>
+                <id>attach-javadocs</id>
+                <goals>
+                  <goal>jar</goal>
+                </goals>
+              </execution>
+            </executions>
+          </plugin>
+          <plugin>
+            <groupId>org.apache.felix</groupId>
+            <artifactId>maven-bundle-plugin</artifactId>
+            <version>5.1.2</version>
+            <extensions>true</extensions>
+          </plugin>
+          <plugin>
+            <groupId>org.sonatype.plugins</groupId>
+            <artifactId>nexus-staging-maven-plugin</artifactId>
+            <version>1.6.8</version>
+            <extensions>true</extensions>
+            <configuration>
+              <serverId>ossrh</serverId>
+              <nexusUrl>https://oss.sonatype.org/</nexusUrl>
+              <autoReleaseAfterClose>true</autoReleaseAfterClose>
+            </configuration>
+          </plugin>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-gpg-plugin</artifactId>
+            <version>3.0.1</version>
+            <executions>
+              <execution>
+                <id>sign-artifacts</id>
+                <phase>verify</phase>
+                <goals>
+                  <goal>sign</goal>
+                </goals>
+                <configuration>
+                    <gpgArguments>
+                        <arg>--pinentry-mode</arg>
+                        <arg>loopback</arg>
+                    </gpgArguments>
+                </configuration>
+              </execution>
+            </executions>
+          </plugin>
+          <plugin>
+            <groupId>org.apache.maven.plugins</groupId>
+            <artifactId>maven-release-plugin</artifactId>
+            <version>2.5.3</version>
+            <configuration>
+              <autoVersionSubmodules>true</autoVersionSubmodules>
+              <useReleaseProfile>false</useReleaseProfile>
+              <releaseProfiles>release</releaseProfiles>
+              <goals>deploy</goals>
+            </configuration>
+          </plugin>
+        </plugins>
+      </build>
+    </profile>
+  </profiles>
 </project>
 
diff -urN a/python/flatbuffers/compat.py b/python/flatbuffers/compat.py
--- a/python/flatbuffers/compat.py	2021-05-10 18:45:16.000000000 +0000
+++ b/python/flatbuffers/compat.py	2023-01-13 07:47:06.877233566 +0000
@@ -16,7 +16,6 @@
  compatibility helpers for numpy. """
 
 import sys
-import imp
 
 PY2 = sys.version_info[0] == 2
 PY26 = sys.version_info[0:2] == (2, 6)
@@ -26,12 +25,14 @@
 PY34 = sys.version_info[0:2] >= (3, 4)
 
 if PY3:
+    import importlib.machinery
     string_types = (str,)
     binary_types = (bytes,bytearray)
     range_func = range
     memoryview_type = memoryview
     struct_bool_decl = "?"
 else:
+    import imp
     string_types = (unicode,)
     if PY26 or PY27:
         binary_types = (str,bytearray)
@@ -52,11 +53,15 @@
     Returns the numpy module if it exists on the system,
     otherwise returns None.
     """
-    try:
-        imp.find_module('numpy')
-        numpy_exists = True
-    except ImportError:
-        numpy_exists = False
+    if PY3:
+        numpy_exists = (
+            importlib.machinery.PathFinder.find_spec('numpy') is not None)
+    else:
+        try:
+            imp.find_module('numpy')
+            numpy_exists = True
+        except ImportError:
+            numpy_exists = False
 
     if numpy_exists:
         # We do this outside of try/except block in case numpy exists
diff -urN a/python/flatbuffers/reflection/AdvancedFeatures.py b/python/flatbuffers/reflection/AdvancedFeatures.py
--- a/python/flatbuffers/reflection/AdvancedFeatures.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/AdvancedFeatures.py	2023-01-13 07:47:07.464238988 +0000
@@ -0,0 +1,10 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+# New schema language features that are not supported by old code generators.
+class AdvancedFeatures(object):
+    AdvancedArrayFeatures = 1
+    AdvancedUnionFeatures = 2
+    OptionalScalars = 4
+    DefaultVectorsAndStrings = 8
diff -urN a/python/flatbuffers/reflection/BaseType.py b/python/flatbuffers/reflection/BaseType.py
--- a/python/flatbuffers/reflection/BaseType.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/BaseType.py	2023-01-13 07:47:07.467239015 +0000
@@ -0,0 +1,24 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+class BaseType(object):
+    None_ = 0
+    UType = 1
+    Bool = 2
+    Byte = 3
+    UByte = 4
+    Short = 5
+    UShort = 6
+    Int = 7
+    UInt = 8
+    Long = 9
+    ULong = 10
+    Float = 11
+    Double = 12
+    String = 13
+    Vector = 14
+    Obj = 15
+    Union = 16
+    Array = 17
+    MaxBaseType = 18
diff -urN a/python/flatbuffers/reflection/Enum.py b/python/flatbuffers/reflection/Enum.py
--- a/python/flatbuffers/reflection/Enum.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/Enum.py	2023-01-13 07:47:07.469239034 +0000
@@ -0,0 +1,169 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class Enum(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = Enum()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsEnum(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def EnumBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # Enum
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # Enum
+    def Name(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # Enum
+    def Values(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.EnumVal import EnumVal
+            obj = EnumVal()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Enum
+    def ValuesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Enum
+    def ValuesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        return o == 0
+
+    # Enum
+    def IsUnion(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        if o != 0:
+            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
+        return False
+
+    # Enum
+    def UnderlyingType(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            x = self._tab.Indirect(o + self._tab.Pos)
+            from reflection.Type import Type
+            obj = Type()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Enum
+    def Attributes(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.KeyValue import KeyValue
+            obj = KeyValue()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Enum
+    def AttributesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Enum
+    def AttributesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        return o == 0
+
+    # Enum
+    def Documentation(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        if o != 0:
+            a = self._tab.Vector(o)
+            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
+        return ""
+
+    # Enum
+    def DocumentationLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Enum
+    def DocumentationIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        return o == 0
+
+    # File that this Enum is declared in.
+    # Enum
+    def DeclarationFile(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+def EnumStart(builder): builder.StartObject(7)
+def Start(builder):
+    return EnumStart(builder)
+def EnumAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
+def AddName(builder, name):
+    return EnumAddName(builder, name)
+def EnumAddValues(builder, values): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(values), 0)
+def AddValues(builder, values):
+    return EnumAddValues(builder, values)
+def EnumStartValuesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartValuesVector(builder, numElems):
+    return EnumStartValuesVector(builder, numElems)
+def EnumAddIsUnion(builder, isUnion): builder.PrependBoolSlot(2, isUnion, 0)
+def AddIsUnion(builder, isUnion):
+    return EnumAddIsUnion(builder, isUnion)
+def EnumAddUnderlyingType(builder, underlyingType): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(underlyingType), 0)
+def AddUnderlyingType(builder, underlyingType):
+    return EnumAddUnderlyingType(builder, underlyingType)
+def EnumAddAttributes(builder, attributes): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(attributes), 0)
+def AddAttributes(builder, attributes):
+    return EnumAddAttributes(builder, attributes)
+def EnumStartAttributesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartAttributesVector(builder, numElems):
+    return EnumStartAttributesVector(builder, numElems)
+def EnumAddDocumentation(builder, documentation): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(documentation), 0)
+def AddDocumentation(builder, documentation):
+    return EnumAddDocumentation(builder, documentation)
+def EnumStartDocumentationVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartDocumentationVector(builder, numElems):
+    return EnumStartDocumentationVector(builder, numElems)
+def EnumAddDeclarationFile(builder, declarationFile): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(declarationFile), 0)
+def AddDeclarationFile(builder, declarationFile):
+    return EnumAddDeclarationFile(builder, declarationFile)
+def EnumEnd(builder): return builder.EndObject()
+def End(builder):
+    return EnumEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/EnumVal.py b/python/flatbuffers/reflection/EnumVal.py
--- a/python/flatbuffers/reflection/EnumVal.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/EnumVal.py	2023-01-13 07:47:07.469239034 +0000
@@ -0,0 +1,96 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class EnumVal(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = EnumVal()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsEnumVal(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def EnumValBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # EnumVal
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # EnumVal
+    def Name(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # EnumVal
+    def Value(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
+        return 0
+
+    # EnumVal
+    def UnionType(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            x = self._tab.Indirect(o + self._tab.Pos)
+            from reflection.Type import Type
+            obj = Type()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # EnumVal
+    def Documentation(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            a = self._tab.Vector(o)
+            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
+        return ""
+
+    # EnumVal
+    def DocumentationLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # EnumVal
+    def DocumentationIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        return o == 0
+
+def EnumValStart(builder): builder.StartObject(5)
+def Start(builder):
+    return EnumValStart(builder)
+def EnumValAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
+def AddName(builder, name):
+    return EnumValAddName(builder, name)
+def EnumValAddValue(builder, value): builder.PrependInt64Slot(1, value, 0)
+def AddValue(builder, value):
+    return EnumValAddValue(builder, value)
+def EnumValAddUnionType(builder, unionType): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(unionType), 0)
+def AddUnionType(builder, unionType):
+    return EnumValAddUnionType(builder, unionType)
+def EnumValAddDocumentation(builder, documentation): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(documentation), 0)
+def AddDocumentation(builder, documentation):
+    return EnumValAddDocumentation(builder, documentation)
+def EnumValStartDocumentationVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartDocumentationVector(builder, numElems):
+    return EnumValStartDocumentationVector(builder, numElems)
+def EnumValEnd(builder): return builder.EndObject()
+def End(builder):
+    return EnumValEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/Field.py b/python/flatbuffers/reflection/Field.py
--- a/python/flatbuffers/reflection/Field.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/Field.py	2023-01-13 07:47:07.470239043 +0000
@@ -0,0 +1,208 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class Field(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = Field()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsField(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def FieldBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # Field
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # Field
+    def Name(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # Field
+    def Type(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            x = self._tab.Indirect(o + self._tab.Pos)
+            from reflection.Type import Type
+            obj = Type()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Field
+    def Id(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
+        return 0
+
+    # Field
+    def Offset(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
+        return 0
+
+    # Field
+    def DefaultInteger(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
+        return 0
+
+    # Field
+    def DefaultReal(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
+        return 0.0
+
+    # Field
+    def Deprecated(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
+        if o != 0:
+            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
+        return False
+
+    # Field
+    def Required(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
+        if o != 0:
+            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
+        return False
+
+    # Field
+    def Key(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
+        if o != 0:
+            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
+        return False
+
+    # Field
+    def Attributes(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.KeyValue import KeyValue
+            obj = KeyValue()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Field
+    def AttributesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Field
+    def AttributesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
+        return o == 0
+
+    # Field
+    def Documentation(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
+        if o != 0:
+            a = self._tab.Vector(o)
+            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
+        return ""
+
+    # Field
+    def DocumentationLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Field
+    def DocumentationIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
+        return o == 0
+
+    # Field
+    def Optional(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
+        if o != 0:
+            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
+        return False
+
+    # Number of padding octets to always add after this field. Structs only.
+    # Field
+    def Padding(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
+        return 0
+
+def FieldStart(builder): builder.StartObject(13)
+def Start(builder):
+    return FieldStart(builder)
+def FieldAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
+def AddName(builder, name):
+    return FieldAddName(builder, name)
+def FieldAddType(builder, type): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)
+def AddType(builder, type):
+    return FieldAddType(builder, type)
+def FieldAddId(builder, id): builder.PrependUint16Slot(2, id, 0)
+def AddId(builder, id):
+    return FieldAddId(builder, id)
+def FieldAddOffset(builder, offset): builder.PrependUint16Slot(3, offset, 0)
+def AddOffset(builder, offset):
+    return FieldAddOffset(builder, offset)
+def FieldAddDefaultInteger(builder, defaultInteger): builder.PrependInt64Slot(4, defaultInteger, 0)
+def AddDefaultInteger(builder, defaultInteger):
+    return FieldAddDefaultInteger(builder, defaultInteger)
+def FieldAddDefaultReal(builder, defaultReal): builder.PrependFloat64Slot(5, defaultReal, 0.0)
+def AddDefaultReal(builder, defaultReal):
+    return FieldAddDefaultReal(builder, defaultReal)
+def FieldAddDeprecated(builder, deprecated): builder.PrependBoolSlot(6, deprecated, 0)
+def AddDeprecated(builder, deprecated):
+    return FieldAddDeprecated(builder, deprecated)
+def FieldAddRequired(builder, required): builder.PrependBoolSlot(7, required, 0)
+def AddRequired(builder, required):
+    return FieldAddRequired(builder, required)
+def FieldAddKey(builder, key): builder.PrependBoolSlot(8, key, 0)
+def AddKey(builder, key):
+    return FieldAddKey(builder, key)
+def FieldAddAttributes(builder, attributes): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(attributes), 0)
+def AddAttributes(builder, attributes):
+    return FieldAddAttributes(builder, attributes)
+def FieldStartAttributesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartAttributesVector(builder, numElems):
+    return FieldStartAttributesVector(builder, numElems)
+def FieldAddDocumentation(builder, documentation): builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(documentation), 0)
+def AddDocumentation(builder, documentation):
+    return FieldAddDocumentation(builder, documentation)
+def FieldStartDocumentationVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartDocumentationVector(builder, numElems):
+    return FieldStartDocumentationVector(builder, numElems)
+def FieldAddOptional(builder, optional): builder.PrependBoolSlot(11, optional, 0)
+def AddOptional(builder, optional):
+    return FieldAddOptional(builder, optional)
+def FieldAddPadding(builder, padding): builder.PrependUint16Slot(12, padding, 0)
+def AddPadding(builder, padding):
+    return FieldAddPadding(builder, padding)
+def FieldEnd(builder): return builder.EndObject()
+def End(builder):
+    return FieldEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/KeyValue.py b/python/flatbuffers/reflection/KeyValue.py
--- a/python/flatbuffers/reflection/KeyValue.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/KeyValue.py	2023-01-13 07:47:07.470239043 +0000
@@ -0,0 +1,56 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class KeyValue(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = KeyValue()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsKeyValue(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def KeyValueBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # KeyValue
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # KeyValue
+    def Key(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # KeyValue
+    def Value(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+def KeyValueStart(builder): builder.StartObject(2)
+def Start(builder):
+    return KeyValueStart(builder)
+def KeyValueAddKey(builder, key): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(key), 0)
+def AddKey(builder, key):
+    return KeyValueAddKey(builder, key)
+def KeyValueAddValue(builder, value): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(value), 0)
+def AddValue(builder, value):
+    return KeyValueAddValue(builder, value)
+def KeyValueEnd(builder): return builder.EndObject()
+def End(builder):
+    return KeyValueEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/Object.py b/python/flatbuffers/reflection/Object.py
--- a/python/flatbuffers/reflection/Object.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/Object.py	2023-01-13 07:47:07.470239043 +0000
@@ -0,0 +1,175 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class Object(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = Object()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsObject(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def ObjectBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # Object
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # Object
+    def Name(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # Object
+    def Fields(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.Field import Field
+            obj = Field()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Object
+    def FieldsLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Object
+    def FieldsIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        return o == 0
+
+    # Object
+    def IsStruct(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        if o != 0:
+            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
+        return False
+
+    # Object
+    def Minalign(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
+        return 0
+
+    # Object
+    def Bytesize(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
+        return 0
+
+    # Object
+    def Attributes(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.KeyValue import KeyValue
+            obj = KeyValue()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Object
+    def AttributesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Object
+    def AttributesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        return o == 0
+
+    # Object
+    def Documentation(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
+        if o != 0:
+            a = self._tab.Vector(o)
+            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
+        return ""
+
+    # Object
+    def DocumentationLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Object
+    def DocumentationIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
+        return o == 0
+
+    # File that this Object is declared in.
+    # Object
+    def DeclarationFile(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+def ObjectStart(builder): builder.StartObject(8)
+def Start(builder):
+    return ObjectStart(builder)
+def ObjectAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
+def AddName(builder, name):
+    return ObjectAddName(builder, name)
+def ObjectAddFields(builder, fields): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(fields), 0)
+def AddFields(builder, fields):
+    return ObjectAddFields(builder, fields)
+def ObjectStartFieldsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartFieldsVector(builder, numElems):
+    return ObjectStartFieldsVector(builder, numElems)
+def ObjectAddIsStruct(builder, isStruct): builder.PrependBoolSlot(2, isStruct, 0)
+def AddIsStruct(builder, isStruct):
+    return ObjectAddIsStruct(builder, isStruct)
+def ObjectAddMinalign(builder, minalign): builder.PrependInt32Slot(3, minalign, 0)
+def AddMinalign(builder, minalign):
+    return ObjectAddMinalign(builder, minalign)
+def ObjectAddBytesize(builder, bytesize): builder.PrependInt32Slot(4, bytesize, 0)
+def AddBytesize(builder, bytesize):
+    return ObjectAddBytesize(builder, bytesize)
+def ObjectAddAttributes(builder, attributes): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(attributes), 0)
+def AddAttributes(builder, attributes):
+    return ObjectAddAttributes(builder, attributes)
+def ObjectStartAttributesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartAttributesVector(builder, numElems):
+    return ObjectStartAttributesVector(builder, numElems)
+def ObjectAddDocumentation(builder, documentation): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(documentation), 0)
+def AddDocumentation(builder, documentation):
+    return ObjectAddDocumentation(builder, documentation)
+def ObjectStartDocumentationVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartDocumentationVector(builder, numElems):
+    return ObjectStartDocumentationVector(builder, numElems)
+def ObjectAddDeclarationFile(builder, declarationFile): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(declarationFile), 0)
+def AddDeclarationFile(builder, declarationFile):
+    return ObjectAddDeclarationFile(builder, declarationFile)
+def ObjectEnd(builder): return builder.EndObject()
+def End(builder):
+    return ObjectEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/RPCCall.py b/python/flatbuffers/reflection/RPCCall.py
--- a/python/flatbuffers/reflection/RPCCall.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/RPCCall.py	2023-01-13 07:47:07.471239052 +0000
@@ -0,0 +1,131 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class RPCCall(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = RPCCall()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsRPCCall(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def RPCCallBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # RPCCall
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # RPCCall
+    def Name(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # RPCCall
+    def Request(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            x = self._tab.Indirect(o + self._tab.Pos)
+            from reflection.Object import Object
+            obj = Object()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # RPCCall
+    def Response(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        if o != 0:
+            x = self._tab.Indirect(o + self._tab.Pos)
+            from reflection.Object import Object
+            obj = Object()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # RPCCall
+    def Attributes(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.KeyValue import KeyValue
+            obj = KeyValue()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # RPCCall
+    def AttributesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # RPCCall
+    def AttributesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        return o == 0
+
+    # RPCCall
+    def Documentation(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            a = self._tab.Vector(o)
+            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
+        return ""
+
+    # RPCCall
+    def DocumentationLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # RPCCall
+    def DocumentationIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        return o == 0
+
+def RPCCallStart(builder): builder.StartObject(5)
+def Start(builder):
+    return RPCCallStart(builder)
+def RPCCallAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
+def AddName(builder, name):
+    return RPCCallAddName(builder, name)
+def RPCCallAddRequest(builder, request): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(request), 0)
+def AddRequest(builder, request):
+    return RPCCallAddRequest(builder, request)
+def RPCCallAddResponse(builder, response): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(response), 0)
+def AddResponse(builder, response):
+    return RPCCallAddResponse(builder, response)
+def RPCCallAddAttributes(builder, attributes): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(attributes), 0)
+def AddAttributes(builder, attributes):
+    return RPCCallAddAttributes(builder, attributes)
+def RPCCallStartAttributesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartAttributesVector(builder, numElems):
+    return RPCCallStartAttributesVector(builder, numElems)
+def RPCCallAddDocumentation(builder, documentation): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(documentation), 0)
+def AddDocumentation(builder, documentation):
+    return RPCCallAddDocumentation(builder, documentation)
+def RPCCallStartDocumentationVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartDocumentationVector(builder, numElems):
+    return RPCCallStartDocumentationVector(builder, numElems)
+def RPCCallEnd(builder): return builder.EndObject()
+def End(builder):
+    return RPCCallEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/Schema.py b/python/flatbuffers/reflection/Schema.py
--- a/python/flatbuffers/reflection/Schema.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/Schema.py	2023-01-13 07:47:07.471239052 +0000
@@ -0,0 +1,206 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class Schema(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = Schema()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsSchema(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def SchemaBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # Schema
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # Schema
+    def Objects(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.Object import Object
+            obj = Object()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Schema
+    def ObjectsLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Schema
+    def ObjectsIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        return o == 0
+
+    # Schema
+    def Enums(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.Enum import Enum
+            obj = Enum()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Schema
+    def EnumsLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Schema
+    def EnumsIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        return o == 0
+
+    # Schema
+    def FileIdent(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # Schema
+    def FileExt(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # Schema
+    def RootTable(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            x = self._tab.Indirect(o + self._tab.Pos)
+            from reflection.Object import Object
+            obj = Object()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Schema
+    def Services(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.Service import Service
+            obj = Service()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Schema
+    def ServicesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Schema
+    def ServicesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        return o == 0
+
+    # Schema
+    def AdvancedFeatures(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
+        return 0
+
+    # All the files used in this compilation. Files are relative to where
+    # flatc was invoked.
+    # Schema
+    def FbsFiles(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.SchemaFile import SchemaFile
+            obj = SchemaFile()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Schema
+    def FbsFilesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Schema
+    def FbsFilesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
+        return o == 0
+
+def SchemaStart(builder): builder.StartObject(8)
+def Start(builder):
+    return SchemaStart(builder)
+def SchemaAddObjects(builder, objects): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(objects), 0)
+def AddObjects(builder, objects):
+    return SchemaAddObjects(builder, objects)
+def SchemaStartObjectsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartObjectsVector(builder, numElems):
+    return SchemaStartObjectsVector(builder, numElems)
+def SchemaAddEnums(builder, enums): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(enums), 0)
+def AddEnums(builder, enums):
+    return SchemaAddEnums(builder, enums)
+def SchemaStartEnumsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartEnumsVector(builder, numElems):
+    return SchemaStartEnumsVector(builder, numElems)
+def SchemaAddFileIdent(builder, fileIdent): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(fileIdent), 0)
+def AddFileIdent(builder, fileIdent):
+    return SchemaAddFileIdent(builder, fileIdent)
+def SchemaAddFileExt(builder, fileExt): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(fileExt), 0)
+def AddFileExt(builder, fileExt):
+    return SchemaAddFileExt(builder, fileExt)
+def SchemaAddRootTable(builder, rootTable): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(rootTable), 0)
+def AddRootTable(builder, rootTable):
+    return SchemaAddRootTable(builder, rootTable)
+def SchemaAddServices(builder, services): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(services), 0)
+def AddServices(builder, services):
+    return SchemaAddServices(builder, services)
+def SchemaStartServicesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartServicesVector(builder, numElems):
+    return SchemaStartServicesVector(builder, numElems)
+def SchemaAddAdvancedFeatures(builder, advancedFeatures): builder.PrependUint64Slot(6, advancedFeatures, 0)
+def AddAdvancedFeatures(builder, advancedFeatures):
+    return SchemaAddAdvancedFeatures(builder, advancedFeatures)
+def SchemaAddFbsFiles(builder, fbsFiles): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(fbsFiles), 0)
+def AddFbsFiles(builder, fbsFiles):
+    return SchemaAddFbsFiles(builder, fbsFiles)
+def SchemaStartFbsFilesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartFbsFilesVector(builder, numElems):
+    return SchemaStartFbsFilesVector(builder, numElems)
+def SchemaEnd(builder): return builder.EndObject()
+def End(builder):
+    return SchemaEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/SchemaFile.py b/python/flatbuffers/reflection/SchemaFile.py
--- a/python/flatbuffers/reflection/SchemaFile.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/SchemaFile.py	2023-01-13 07:47:07.472239062 +0000
@@ -0,0 +1,77 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+# File specific information.
+# Symbols declared within a file may be recovered by iterating over all
+# symbols and examining the `declaration_file` field.
+class SchemaFile(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = SchemaFile()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsSchemaFile(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def SchemaFileBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # SchemaFile
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # Filename, relative to project root.
+    # SchemaFile
+    def Filename(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # Names of included files, relative to project root.
+    # SchemaFile
+    def IncludedFilenames(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            a = self._tab.Vector(o)
+            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
+        return ""
+
+    # SchemaFile
+    def IncludedFilenamesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # SchemaFile
+    def IncludedFilenamesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        return o == 0
+
+def SchemaFileStart(builder): builder.StartObject(2)
+def Start(builder):
+    return SchemaFileStart(builder)
+def SchemaFileAddFilename(builder, filename): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(filename), 0)
+def AddFilename(builder, filename):
+    return SchemaFileAddFilename(builder, filename)
+def SchemaFileAddIncludedFilenames(builder, includedFilenames): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(includedFilenames), 0)
+def AddIncludedFilenames(builder, includedFilenames):
+    return SchemaFileAddIncludedFilenames(builder, includedFilenames)
+def SchemaFileStartIncludedFilenamesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartIncludedFilenamesVector(builder, numElems):
+    return SchemaFileStartIncludedFilenamesVector(builder, numElems)
+def SchemaFileEnd(builder): return builder.EndObject()
+def End(builder):
+    return SchemaFileEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/Service.py b/python/flatbuffers/reflection/Service.py
--- a/python/flatbuffers/reflection/Service.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/Service.py	2023-01-13 07:47:07.472239062 +0000
@@ -0,0 +1,145 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class Service(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = Service()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsService(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def ServiceBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # Service
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # Service
+    def Name(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+    # Service
+    def Calls(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.RPCCall import RPCCall
+            obj = RPCCall()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Service
+    def CallsLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Service
+    def CallsIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        return o == 0
+
+    # Service
+    def Attributes(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        if o != 0:
+            x = self._tab.Vector(o)
+            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
+            x = self._tab.Indirect(x)
+            from reflection.KeyValue import KeyValue
+            obj = KeyValue()
+            obj.Init(self._tab.Bytes, x)
+            return obj
+        return None
+
+    # Service
+    def AttributesLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Service
+    def AttributesIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        return o == 0
+
+    # Service
+    def Documentation(self, j):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            a = self._tab.Vector(o)
+            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
+        return ""
+
+    # Service
+    def DocumentationLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            return self._tab.VectorLen(o)
+        return 0
+
+    # Service
+    def DocumentationIsNone(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        return o == 0
+
+    # File that this Service is declared in.
+    # Service
+    def DeclarationFile(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            return self._tab.String(o + self._tab.Pos)
+        return None
+
+def ServiceStart(builder): builder.StartObject(5)
+def Start(builder):
+    return ServiceStart(builder)
+def ServiceAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
+def AddName(builder, name):
+    return ServiceAddName(builder, name)
+def ServiceAddCalls(builder, calls): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(calls), 0)
+def AddCalls(builder, calls):
+    return ServiceAddCalls(builder, calls)
+def ServiceStartCallsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartCallsVector(builder, numElems):
+    return ServiceStartCallsVector(builder, numElems)
+def ServiceAddAttributes(builder, attributes): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(attributes), 0)
+def AddAttributes(builder, attributes):
+    return ServiceAddAttributes(builder, attributes)
+def ServiceStartAttributesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartAttributesVector(builder, numElems):
+    return ServiceStartAttributesVector(builder, numElems)
+def ServiceAddDocumentation(builder, documentation): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(documentation), 0)
+def AddDocumentation(builder, documentation):
+    return ServiceAddDocumentation(builder, documentation)
+def ServiceStartDocumentationVector(builder, numElems): return builder.StartVector(4, numElems, 4)
+def StartDocumentationVector(builder, numElems):
+    return ServiceStartDocumentationVector(builder, numElems)
+def ServiceAddDeclarationFile(builder, declarationFile): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(declarationFile), 0)
+def AddDeclarationFile(builder, declarationFile):
+    return ServiceAddDeclarationFile(builder, declarationFile)
+def ServiceEnd(builder): return builder.EndObject()
+def End(builder):
+    return ServiceEnd(builder)
\ No newline at end of file
diff -urN a/python/flatbuffers/reflection/Type.py b/python/flatbuffers/reflection/Type.py
--- a/python/flatbuffers/reflection/Type.py	1970-01-01 00:00:00.000000000 +0000
+++ b/python/flatbuffers/reflection/Type.py	2023-01-13 07:47:07.472239062 +0000
@@ -0,0 +1,98 @@
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: reflection
+
+import flatbuffers
+from flatbuffers.compat import import_numpy
+np = import_numpy()
+
+class Type(object):
+    __slots__ = ['_tab']
+
+    @classmethod
+    def GetRootAs(cls, buf, offset=0):
+        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+        x = Type()
+        x.Init(buf, n + offset)
+        return x
+
+    @classmethod
+    def GetRootAsType(cls, buf, offset=0):
+        """This method is deprecated. Please switch to GetRootAs."""
+        return cls.GetRootAs(buf, offset)
+    @classmethod
+    def TypeBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
+        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x42\x46\x42\x53", size_prefixed=size_prefixed)
+
+    # Type
+    def Init(self, buf, pos):
+        self._tab = flatbuffers.table.Table(buf, pos)
+
+    # Type
+    def BaseType(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
+        return 0
+
+    # Type
+    def Element(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
+        return 0
+
+    # Type
+    def Index(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
+        return -1
+
+    # Type
+    def FixedLength(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
+        return 0
+
+    # The size (octets) of the `base_type` field.
+    # Type
+    def BaseSize(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
+        return 4
+
+    # The size (octets) of the `element` field, if present.
+    # Type
+    def ElementSize(self):
+        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
+        if o != 0:
+            return self._tab.Get(flatbuffers.number_types.Uint32Flags, o + self._tab.Pos)
+        return 0
+
+def TypeStart(builder): builder.StartObject(6)
+def Start(builder):
+    return TypeStart(builder)
+def TypeAddBaseType(builder, baseType): builder.PrependInt8Slot(0, baseType, 0)
+def AddBaseType(builder, baseType):
+    return TypeAddBaseType(builder, baseType)
+def TypeAddElement(builder, element): builder.PrependInt8Slot(1, element, 0)
+def AddElement(builder, element):
+    return TypeAddElement(builder, element)
+def TypeAddIndex(builder, index): builder.PrependInt32Slot(2, index, -1)
+def AddIndex(builder, index):
+    return TypeAddIndex(builder, index)
+def TypeAddFixedLength(builder, fixedLength): builder.PrependUint16Slot(3, fixedLength, 0)
+def AddFixedLength(builder, fixedLength):
+    return TypeAddFixedLength(builder, fixedLength)
+def TypeAddBaseSize(builder, baseSize): builder.PrependUint32Slot(4, baseSize, 4)
+def AddBaseSize(builder, baseSize):
+    return TypeAddBaseSize(builder, baseSize)
+def TypeAddElementSize(builder, elementSize): builder.PrependUint32Slot(5, elementSize, 0)
+def AddElementSize(builder, elementSize):
+    return TypeAddElementSize(builder, elementSize)
+def TypeEnd(builder): return builder.EndObject()
+def End(builder):
+    return TypeEnd(builder)
\ No newline at end of file
diff -urN a/readme.md b/readme.md
--- a/readme.md	2021-05-10 18:45:16.000000000 +0000
+++ b/readme.md	2023-01-13 07:47:07.473239071 +0000
@@ -1,11 +1,11 @@
 ![logo](http://google.github.io/flatbuffers/fpl_logo_small.png) FlatBuffers
 ===========
 
-[![Build Status](https://travis-ci.org/google/flatbuffers.svg?branch=master)](https://travis-ci.org/google/flatbuffers)
-[![Build status](https://ci.appveyor.com/api/projects/status/yg5idd2fnusv1n10?svg=true)](https://ci.appveyor.com/project/gwvo/flatbuffers)
+![Build status](https://github.com/google/flatbuffers/actions/workflows/build.yml/badge.svg?branch=master)
 [![Join the chat at https://gitter.im/google/flatbuffers](https://badges.gitter.im/google/flatbuffers.svg)](https://gitter.im/google/flatbuffers?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 [![Discord Chat](https://img.shields.io/discord/656202785926152206.svg)](https:///discord.gg/6qgKs3R)
 [![Twitter Follow](https://img.shields.io/twitter/follow/wvo.svg?style=social)](https://twitter.com/wvo)
+[![Twitter Follow](https://img.shields.io/twitter/follow/dbaileychess.svg?style=social)](https://twitter.com/dbaileychess)
 
 
 **FlatBuffers** is a cross platform serialization library architected for
@@ -44,6 +44,10 @@
 
 *To contribute to this project,* see [CONTRIBUTING][].
 
+## Security
+
+Please see our [Security Policy](SECURITY.md) for reporting vulnerabilities.
+
 ## Licensing
 *Flatbuffers* is licensed under the Apache License, Version 2.0. See [LICENSE][] for the full license text.
 
diff -urN a/reflection/generate_code.bat b/reflection/generate_code.bat
--- a/reflection/generate_code.bat	2021-05-10 18:45:16.000000000 +0000
+++ b/reflection/generate_code.bat	1970-01-01 00:00:00.000000000 +0000
@@ -1,18 +0,0 @@
-:: Copyright 2015 Google Inc. All rights reserved.
-::
-:: Licensed under the Apache License, Version 2.0 (the "License");
-:: you may not use this file except in compliance with the License.
-:: You may obtain a copy of the License at
-::
-::     http://www.apache.org/licenses/LICENSE-2.0
-::
-:: Unless required by applicable law or agreed to in writing, software
-:: distributed under the License is distributed on an "AS IS" BASIS,
-:: WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-:: See the License for the specific language governing permissions and
-:: limitations under the License.
-
-set buildtype=Release
-if "%1"=="-b" set buildtype=%2
-
-..\%buildtype%\flatc.exe --cpp --cpp-std c++0x --no-prefix -o ../include/flatbuffers reflection.fbs || exit /b 1
diff -urN a/reflection/generate_code.sh b/reflection/generate_code.sh
--- a/reflection/generate_code.sh	2021-05-10 18:45:16.000000000 +0000
+++ b/reflection/generate_code.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,31 +0,0 @@
-#!/bin/bash
-#
-# Copyright 2016 Google Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-set -e
-
-tempDir="../include/flatbuffers/.tmp"
-originalFile="../include/flatbuffers/reflection_generated.h"
-newFile="$tempDir/reflection_generated.h"
-
-../flatc -c --cpp-std c++0x --no-prefix -o $tempDir reflection.fbs
-
-if [ -f "$newFile" ]; then
-  if ! cmp -s "$originalFile" "$newFile"; then
-    mv $newFile $originalFile
-  else
-    rm $newFile
-  fi
-  rmdir $tempDir
-fi
diff -urN a/reflection/reflection.fbs b/reflection/reflection.fbs
--- a/reflection/reflection.fbs	2021-05-10 18:45:16.000000000 +0000
+++ b/reflection/reflection.fbs	2023-01-13 07:46:54.480119075 +0000
@@ -38,6 +38,10 @@
                      // If base_type == Union, UnionType, or integral derived
                      // from an enum, index into "enums" below.
     fixed_length:uint16 = 0;  // Only if base_type == Array.
+    /// The size (octets) of the `base_type` field.
+    base_size:uint = 4; // 4 Is a common size due to offsets being that size.
+    /// The size (octets) of the `element` field, if present.
+    element_size:uint = 0;
 }
 
 table KeyValue {
@@ -48,7 +52,7 @@
 table EnumVal {
     name:string (required);
     value:long (key);
-    object:Object;  // Will be deprecated in favor of union_type in the future.
+    object:Object (deprecated);
     union_type:Type;
     documentation:[string];
 }
@@ -60,6 +64,8 @@
     underlying_type:Type (required);
     attributes:[KeyValue];
     documentation:[string];
+    /// File that this Enum is declared in.
+    declaration_file: string;
 }
 
 table Field {
@@ -75,6 +81,8 @@
     attributes:[KeyValue];
     documentation:[string];
     optional:bool = false;
+    /// Number of padding octets to always add after this field. Structs only.
+    padding:uint16 = 0; 
 }
 
 table Object {  // Used for both tables and structs.
@@ -85,6 +93,8 @@
     bytesize:int;  // For structs.
     attributes:[KeyValue];
     documentation:[string];
+    /// File that this Object is declared in.
+    declaration_file: string;
 }
 
 table RPCCall {
@@ -100,9 +110,11 @@
     calls:[RPCCall];
     attributes:[KeyValue];
     documentation:[string];
+    /// File that this Service is declared in.
+    declaration_file: string;
 }
 
-// New schema language features that are not supported by old code generators.
+/// New schema language features that are not supported by old code generators.
 enum AdvancedFeatures : ulong (bit_flags) {
     AdvancedArrayFeatures,
     AdvancedUnionFeatures,
@@ -110,6 +122,16 @@
     DefaultVectorsAndStrings,
 }
 
+/// File specific information.
+/// Symbols declared within a file may be recovered by iterating over all
+/// symbols and examining the `declaration_file` field.
+table SchemaFile {
+  /// Filename, relative to project root.
+  filename:string (required, key);
+  /// Names of included files, relative to project root.
+  included_filenames:[string];
+}
+
 table Schema {
     objects:[Object] (required);    // Sorted.
     enums:[Enum] (required);        // Sorted.
@@ -118,6 +140,9 @@
     root_table:Object;
     services:[Service];             // Sorted.
     advanced_features:AdvancedFeatures;
+    /// All the files used in this compilation. Files are relative to where
+    /// flatc was invoked.
+    fbs_files:[SchemaFile];         // Sorted.
 }
 
 root_type Schema;
diff -urN a/rust/flatbuffers/Cargo.toml b/rust/flatbuffers/Cargo.toml
--- a/rust/flatbuffers/Cargo.toml	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/Cargo.toml	2023-01-13 07:47:07.806242147 +0000
@@ -1,6 +1,6 @@
 [package]
 name = "flatbuffers"
-version = "2.0.0"
+version = "2.1.0"
 edition = "2018"
 authors = ["Robert Winslow <hello@rwinslow.com>", "FlatBuffers Maintainers"]
 license = "Apache-2.0"
@@ -11,7 +11,16 @@
 categories = ["encoding", "data-structures", "memory-management"]
 rust = "1.51"
 
+[features]
+default = ["thiserror"]
+no_std = ["core2", "thiserror_core2"]
+serialize = ["serde"]
+
 [dependencies]
 smallvec = "1.6.1"
 bitflags = "1.2.1"
-thiserror = "1.0.23"
+serde = { version = "1.0", optional = true }
+thiserror = { version = "1.0.30", optional = true }
+core2 = { version = "0.4.0", optional = true }
+# This version is compliant with mainline 1.0.30
+thiserror_core2 = { version = "2.0.0", default-features = false, optional = true }
diff -urN a/rust/flatbuffers/README.md b/rust/flatbuffers/README.md
--- a/rust/flatbuffers/README.md	1970-01-01 00:00:00.000000000 +0000
+++ b/rust/flatbuffers/README.md	2023-01-13 07:47:07.807242156 +0000
@@ -0,0 +1,15 @@
+# Flatbuffers
+
+FlatBuffers is a cross platform serialization library architected for maximum
+memory efficiency. It allows you to directly access serialized data without
+parsing/unpacking it first, while still having great forwards/backwards
+compatibility. It was originally created at Google for game development and
+other performance-critical applications.
+
+## See our
+* [Tutorial](https://google.github.io/flatbuffers/flatbuffers_guide_tutorial.html)
+* [Landing Page](https://google.github.io/flatbuffers/)
+* [Rust sample binary](https://github.com/google/flatbuffers/blob/master/samples/sample_binary.rs)
+* [Schema**less** format, Flexbuffers](https://crates.io/crates/flexbuffers)
+* [Github](https://github.com/google/flatbuffers)
+
diff -urN a/rust/flatbuffers/src/array.rs b/rust/flatbuffers/src/array.rs
--- a/rust/flatbuffers/src/array.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/array.rs	2023-01-13 07:47:07.807242156 +0000
@@ -17,9 +17,9 @@
 use crate::follow::Follow;
 use crate::vector::VectorIter;
 use crate::EndianScalar;
-use std::fmt::{Debug, Formatter, Result};
-use std::marker::PhantomData;
-use std::mem::size_of;
+use core::fmt::{Debug, Formatter, Result};
+use core::marker::PhantomData;
+use core::mem::size_of;
 
 #[derive(Copy, Clone)]
 pub struct Array<'a, T: 'a, const N: usize>(&'a [u8], PhantomData<T>);
@@ -133,3 +133,22 @@
         array.assume_init()
     }
 }
+
+#[cfg(feature="serialize")]
+impl<'a, T: 'a, const N: usize> serde::ser::Serialize for Array<'a, T, N>
+where
+    T: 'a + Follow<'a>,
+    <T as Follow<'a>>::Inner: serde::ser::Serialize,
+{
+    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
+    where
+        S: serde::ser::Serializer,
+    {
+        use serde::ser::SerializeSeq;
+        let mut seq = serializer.serialize_seq(Some(self.len()))?;
+        for element in self.iter() {
+            seq.serialize_element(&element)?;
+        }
+        seq.end()
+    }
+}
diff -urN a/rust/flatbuffers/src/builder.rs b/rust/flatbuffers/src/builder.rs
--- a/rust/flatbuffers/src/builder.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/builder.rs	2023-01-13 07:47:07.816242239 +0000
@@ -16,11 +16,13 @@
 
 extern crate smallvec;
 
-use std::cmp::max;
-use std::iter::{DoubleEndedIterator, ExactSizeIterator};
-use std::marker::PhantomData;
-use std::ptr::write_bytes;
-use std::slice::from_raw_parts;
+use core::cmp::max;
+use core::iter::{DoubleEndedIterator, ExactSizeIterator};
+use core::marker::PhantomData;
+use core::ptr::write_bytes;
+use core::slice::from_raw_parts;
+#[cfg(feature = "no_std")]
+use alloc::{vec, vec::Vec};
 
 use crate::endian_scalar::{emplace_scalar, read_scalar_at};
 use crate::primitives::*;
@@ -554,42 +556,38 @@
             // serialize every FieldLoc to the vtable:
             for &fl in self.field_locs.iter() {
                 let pos: VOffsetT = (object_revloc_to_vtable.value() - fl.off) as VOffsetT;
-                debug_assert_eq!(
-                    vtfw.get_field_offset(fl.id),
-                    0,
-                    "tried to write a vtable field multiple times"
-                );
                 vtfw.write_field_offset(fl.id, pos);
             }
         }
-        let dup_vt_use = {
-            let this_vt = VTable::init(&self.owned_buf[..], self.head);
-            self.find_duplicate_stored_vtable_revloc(this_vt)
-        };
-
-        let vt_use = match dup_vt_use {
-            Some(n) => {
+        let new_vt_bytes = &self.owned_buf[vt_start_pos..vt_end_pos];
+        let found = self.written_vtable_revpos.binary_search_by(|old_vtable_revpos: &UOffsetT| {
+            let old_vtable_pos = self.owned_buf.len() - *old_vtable_revpos as usize;
+            let old_vtable = VTable::init(&self.owned_buf, old_vtable_pos);
+            new_vt_bytes.cmp(old_vtable.as_bytes())
+        });
+        let final_vtable_revpos = match found {
+            Ok(i) => {
+                // The new vtable is a duplicate so clear it.
                 VTableWriter::init(&mut self.owned_buf[vt_start_pos..vt_end_pos]).clear();
                 self.head += vtable_byte_len;
-                n
+                self.written_vtable_revpos[i]
             }
-            None => {
-                let new_vt_use = self.used_space() as UOffsetT;
-                self.written_vtable_revpos.push(new_vt_use);
-                new_vt_use
+            Err(i) => {
+                // This is a new vtable. Add it to the cache.
+                let new_vt_revpos = self.used_space() as UOffsetT;
+                self.written_vtable_revpos.insert(i, new_vt_revpos);
+                new_vt_revpos
             }
         };
-
-        {
-            let n = self.head + self.used_space() - object_revloc_to_vtable.value() as usize;
-            let saw = unsafe { read_scalar_at::<UOffsetT>(&self.owned_buf, n) };
-            debug_assert_eq!(saw, 0xF0F0_F0F0);
-            unsafe {
-                emplace_scalar::<SOffsetT>(
-                    &mut self.owned_buf[n..n + SIZE_SOFFSET],
-                    vt_use as SOffsetT - object_revloc_to_vtable.value() as SOffsetT,
-                );
-            }
+        // Write signed offset from table to its vtable.
+        let table_pos = self.owned_buf.len() - object_revloc_to_vtable.value() as usize;
+        let tmp_soffset_to_vt = unsafe { read_scalar_at::<UOffsetT>(&self.owned_buf, table_pos) };
+        debug_assert_eq!(tmp_soffset_to_vt, 0xF0F0_F0F0);
+        unsafe {
+            emplace_scalar::<SOffsetT>(
+                &mut self.owned_buf[table_pos..table_pos + SIZE_SOFFSET],
+                final_vtable_revpos as SOffsetT - object_revloc_to_vtable.value() as SOffsetT
+            );
         }
 
         self.field_locs.clear();
@@ -597,20 +595,6 @@
         object_revloc_to_vtable
     }
 
-    #[inline]
-    fn find_duplicate_stored_vtable_revloc(&self, needle: VTable) -> Option<UOffsetT> {
-        for &revloc in self.written_vtable_revpos.iter().rev() {
-            let o = VTable::init(
-                &self.owned_buf[..],
-                self.head + self.used_space() - revloc as usize,
-            );
-            if needle == o {
-                return Some(revloc);
-            }
-        }
-        None
-    }
-
     // Only call this when you know it is safe to double the size of the buffer.
     #[inline]
     fn grow_owned_buf(&mut self) {
diff -urN a/rust/flatbuffers/src/endian_scalar.rs b/rust/flatbuffers/src/endian_scalar.rs
--- a/rust/flatbuffers/src/endian_scalar.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/endian_scalar.rs	2023-01-13 07:47:07.816242239 +0000
@@ -15,7 +15,7 @@
  */
 #![allow(clippy::wrong_self_convention)]
 
-use std::mem::size_of;
+use core::mem::size_of;
 
 /// Trait for values that must be stored in little-endian byte order, but
 /// might be represented in memory as big-endian. Every type that implements
diff -urN a/rust/flatbuffers/src/follow.rs b/rust/flatbuffers/src/follow.rs
--- a/rust/flatbuffers/src/follow.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/follow.rs	2023-01-13 07:47:07.816242239 +0000
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-use std::marker::PhantomData;
+use core::marker::PhantomData;
 
 /// Follow is a trait that allows us to access FlatBuffers in a declarative,
 /// type safe, and fast way. They compile down to almost no code (after
diff -urN a/rust/flatbuffers/src/get_root.rs b/rust/flatbuffers/src/get_root.rs
--- a/rust/flatbuffers/src/get_root.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/get_root.rs	2023-01-13 07:47:07.816242239 +0000
@@ -43,7 +43,7 @@
 where
     T: 'buf + Follow<'buf> + Verifiable,
 {
-    let mut v = Verifier::new(&opts, data);
+    let mut v = Verifier::new(opts, data);
     <ForwardsUOffset<T>>::run_verifier(&mut v, 0)?;
     Ok(unsafe { root_unchecked::<T>(data) })
 }
@@ -73,7 +73,7 @@
 where
     T: 'buf + Follow<'buf> + Verifiable,
 {
-    let mut v = Verifier::new(&opts, data);
+    let mut v = Verifier::new(opts, data);
     <SkipSizePrefix<ForwardsUOffset<T>>>::run_verifier(&mut v, 0)?;
     Ok(unsafe { size_prefixed_root_unchecked::<T>(data) })
 }
diff -urN a/rust/flatbuffers/src/lib.rs b/rust/flatbuffers/src/lib.rs
--- a/rust/flatbuffers/src/lib.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/lib.rs	2023-01-13 07:47:07.816242239 +0000
@@ -28,6 +28,11 @@
 //! At this time, to generate Rust code, you will need the latest `master` version of `flatc`, available from here: <https://github.com/google/flatbuffers>
 //! (On OSX, you can install FlatBuffers from `HEAD` with the Homebrew package manager.)
 
+#![cfg_attr(feature = "no_std", no_std)]
+
+#[cfg(feature = "no_std")]
+extern crate alloc;
+
 mod array;
 mod builder;
 mod endian_scalar;
diff -urN a/rust/flatbuffers/src/primitives.rs b/rust/flatbuffers/src/primitives.rs
--- a/rust/flatbuffers/src/primitives.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/primitives.rs	2023-01-13 07:47:07.817242248 +0000
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-use std::marker::PhantomData;
-use std::mem::size_of;
-use std::ops::Deref;
+use core::marker::PhantomData;
+use core::mem::size_of;
+use core::ops::Deref;
 
 use crate::endian_scalar::{emplace_scalar, read_scalar, read_scalar_at};
 use crate::follow::Follow;
diff -urN a/rust/flatbuffers/src/push.rs b/rust/flatbuffers/src/push.rs
--- a/rust/flatbuffers/src/push.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/push.rs	2023-01-13 07:47:07.817242248 +0000
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-use std::cmp::max;
-use std::mem::{align_of, size_of};
+use core::cmp::max;
+use core::mem::{align_of, size_of};
 
 use crate::endian_scalar::emplace_scalar;
 
diff -urN a/rust/flatbuffers/src/vector.rs b/rust/flatbuffers/src/vector.rs
--- a/rust/flatbuffers/src/vector.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/vector.rs	2023-01-13 07:47:08.193245721 +0000
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 
-use std::fmt::{Debug, Formatter, Result};
-use std::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator};
-use std::marker::PhantomData;
-use std::mem::size_of;
-use std::slice::from_raw_parts;
-use std::str::from_utf8_unchecked;
+use core::fmt::{Debug, Formatter, Result};
+use core::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator};
+use core::marker::PhantomData;
+use core::mem::size_of;
+use core::slice::from_raw_parts;
+use core::str::from_utf8_unchecked;
 
 use crate::endian_scalar::read_scalar_at;
 #[cfg(target_endian = "little")]
@@ -73,7 +73,7 @@
 
     #[inline(always)]
     pub fn len(&self) -> usize {
-        unsafe { read_scalar_at::<UOffsetT>(&self.0, self.1) as usize }
+        unsafe { read_scalar_at::<UOffsetT>(self.0, self.1) as usize }
     }
     #[inline(always)]
     pub fn is_empty(&self) -> bool {
@@ -103,7 +103,7 @@
         let loc = self.1;
         let sz = size_of::<T>();
         debug_assert!(sz > 0);
-        let len = unsafe { read_scalar_at::<UOffsetT>(&buf, loc) } as usize;
+        let len = unsafe { read_scalar_at::<UOffsetT>(buf, loc) } as usize;
         let data_buf = &buf[loc + SIZE_UOFFSET..loc + SIZE_UOFFSET + len * sz];
         let ptr = data_buf.as_ptr() as *const T;
         let s: &'a [T] = unsafe { from_raw_parts(ptr, len) };
@@ -144,7 +144,7 @@
 impl<'a> Follow<'a> for &'a str {
     type Inner = &'a str;
     fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
-        let len = unsafe { read_scalar_at::<UOffsetT>(&buf, loc) } as usize;
+        let len = unsafe { read_scalar_at::<UOffsetT>(buf, loc) } as usize;
         let slice = &buf[loc + SIZE_UOFFSET..loc + SIZE_UOFFSET + len];
         unsafe { from_utf8_unchecked(slice) }
     }
@@ -154,7 +154,7 @@
 fn follow_slice_helper<T>(buf: &[u8], loc: usize) -> &[T] {
     let sz = size_of::<T>();
     debug_assert!(sz > 0);
-    let len = unsafe { read_scalar_at::<UOffsetT>(&buf, loc) as usize };
+    let len = unsafe { read_scalar_at::<UOffsetT>(buf, loc) as usize };
     let data_buf = &buf[loc + SIZE_UOFFSET..loc + SIZE_UOFFSET + len * sz];
     let ptr = data_buf.as_ptr() as *const T;
     let s: &[T] = unsafe { from_raw_parts(ptr, len) };
@@ -308,3 +308,22 @@
         self.iter()
     }
 }
+
+#[cfg(feature="serialize")]
+impl<'a, T> serde::ser::Serialize for Vector<'a, T>
+where
+    T: 'a + Follow<'a>,
+    <T as Follow<'a>>::Inner: serde::ser::Serialize,
+{
+    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
+    where
+        S: serde::ser::Serializer,
+    {
+        use serde::ser::SerializeSeq;
+        let mut seq = serializer.serialize_seq(Some(self.len()))?;
+        for element in self {
+            seq.serialize_element(&element)?;
+        }
+        seq.end()
+    }
+}
diff -urN a/rust/flatbuffers/src/verifier.rs b/rust/flatbuffers/src/verifier.rs
--- a/rust/flatbuffers/src/verifier.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/verifier.rs	2023-01-13 07:47:08.193245721 +0000
@@ -1,6 +1,12 @@
+#[cfg(feature = "no_std")]
+use alloc::vec::Vec;
+use core::ops::Range;
+use core::option::Option;
 use crate::follow::Follow;
 use crate::{ForwardsUOffset, SOffsetT, SkipSizePrefix, UOffsetT, VOffsetT, Vector, SIZE_UOFFSET};
-use std::ops::Range;
+
+#[cfg(feature="no_std")]
+extern crate thiserror_core2 as thiserror;
 use thiserror::Error;
 
 /// Traces the location of data errors. Not populated for Dos detecting errors.
@@ -23,7 +29,7 @@
 }
 #[derive(PartialEq, Eq, Default, Debug, Clone)]
 pub struct ErrorTrace(Vec<ErrorTraceDetail>);
-impl std::convert::AsRef<[ErrorTraceDetail]> for ErrorTrace {
+impl core::convert::AsRef<[ErrorTraceDetail]> for ErrorTrace {
     #[inline]
     fn as_ref(&self) -> &[ErrorTraceDetail] {
         &self.0
@@ -51,7 +57,7 @@
     #[error("Utf8 error for string in {range:?}: {error}\n{error_trace}")]
     Utf8Error {
         #[source]
-        error: std::str::Utf8Error,
+        error: core::str::Utf8Error,
         range: Range<usize>,
         error_trace: ErrorTrace,
     },
@@ -90,8 +96,8 @@
     DepthLimitReached,
 }
 
-impl std::fmt::Display for ErrorTrace {
-    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+impl core::fmt::Display for ErrorTrace {
+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
         use ErrorTraceDetail::*;
         for e in self.0.iter() {
             match e {
@@ -125,7 +131,7 @@
     }
 }
 
-pub type Result<T> = std::prelude::v1::Result<T, InvalidFlatbuffer>;
+pub type Result<T> = core::result::Result<T, InvalidFlatbuffer>;
 
 impl InvalidFlatbuffer {
     fn new_range_oob<T>(start: usize, end: usize) -> Result<T> {
@@ -245,11 +251,11 @@
     /// `buffer[0]`. TODO(caspern).
     #[inline]
     fn is_aligned<T>(&self, pos: usize) -> Result<()> {
-        if pos % std::mem::align_of::<T>() == 0 {
+        if pos % core::mem::align_of::<T>() == 0 {
             Ok(())
         } else {
             Err(InvalidFlatbuffer::Unaligned {
-                unaligned_type: std::any::type_name::<T>(),
+                unaligned_type: core::any::type_name::<T>(),
                 position: pos,
                 error_trace: Default::default(),
             })
@@ -271,7 +277,7 @@
     #[inline]
     pub fn in_buffer<T>(&mut self, pos: usize) -> Result<()> {
         self.is_aligned::<T>(pos)?;
-        self.range_in_buffer(pos, std::mem::size_of::<T>())
+        self.range_in_buffer(pos, core::mem::size_of::<T>())
     }
     #[inline]
     fn get_u16(&mut self, pos: usize) -> Result<u16> {
@@ -416,7 +422,7 @@
     where
         Key: Follow<'buf> + Verifiable,
         UnionVerifier:
-            (std::ops::FnOnce(<Key as Follow<'buf>>::Inner, &mut Verifier, usize) -> Result<()>),
+            (core::ops::FnOnce(<Key as Follow<'buf>>::Inner, &mut Verifier, usize) -> Result<()>),
         // NOTE: <Key as Follow<'buf>>::Inner == Key
     {
         // TODO(caspern): how to trace vtable errors?
@@ -468,14 +474,14 @@
 }
 
 /// Checks and returns the range containing the flatbuffers vector.
-fn verify_vector_range<T>(v: &mut Verifier, pos: usize) -> Result<std::ops::Range<usize>> {
+fn verify_vector_range<T>(v: &mut Verifier, pos: usize) -> Result<core::ops::Range<usize>> {
     let len = v.get_uoffset(pos)? as usize;
     let start = pos.saturating_add(SIZE_UOFFSET);
     v.is_aligned::<T>(start)?;
-    let size = len.saturating_mul(std::mem::size_of::<T>());
+    let size = len.saturating_mul(core::mem::size_of::<T>());
     let end = start.saturating_add(size);
     v.range_in_buffer(start, size)?;
-    Ok(std::ops::Range { start, end })
+    Ok(core::ops::Range { start, end })
 }
 
 pub trait SimpleToVerifyInSlice {}
@@ -509,7 +515,7 @@
     #[inline]
     fn run_verifier(v: &mut Verifier, pos: usize) -> Result<()> {
         let range = verify_vector_range::<ForwardsUOffset<T>>(v, pos)?;
-        let size = std::mem::size_of::<ForwardsUOffset<T>>();
+        let size = core::mem::size_of::<ForwardsUOffset<T>>();
         for (i, element_pos) in range.step_by(size).enumerate() {
             trace_elem(
                 <ForwardsUOffset<T>>::run_verifier(v, element_pos),
@@ -526,7 +532,7 @@
     fn run_verifier(v: &mut Verifier, pos: usize) -> Result<()> {
         let range = verify_vector_range::<u8>(v, pos)?;
         let has_null_terminator = v.buffer.get(range.end).map(|&b| b == 0).unwrap_or(false);
-        let s = std::str::from_utf8(&v.buffer[range.clone()]);
+        let s = core::str::from_utf8(&v.buffer[range.clone()]);
         if let Err(error) = s {
             return Err(InvalidFlatbuffer::Utf8Error {
                 error,
diff -urN a/rust/flatbuffers/src/vtable_writer.rs b/rust/flatbuffers/src/vtable_writer.rs
--- a/rust/flatbuffers/src/vtable_writer.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flatbuffers/src/vtable_writer.rs	2023-01-13 07:47:08.194245730 +0000
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-use std::ptr::write_bytes;
+use core::ptr::write_bytes;
 
-use crate::endian_scalar::{emplace_scalar, read_scalar_at};
+use crate::endian_scalar::emplace_scalar;
 use crate::primitives::*;
 
 /// VTableWriter compartmentalizes actions needed to create a vtable.
@@ -54,16 +54,6 @@
         }
     }
 
-    /// Gets an object field offset from the vtable. Only used for debugging.
-    ///
-    /// Note that this expects field offsets (which are like pointers), not
-    /// field ids (which are like array indices).
-    #[inline(always)]
-    pub fn get_field_offset(&self, vtable_offset: VOffsetT) -> VOffsetT {
-        let idx = vtable_offset as usize;
-        unsafe { read_scalar_at::<VOffsetT>(&self.buf, idx) }
-    }
-
     /// Writes an object field offset into the vtable.
     ///
     /// Note that this expects field offsets (which are like pointers), not
diff -urN a/rust/flexbuffers/src/buffer.rs b/rust/flexbuffers/src/buffer.rs
--- a/rust/flexbuffers/src/buffer.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flexbuffers/src/buffer.rs	2023-01-13 07:47:07.474239080 +0000
@@ -1,6 +1,6 @@
 use std::ops::{Deref, Range};
 
-/// The underlying buffer that is used by a flexbuffer Reader. 
+/// The underlying buffer that is used by a flexbuffer Reader.
 ///
 /// This allows for custom buffer implementations as long as they can be viewed as a &[u8].
 pub trait Buffer: Deref<Target = [u8]> + Sized {
@@ -14,12 +14,12 @@
     /// A BufferString which will live at least as long as the Buffer itself.
     ///
     /// Deref's to UTF-8 `str`, and only generated from the `buffer_str` function Result.
-    type BufferString: Deref<Target = str> + Sized;
+    type BufferString: Deref<Target = str> + Sized + serde::ser::Serialize;
 
     /// This method returns an instance of type Self. This allows for lifetimes to be tracked
     /// in cases of deserialization.
     ///
-    /// It also lets custom buffers manage reference counts. 
+    /// It also lets custom buffers manage reference counts.
     ///
     /// Returns None if:
     /// - range start is greater than end
@@ -48,7 +48,7 @@
         Self::empty().buffer_str().unwrap()
     }
 
-    /// Attempts to convert the given buffer to a custom string type. 
+    /// Attempts to convert the given buffer to a custom string type.
     ///
     /// This should fail if the type does not have valid UTF-8 bytes, and must be zero copy.
     fn buffer_str(&self) -> Result<Self::BufferString, std::str::Utf8Error>;
@@ -78,4 +78,3 @@
         std::str::from_utf8(self)
     }
 }
-
diff -urN a/rust/flexbuffers/src/builder/map.rs b/rust/flexbuffers/src/builder/map.rs
--- a/rust/flexbuffers/src/builder/map.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flexbuffers/src/builder/map.rs	2023-01-13 07:47:07.475239089 +0000
@@ -97,8 +97,7 @@
     // preferred over custom sorting or adding another dependency. By construction, this part
     // of the values stack must be alternating (key, value) pairs. The public API must not be
     // able to trigger the above debug_assets that protect this unsafe usage.
-    let pairs: &mut [[Value; 2]] =
-        unsafe { std::slice::from_raw_parts_mut(raw_pairs, pairs_len) };
+    let pairs: &mut [[Value; 2]] = unsafe { std::slice::from_raw_parts_mut(raw_pairs, pairs_len) };
     #[rustfmt::skip]
     pairs.sort_unstable_by(|[key1, _], [key2, _]| {
         if let Value::Key(a1) = *key1 {
diff -urN a/rust/flexbuffers/src/builder/mod.rs b/rust/flexbuffers/src/builder/mod.rs
--- a/rust/flexbuffers/src/builder/mod.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flexbuffers/src/builder/mod.rs	2023-01-13 07:47:07.475239089 +0000
@@ -32,10 +32,11 @@
         fn $push_name<T, S>(&mut self, xs: S)
         where
             T: Into<$scalar> + Copy,
-            S: AsRef<[T]>
+            S: AsRef<[T]>,
         {
             let mut value = Value::$new_vec(xs.as_ref().len());
-            let mut width = xs.as_ref()
+            let mut width = xs
+                .as_ref()
                 .iter()
                 .map(|x| BitWidth::from((*x).into()))
                 .max()
@@ -56,7 +57,7 @@
             value.set_child_width_or_panic(width);
             self.values.push(value);
         }
-    }
+    };
 }
 macro_rules! push_indirect {
     ($push_name: ident, $scalar: ty, $Direct: ident, $Indirect: ident) => {
@@ -65,15 +66,13 @@
             let child_width = x.width_or_child_width();
             let address = self.buffer.len();
             store_value(&mut self.buffer, x, child_width);
-            self.values.push(
-                Value::Reference {
-                    address,
-                    child_width,
-                    fxb_type: FlexBufferType::$Indirect,
-                }
-            );
+            self.values.push(Value::Reference {
+                address,
+                child_width,
+                fxb_type: FlexBufferType::$Indirect,
+            });
         }
-    }
+    };
 }
 
 bitflags! {
diff -urN a/rust/flexbuffers/src/builder/ser.rs b/rust/flexbuffers/src/builder/ser.rs
--- a/rust/flexbuffers/src/builder/ser.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flexbuffers/src/builder/ser.rs	2023-01-13 07:47:07.482239154 +0000
@@ -36,6 +36,10 @@
     pub fn take_buffer(&mut self) -> Vec<u8> {
         self.builder.take_buffer()
     }
+    pub fn reset(&mut self) {
+        self.builder.reset();
+        self.nesting.clear();
+    }
     fn finish_if_not_nested(&mut self) -> Result<(), Error> {
         if self.nesting.is_empty() {
             assert_eq!(self.builder.values.len(), 1);
diff -urN a/rust/flexbuffers/src/lib.rs b/rust/flexbuffers/src/lib.rs
--- a/rust/flexbuffers/src/lib.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flexbuffers/src/lib.rs	2023-01-13 07:47:07.474239080 +0000
@@ -41,18 +41,18 @@
 extern crate serde;
 
 mod bitwidth;
+mod buffer;
 mod builder;
 mod flexbuffer_type;
 mod reader;
-mod buffer;
 
 pub use bitwidth::BitWidth;
+pub use buffer::Buffer;
 pub use builder::Error as SerializationError;
 pub use builder::{
     singleton, Builder, BuilderOptions, FlexbufferSerializer, MapBuilder, Pushable, VectorBuilder,
 };
 pub use flexbuffer_type::FlexBufferType;
-pub use buffer::Buffer;
 pub use reader::Error as ReaderError;
 pub use reader::{DeserializationError, MapReader, Reader, ReaderIterator, VectorReader};
 use serde::{Deserialize, Serialize};
@@ -76,7 +76,7 @@
 
 /// Deserialize a type from a flexbuffer.
 pub fn from_buffer<'de, T: Deserialize<'de>, B: Buffer>(
-    buf: &'de B
+    buf: &'de B,
 ) -> Result<T, DeserializationError> {
     let r = Reader::get_root(buf as &'de [u8])?;
     T::deserialize(r)
diff -urN a/rust/flexbuffers/src/reader/mod.rs b/rust/flexbuffers/src/reader/mod.rs
--- a/rust/flexbuffers/src/reader/mod.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flexbuffers/src/reader/mod.rs	2023-01-13 07:47:07.760241721 +0000
@@ -14,7 +14,7 @@
 
 use crate::bitwidth::BitWidth;
 use crate::flexbuffer_type::FlexBufferType;
-use crate::{Buffer, Blob};
+use crate::{Blob, Buffer};
 use std::convert::{TryFrom, TryInto};
 use std::fmt;
 use std::ops::Rem;
@@ -22,6 +22,7 @@
 mod de;
 mod iter;
 mod map;
+mod serialize;
 mod vector;
 pub use de::DeserializationError;
 pub use iter::ReaderIterator;
@@ -184,13 +185,12 @@
     }
 }
 
-
 macro_rules! try_cast_fn {
     ($name: ident, $full_width: ident, $Ty: ident) => {
         pub fn $name(&self) -> $Ty {
             self.$full_width().try_into().unwrap_or_default()
         }
-    }
+    };
 }
 
 fn safe_sub(a: usize, b: usize) -> Result<usize, Error> {
@@ -242,7 +242,7 @@
     }
 
     /// Convenience function to get the underlying buffer. By using `shallow_copy`, this preserves
-    /// the lifetime that the underlying buffer has. 
+    /// the lifetime that the underlying buffer has.
     pub fn buffer(&self) -> B {
         self.buffer.shallow_copy()
     }
@@ -263,7 +263,11 @@
         if let Some(len) = self.fxb_type.fixed_length_vector_length() {
             len
         } else if self.fxb_type.has_length_slot() && self.address >= self.width.n_bytes() {
-            read_usize(&self.buffer, self.address - self.width.n_bytes(), self.width)
+            read_usize(
+                &self.buffer,
+                self.address - self.width.n_bytes(),
+                self.width,
+            )
         } else {
             0
         }
@@ -359,7 +363,8 @@
 
     /// Retrieves the string value up until the first `\0` character.
     pub fn get_key(&self) -> Result<B::BufferString, Error> {
-        let bytes = self.buffer
+        let bytes = self
+            .buffer
             .slice(self.address..self.address + self.get_key_len()?)
             .ok_or(Error::IndexOutOfBounds)?;
         Ok(bytes.buffer_str()?)
@@ -368,9 +373,9 @@
     pub fn get_blob(&self) -> Result<Blob<B>, Error> {
         self.expect_type(FlexBufferType::Blob)?;
         Ok(Blob(
-                self.buffer
-                    .slice(self.address..self.address + self.length())
-                    .ok_or(Error::IndexOutOfBounds)?
+            self.buffer
+                .slice(self.address..self.address + self.length())
+                .ok_or(Error::IndexOutOfBounds)?,
         ))
     }
 
@@ -382,7 +387,9 @@
     /// is out of bounds.
     pub fn get_str(&self) -> Result<B::BufferString, Error> {
         self.expect_type(FlexBufferType::String)?;
-        let bytes = self.buffer.slice(self.address..self.address + self.length());
+        let bytes = self
+            .buffer
+            .slice(self.address..self.address + self.length());
         Ok(bytes.ok_or(Error::ReadUsizeOverflowed)?.buffer_str()?)
     }
 
@@ -666,4 +673,4 @@
     let w = BitWidth::try_from(ty & 3u8).map_err(|_| Error::InvalidPackedType)?;
     let t = FlexBufferType::try_from(ty >> 2).map_err(|_| Error::InvalidPackedType)?;
     Ok((t, w))
-}
\ No newline at end of file
+}
diff -urN a/rust/flexbuffers/src/reader/serialize.rs b/rust/flexbuffers/src/reader/serialize.rs
--- a/rust/flexbuffers/src/reader/serialize.rs	1970-01-01 00:00:00.000000000 +0000
+++ b/rust/flexbuffers/src/reader/serialize.rs	2023-01-13 07:47:07.789241990 +0000
@@ -0,0 +1,76 @@
+// Copyright 2021 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use crate::reader::Reader;
+use crate::Buffer;
+use crate::{BitWidth::*, FlexBufferType::*};
+use serde::ser;
+use serde::ser::{SerializeMap, SerializeSeq};
+
+impl<B: Buffer> ser::Serialize for &Reader<B> {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: ser::Serializer,
+    {
+        #[allow(deprecated)]
+        match (self.flexbuffer_type(), self.bitwidth()) {
+            (Null, _) => serializer.serialize_unit(),
+            (Int, W8) | (IndirectInt, W8) => serializer.serialize_i8(self.as_i8()),
+            (Int, W16) | (IndirectInt, W16) => serializer.serialize_i16(self.as_i16()),
+            (Int, W32) | (IndirectInt, W32) => serializer.serialize_i32(self.as_i32()),
+            (Int, W64) | (IndirectInt, W64) => serializer.serialize_i64(self.as_i64()),
+            (UInt, W8) | (IndirectUInt, W8) => serializer.serialize_u8(self.as_u8()),
+            (UInt, W16) | (IndirectUInt, W16) => serializer.serialize_u16(self.as_u16()),
+            (UInt, W32) | (IndirectUInt, W32) => serializer.serialize_u32(self.as_u32()),
+            (UInt, W64) | (IndirectUInt, W64) => serializer.serialize_u64(self.as_u64()),
+            (Float, W32) | (IndirectFloat, W32) => serializer.serialize_f32(self.as_f32()),
+            (Float, _) | (IndirectFloat, _) => serializer.serialize_f64(self.as_f64()),
+            (Bool, _) => serializer.serialize_bool(self.as_bool()),
+            (Key, _) | (String, _) => serializer.serialize_str(&self.as_str()),
+            (Map, _) => {
+                let m = self.as_map();
+                let mut map_serializer = serializer.serialize_map(Some(m.len()))?;
+                for (k, v) in m.iter_keys().zip(m.iter_values()) {
+                    map_serializer.serialize_key(&&k)?;
+                    map_serializer.serialize_value(&&v)?;
+                }
+                map_serializer.end()
+            }
+            (Vector, _)
+            | (VectorInt, _)
+            | (VectorUInt, _)
+            | (VectorFloat, _)
+            | (VectorKey, _)
+            | (VectorString, _)
+            | (VectorBool, _)
+            | (VectorInt2, _)
+            | (VectorUInt2, _)
+            | (VectorFloat2, _)
+            | (VectorInt3, _)
+            | (VectorUInt3, _)
+            | (VectorFloat3, _)
+            | (VectorInt4, _)
+            | (VectorUInt4, _)
+            | (VectorFloat4, _) => {
+                let v = self.as_vector();
+                let mut seq_serializer = serializer.serialize_seq(Some(v.len()))?;
+                for x in v.iter() {
+                    seq_serializer.serialize_element(&&x)?;
+                }
+                seq_serializer.end()
+            }
+            (Blob, _) => serializer.serialize_bytes(&self.as_blob().0),
+        }
+    }
+}
diff -urN a/rust/flexbuffers/src/reader/vector.rs b/rust/flexbuffers/src/reader/vector.rs
--- a/rust/flexbuffers/src/reader/vector.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/rust/flexbuffers/src/reader/vector.rs	2023-01-13 07:47:07.806242147 +0000
@@ -40,7 +40,7 @@
     fn default() -> Self {
         VectorReader {
             reader: Reader::default(),
-            length: usize::default()
+            length: usize::default(),
         }
     }
 }
diff -urN a/samples/dart_sample.sh b/samples/dart_sample.sh
--- a/samples/dart_sample.sh	2021-05-10 18:45:16.000000000 +0000
+++ b/samples/dart_sample.sh	2023-01-13 07:46:54.481119084 +0000
@@ -1,4 +1,5 @@
 #!/bin/bash
+set -euo
 #
 # Copyright 2018 Dan Field. All rights reserved.
 #
@@ -27,14 +28,12 @@
   exit 1
 fi
 
-cd ../dart/example
-
 # Run `flatc`. Note: This requires you to compile using `cmake` from the
 # root `/flatbuffers` directory.
-if [ -e ../../flatc ]; then
-  ../../flatc --dart ../../samples/monster.fbs
-elif [ -e ../../Debug/flatc ]; then
-  ../../Debug/flatc --dart ../../samples/monster.fbs
+if [ -e ../flatc ]; then
+  ../flatc --dart -o ../dart/example/ monster.fbs
+elif [ -e ../Debug/flatc ]; then
+  ../Debug/flatc --dart -o ../dart/example/ monster.fbs
 else
   echo 'flatc' could not be found. Make sure to build FlatBuffers from the \
        $rootdir directory.
@@ -44,9 +43,7 @@
 echo Running the Dart sample.
 
 # Execute the sample.
-dart example.dart
-
-# Cleanup temporary files.
-git checkout monster_my_game.sample_generated.dart
+dart ../dart/example/example.dart
 
-cd ../../samples
+# Copy the source schema so it is distributed when published to pub.dev
+cp monster.fbs ../dart/example/
\ No newline at end of file
Binary files a/samples/monster.bfbs and b/samples/monster.bfbs differ
diff -urN a/samples/monster_generated.h b/samples/monster_generated.h
--- a/samples/monster_generated.h	2021-05-10 18:45:16.000000000 +0000
+++ b/samples/monster_generated.h	2023-01-13 07:46:54.481119084 +0000
@@ -103,6 +103,14 @@
   static const Equipment enum_value = Equipment_Weapon;
 };
 
+template<typename T> struct EquipmentUnionTraits {
+  static const Equipment enum_value = Equipment_NONE;
+};
+
+template<> struct EquipmentUnionTraits<MyGame::Sample::WeaponT> {
+  static const Equipment enum_value = Equipment_Weapon;
+};
+
 struct EquipmentUnion {
   Equipment type;
   void *value;
@@ -120,17 +128,15 @@
 
   void Reset();
 
-#ifndef FLATBUFFERS_CPP98_STL
   template <typename T>
   void Set(T&& val) {
-    using RT = typename std::remove:reference<T>::type;
+    typedef typename std::remove:reference<T>::type RT;
     Reset();
-    type = EquipmentTraits<typename RT::TableType>::enum_value;
+    type = EquipmentUnionTraits<RT>::enum_value;
     if (type != Equipment_NONE) {
       value = new RT(std::forward<T>(val));
     }
   }
-#endif  // FLATBUFFERS_CPP98_STL
 
   static void *UnPack(const void *obj, Equipment type, const flatbuffers::resolver_function_t *resolver);
   flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;
@@ -233,26 +239,12 @@
   std::vector<flatbuffers::unique_ptr<MyGame::Sample::WeaponT>> weapons{};
   MyGame::Sample::EquipmentUnion equipped{};
   std::vector<MyGame::Sample::Vec3> path{};
+  MonsterT() = default;
+  MonsterT(const MonsterT &o);
+  MonsterT(MonsterT&&) FLATBUFFERS_NOEXCEPT = default;
+  MonsterT &operator=(MonsterT o) FLATBUFFERS_NOEXCEPT;
 };
 
-inline bool operator==(const MonsterT &lhs, const MonsterT &rhs) {
-  return
-      (lhs.pos == rhs.pos) &&
-      (lhs.mana == rhs.mana) &&
-      (lhs.hp == rhs.hp) &&
-      (lhs.name == rhs.name) &&
-      (lhs.inventory == rhs.inventory) &&
-      (lhs.color == rhs.color) &&
-      (lhs.weapons == rhs.weapons) &&
-      (lhs.equipped == rhs.equipped) &&
-      (lhs.path == rhs.path);
-}
-
-inline bool operator!=(const MonsterT &lhs, const MonsterT &rhs) {
-    return !(lhs == rhs);
-}
-
-
 struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef MonsterT NativeTableType;
   typedef MonsterBuilder Builder;
@@ -280,13 +272,13 @@
   int16_t mana() const {
     return GetField<int16_t>(VT_MANA, 150);
   }
-  bool mutate_mana(int16_t _mana) {
+  bool mutate_mana(int16_t _mana = 150) {
     return SetField<int16_t>(VT_MANA, _mana, 150);
   }
   int16_t hp() const {
     return GetField<int16_t>(VT_HP, 100);
   }
-  bool mutate_hp(int16_t _hp) {
+  bool mutate_hp(int16_t _hp = 100) {
     return SetField<int16_t>(VT_HP, _hp, 100);
   }
   const flatbuffers::String *name() const {
@@ -304,7 +296,7 @@
   MyGame::Sample::Color color() const {
     return static_cast<MyGame::Sample::Color>(GetField<int8_t>(VT_COLOR, 2));
   }
-  bool mutate_color(MyGame::Sample::Color _color) {
+  bool mutate_color(MyGame::Sample::Color _color = static_cast<MyGame::Sample::Color>(2)) {
     return SetField<int8_t>(VT_COLOR, static_cast<int8_t>(_color), 2);
   }
   const flatbuffers::Vector<flatbuffers::Offset<MyGame::Sample::Weapon>> *weapons() const {
@@ -334,18 +326,18 @@
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
-           VerifyField<MyGame::Sample::Vec3>(verifier, VT_POS) &&
-           VerifyField<int16_t>(verifier, VT_MANA) &&
-           VerifyField<int16_t>(verifier, VT_HP) &&
+           VerifyField<MyGame::Sample::Vec3>(verifier, VT_POS, 4) &&
+           VerifyField<int16_t>(verifier, VT_MANA, 2) &&
+           VerifyField<int16_t>(verifier, VT_HP, 2) &&
            VerifyOffset(verifier, VT_NAME) &&
            verifier.VerifyString(name()) &&
            VerifyOffset(verifier, VT_INVENTORY) &&
            verifier.VerifyVector(inventory()) &&
-           VerifyField<int8_t>(verifier, VT_COLOR) &&
+           VerifyField<int8_t>(verifier, VT_COLOR, 1) &&
            VerifyOffset(verifier, VT_WEAPONS) &&
            verifier.VerifyVector(weapons()) &&
            verifier.VerifyVectorOfTables(weapons()) &&
-           VerifyField<uint8_t>(verifier, VT_EQUIPPED_TYPE) &&
+           VerifyField<uint8_t>(verifier, VT_EQUIPPED_TYPE, 1) &&
            VerifyOffset(verifier, VT_EQUIPPED) &&
            VerifyEquipment(verifier, equipped(), equipped_type()) &&
            VerifyOffset(verifier, VT_PATH) &&
@@ -408,7 +400,7 @@
 
 inline flatbuffers::Offset<Monster> CreateMonster(
     flatbuffers::FlatBufferBuilder &_fbb,
-    const MyGame::Sample::Vec3 *pos = 0,
+    const MyGame::Sample::Vec3 *pos = nullptr,
     int16_t mana = 150,
     int16_t hp = 100,
     flatbuffers::Offset<flatbuffers::String> name = 0,
@@ -434,7 +426,7 @@
 
 inline flatbuffers::Offset<Monster> CreateMonsterDirect(
     flatbuffers::FlatBufferBuilder &_fbb,
-    const MyGame::Sample::Vec3 *pos = 0,
+    const MyGame::Sample::Vec3 *pos = nullptr,
     int16_t mana = 150,
     int16_t hp = 100,
     const char *name = nullptr,
@@ -470,17 +462,6 @@
   int16_t damage = 0;
 };
 
-inline bool operator==(const WeaponT &lhs, const WeaponT &rhs) {
-  return
-      (lhs.name == rhs.name) &&
-      (lhs.damage == rhs.damage);
-}
-
-inline bool operator!=(const WeaponT &lhs, const WeaponT &rhs) {
-    return !(lhs == rhs);
-}
-
-
 struct Weapon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
   typedef WeaponT NativeTableType;
   typedef WeaponBuilder Builder;
@@ -500,14 +481,14 @@
   int16_t damage() const {
     return GetField<int16_t>(VT_DAMAGE, 0);
   }
-  bool mutate_damage(int16_t _damage) {
+  bool mutate_damage(int16_t _damage = 0) {
     return SetField<int16_t>(VT_DAMAGE, _damage, 0);
   }
   bool Verify(flatbuffers::Verifier &verifier) const {
     return VerifyTableStart(verifier) &&
            VerifyOffset(verifier, VT_NAME) &&
            verifier.VerifyString(name()) &&
-           VerifyField<int16_t>(verifier, VT_DAMAGE) &&
+           VerifyField<int16_t>(verifier, VT_DAMAGE, 2) &&
            verifier.EndTable();
   }
   WeaponT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
@@ -559,6 +540,51 @@
 
 flatbuffers::Offset<Weapon> CreateWeapon(flatbuffers::FlatBufferBuilder &_fbb, const WeaponT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 
+
+inline bool operator==(const MonsterT &lhs, const MonsterT &rhs) {
+  return
+      ((lhs.pos == rhs.pos) || (lhs.pos && rhs.pos && *lhs.pos == *rhs.pos)) &&
+      (lhs.mana == rhs.mana) &&
+      (lhs.hp == rhs.hp) &&
+      (lhs.name == rhs.name) &&
+      (lhs.inventory == rhs.inventory) &&
+      (lhs.color == rhs.color) &&
+      (lhs.weapons == rhs.weapons) &&
+      (lhs.equipped == rhs.equipped) &&
+      (lhs.path == rhs.path);
+}
+
+inline bool operator!=(const MonsterT &lhs, const MonsterT &rhs) {
+    return !(lhs == rhs);
+}
+
+
+inline MonsterT::MonsterT(const MonsterT &o)
+      : pos((o.pos) ? new MyGame::Sample::Vec3(*o.pos) : nullptr),
+        mana(o.mana),
+        hp(o.hp),
+        name(o.name),
+        inventory(o.inventory),
+        color(o.color),
+        equipped(o.equipped),
+        path(o.path) {
+  weapons.reserve(o.weapons.size());
+  for (const auto &v : o.weapons) { weapons.emplace_back((v) ? new MyGame::Sample::WeaponT(*v) : nullptr); }
+}
+
+inline MonsterT &MonsterT::operator=(MonsterT o) FLATBUFFERS_NOEXCEPT {
+  std::swap(pos, o.pos);
+  std::swap(mana, o.mana);
+  std::swap(hp, o.hp);
+  std::swap(name, o.name);
+  std::swap(inventory, o.inventory);
+  std::swap(color, o.color);
+  std::swap(weapons, o.weapons);
+  std::swap(equipped, o.equipped);
+  std::swap(path, o.path);
+  return *this;
+}
+
 inline MonsterT *Monster::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
   auto _o = std::unique_ptr<MonsterT>(new MonsterT());
   UnPackTo(_o.get(), _resolver);
@@ -574,7 +600,7 @@
   { auto _e = name(); if (_e) _o->name = _e->str(); }
   { auto _e = inventory(); if (_e) { _o->inventory.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->inventory.begin()); } }
   { auto _e = color(); _o->color = _e; }
-  { auto _e = weapons(); if (_e) { _o->weapons.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weapons[_i] = flatbuffers::unique_ptr<MyGame::Sample::WeaponT>(_e->Get(_i)->UnPack(_resolver)); } } }
+  { auto _e = weapons(); if (_e) { _o->weapons.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->weapons[_i]) { _e->Get(_i)->UnPackTo(_o->weapons[_i].get(), _resolver); } else { _o->weapons[_i] = flatbuffers::unique_ptr<MyGame::Sample::WeaponT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
   { auto _e = equipped_type(); _o->equipped.type = _e; }
   { auto _e = equipped(); if (_e) _o->equipped.value = MyGame::Sample::EquipmentUnion::UnPack(_e, equipped_type(), _resolver); }
   { auto _e = path(); if (_e) { _o->path.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->path[_i] = *_e->Get(_i); } } }
@@ -612,6 +638,18 @@
       _path);
 }
 
+
+inline bool operator==(const WeaponT &lhs, const WeaponT &rhs) {
+  return
+      (lhs.name == rhs.name) &&
+      (lhs.damage == rhs.damage);
+}
+
+inline bool operator!=(const WeaponT &lhs, const WeaponT &rhs) {
+    return !(lhs == rhs);
+}
+
+
 inline WeaponT *Weapon::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
   auto _o = std::unique_ptr<WeaponT>(new WeaponT());
   UnPackTo(_o.get(), _resolver);
@@ -667,6 +705,7 @@
 }
 
 inline void *EquipmentUnion::UnPack(const void *obj, Equipment type, const flatbuffers::resolver_function_t *resolver) {
+  (void)resolver;
   switch (type) {
     case Equipment_Weapon: {
       auto ptr = reinterpret_cast<const MyGame::Sample::Weapon *>(obj);
@@ -677,6 +716,7 @@
 }
 
 inline flatbuffers::Offset<void> EquipmentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
+  (void)_rehasher;
   switch (type) {
     case Equipment_Weapon: {
       auto ptr = reinterpret_cast<const MyGame::Sample::WeaponT *>(value);
@@ -832,6 +872,10 @@
   return flatbuffers::GetMutableRoot<Monster>(buf);
 }
 
+inline MyGame::Sample::Monster *GetMutableSizePrefixedMonster(void *buf) {
+  return flatbuffers::GetMutableSizePrefixedRoot<MyGame::Sample::Monster>(buf);
+}
+
 inline bool VerifyMonsterBuffer(
     flatbuffers::Verifier &verifier) {
   return verifier.VerifyBuffer<MyGame::Sample::Monster>(nullptr);
diff -urN a/samples/monster_generated.rs b/samples/monster_generated.rs
--- a/samples/monster_generated.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/samples/monster_generated.rs	1970-01-01 00:00:00.000000000 +0000
@@ -1,1006 +0,0 @@
-// automatically generated by the FlatBuffers compiler, do not modify
-
-
-
-use std::mem;
-use std::cmp::Ordering;
-
-extern crate flatbuffers;
-use self::flatbuffers::{EndianScalar, Follow};
-
-#[allow(unused_imports, dead_code)]
-pub mod my_game {
-
-  use std::mem;
-  use std::cmp::Ordering;
-
-  extern crate flatbuffers;
-  use self::flatbuffers::{EndianScalar, Follow};
-#[allow(unused_imports, dead_code)]
-pub mod sample {
-
-  use std::mem;
-  use std::cmp::Ordering;
-
-  extern crate flatbuffers;
-  use self::flatbuffers::{EndianScalar, Follow};
-
-#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
-pub const ENUM_MIN_COLOR: i8 = 0;
-#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
-pub const ENUM_MAX_COLOR: i8 = 2;
-#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
-#[allow(non_camel_case_types)]
-pub const ENUM_VALUES_COLOR: [Color; 3] = [
-  Color::Red,
-  Color::Green,
-  Color::Blue,
-];
-
-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
-#[repr(transparent)]
-pub struct Color(pub i8);
-#[allow(non_upper_case_globals)]
-impl Color {
-  pub const Red: Self = Self(0);
-  pub const Green: Self = Self(1);
-  pub const Blue: Self = Self(2);
-
-  pub const ENUM_MIN: i8 = 0;
-  pub const ENUM_MAX: i8 = 2;
-  pub const ENUM_VALUES: &'static [Self] = &[
-    Self::Red,
-    Self::Green,
-    Self::Blue,
-  ];
-  /// Returns the variant's name or "" if unknown.
-  pub fn variant_name(self) -> Option<&'static str> {
-    match self {
-      Self::Red => Some("Red"),
-      Self::Green => Some("Green"),
-      Self::Blue => Some("Blue"),
-      _ => None,
-    }
-  }
-}
-impl std::fmt::Debug for Color {
-  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
-    if let Some(name) = self.variant_name() {
-      f.write_str(name)
-    } else {
-      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
-    }
-  }
-}
-impl<'a> flatbuffers::Follow<'a> for Color {
-  type Inner = Self;
-  #[inline]
-  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
-    let b = unsafe {
-      flatbuffers::read_scalar_at::<i8>(buf, loc)
-    };
-    Self(b)
-  }
-}
-
-impl flatbuffers::Push for Color {
-    type Output = Color;
-    #[inline]
-    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
-        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
-    }
-}
-
-impl flatbuffers::EndianScalar for Color {
-  #[inline]
-  fn to_little_endian(self) -> Self {
-    let b = i8::to_le(self.0);
-    Self(b)
-  }
-  #[inline]
-  #[allow(clippy::wrong_self_convention)]
-  fn from_little_endian(self) -> Self {
-    let b = i8::from_le(self.0);
-    Self(b)
-  }
-}
-
-impl<'a> flatbuffers::Verifiable for Color {
-  #[inline]
-  fn run_verifier(
-    v: &mut flatbuffers::Verifier, pos: usize
-  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
-    use self::flatbuffers::Verifiable;
-    i8::run_verifier(v, pos)
-  }
-}
-
-impl flatbuffers::SimpleToVerifyInSlice for Color {}
-#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
-pub const ENUM_MIN_EQUIPMENT: u8 = 0;
-#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
-pub const ENUM_MAX_EQUIPMENT: u8 = 1;
-#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
-#[allow(non_camel_case_types)]
-pub const ENUM_VALUES_EQUIPMENT: [Equipment; 2] = [
-  Equipment::NONE,
-  Equipment::Weapon,
-];
-
-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
-#[repr(transparent)]
-pub struct Equipment(pub u8);
-#[allow(non_upper_case_globals)]
-impl Equipment {
-  pub const NONE: Self = Self(0);
-  pub const Weapon: Self = Self(1);
-
-  pub const ENUM_MIN: u8 = 0;
-  pub const ENUM_MAX: u8 = 1;
-  pub const ENUM_VALUES: &'static [Self] = &[
-    Self::NONE,
-    Self::Weapon,
-  ];
-  /// Returns the variant's name or "" if unknown.
-  pub fn variant_name(self) -> Option<&'static str> {
-    match self {
-      Self::NONE => Some("NONE"),
-      Self::Weapon => Some("Weapon"),
-      _ => None,
-    }
-  }
-}
-impl std::fmt::Debug for Equipment {
-  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
-    if let Some(name) = self.variant_name() {
-      f.write_str(name)
-    } else {
-      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
-    }
-  }
-}
-impl<'a> flatbuffers::Follow<'a> for Equipment {
-  type Inner = Self;
-  #[inline]
-  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
-    let b = unsafe {
-      flatbuffers::read_scalar_at::<u8>(buf, loc)
-    };
-    Self(b)
-  }
-}
-
-impl flatbuffers::Push for Equipment {
-    type Output = Equipment;
-    #[inline]
-    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
-        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
-    }
-}
-
-impl flatbuffers::EndianScalar for Equipment {
-  #[inline]
-  fn to_little_endian(self) -> Self {
-    let b = u8::to_le(self.0);
-    Self(b)
-  }
-  #[inline]
-  #[allow(clippy::wrong_self_convention)]
-  fn from_little_endian(self) -> Self {
-    let b = u8::from_le(self.0);
-    Self(b)
-  }
-}
-
-impl<'a> flatbuffers::Verifiable for Equipment {
-  #[inline]
-  fn run_verifier(
-    v: &mut flatbuffers::Verifier, pos: usize
-  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
-    use self::flatbuffers::Verifiable;
-    u8::run_verifier(v, pos)
-  }
-}
-
-impl flatbuffers::SimpleToVerifyInSlice for Equipment {}
-pub struct EquipmentUnionTableOffset {}
-
-#[non_exhaustive]
-#[derive(Debug, Clone, PartialEq)]
-pub enum EquipmentT {
-  NONE,
-  Weapon(Box<WeaponT>),
-}
-impl Default for EquipmentT {
-  fn default() -> Self {
-    Self::NONE
-  }
-}
-impl EquipmentT {
-  pub fn equipment_type(&self) -> Equipment {
-    match self {
-      Self::NONE => Equipment::NONE,
-      Self::Weapon(_) => Equipment::Weapon,
-    }
-  }
-  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
-    match self {
-      Self::NONE => None,
-      Self::Weapon(v) => Some(v.pack(fbb).as_union_value()),
-    }
-  }
-  /// If the union variant matches, return the owned WeaponT, setting the union to NONE.
-  pub fn take_weapon(&mut self) -> Option<Box<WeaponT>> {
-    if let Self::Weapon(_) = self {
-      let v = std::mem::replace(self, Self::NONE);
-      if let Self::Weapon(w) = v {
-        Some(w)
-      } else {
-        unreachable!()
-      }
-    } else {
-      None
-    }
-  }
-  /// If the union variant matches, return a reference to the WeaponT.
-  pub fn as_weapon(&self) -> Option<&WeaponT> {
-    if let Self::Weapon(v) = self { Some(v.as_ref()) } else { None }
-  }
-  /// If the union variant matches, return a mutable reference to the WeaponT.
-  pub fn as_weapon_mut(&mut self) -> Option<&mut WeaponT> {
-    if let Self::Weapon(v) = self { Some(v.as_mut()) } else { None }
-  }
-}
-// struct Vec3, aligned to 4
-#[repr(transparent)]
-#[derive(Clone, Copy, PartialEq)]
-pub struct Vec3(pub [u8; 12]);
-impl Default for Vec3 { 
-  fn default() -> Self { 
-    Self([0; 12])
-  }
-}
-impl std::fmt::Debug for Vec3 {
-  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
-    f.debug_struct("Vec3")
-      .field("x", &self.x())
-      .field("y", &self.y())
-      .field("z", &self.z())
-      .finish()
-  }
-}
-
-impl flatbuffers::SimpleToVerifyInSlice for Vec3 {}
-impl flatbuffers::SafeSliceAccess for Vec3 {}
-impl<'a> flatbuffers::Follow<'a> for Vec3 {
-  type Inner = &'a Vec3;
-  #[inline]
-  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
-    <&'a Vec3>::follow(buf, loc)
-  }
-}
-impl<'a> flatbuffers::Follow<'a> for &'a Vec3 {
-  type Inner = &'a Vec3;
-  #[inline]
-  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
-    flatbuffers::follow_cast_ref::<Vec3>(buf, loc)
-  }
-}
-impl<'b> flatbuffers::Push for Vec3 {
-    type Output = Vec3;
-    #[inline]
-    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
-        let src = unsafe {
-            ::std::slice::from_raw_parts(self as *const Vec3 as *const u8, Self::size())
-        };
-        dst.copy_from_slice(src);
-    }
-}
-impl<'b> flatbuffers::Push for &'b Vec3 {
-    type Output = Vec3;
-
-    #[inline]
-    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
-        let src = unsafe {
-            ::std::slice::from_raw_parts(*self as *const Vec3 as *const u8, Self::size())
-        };
-        dst.copy_from_slice(src);
-    }
-}
-
-impl<'a> flatbuffers::Verifiable for Vec3 {
-  #[inline]
-  fn run_verifier(
-    v: &mut flatbuffers::Verifier, pos: usize
-  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
-    use self::flatbuffers::Verifiable;
-    v.in_buffer::<Self>(pos)
-  }
-}
-impl<'a> Vec3 {
-  #[allow(clippy::too_many_arguments)]
-  pub fn new(
-    x: f32,
-    y: f32,
-    z: f32,
-  ) -> Self {
-    let mut s = Self([0; 12]);
-    s.set_x(x);
-    s.set_y(y);
-    s.set_z(z);
-    s
-  }
-
-  pub fn x(&self) -> f32 {
-    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
-    unsafe {
-      core::ptr::copy_nonoverlapping(
-        self.0[0..].as_ptr(),
-        mem.as_mut_ptr() as *mut u8,
-        core::mem::size_of::<f32>(),
-      );
-      mem.assume_init()
-    }.from_little_endian()
-  }
-
-  pub fn set_x(&mut self, x: f32) {
-    let x_le = x.to_little_endian();
-    unsafe {
-      core::ptr::copy_nonoverlapping(
-        &x_le as *const f32 as *const u8,
-        self.0[0..].as_mut_ptr(),
-        core::mem::size_of::<f32>(),
-      );
-    }
-  }
-
-  pub fn y(&self) -> f32 {
-    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
-    unsafe {
-      core::ptr::copy_nonoverlapping(
-        self.0[4..].as_ptr(),
-        mem.as_mut_ptr() as *mut u8,
-        core::mem::size_of::<f32>(),
-      );
-      mem.assume_init()
-    }.from_little_endian()
-  }
-
-  pub fn set_y(&mut self, x: f32) {
-    let x_le = x.to_little_endian();
-    unsafe {
-      core::ptr::copy_nonoverlapping(
-        &x_le as *const f32 as *const u8,
-        self.0[4..].as_mut_ptr(),
-        core::mem::size_of::<f32>(),
-      );
-    }
-  }
-
-  pub fn z(&self) -> f32 {
-    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
-    unsafe {
-      core::ptr::copy_nonoverlapping(
-        self.0[8..].as_ptr(),
-        mem.as_mut_ptr() as *mut u8,
-        core::mem::size_of::<f32>(),
-      );
-      mem.assume_init()
-    }.from_little_endian()
-  }
-
-  pub fn set_z(&mut self, x: f32) {
-    let x_le = x.to_little_endian();
-    unsafe {
-      core::ptr::copy_nonoverlapping(
-        &x_le as *const f32 as *const u8,
-        self.0[8..].as_mut_ptr(),
-        core::mem::size_of::<f32>(),
-      );
-    }
-  }
-
-  pub fn unpack(&self) -> Vec3T {
-    Vec3T {
-      x: self.x(),
-      y: self.y(),
-      z: self.z(),
-    }
-  }
-}
-
-#[derive(Debug, Clone, PartialEq, Default)]
-pub struct Vec3T {
-  pub x: f32,
-  pub y: f32,
-  pub z: f32,
-}
-impl Vec3T {
-  pub fn pack(&self) -> Vec3 {
-    Vec3::new(
-      self.x,
-      self.y,
-      self.z,
-    )
-  }
-}
-
-pub enum MonsterOffset {}
-#[derive(Copy, Clone, PartialEq)]
-
-pub struct Monster<'a> {
-  pub _tab: flatbuffers::Table<'a>,
-}
-
-impl<'a> flatbuffers::Follow<'a> for Monster<'a> {
-    type Inner = Monster<'a>;
-    #[inline]
-    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
-        Self { _tab: flatbuffers::Table { buf, loc } }
-    }
-}
-
-impl<'a> Monster<'a> {
-    #[inline]
-    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
-        Monster { _tab: table }
-    }
-    #[allow(unused_mut)]
-    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
-        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
-        args: &'args MonsterArgs<'args>) -> flatbuffers::WIPOffset<Monster<'bldr>> {
-      let mut builder = MonsterBuilder::new(_fbb);
-      if let Some(x) = args.path { builder.add_path(x); }
-      if let Some(x) = args.equipped { builder.add_equipped(x); }
-      if let Some(x) = args.weapons { builder.add_weapons(x); }
-      if let Some(x) = args.inventory { builder.add_inventory(x); }
-      if let Some(x) = args.name { builder.add_name(x); }
-      if let Some(x) = args.pos { builder.add_pos(x); }
-      builder.add_hp(args.hp);
-      builder.add_mana(args.mana);
-      builder.add_equipped_type(args.equipped_type);
-      builder.add_color(args.color);
-      builder.finish()
-    }
-
-    pub fn unpack(&self) -> MonsterT {
-      let pos = self.pos().map(|x| {
-        x.unpack()
-      });
-      let mana = self.mana();
-      let hp = self.hp();
-      let name = self.name().map(|x| {
-        x.to_string()
-      });
-      let inventory = self.inventory().map(|x| {
-        x.to_vec()
-      });
-      let color = self.color();
-      let weapons = self.weapons().map(|x| {
-        x.iter().map(|t| t.unpack()).collect()
-      });
-      let equipped = match self.equipped_type() {
-        Equipment::NONE => EquipmentT::NONE,
-        Equipment::Weapon => EquipmentT::Weapon(Box::new(
-          self.equipped_as_weapon()
-              .expect("Invalid union table, expected `Equipment::Weapon`.")
-              .unpack()
-        )),
-        _ => EquipmentT::NONE,
-      };
-      let path = self.path().map(|x| {
-        x.iter().map(|t| t.unpack()).collect()
-      });
-      MonsterT {
-        pos,
-        mana,
-        hp,
-        name,
-        inventory,
-        color,
-        weapons,
-        equipped,
-        path,
-      }
-    }
-    pub const VT_POS: flatbuffers::VOffsetT = 4;
-    pub const VT_MANA: flatbuffers::VOffsetT = 6;
-    pub const VT_HP: flatbuffers::VOffsetT = 8;
-    pub const VT_NAME: flatbuffers::VOffsetT = 10;
-    pub const VT_INVENTORY: flatbuffers::VOffsetT = 14;
-    pub const VT_COLOR: flatbuffers::VOffsetT = 16;
-    pub const VT_WEAPONS: flatbuffers::VOffsetT = 18;
-    pub const VT_EQUIPPED_TYPE: flatbuffers::VOffsetT = 20;
-    pub const VT_EQUIPPED: flatbuffers::VOffsetT = 22;
-    pub const VT_PATH: flatbuffers::VOffsetT = 24;
-
-  #[inline]
-  pub fn pos(&self) -> Option<&'a Vec3> {
-    self._tab.get::<Vec3>(Monster::VT_POS, None)
-  }
-  #[inline]
-  pub fn mana(&self) -> i16 {
-    self._tab.get::<i16>(Monster::VT_MANA, Some(150)).unwrap()
-  }
-  #[inline]
-  pub fn hp(&self) -> i16 {
-    self._tab.get::<i16>(Monster::VT_HP, Some(100)).unwrap()
-  }
-  #[inline]
-  pub fn name(&self) -> Option<&'a str> {
-    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Monster::VT_NAME, None)
-  }
-  #[inline]
-  pub fn inventory(&self) -> Option<&'a [u8]> {
-    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_INVENTORY, None).map(|v| v.safe_slice())
-  }
-  #[inline]
-  pub fn color(&self) -> Color {
-    self._tab.get::<Color>(Monster::VT_COLOR, Some(Color::Blue)).unwrap()
-  }
-  #[inline]
-  pub fn weapons(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Weapon<'a>>>> {
-    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Weapon>>>>(Monster::VT_WEAPONS, None)
-  }
-  #[inline]
-  pub fn equipped_type(&self) -> Equipment {
-    self._tab.get::<Equipment>(Monster::VT_EQUIPPED_TYPE, Some(Equipment::NONE)).unwrap()
-  }
-  #[inline]
-  pub fn equipped(&self) -> Option<flatbuffers::Table<'a>> {
-    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_EQUIPPED, None)
-  }
-  #[inline]
-  pub fn path(&self) -> Option<&'a [Vec3]> {
-    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vec3>>>(Monster::VT_PATH, None).map(|v| v.safe_slice())
-  }
-  #[inline]
-  #[allow(non_snake_case)]
-  pub fn equipped_as_weapon(&self) -> Option<Weapon<'a>> {
-    if self.equipped_type() == Equipment::Weapon {
-      self.equipped().map(Weapon::init_from_table)
-    } else {
-      None
-    }
-  }
-
-}
-
-impl flatbuffers::Verifiable for Monster<'_> {
-  #[inline]
-  fn run_verifier(
-    v: &mut flatbuffers::Verifier, pos: usize
-  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
-    use self::flatbuffers::Verifiable;
-    v.visit_table(pos)?
-     .visit_field::<Vec3>(&"pos", Self::VT_POS, false)?
-     .visit_field::<i16>(&"mana", Self::VT_MANA, false)?
-     .visit_field::<i16>(&"hp", Self::VT_HP, false)?
-     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
-     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(&"inventory", Self::VT_INVENTORY, false)?
-     .visit_field::<Color>(&"color", Self::VT_COLOR, false)?
-     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Weapon>>>>(&"weapons", Self::VT_WEAPONS, false)?
-     .visit_union::<Equipment, _>(&"equipped_type", Self::VT_EQUIPPED_TYPE, &"equipped", Self::VT_EQUIPPED, false, |key, v, pos| {
-        match key {
-          Equipment::Weapon => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Weapon>>("Equipment::Weapon", pos),
-          _ => Ok(()),
-        }
-     })?
-     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vec3>>>(&"path", Self::VT_PATH, false)?
-     .finish();
-    Ok(())
-  }
-}
-pub struct MonsterArgs<'a> {
-    pub pos: Option<&'a Vec3>,
-    pub mana: i16,
-    pub hp: i16,
-    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
-    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
-    pub color: Color,
-    pub weapons: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Weapon<'a>>>>>,
-    pub equipped_type: Equipment,
-    pub equipped: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
-    pub path: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vec3>>>,
-}
-impl<'a> Default for MonsterArgs<'a> {
-    #[inline]
-    fn default() -> Self {
-        MonsterArgs {
-            pos: None,
-            mana: 150,
-            hp: 100,
-            name: None,
-            inventory: None,
-            color: Color::Blue,
-            weapons: None,
-            equipped_type: Equipment::NONE,
-            equipped: None,
-            path: None,
-        }
-    }
-}
-pub struct MonsterBuilder<'a: 'b, 'b> {
-  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
-  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
-}
-impl<'a: 'b, 'b> MonsterBuilder<'a, 'b> {
-  #[inline]
-  pub fn add_pos(&mut self, pos: &Vec3) {
-    self.fbb_.push_slot_always::<&Vec3>(Monster::VT_POS, pos);
-  }
-  #[inline]
-  pub fn add_mana(&mut self, mana: i16) {
-    self.fbb_.push_slot::<i16>(Monster::VT_MANA, mana, 150);
-  }
-  #[inline]
-  pub fn add_hp(&mut self, hp: i16) {
-    self.fbb_.push_slot::<i16>(Monster::VT_HP, hp, 100);
-  }
-  #[inline]
-  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
-    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_NAME, name);
-  }
-  #[inline]
-  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
-    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_INVENTORY, inventory);
-  }
-  #[inline]
-  pub fn add_color(&mut self, color: Color) {
-    self.fbb_.push_slot::<Color>(Monster::VT_COLOR, color, Color::Blue);
-  }
-  #[inline]
-  pub fn add_weapons(&mut self, weapons: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Weapon<'b >>>>) {
-    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_WEAPONS, weapons);
-  }
-  #[inline]
-  pub fn add_equipped_type(&mut self, equipped_type: Equipment) {
-    self.fbb_.push_slot::<Equipment>(Monster::VT_EQUIPPED_TYPE, equipped_type, Equipment::NONE);
-  }
-  #[inline]
-  pub fn add_equipped(&mut self, equipped: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
-    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_EQUIPPED, equipped);
-  }
-  #[inline]
-  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vec3>>) {
-    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_PATH, path);
-  }
-  #[inline]
-  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MonsterBuilder<'a, 'b> {
-    let start = _fbb.start_table();
-    MonsterBuilder {
-      fbb_: _fbb,
-      start_: start,
-    }
-  }
-  #[inline]
-  pub fn finish(self) -> flatbuffers::WIPOffset<Monster<'a>> {
-    let o = self.fbb_.end_table(self.start_);
-    flatbuffers::WIPOffset::new(o.value())
-  }
-}
-
-impl std::fmt::Debug for Monster<'_> {
-  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-    let mut ds = f.debug_struct("Monster");
-      ds.field("pos", &self.pos());
-      ds.field("mana", &self.mana());
-      ds.field("hp", &self.hp());
-      ds.field("name", &self.name());
-      ds.field("inventory", &self.inventory());
-      ds.field("color", &self.color());
-      ds.field("weapons", &self.weapons());
-      ds.field("equipped_type", &self.equipped_type());
-      match self.equipped_type() {
-        Equipment::Weapon => {
-          if let Some(x) = self.equipped_as_weapon() {
-            ds.field("equipped", &x)
-          } else {
-            ds.field("equipped", &"InvalidFlatbuffer: Union discriminant does not match value.")
-          }
-        },
-        _ => {
-          let x: Option<()> = None;
-          ds.field("equipped", &x)
-        },
-      };
-      ds.field("path", &self.path());
-      ds.finish()
-  }
-}
-#[non_exhaustive]
-#[derive(Debug, Clone, PartialEq)]
-pub struct MonsterT {
-  pub pos: Option<Vec3T>,
-  pub mana: i16,
-  pub hp: i16,
-  pub name: Option<String>,
-  pub inventory: Option<Vec<u8>>,
-  pub color: Color,
-  pub weapons: Option<Vec<WeaponT>>,
-  pub equipped: EquipmentT,
-  pub path: Option<Vec<Vec3T>>,
-}
-impl Default for MonsterT {
-  fn default() -> Self {
-    Self {
-      pos: None,
-      mana: 150,
-      hp: 100,
-      name: None,
-      inventory: None,
-      color: Color::Blue,
-      weapons: None,
-      equipped: EquipmentT::NONE,
-      path: None,
-    }
-  }
-}
-impl MonsterT {
-  pub fn pack<'b>(
-    &self,
-    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
-  ) -> flatbuffers::WIPOffset<Monster<'b>> {
-    let pos_tmp = self.pos.as_ref().map(|x| x.pack());
-    let pos = pos_tmp.as_ref();
-    let mana = self.mana;
-    let hp = self.hp;
-    let name = self.name.as_ref().map(|x|{
-      _fbb.create_string(x)
-    });
-    let inventory = self.inventory.as_ref().map(|x|{
-      _fbb.create_vector(x)
-    });
-    let color = self.color;
-    let weapons = self.weapons.as_ref().map(|x|{
-      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
-    });
-    let equipped_type = self.equipped.equipment_type();
-    let equipped = self.equipped.pack(_fbb);
-    let path = self.path.as_ref().map(|x|{
-      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
-    });
-    Monster::create(_fbb, &MonsterArgs{
-      pos,
-      mana,
-      hp,
-      name,
-      inventory,
-      color,
-      weapons,
-      equipped_type,
-      equipped,
-      path,
-    })
-  }
-}
-pub enum WeaponOffset {}
-#[derive(Copy, Clone, PartialEq)]
-
-pub struct Weapon<'a> {
-  pub _tab: flatbuffers::Table<'a>,
-}
-
-impl<'a> flatbuffers::Follow<'a> for Weapon<'a> {
-    type Inner = Weapon<'a>;
-    #[inline]
-    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
-        Self { _tab: flatbuffers::Table { buf, loc } }
-    }
-}
-
-impl<'a> Weapon<'a> {
-    #[inline]
-    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
-        Weapon { _tab: table }
-    }
-    #[allow(unused_mut)]
-    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
-        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
-        args: &'args WeaponArgs<'args>) -> flatbuffers::WIPOffset<Weapon<'bldr>> {
-      let mut builder = WeaponBuilder::new(_fbb);
-      if let Some(x) = args.name { builder.add_name(x); }
-      builder.add_damage(args.damage);
-      builder.finish()
-    }
-
-    pub fn unpack(&self) -> WeaponT {
-      let name = self.name().map(|x| {
-        x.to_string()
-      });
-      let damage = self.damage();
-      WeaponT {
-        name,
-        damage,
-      }
-    }
-    pub const VT_NAME: flatbuffers::VOffsetT = 4;
-    pub const VT_DAMAGE: flatbuffers::VOffsetT = 6;
-
-  #[inline]
-  pub fn name(&self) -> Option<&'a str> {
-    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Weapon::VT_NAME, None)
-  }
-  #[inline]
-  pub fn damage(&self) -> i16 {
-    self._tab.get::<i16>(Weapon::VT_DAMAGE, Some(0)).unwrap()
-  }
-}
-
-impl flatbuffers::Verifiable for Weapon<'_> {
-  #[inline]
-  fn run_verifier(
-    v: &mut flatbuffers::Verifier, pos: usize
-  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
-    use self::flatbuffers::Verifiable;
-    v.visit_table(pos)?
-     .visit_field::<flatbuffers::ForwardsUOffset<&str>>(&"name", Self::VT_NAME, false)?
-     .visit_field::<i16>(&"damage", Self::VT_DAMAGE, false)?
-     .finish();
-    Ok(())
-  }
-}
-pub struct WeaponArgs<'a> {
-    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
-    pub damage: i16,
-}
-impl<'a> Default for WeaponArgs<'a> {
-    #[inline]
-    fn default() -> Self {
-        WeaponArgs {
-            name: None,
-            damage: 0,
-        }
-    }
-}
-pub struct WeaponBuilder<'a: 'b, 'b> {
-  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
-  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
-}
-impl<'a: 'b, 'b> WeaponBuilder<'a, 'b> {
-  #[inline]
-  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
-    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Weapon::VT_NAME, name);
-  }
-  #[inline]
-  pub fn add_damage(&mut self, damage: i16) {
-    self.fbb_.push_slot::<i16>(Weapon::VT_DAMAGE, damage, 0);
-  }
-  #[inline]
-  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WeaponBuilder<'a, 'b> {
-    let start = _fbb.start_table();
-    WeaponBuilder {
-      fbb_: _fbb,
-      start_: start,
-    }
-  }
-  #[inline]
-  pub fn finish(self) -> flatbuffers::WIPOffset<Weapon<'a>> {
-    let o = self.fbb_.end_table(self.start_);
-    flatbuffers::WIPOffset::new(o.value())
-  }
-}
-
-impl std::fmt::Debug for Weapon<'_> {
-  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
-    let mut ds = f.debug_struct("Weapon");
-      ds.field("name", &self.name());
-      ds.field("damage", &self.damage());
-      ds.finish()
-  }
-}
-#[non_exhaustive]
-#[derive(Debug, Clone, PartialEq)]
-pub struct WeaponT {
-  pub name: Option<String>,
-  pub damage: i16,
-}
-impl Default for WeaponT {
-  fn default() -> Self {
-    Self {
-      name: None,
-      damage: 0,
-    }
-  }
-}
-impl WeaponT {
-  pub fn pack<'b>(
-    &self,
-    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
-  ) -> flatbuffers::WIPOffset<Weapon<'b>> {
-    let name = self.name.as_ref().map(|x|{
-      _fbb.create_string(x)
-    });
-    let damage = self.damage;
-    Weapon::create(_fbb, &WeaponArgs{
-      name,
-      damage,
-    })
-  }
-}
-#[inline]
-#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
-pub fn get_root_as_monster<'a>(buf: &'a [u8]) -> Monster<'a> {
-  unsafe { flatbuffers::root_unchecked::<Monster<'a>>(buf) }
-}
-
-#[inline]
-#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
-pub fn get_size_prefixed_root_as_monster<'a>(buf: &'a [u8]) -> Monster<'a> {
-  unsafe { flatbuffers::size_prefixed_root_unchecked::<Monster<'a>>(buf) }
-}
-
-#[inline]
-/// Verifies that a buffer of bytes contains a `Monster`
-/// and returns it.
-/// Note that verification is still experimental and may not
-/// catch every error, or be maximally performant. For the
-/// previous, unchecked, behavior use
-/// `root_as_monster_unchecked`.
-pub fn root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
-  flatbuffers::root::<Monster>(buf)
-}
-#[inline]
-/// Verifies that a buffer of bytes contains a size prefixed
-/// `Monster` and returns it.
-/// Note that verification is still experimental and may not
-/// catch every error, or be maximally performant. For the
-/// previous, unchecked, behavior use
-/// `size_prefixed_root_as_monster_unchecked`.
-pub fn size_prefixed_root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
-  flatbuffers::size_prefixed_root::<Monster>(buf)
-}
-#[inline]
-/// Verifies, with the given options, that a buffer of bytes
-/// contains a `Monster` and returns it.
-/// Note that verification is still experimental and may not
-/// catch every error, or be maximally performant. For the
-/// previous, unchecked, behavior use
-/// `root_as_monster_unchecked`.
-pub fn root_as_monster_with_opts<'b, 'o>(
-  opts: &'o flatbuffers::VerifierOptions,
-  buf: &'b [u8],
-) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
-  flatbuffers::root_with_opts::<Monster<'b>>(opts, buf)
-}
-#[inline]
-/// Verifies, with the given verifier options, that a buffer of
-/// bytes contains a size prefixed `Monster` and returns
-/// it. Note that verification is still experimental and may not
-/// catch every error, or be maximally performant. For the
-/// previous, unchecked, behavior use
-/// `root_as_monster_unchecked`.
-pub fn size_prefixed_root_as_monster_with_opts<'b, 'o>(
-  opts: &'o flatbuffers::VerifierOptions,
-  buf: &'b [u8],
-) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
-  flatbuffers::size_prefixed_root_with_opts::<Monster<'b>>(opts, buf)
-}
-#[inline]
-/// Assumes, without verification, that a buffer of bytes contains a Monster and returns it.
-/// # Safety
-/// Callers must trust the given bytes do indeed contain a valid `Monster`.
-pub unsafe fn root_as_monster_unchecked(buf: &[u8]) -> Monster {
-  flatbuffers::root_unchecked::<Monster>(buf)
-}
-#[inline]
-/// Assumes, without verification, that a buffer of bytes contains a size prefixed Monster and returns it.
-/// # Safety
-/// Callers must trust the given bytes do indeed contain a valid size prefixed `Monster`.
-pub unsafe fn size_prefixed_root_as_monster_unchecked(buf: &[u8]) -> Monster {
-  flatbuffers::size_prefixed_root_unchecked::<Monster>(buf)
-}
-#[inline]
-pub fn finish_monster_buffer<'a, 'b>(
-    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
-    root: flatbuffers::WIPOffset<Monster<'a>>) {
-  fbb.finish(root, None);
-}
-
-#[inline]
-pub fn finish_size_prefixed_monster_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Monster<'a>>) {
-  fbb.finish_size_prefixed(root, None);
-}
-}  // pub mod Sample
-}  // pub mod MyGame
-
diff -urN a/samples/rust_generated/mod.rs b/samples/rust_generated/mod.rs
--- a/samples/rust_generated/mod.rs	1970-01-01 00:00:00.000000000 +0000
+++ b/samples/rust_generated/mod.rs	2023-01-13 07:46:54.482119093 +0000
@@ -0,0 +1,17 @@
+// Automatically generated by the Flatbuffers compiler. Do not modify.
+pub mod my_game {
+  use super::*;
+  pub mod sample {
+    use super::*;
+    mod color_generated;
+    pub use self::color_generated::*;
+    mod equipment_generated;
+    pub use self::equipment_generated::*;
+    mod vec_3_generated;
+    pub use self::vec_3_generated::*;
+    mod monster_generated;
+    pub use self::monster_generated::*;
+    mod weapon_generated;
+    pub use self::weapon_generated::*;
+  } // sample
+} // my_game
diff -urN a/samples/rust_generated/my_game/sample/color_generated.rs b/samples/rust_generated/my_game/sample/color_generated.rs
--- a/samples/rust_generated/my_game/sample/color_generated.rs	1970-01-01 00:00:00.000000000 +0000
+++ b/samples/rust_generated/my_game/sample/color_generated.rs	2023-01-13 07:46:54.705121153 +0000
@@ -0,0 +1,97 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+extern crate flatbuffers;
+use std::mem;
+use std::cmp::Ordering;
+use self::flatbuffers::{EndianScalar, Follow};
+use super::*;
+#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
+pub const ENUM_MIN_COLOR: i8 = 0;
+#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
+pub const ENUM_MAX_COLOR: i8 = 2;
+#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
+#[allow(non_camel_case_types)]
+pub const ENUM_VALUES_COLOR: [Color; 3] = [
+  Color::Red,
+  Color::Green,
+  Color::Blue,
+];
+
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
+#[repr(transparent)]
+pub struct Color(pub i8);
+#[allow(non_upper_case_globals)]
+impl Color {
+  pub const Red: Self = Self(0);
+  pub const Green: Self = Self(1);
+  pub const Blue: Self = Self(2);
+
+  pub const ENUM_MIN: i8 = 0;
+  pub const ENUM_MAX: i8 = 2;
+  pub const ENUM_VALUES: &'static [Self] = &[
+    Self::Red,
+    Self::Green,
+    Self::Blue,
+  ];
+  /// Returns the variant's name or "" if unknown.
+  pub fn variant_name(self) -> Option<&'static str> {
+    match self {
+      Self::Red => Some("Red"),
+      Self::Green => Some("Green"),
+      Self::Blue => Some("Blue"),
+      _ => None,
+    }
+  }
+}
+impl std::fmt::Debug for Color {
+  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+    if let Some(name) = self.variant_name() {
+      f.write_str(name)
+    } else {
+      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
+    }
+  }
+}
+impl<'a> flatbuffers::Follow<'a> for Color {
+  type Inner = Self;
+  #[inline]
+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
+    let b = unsafe {
+      flatbuffers::read_scalar_at::<i8>(buf, loc)
+    };
+    Self(b)
+  }
+}
+
+impl flatbuffers::Push for Color {
+    type Output = Color;
+    #[inline]
+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
+        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
+    }
+}
+
+impl flatbuffers::EndianScalar for Color {
+  #[inline]
+  fn to_little_endian(self) -> Self {
+    let b = i8::to_le(self.0);
+    Self(b)
+  }
+  #[inline]
+  #[allow(clippy::wrong_self_convention)]
+  fn from_little_endian(self) -> Self {
+    let b = i8::from_le(self.0);
+    Self(b)
+  }
+}
+
+impl<'a> flatbuffers::Verifiable for Color {
+  #[inline]
+  fn run_verifier(
+    v: &mut flatbuffers::Verifier, pos: usize
+  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
+    use self::flatbuffers::Verifiable;
+    i8::run_verifier(v, pos)
+  }
+}
+
+impl flatbuffers::SimpleToVerifyInSlice for Color {}
diff -urN a/samples/rust_generated/my_game/sample/equipment_generated.rs b/samples/rust_generated/my_game/sample/equipment_generated.rs
--- a/samples/rust_generated/my_game/sample/equipment_generated.rs	1970-01-01 00:00:00.000000000 +0000
+++ b/samples/rust_generated/my_game/sample/equipment_generated.rs	2023-01-13 07:46:54.854122528 +0000
@@ -0,0 +1,142 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+extern crate flatbuffers;
+use std::mem;
+use std::cmp::Ordering;
+use self::flatbuffers::{EndianScalar, Follow};
+use super::*;
+#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
+pub const ENUM_MIN_EQUIPMENT: u8 = 0;
+#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
+pub const ENUM_MAX_EQUIPMENT: u8 = 1;
+#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
+#[allow(non_camel_case_types)]
+pub const ENUM_VALUES_EQUIPMENT: [Equipment; 2] = [
+  Equipment::NONE,
+  Equipment::Weapon,
+];
+
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
+#[repr(transparent)]
+pub struct Equipment(pub u8);
+#[allow(non_upper_case_globals)]
+impl Equipment {
+  pub const NONE: Self = Self(0);
+  pub const Weapon: Self = Self(1);
+
+  pub const ENUM_MIN: u8 = 0;
+  pub const ENUM_MAX: u8 = 1;
+  pub const ENUM_VALUES: &'static [Self] = &[
+    Self::NONE,
+    Self::Weapon,
+  ];
+  /// Returns the variant's name or "" if unknown.
+  pub fn variant_name(self) -> Option<&'static str> {
+    match self {
+      Self::NONE => Some("NONE"),
+      Self::Weapon => Some("Weapon"),
+      _ => None,
+    }
+  }
+}
+impl std::fmt::Debug for Equipment {
+  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+    if let Some(name) = self.variant_name() {
+      f.write_str(name)
+    } else {
+      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
+    }
+  }
+}
+impl<'a> flatbuffers::Follow<'a> for Equipment {
+  type Inner = Self;
+  #[inline]
+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
+    let b = unsafe {
+      flatbuffers::read_scalar_at::<u8>(buf, loc)
+    };
+    Self(b)
+  }
+}
+
+impl flatbuffers::Push for Equipment {
+    type Output = Equipment;
+    #[inline]
+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
+        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
+    }
+}
+
+impl flatbuffers::EndianScalar for Equipment {
+  #[inline]
+  fn to_little_endian(self) -> Self {
+    let b = u8::to_le(self.0);
+    Self(b)
+  }
+  #[inline]
+  #[allow(clippy::wrong_self_convention)]
+  fn from_little_endian(self) -> Self {
+    let b = u8::from_le(self.0);
+    Self(b)
+  }
+}
+
+impl<'a> flatbuffers::Verifiable for Equipment {
+  #[inline]
+  fn run_verifier(
+    v: &mut flatbuffers::Verifier, pos: usize
+  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
+    use self::flatbuffers::Verifiable;
+    u8::run_verifier(v, pos)
+  }
+}
+
+impl flatbuffers::SimpleToVerifyInSlice for Equipment {}
+pub struct EquipmentUnionTableOffset {}
+
+#[allow(clippy::upper_case_acronyms)]
+#[non_exhaustive]
+#[derive(Debug, Clone, PartialEq)]
+pub enum EquipmentT {
+  NONE,
+  Weapon(Box<WeaponT>),
+}
+impl Default for EquipmentT {
+  fn default() -> Self {
+    Self::NONE
+  }
+}
+impl EquipmentT {
+  pub fn equipment_type(&self) -> Equipment {
+    match self {
+      Self::NONE => Equipment::NONE,
+      Self::Weapon(_) => Equipment::Weapon,
+    }
+  }
+  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
+    match self {
+      Self::NONE => None,
+      Self::Weapon(v) => Some(v.pack(fbb).as_union_value()),
+    }
+  }
+  /// If the union variant matches, return the owned WeaponT, setting the union to NONE.
+  pub fn take_weapon(&mut self) -> Option<Box<WeaponT>> {
+    if let Self::Weapon(_) = self {
+      let v = std::mem::replace(self, Self::NONE);
+      if let Self::Weapon(w) = v {
+        Some(w)
+      } else {
+        unreachable!()
+      }
+    } else {
+      None
+    }
+  }
+  /// If the union variant matches, return a reference to the WeaponT.
+  pub fn as_weapon(&self) -> Option<&WeaponT> {
+    if let Self::Weapon(v) = self { Some(v.as_ref()) } else { None }
+  }
+  /// If the union variant matches, return a mutable reference to the WeaponT.
+  pub fn as_weapon_mut(&mut self) -> Option<&mut WeaponT> {
+    if let Self::Weapon(v) = self { Some(v.as_mut()) } else { None }
+  }
+}
diff -urN a/samples/rust_generated/my_game/sample/monster_generated.rs b/samples/rust_generated/my_game/sample/monster_generated.rs
--- a/samples/rust_generated/my_game/sample/monster_generated.rs	1970-01-01 00:00:00.000000000 +0000
+++ b/samples/rust_generated/my_game/sample/monster_generated.rs	2023-01-13 07:46:54.893122889 +0000
@@ -0,0 +1,445 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+extern crate flatbuffers;
+use std::mem;
+use std::cmp::Ordering;
+use self::flatbuffers::{EndianScalar, Follow};
+use super::*;
+pub enum MonsterOffset {}
+#[derive(Copy, Clone, PartialEq)]
+
+pub struct Monster<'a> {
+  pub _tab: flatbuffers::Table<'a>,
+}
+
+impl<'a> flatbuffers::Follow<'a> for Monster<'a> {
+  type Inner = Monster<'a>;
+  #[inline]
+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
+    Self { _tab: flatbuffers::Table { buf, loc } }
+  }
+}
+
+impl<'a> Monster<'a> {
+  pub const VT_POS: flatbuffers::VOffsetT = 4;
+  pub const VT_MANA: flatbuffers::VOffsetT = 6;
+  pub const VT_HP: flatbuffers::VOffsetT = 8;
+  pub const VT_NAME: flatbuffers::VOffsetT = 10;
+  pub const VT_INVENTORY: flatbuffers::VOffsetT = 14;
+  pub const VT_COLOR: flatbuffers::VOffsetT = 16;
+  pub const VT_WEAPONS: flatbuffers::VOffsetT = 18;
+  pub const VT_EQUIPPED_TYPE: flatbuffers::VOffsetT = 20;
+  pub const VT_EQUIPPED: flatbuffers::VOffsetT = 22;
+  pub const VT_PATH: flatbuffers::VOffsetT = 24;
+
+  pub const fn get_fully_qualified_name() -> &'static str {
+    "MyGame.Sample.Monster"
+  }
+
+  #[inline]
+  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
+    Monster { _tab: table }
+  }
+  #[allow(unused_mut)]
+  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
+    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
+    args: &'args MonsterArgs<'args>
+  ) -> flatbuffers::WIPOffset<Monster<'bldr>> {
+    let mut builder = MonsterBuilder::new(_fbb);
+    if let Some(x) = args.path { builder.add_path(x); }
+    if let Some(x) = args.equipped { builder.add_equipped(x); }
+    if let Some(x) = args.weapons { builder.add_weapons(x); }
+    if let Some(x) = args.inventory { builder.add_inventory(x); }
+    if let Some(x) = args.name { builder.add_name(x); }
+    if let Some(x) = args.pos { builder.add_pos(x); }
+    builder.add_hp(args.hp);
+    builder.add_mana(args.mana);
+    builder.add_equipped_type(args.equipped_type);
+    builder.add_color(args.color);
+    builder.finish()
+  }
+
+  pub fn unpack(&self) -> MonsterT {
+    let pos = self.pos().map(|x| {
+      x.unpack()
+    });
+    let mana = self.mana();
+    let hp = self.hp();
+    let name = self.name().map(|x| {
+      x.to_string()
+    });
+    let inventory = self.inventory().map(|x| {
+      x.to_vec()
+    });
+    let color = self.color();
+    let weapons = self.weapons().map(|x| {
+      x.iter().map(|t| t.unpack()).collect()
+    });
+    let equipped = match self.equipped_type() {
+      Equipment::NONE => EquipmentT::NONE,
+      Equipment::Weapon => EquipmentT::Weapon(Box::new(
+        self.equipped_as_weapon()
+            .expect("Invalid union table, expected `Equipment::Weapon`.")
+            .unpack()
+      )),
+      _ => EquipmentT::NONE,
+    };
+    let path = self.path().map(|x| {
+      x.iter().map(|t| t.unpack()).collect()
+    });
+    MonsterT {
+      pos,
+      mana,
+      hp,
+      name,
+      inventory,
+      color,
+      weapons,
+      equipped,
+      path,
+    }
+  }
+
+  #[inline]
+  pub fn pos(&self) -> Option<&'a Vec3> {
+    self._tab.get::<Vec3>(Monster::VT_POS, None)
+  }
+  #[inline]
+  pub fn mana(&self) -> i16 {
+    self._tab.get::<i16>(Monster::VT_MANA, Some(150)).unwrap()
+  }
+  #[inline]
+  pub fn hp(&self) -> i16 {
+    self._tab.get::<i16>(Monster::VT_HP, Some(100)).unwrap()
+  }
+  #[inline]
+  pub fn name(&self) -> Option<&'a str> {
+    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Monster::VT_NAME, None)
+  }
+  #[inline]
+  pub fn inventory(&self) -> Option<&'a [u8]> {
+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Monster::VT_INVENTORY, None).map(|v| v.safe_slice())
+  }
+  #[inline]
+  pub fn color(&self) -> Color {
+    self._tab.get::<Color>(Monster::VT_COLOR, Some(Color::Blue)).unwrap()
+  }
+  #[inline]
+  pub fn weapons(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Weapon<'a>>>> {
+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Weapon>>>>(Monster::VT_WEAPONS, None)
+  }
+  #[inline]
+  pub fn equipped_type(&self) -> Equipment {
+    self._tab.get::<Equipment>(Monster::VT_EQUIPPED_TYPE, Some(Equipment::NONE)).unwrap()
+  }
+  #[inline]
+  pub fn equipped(&self) -> Option<flatbuffers::Table<'a>> {
+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Monster::VT_EQUIPPED, None)
+  }
+  #[inline]
+  pub fn path(&self) -> Option<&'a [Vec3]> {
+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Vec3>>>(Monster::VT_PATH, None).map(|v| v.safe_slice())
+  }
+  #[inline]
+  #[allow(non_snake_case)]
+  pub fn equipped_as_weapon(&self) -> Option<Weapon<'a>> {
+    if self.equipped_type() == Equipment::Weapon {
+      self.equipped().map(Weapon::init_from_table)
+    } else {
+      None
+    }
+  }
+
+}
+
+impl flatbuffers::Verifiable for Monster<'_> {
+  #[inline]
+  fn run_verifier(
+    v: &mut flatbuffers::Verifier, pos: usize
+  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
+    use self::flatbuffers::Verifiable;
+    v.visit_table(pos)?
+     .visit_field::<Vec3>("pos", Self::VT_POS, false)?
+     .visit_field::<i16>("mana", Self::VT_MANA, false)?
+     .visit_field::<i16>("hp", Self::VT_HP, false)?
+     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
+     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("inventory", Self::VT_INVENTORY, false)?
+     .visit_field::<Color>("color", Self::VT_COLOR, false)?
+     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Weapon>>>>("weapons", Self::VT_WEAPONS, false)?
+     .visit_union::<Equipment, _>("equipped_type", Self::VT_EQUIPPED_TYPE, "equipped", Self::VT_EQUIPPED, false, |key, v, pos| {
+        match key {
+          Equipment::Weapon => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Weapon>>("Equipment::Weapon", pos),
+          _ => Ok(()),
+        }
+     })?
+     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Vec3>>>("path", Self::VT_PATH, false)?
+     .finish();
+    Ok(())
+  }
+}
+pub struct MonsterArgs<'a> {
+    pub pos: Option<&'a Vec3>,
+    pub mana: i16,
+    pub hp: i16,
+    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
+    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
+    pub color: Color,
+    pub weapons: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Weapon<'a>>>>>,
+    pub equipped_type: Equipment,
+    pub equipped: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
+    pub path: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Vec3>>>,
+}
+impl<'a> Default for MonsterArgs<'a> {
+  #[inline]
+  fn default() -> Self {
+    MonsterArgs {
+      pos: None,
+      mana: 150,
+      hp: 100,
+      name: None,
+      inventory: None,
+      color: Color::Blue,
+      weapons: None,
+      equipped_type: Equipment::NONE,
+      equipped: None,
+      path: None,
+    }
+  }
+}
+
+pub struct MonsterBuilder<'a: 'b, 'b> {
+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
+}
+impl<'a: 'b, 'b> MonsterBuilder<'a, 'b> {
+  #[inline]
+  pub fn add_pos(&mut self, pos: &Vec3) {
+    self.fbb_.push_slot_always::<&Vec3>(Monster::VT_POS, pos);
+  }
+  #[inline]
+  pub fn add_mana(&mut self, mana: i16) {
+    self.fbb_.push_slot::<i16>(Monster::VT_MANA, mana, 150);
+  }
+  #[inline]
+  pub fn add_hp(&mut self, hp: i16) {
+    self.fbb_.push_slot::<i16>(Monster::VT_HP, hp, 100);
+  }
+  #[inline]
+  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_NAME, name);
+  }
+  #[inline]
+  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_INVENTORY, inventory);
+  }
+  #[inline]
+  pub fn add_color(&mut self, color: Color) {
+    self.fbb_.push_slot::<Color>(Monster::VT_COLOR, color, Color::Blue);
+  }
+  #[inline]
+  pub fn add_weapons(&mut self, weapons: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Weapon<'b >>>>) {
+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_WEAPONS, weapons);
+  }
+  #[inline]
+  pub fn add_equipped_type(&mut self, equipped_type: Equipment) {
+    self.fbb_.push_slot::<Equipment>(Monster::VT_EQUIPPED_TYPE, equipped_type, Equipment::NONE);
+  }
+  #[inline]
+  pub fn add_equipped(&mut self, equipped: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_EQUIPPED, equipped);
+  }
+  #[inline]
+  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Vec3>>) {
+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Monster::VT_PATH, path);
+  }
+  #[inline]
+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MonsterBuilder<'a, 'b> {
+    let start = _fbb.start_table();
+    MonsterBuilder {
+      fbb_: _fbb,
+      start_: start,
+    }
+  }
+  #[inline]
+  pub fn finish(self) -> flatbuffers::WIPOffset<Monster<'a>> {
+    let o = self.fbb_.end_table(self.start_);
+    flatbuffers::WIPOffset::new(o.value())
+  }
+}
+
+impl std::fmt::Debug for Monster<'_> {
+  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    let mut ds = f.debug_struct("Monster");
+      ds.field("pos", &self.pos());
+      ds.field("mana", &self.mana());
+      ds.field("hp", &self.hp());
+      ds.field("name", &self.name());
+      ds.field("inventory", &self.inventory());
+      ds.field("color", &self.color());
+      ds.field("weapons", &self.weapons());
+      ds.field("equipped_type", &self.equipped_type());
+      match self.equipped_type() {
+        Equipment::Weapon => {
+          if let Some(x) = self.equipped_as_weapon() {
+            ds.field("equipped", &x)
+          } else {
+            ds.field("equipped", &"InvalidFlatbuffer: Union discriminant does not match value.")
+          }
+        },
+        _ => {
+          let x: Option<()> = None;
+          ds.field("equipped", &x)
+        },
+      };
+      ds.field("path", &self.path());
+      ds.finish()
+  }
+}
+#[non_exhaustive]
+#[derive(Debug, Clone, PartialEq)]
+pub struct MonsterT {
+  pub pos: Option<Vec3T>,
+  pub mana: i16,
+  pub hp: i16,
+  pub name: Option<String>,
+  pub inventory: Option<Vec<u8>>,
+  pub color: Color,
+  pub weapons: Option<Vec<WeaponT>>,
+  pub equipped: EquipmentT,
+  pub path: Option<Vec<Vec3T>>,
+}
+impl Default for MonsterT {
+  fn default() -> Self {
+    Self {
+      pos: None,
+      mana: 150,
+      hp: 100,
+      name: None,
+      inventory: None,
+      color: Color::Blue,
+      weapons: None,
+      equipped: EquipmentT::NONE,
+      path: None,
+    }
+  }
+}
+impl MonsterT {
+  pub fn pack<'b>(
+    &self,
+    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
+  ) -> flatbuffers::WIPOffset<Monster<'b>> {
+    let pos_tmp = self.pos.as_ref().map(|x| x.pack());
+    let pos = pos_tmp.as_ref();
+    let mana = self.mana;
+    let hp = self.hp;
+    let name = self.name.as_ref().map(|x|{
+      _fbb.create_string(x)
+    });
+    let inventory = self.inventory.as_ref().map(|x|{
+      _fbb.create_vector(x)
+    });
+    let color = self.color;
+    let weapons = self.weapons.as_ref().map(|x|{
+      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
+    });
+    let equipped_type = self.equipped.equipment_type();
+    let equipped = self.equipped.pack(_fbb);
+    let path = self.path.as_ref().map(|x|{
+      let w: Vec<_> = x.iter().map(|t| t.pack()).collect();_fbb.create_vector(&w)
+    });
+    Monster::create(_fbb, &MonsterArgs{
+      pos,
+      mana,
+      hp,
+      name,
+      inventory,
+      color,
+      weapons,
+      equipped_type,
+      equipped,
+      path,
+    })
+  }
+}
+#[inline]
+#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
+pub fn get_root_as_monster<'a>(buf: &'a [u8]) -> Monster<'a> {
+  unsafe { flatbuffers::root_unchecked::<Monster<'a>>(buf) }
+}
+
+#[inline]
+#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
+pub fn get_size_prefixed_root_as_monster<'a>(buf: &'a [u8]) -> Monster<'a> {
+  unsafe { flatbuffers::size_prefixed_root_unchecked::<Monster<'a>>(buf) }
+}
+
+#[inline]
+/// Verifies that a buffer of bytes contains a `Monster`
+/// and returns it.
+/// Note that verification is still experimental and may not
+/// catch every error, or be maximally performant. For the
+/// previous, unchecked, behavior use
+/// `root_as_monster_unchecked`.
+pub fn root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
+  flatbuffers::root::<Monster>(buf)
+}
+#[inline]
+/// Verifies that a buffer of bytes contains a size prefixed
+/// `Monster` and returns it.
+/// Note that verification is still experimental and may not
+/// catch every error, or be maximally performant. For the
+/// previous, unchecked, behavior use
+/// `size_prefixed_root_as_monster_unchecked`.
+pub fn size_prefixed_root_as_monster(buf: &[u8]) -> Result<Monster, flatbuffers::InvalidFlatbuffer> {
+  flatbuffers::size_prefixed_root::<Monster>(buf)
+}
+#[inline]
+/// Verifies, with the given options, that a buffer of bytes
+/// contains a `Monster` and returns it.
+/// Note that verification is still experimental and may not
+/// catch every error, or be maximally performant. For the
+/// previous, unchecked, behavior use
+/// `root_as_monster_unchecked`.
+pub fn root_as_monster_with_opts<'b, 'o>(
+  opts: &'o flatbuffers::VerifierOptions,
+  buf: &'b [u8],
+) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
+  flatbuffers::root_with_opts::<Monster<'b>>(opts, buf)
+}
+#[inline]
+/// Verifies, with the given verifier options, that a buffer of
+/// bytes contains a size prefixed `Monster` and returns
+/// it. Note that verification is still experimental and may not
+/// catch every error, or be maximally performant. For the
+/// previous, unchecked, behavior use
+/// `root_as_monster_unchecked`.
+pub fn size_prefixed_root_as_monster_with_opts<'b, 'o>(
+  opts: &'o flatbuffers::VerifierOptions,
+  buf: &'b [u8],
+) -> Result<Monster<'b>, flatbuffers::InvalidFlatbuffer> {
+  flatbuffers::size_prefixed_root_with_opts::<Monster<'b>>(opts, buf)
+}
+#[inline]
+/// Assumes, without verification, that a buffer of bytes contains a Monster and returns it.
+/// # Safety
+/// Callers must trust the given bytes do indeed contain a valid `Monster`.
+pub unsafe fn root_as_monster_unchecked(buf: &[u8]) -> Monster {
+  flatbuffers::root_unchecked::<Monster>(buf)
+}
+#[inline]
+/// Assumes, without verification, that a buffer of bytes contains a size prefixed Monster and returns it.
+/// # Safety
+/// Callers must trust the given bytes do indeed contain a valid size prefixed `Monster`.
+pub unsafe fn size_prefixed_root_as_monster_unchecked(buf: &[u8]) -> Monster {
+  flatbuffers::size_prefixed_root_unchecked::<Monster>(buf)
+}
+#[inline]
+pub fn finish_monster_buffer<'a, 'b>(
+    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
+    root: flatbuffers::WIPOffset<Monster<'a>>) {
+  fbb.finish(root, None);
+}
+
+#[inline]
+pub fn finish_size_prefixed_monster_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Monster<'a>>) {
+  fbb.finish_size_prefixed(root, None);
+}
diff -urN a/samples/rust_generated/my_game/sample/vec_3_generated.rs b/samples/rust_generated/my_game/sample/vec_3_generated.rs
--- a/samples/rust_generated/my_game/sample/vec_3_generated.rs	1970-01-01 00:00:00.000000000 +0000
+++ b/samples/rust_generated/my_game/sample/vec_3_generated.rs	2023-01-13 07:46:54.908123027 +0000
@@ -0,0 +1,185 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+extern crate flatbuffers;
+use std::mem;
+use std::cmp::Ordering;
+use self::flatbuffers::{EndianScalar, Follow};
+use super::*;
+// struct Vec3, aligned to 4
+#[repr(transparent)]
+#[derive(Clone, Copy, PartialEq)]
+pub struct Vec3(pub [u8; 12]);
+impl Default for Vec3 { 
+  fn default() -> Self { 
+    Self([0; 12])
+  }
+}
+impl std::fmt::Debug for Vec3 {
+  fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+    f.debug_struct("Vec3")
+      .field("x", &self.x())
+      .field("y", &self.y())
+      .field("z", &self.z())
+      .finish()
+  }
+}
+
+impl flatbuffers::SimpleToVerifyInSlice for Vec3 {}
+impl flatbuffers::SafeSliceAccess for Vec3 {}
+impl<'a> flatbuffers::Follow<'a> for Vec3 {
+  type Inner = &'a Vec3;
+  #[inline]
+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
+    <&'a Vec3>::follow(buf, loc)
+  }
+}
+impl<'a> flatbuffers::Follow<'a> for &'a Vec3 {
+  type Inner = &'a Vec3;
+  #[inline]
+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
+    flatbuffers::follow_cast_ref::<Vec3>(buf, loc)
+  }
+}
+impl<'b> flatbuffers::Push for Vec3 {
+    type Output = Vec3;
+    #[inline]
+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
+        let src = unsafe {
+            ::std::slice::from_raw_parts(self as *const Vec3 as *const u8, Self::size())
+        };
+        dst.copy_from_slice(src);
+    }
+}
+impl<'b> flatbuffers::Push for &'b Vec3 {
+    type Output = Vec3;
+
+    #[inline]
+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
+        let src = unsafe {
+            ::std::slice::from_raw_parts(*self as *const Vec3 as *const u8, Self::size())
+        };
+        dst.copy_from_slice(src);
+    }
+}
+
+impl<'a> flatbuffers::Verifiable for Vec3 {
+  #[inline]
+  fn run_verifier(
+    v: &mut flatbuffers::Verifier, pos: usize
+  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
+    use self::flatbuffers::Verifiable;
+    v.in_buffer::<Self>(pos)
+  }
+}
+
+impl<'a> Vec3 {
+  #[allow(clippy::too_many_arguments)]
+  pub fn new(
+    x: f32,
+    y: f32,
+    z: f32,
+  ) -> Self {
+    let mut s = Self([0; 12]);
+    s.set_x(x);
+    s.set_y(y);
+    s.set_z(z);
+    s
+  }
+
+  pub const fn get_fully_qualified_name() -> &'static str {
+    "MyGame.Sample.Vec3"
+  }
+
+  pub fn x(&self) -> f32 {
+    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
+    unsafe {
+      core::ptr::copy_nonoverlapping(
+        self.0[0..].as_ptr(),
+        mem.as_mut_ptr() as *mut u8,
+        core::mem::size_of::<f32>(),
+      );
+      mem.assume_init()
+    }.from_little_endian()
+  }
+
+  pub fn set_x(&mut self, x: f32) {
+    let x_le = x.to_little_endian();
+    unsafe {
+      core::ptr::copy_nonoverlapping(
+        &x_le as *const f32 as *const u8,
+        self.0[0..].as_mut_ptr(),
+        core::mem::size_of::<f32>(),
+      );
+    }
+  }
+
+  pub fn y(&self) -> f32 {
+    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
+    unsafe {
+      core::ptr::copy_nonoverlapping(
+        self.0[4..].as_ptr(),
+        mem.as_mut_ptr() as *mut u8,
+        core::mem::size_of::<f32>(),
+      );
+      mem.assume_init()
+    }.from_little_endian()
+  }
+
+  pub fn set_y(&mut self, x: f32) {
+    let x_le = x.to_little_endian();
+    unsafe {
+      core::ptr::copy_nonoverlapping(
+        &x_le as *const f32 as *const u8,
+        self.0[4..].as_mut_ptr(),
+        core::mem::size_of::<f32>(),
+      );
+    }
+  }
+
+  pub fn z(&self) -> f32 {
+    let mut mem = core::mem::MaybeUninit::<f32>::uninit();
+    unsafe {
+      core::ptr::copy_nonoverlapping(
+        self.0[8..].as_ptr(),
+        mem.as_mut_ptr() as *mut u8,
+        core::mem::size_of::<f32>(),
+      );
+      mem.assume_init()
+    }.from_little_endian()
+  }
+
+  pub fn set_z(&mut self, x: f32) {
+    let x_le = x.to_little_endian();
+    unsafe {
+      core::ptr::copy_nonoverlapping(
+        &x_le as *const f32 as *const u8,
+        self.0[8..].as_mut_ptr(),
+        core::mem::size_of::<f32>(),
+      );
+    }
+  }
+
+  pub fn unpack(&self) -> Vec3T {
+    Vec3T {
+      x: self.x(),
+      y: self.y(),
+      z: self.z(),
+    }
+  }
+}
+
+#[derive(Debug, Clone, PartialEq, Default)]
+pub struct Vec3T {
+  pub x: f32,
+  pub y: f32,
+  pub z: f32,
+}
+impl Vec3T {
+  pub fn pack(&self) -> Vec3 {
+    Vec3::new(
+      self.x,
+      self.y,
+      self.z,
+    )
+  }
+}
+
diff -urN a/samples/rust_generated/my_game/sample/weapon_generated.rs b/samples/rust_generated/my_game/sample/weapon_generated.rs
--- a/samples/rust_generated/my_game/sample/weapon_generated.rs	1970-01-01 00:00:00.000000000 +0000
+++ b/samples/rust_generated/my_game/sample/weapon_generated.rs	2023-01-13 07:46:55.037124218 +0000
@@ -0,0 +1,157 @@
+// automatically generated by the FlatBuffers compiler, do not modify
+extern crate flatbuffers;
+use std::mem;
+use std::cmp::Ordering;
+use self::flatbuffers::{EndianScalar, Follow};
+use super::*;
+pub enum WeaponOffset {}
+#[derive(Copy, Clone, PartialEq)]
+
+pub struct Weapon<'a> {
+  pub _tab: flatbuffers::Table<'a>,
+}
+
+impl<'a> flatbuffers::Follow<'a> for Weapon<'a> {
+  type Inner = Weapon<'a>;
+  #[inline]
+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
+    Self { _tab: flatbuffers::Table { buf, loc } }
+  }
+}
+
+impl<'a> Weapon<'a> {
+  pub const VT_NAME: flatbuffers::VOffsetT = 4;
+  pub const VT_DAMAGE: flatbuffers::VOffsetT = 6;
+
+  pub const fn get_fully_qualified_name() -> &'static str {
+    "MyGame.Sample.Weapon"
+  }
+
+  #[inline]
+  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
+    Weapon { _tab: table }
+  }
+  #[allow(unused_mut)]
+  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
+    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
+    args: &'args WeaponArgs<'args>
+  ) -> flatbuffers::WIPOffset<Weapon<'bldr>> {
+    let mut builder = WeaponBuilder::new(_fbb);
+    if let Some(x) = args.name { builder.add_name(x); }
+    builder.add_damage(args.damage);
+    builder.finish()
+  }
+
+  pub fn unpack(&self) -> WeaponT {
+    let name = self.name().map(|x| {
+      x.to_string()
+    });
+    let damage = self.damage();
+    WeaponT {
+      name,
+      damage,
+    }
+  }
+
+  #[inline]
+  pub fn name(&self) -> Option<&'a str> {
+    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Weapon::VT_NAME, None)
+  }
+  #[inline]
+  pub fn damage(&self) -> i16 {
+    self._tab.get::<i16>(Weapon::VT_DAMAGE, Some(0)).unwrap()
+  }
+}
+
+impl flatbuffers::Verifiable for Weapon<'_> {
+  #[inline]
+  fn run_verifier(
+    v: &mut flatbuffers::Verifier, pos: usize
+  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
+    use self::flatbuffers::Verifiable;
+    v.visit_table(pos)?
+     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
+     .visit_field::<i16>("damage", Self::VT_DAMAGE, false)?
+     .finish();
+    Ok(())
+  }
+}
+pub struct WeaponArgs<'a> {
+    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
+    pub damage: i16,
+}
+impl<'a> Default for WeaponArgs<'a> {
+  #[inline]
+  fn default() -> Self {
+    WeaponArgs {
+      name: None,
+      damage: 0,
+    }
+  }
+}
+
+pub struct WeaponBuilder<'a: 'b, 'b> {
+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
+}
+impl<'a: 'b, 'b> WeaponBuilder<'a, 'b> {
+  #[inline]
+  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Weapon::VT_NAME, name);
+  }
+  #[inline]
+  pub fn add_damage(&mut self, damage: i16) {
+    self.fbb_.push_slot::<i16>(Weapon::VT_DAMAGE, damage, 0);
+  }
+  #[inline]
+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WeaponBuilder<'a, 'b> {
+    let start = _fbb.start_table();
+    WeaponBuilder {
+      fbb_: _fbb,
+      start_: start,
+    }
+  }
+  #[inline]
+  pub fn finish(self) -> flatbuffers::WIPOffset<Weapon<'a>> {
+    let o = self.fbb_.end_table(self.start_);
+    flatbuffers::WIPOffset::new(o.value())
+  }
+}
+
+impl std::fmt::Debug for Weapon<'_> {
+  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+    let mut ds = f.debug_struct("Weapon");
+      ds.field("name", &self.name());
+      ds.field("damage", &self.damage());
+      ds.finish()
+  }
+}
+#[non_exhaustive]
+#[derive(Debug, Clone, PartialEq)]
+pub struct WeaponT {
+  pub name: Option<String>,
+  pub damage: i16,
+}
+impl Default for WeaponT {
+  fn default() -> Self {
+    Self {
+      name: None,
+      damage: 0,
+    }
+  }
+}
+impl WeaponT {
+  pub fn pack<'b>(
+    &self,
+    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
+  ) -> flatbuffers::WIPOffset<Weapon<'b>> {
+    let name = self.name.as_ref().map(|x|{
+      _fbb.create_string(x)
+    });
+    let damage = self.damage;
+    Weapon::create(_fbb, &WeaponArgs{
+      name,
+      damage,
+    })
+  }
+}
diff -urN a/samples/sample_binary.rs b/samples/sample_binary.rs
--- a/samples/sample_binary.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/samples/sample_binary.rs	2023-01-13 07:46:55.038124227 +0000
@@ -19,10 +19,9 @@
 
 // import the generated code
 #[allow(dead_code, unused_imports)]
-#[path = "./monster_generated.rs"]
 #[allow(clippy::approx_constant)]  // We use low precision PI as a default value.
-mod monster_generated;
-pub use monster_generated::my_game::sample::{Color, Equipment,
+mod rust_generated;
+pub use rust_generated::my_game::sample::{Color, Equipment,
                                              Monster, MonsterArgs,
                                              Vec3,
                                              Weapon, WeaponArgs};
@@ -33,7 +32,7 @@
 fn main() {
   // Build up a serialized buffer algorithmically.
   // Initialize it with a capacity of 1024 bytes.
-  let mut builder = flatbuffers::FlatBufferBuilder::new_with_capacity(1024);
+  let mut builder = flatbuffers::FlatBufferBuilder::with_capacity(1024);
 
   // Serialize some weapons for the Monster: A 'sword' and an 'axe'.
   let weapon_one_name = builder.create_string("Sword");
diff -urN a/samples/sample_flexbuffers.rs b/samples/sample_flexbuffers.rs
--- a/samples/sample_flexbuffers.rs	2021-05-10 18:45:16.000000000 +0000
+++ b/samples/sample_flexbuffers.rs	2023-01-13 07:46:55.038124227 +0000
@@ -16,7 +16,6 @@
 
 use flexbuffers::{BitWidth, Builder, Reader, ReaderError};
 
-
 // In this Example we're creating a monster that corresponds to the following JSON:
 // {
 //     "coins": [5, 10, 25, 25, 25, 100],
diff -urN a/scripts/check-generate-code.sh b/scripts/check-generate-code.sh
--- a/scripts/check-generate-code.sh	2021-05-10 18:45:16.000000000 +0000
+++ b/scripts/check-generate-code.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,36 +0,0 @@
-#!/bin/bash
-#
-# Copyright 2018 Google Inc. All rights reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-set -e
-
-cd tests
-./generate_code.sh
-cd ..
-
-# TODO: Linux and macos builds produce differences here for some reason.
-git checkout HEAD -- tests/monster_test.bfbs
-git checkout HEAD -- tests/arrays_test.bfbs
-git checkout HEAD -- samples/monster.bfbs
-
-if ! git diff --quiet; then
-  echo >&2
-  echo "ERROR: ********************************************************" >&2
-  echo "ERROR: The following differences were found after running the" >&2
-  echo "ERROR: tests/generate_code.sh script.  Maybe you forgot to run" >&2
-  echo "ERROR: it after making changes in a generator or schema?" >&2
-  echo "ERROR: ********************************************************" >&2
-  echo >&2
-  git diff --binary --exit-code
-fi
diff -urN a/scripts/check_generate_code.py b/scripts/check_generate_code.py
--- a/scripts/check_generate_code.py	1970-01-01 00:00:00.000000000 +0000
+++ b/scripts/check_generate_code.py	2023-01-13 07:47:13.358293421 +0000
@@ -0,0 +1,63 @@
+#!/usr/bin/env python3
+#
+# Copyright 2021 Google Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import platform
+import subprocess
+import sys
+from pathlib import Path
+
+# Get the path where this script is located so we can invoke the script from
+# any directory and have the paths work correctly.
+script_path = Path(__file__).parent.resolve()
+
+# Get the root path as an absolute path, so all derived paths are absolute.
+root_path = script_path.parent.absolute()
+
+result = subprocess.run(["git", "diff", "--quiet"], cwd=root_path)
+
+if result.returncode != 0:
+    print(
+        "\n"
+        "ERROR: *********************************************************\n"
+        "ERROR: * The following differences were found after building.  *\n"
+        "ERROR: * Perhaps there is a difference in the flags for the.   *\n"
+        "ERROR: * CMakeLists.txt vs the script/generate_code.py script? *\n"
+        "ERROR: *********************************************************\n"
+    )
+    subprocess.run(["git", "diff", "--binary", "--exit-code"], cwd=root_path)
+    sys.exit(result.returncode)
+
+# Rung the generate_code.py script, forwarding arguments
+gen_cmd = ["scripts/generate_code.py"] + sys.argv[1:]
+if platform.system() == "Windows":
+    gen_cmd = ["py"] + gen_cmd
+subprocess.run(gen_cmd, cwd=root_path)
+
+result = subprocess.run(["git", "diff", "--quiet"], cwd=root_path)
+
+if result.returncode != 0:
+    print(
+        "\n"
+        "ERROR: ********************************************************\n"
+        "ERROR: * The following differences were found after running   *\n"
+        "ERROR: * the script/generate_code.py script. Maybe you forgot *\n"
+        "ERROR: * to run it after making changes in a generator?       *\n"
+        "ERROR: ********************************************************\n"
+    )
+    subprocess.run(["git", "diff", "--binary", "--exit-code"], cwd=root_path)
+    sys.exit(result.returncode)
+
+sys.exit(0)
diff -urN a/scripts/clang-format-all.sh b/scripts/clang-format-all.sh
--- a/scripts/clang-format-all.sh	1970-01-01 00:00:00.000000000 +0000
+++ b/scripts/clang-format-all.sh	2023-01-13 07:47:13.358293421 +0000
@@ -0,0 +1,6 @@
+# Running it twice corrects some bugs in clang-format.
+for run in {1..2}
+do
+  clang-format -i include/flatbuffers/* src/*.cpp tests/*.cpp samples/*.cpp grpc/src/compiler/schema_interface.h grpc/tests/*.cpp
+done
+git checkout include/flatbuffers/reflection_generated.h
diff -urN a/scripts/clang-format-git.sh b/scripts/clang-format-git.sh
--- a/scripts/clang-format-git.sh	1970-01-01 00:00:00.000000000 +0000
+++ b/scripts/clang-format-git.sh	2023-01-13 07:47:13.369293522 +0000
@@ -0,0 +1,6 @@
+# Running it twice corrects some bugs in clang-format.
+for run in {1..2}
+do
+  git clang-format HEAD^ -- include/flatbuffers/* src/*.cpp tests/*.cpp samples/*.cpp grpc/src/compiler/schema_interface.h grpc/tests/*.cpp -f
+done
+git checkout include/flatbuffers/reflection_generated.h
diff -urN a/scripts/generate_code.py b/scripts/generate_code.py
--- a/scripts/generate_code.py	1970-01-01 00:00:00.000000000 +0000
+++ b/scripts/generate_code.py	2023-01-13 07:47:13.370293532 +0000
@@ -0,0 +1,453 @@
+#!/usr/bin/env python3
+#
+# Copyright 2021 Google Inc. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import argparse
+import filecmp
+import glob
+import platform
+import shutil
+import subprocess
+import sys
+from pathlib import Path
+
+parser = argparse.ArgumentParser()
+parser.add_argument(
+    "--flatc",
+    help="path of the Flat C compiler relative to the root directory",
+)
+parser.add_argument("--cpp-0x", action="store_true", help="use --cpp-std c++ox")
+parser.add_argument(
+    "--skip-monster-extra",
+    action="store_true",
+    help="skip generating tests involving monster_extra.fbs",
+)
+parser.add_argument(
+    "--skip-gen-reflection",
+    action="store_true",
+    help="skip generating the reflection.fbs files",
+)
+args = parser.parse_args()
+
+# Get the path where this script is located so we can invoke the script from
+# any directory and have the paths work correctly.
+script_path = Path(__file__).parent.resolve()
+
+# Get the root path as an absolute path, so all derived paths are absolute.
+root_path = script_path.parent.absolute()
+
+# Get the location of the flatc executable, reading from the first command line
+# argument or defaulting to default names.
+flatc_exe = Path(
+    ("flatc" if not platform.system() == "Windows" else "flatc.exe")
+    if not args.flatc
+    else args.flatc
+)
+
+# Find and assert flatc compiler is present.
+if root_path in flatc_exe.parents:
+    flatc_exe = flatc_exe.relative_to(root_path)
+flatc_path = Path(root_path, flatc_exe)
+assert flatc_path.exists(), "Cannot find the flatc compiler " + str(flatc_path)
+
+# Specify the other paths that will be referenced
+tests_path = Path(root_path, "tests")
+samples_path = Path(root_path, "samples")
+reflection_path = Path(root_path, "reflection")
+
+# Execute the flatc compiler with the specified parameters
+def flatc(
+    options, schema, prefix=None, include=None, data=None, cwd=tests_path
+):
+    cmd = [str(flatc_path)] + options
+    if prefix:
+        cmd += ["-o"] + [prefix]
+    if include:
+        cmd += ["-I"] + [include]
+    cmd += [schema] if isinstance(schema, str) else schema
+    if data:
+        cmd += [data] if isinstance(data, str) else data
+    result = subprocess.run(cmd, cwd=str(cwd), check=True)
+
+
+# Generate the code for flatbuffers reflection schema
+def flatc_reflection(options, location, target):
+    full_options = ["--no-prefix"] + options
+    temp_dir = ".tmp"
+    flatc(
+        full_options,
+        prefix=temp_dir,
+        schema="reflection.fbs",
+        cwd=reflection_path,
+    )
+    new_reflection_path = Path(reflection_path, temp_dir, target)
+    original_reflection_path = Path(root_path, location, target)
+    if not filecmp.cmp(str(new_reflection_path), str(original_reflection_path)):
+        shutil.rmtree(str(original_reflection_path))
+        shutil.move(str(new_reflection_path), str(original_reflection_path))
+    shutil.rmtree(str(Path(reflection_path, temp_dir)))
+
+
+# Glob a pattern relative to file path
+def glob(path, pattern):
+    return [str(p) for p in path.glob(pattern)]
+
+
+# flatc options that are shared
+BASE_OPTS = ["--reflect-names", "--gen-mutable", "--gen-object-api"]
+NO_INCL_OPTS = BASE_OPTS + ["--no-includes"]
+
+# Language specific options
+CS_OPTS = ["--csharp", "--cs-gen-json-serializer"]
+CPP_OPTS = [
+    "--cpp",
+    "--gen-compare",
+    "--cpp-ptr-type",
+    "flatbuffers::unique_ptr",
+] + (["--cpp-std", "c++0x"] if args.cpp_0x else [])
+
+CPP_17_OPTS = NO_INCL_OPTS + [
+    "--cpp",
+    "--cpp-std",
+    "c++17",
+    "--cpp-static-reflection",
+    "--gen-object-api",
+]
+RUST_OPTS = BASE_OPTS + ["--rust", "--gen-all", "--gen-name-strings", "--rust-module-root-file"]
+RUST_SERIALIZE_OPTS = BASE_OPTS + [
+    "--rust",
+    "--gen-all",
+    "--gen-name-strings",
+    "--rust-serialize",
+    "--rust-module-root-file",
+]
+TS_OPTS = ["--ts", "--gen-name-strings"]
+LOBSTER_OPTS = ["--lobster"]
+SWIFT_OPTS = ["--swift", "--gen-json-emit", "--bfbs-filenames", str(tests_path)]
+JAVA_OPTS = ["--java"]
+KOTLIN_OPTS = ["--kotlin"]
+PHP_OPTS = ["--php"]
+DART_OPTS = ["--dart"]
+PYTHON_OPTS = ["--python"]
+BINARY_OPTS = ["-b", "--schema", "--bfbs-comments", "--bfbs-builtins"]
+
+# Basic Usage
+
+flatc(
+    NO_INCL_OPTS
+    + CPP_OPTS
+    + CS_OPTS
+    + TS_OPTS
+    + [
+        "--binary",
+        "--java",
+        "--kotlin",
+        "--dart",
+        "--go",
+        "--lobster",
+        "--php",
+    ],
+    schema="monster_test.fbs",
+    include="include_test",
+    data="monsterdata_test.json",
+)
+
+flatc(
+    ["--lua", "--bfbs-filenames", str(tests_path)],
+    schema="monster_test.fbs",
+    include="include_test",
+)
+
+flatc(
+    NO_INCL_OPTS + CPP_OPTS + ["--grpc"],
+    schema="monster_test.fbs",
+    include="include_test",
+    data="monsterdata_test.json",
+)
+
+flatc(
+    RUST_OPTS,
+    schema="monster_test.fbs",
+    include="include_test",
+    prefix="monster_test",
+    data="monsterdata_test.json",
+)
+
+flatc(
+    RUST_SERIALIZE_OPTS,
+    schema="monster_test.fbs",
+    include="include_test",
+    prefix="monster_test_serialize",
+    data="monsterdata_test.json",
+)
+
+flatc(
+    options=BASE_OPTS + ["--python"],
+    schema="monster_test.fbs",
+    include="include_test",
+    data="monsterdata_test.json",
+)
+
+flatc(
+    options=BASE_OPTS + ["--python", "--gen-onefile"],
+    schema="monster_test.fbs",
+    include="include_test",
+    data="monsterdata_test.json",
+)
+
+# For Rust we currently generate two independent schemas, with namespace_test2
+# duplicating the types in namespace_test1
+flatc(
+    RUST_OPTS,
+    prefix="namespace_test",
+    schema=[
+        "namespace_test/namespace_test1.fbs",
+        "namespace_test/namespace_test2.fbs",
+    ],
+)
+
+flatc(
+    BASE_OPTS
+    + CPP_OPTS
+    + CS_OPTS
+    + TS_OPTS
+    + JAVA_OPTS
+    + KOTLIN_OPTS
+    + PHP_OPTS,
+    prefix="union_vector",
+    schema="union_vector/union_vector.fbs",
+)
+
+flatc(
+    BASE_OPTS + TS_OPTS + ["--gen-name-strings", "--gen-mutable"],
+    include="include_test",
+    schema="monster_test.fbs",
+)
+
+flatc(
+    BASE_OPTS + TS_OPTS + ["-b"],
+    include="include_test",
+    schema="monster_test.fbs",
+    data="unicode_test.json",
+)
+
+flatc(
+    BASE_OPTS + TS_OPTS + ["--gen-name-strings"],
+    prefix="union_vector",
+    schema="union_vector/union_vector.fbs",
+)
+
+flatc(
+    RUST_OPTS,
+    prefix="include_test1",
+    include="include_test",
+    schema="include_test/include_test1.fbs",
+)
+
+flatc(
+    RUST_OPTS,
+    prefix="include_test2",
+    include="include_test",
+    schema="include_test/sub/include_test2.fbs",
+)
+
+flatc(
+    BINARY_OPTS + ["--bfbs-filenames", str(tests_path)],
+    include="include_test",
+    schema="monster_test.fbs",
+)
+
+flatc(
+    CPP_OPTS
+    + NO_INCL_OPTS
+    + [
+        "--bfbs-comments",
+        "--bfbs-builtins",
+        "--bfbs-gen-embed",
+        "--bfbs-filenames",
+        str(tests_path),
+    ],
+    include="include_test",
+    schema="monster_test.fbs",
+)
+
+flatc(
+    BINARY_OPTS + ["--bfbs-filenames", str(tests_path)],
+    include="include_test",
+    schema="arrays_test.fbs",
+)
+
+flatc(
+    ["--jsonschema", "--schema"],
+    include="include_test",
+    schema="monster_test.fbs",
+)
+
+if not args.skip_monster_extra:
+    flatc(
+        CPP_OPTS
+        + CS_OPTS
+        + NO_INCL_OPTS
+        + JAVA_OPTS
+        + KOTLIN_OPTS
+        + PYTHON_OPTS,
+        schema="monster_extra.fbs",
+        data="monsterdata_extra.json",
+    )
+
+    flatc(
+        DART_OPTS + ["--gen-object-api"],
+        schema="monster_extra.fbs",
+    )
+
+flatc(
+    CPP_OPTS
+    + CS_OPTS
+    + NO_INCL_OPTS
+    + JAVA_OPTS
+    + ["--jsonschema", "--scoped-enums"],
+    schema="arrays_test.fbs",
+)
+
+flatc(
+    RUST_OPTS,
+    prefix="arrays_test",
+    schema="arrays_test.fbs",
+)
+
+flatc(
+    BASE_OPTS + PYTHON_OPTS,
+    schema="arrays_test.fbs",
+)
+
+
+# Optional Scalars
+optional_scalars_schema = "optional_scalars.fbs"
+flatc(
+    ["--java", "--kotlin", "--lobster", "--ts"], schema=optional_scalars_schema
+)
+
+flatc(["--csharp", "--gen-object-api"], schema=optional_scalars_schema)
+
+flatc(RUST_OPTS, prefix="optional_scalars", schema=optional_scalars_schema)
+
+flatc(NO_INCL_OPTS + CPP_OPTS, schema=optional_scalars_schema)
+
+# Generate string/vector default code for tests
+flatc(RUST_OPTS, prefix="more_defaults", schema="more_defaults.fbs")
+
+# Generate the schema evolution tests
+flatc(
+    CPP_OPTS + ["--scoped-enums"],
+    prefix="evolution_test",
+    schema=glob(tests_path, "evolution_test/evolution_v*.fbs"),
+)
+
+# Generate the keywords tests
+flatc(BASE_OPTS + CS_OPTS, schema="keyword_test.fbs")
+flatc(RUST_OPTS, prefix="keyword_test", schema="keyword_test.fbs")
+flatc(
+    BASE_OPTS + CS_OPTS + ["--cs-global-alias", "--gen-onefile"],
+    prefix="nested_namespace_test",
+    schema=glob(tests_path, "nested_namespace_test/nested_namespace_test*.fbs"),
+)
+
+# Swift Tests
+swift_prefix = "FlatBuffers.Test.Swift/Tests/FlatBuffers.Test.SwiftTests"
+flatc(
+    SWIFT_OPTS + NO_INCL_OPTS + ["--grpc"],
+    schema="monster_test.fbs",
+    include="include_test",
+    prefix=swift_prefix,
+)
+flatc(
+    SWIFT_OPTS + BASE_OPTS,
+    schema="union_vector/union_vector.fbs",
+    prefix=swift_prefix,
+)
+flatc(SWIFT_OPTS, schema="optional_scalars.fbs", prefix=swift_prefix)
+flatc(
+    SWIFT_OPTS + ["--gen-object-api"],
+    schema="more_defaults.fbs",
+    prefix=swift_prefix,
+)
+flatc(
+    SWIFT_OPTS + BASE_OPTS,
+    schema="MutatingBool.fbs",
+    prefix=swift_prefix,
+)
+
+# --filename-suffix and --filename-ext tests
+flatc(
+    CPP_OPTS
+    + NO_INCL_OPTS
+    + ["--filename-suffix", "_suffix", "--filename-ext", "hpp"],
+    include="include_test",
+    schema="monster_test.fbs",
+)
+orig_monster_file = Path(tests_path, "monster_test_generated.h")
+new_monster_file = Path(tests_path, "monster_test_suffix.hpp")
+assert (
+    new_monster_file.exists()
+), "filename suffix option did not produce a file"
+assert filecmp.cmp(
+    str(orig_monster_file), str(new_monster_file)
+), "filename suffix option did not produce identical results"
+new_monster_file.unlink()
+
+# Flag c++17 requires Clang6, GCC7, MSVC2017 (_MSC_VER >= 1914) or higher.
+cpp_17_prefix = "cpp17/generated_cpp17"
+flatc(
+    CPP_17_OPTS,
+    schema="monster_test.fbs",
+    include="include_test",
+    prefix=cpp_17_prefix,
+)
+flatc(
+    CPP_17_OPTS,
+    schema="optional_scalars.fbs",
+    prefix=cpp_17_prefix,
+)
+flatc(
+    CPP_17_OPTS,
+    schema="union_vector/union_vector.fbs",
+    prefix=cpp_17_prefix,
+)
+
+# Sample files
+samples_schema = "monster.fbs"
+flatc(
+    BASE_OPTS + CPP_OPTS + LOBSTER_OPTS, schema=samples_schema, cwd=samples_path
+)
+flatc(
+    RUST_OPTS, prefix="rust_generated", schema=samples_schema, cwd=samples_path
+)
+flatc(
+    BINARY_OPTS + ["--bfbs-filenames", str(samples_path)],
+    schema=samples_schema,
+    cwd=samples_path,
+)
+
+# Reflection
+
+# Skip generating the reflection if told too, as we run this script after
+# building flatc which uses the reflection_generated.h itself.
+if not args.skip_gen_reflection:
+  # C++ Reflection
+  flatc_reflection(["-c", "--cpp-std", "c++0x"], "include/flatbuffers",
+                   "reflection_generated.h")
+
+# Python Reflection
+flatc_reflection(["-p"], "python/flatbuffers", "reflection")
diff -urN a/snap/snapcraft.yaml b/snap/snapcraft.yaml
--- a/snap/snapcraft.yaml	2021-05-10 18:45:16.000000000 +0000
+++ b/snap/snapcraft.yaml	2023-01-13 07:46:55.744130748 +0000
@@ -1,6 +1,6 @@
 name: flatbuffers
 base: core18
-version: git
+adopt-info: flatc
 summary: FlatBuffers compiler
 description: |
   FlatBuffers compiler
@@ -26,10 +26,24 @@
       - -DCMAKE_BUILD_TYPE=Release
     build-packages:
       - g++
+      - git
+    override-pull: |
+      snapcraftctl pull
+      tag=$(git describe --tags --abbrev=0)
+      count=$(git rev-list $tag.. --count)
+      if [ "$count" = 0 ];
+      then
+        version=$tag
+      else
+        hash=$(git rev-parse --short HEAD)
+        version=$tag+git$count.$hash
+      fi
+      snapcraftctl set-version $version
+
 
 apps:
   flatc:
-    command: flatc
+    command: bin/flatc
     plugs:
       - home
       - removable-media
diff -urN a/src/BUILD.bazel b/src/BUILD.bazel
--- a/src/BUILD.bazel	2021-05-10 18:45:16.000000000 +0000
+++ b/src/BUILD.bazel	2023-01-13 07:47:08.194245730 +0000
@@ -17,6 +17,15 @@
         "util.cpp",
     ],
     hdrs = ["//:public_headers"],
+    linkopts = select({
+        # TODO: Bazel uses `clang` instead of `clang++` to link
+        # C++ code on BSD. Temporarily adding these linker flags while
+        # we wait for Bazel to resolve
+        # https://github.com/bazelbuild/bazel/issues/12023.
+        "//:platform_freebsd": ["-lm"],
+        "//:platform_openbsd": ["-lm"],
+        "//conditions:default": [],
+    }),
     strip_include_prefix = "/include",
     visibility = ["//:__pkg__"],
 )
@@ -25,6 +34,9 @@
 cc_library(
     name = "flatc_library",
     srcs = [
+        "bfbs_gen.h",
+        "bfbs_gen_lua.cpp",
+        "bfbs_gen_lua.h",
         "flatc.cpp",
     ],
     hdrs = [
@@ -41,6 +53,9 @@
 cc_library(
     name = "flatc",
     srcs = [
+        "bfbs_gen.h",
+        "bfbs_gen_lua.cpp",
+        "bfbs_gen_lua.h",
         "flatc_main.cpp",
         "idl_gen_cpp.cpp",
         "idl_gen_csharp.cpp",
diff -urN a/src/bfbs_gen.h b/src/bfbs_gen.h
--- a/src/bfbs_gen.h	1970-01-01 00:00:00.000000000 +0000
+++ b/src/bfbs_gen.h	2023-01-13 07:47:08.195245739 +0000
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_BFBS_GEN_H_
+#define FLATBUFFERS_BFBS_GEN_H_
+
+#include <cstdint>
+
+#include "flatbuffers/bfbs_generator.h"
+#include "flatbuffers/reflection_generated.h"
+
+namespace flatbuffers {
+
+void ForAllEnums(
+    const flatbuffers::Vector<flatbuffers::Offset<reflection::Enum>> *enums,
+    std::function<void(const reflection::Enum *)> func) {
+  for (auto it = enums->cbegin(); it != enums->cend(); ++it) { func(*it); }
+}
+
+void ForAllObjects(
+    const flatbuffers::Vector<flatbuffers::Offset<reflection::Object>> *objects,
+    std::function<void(const reflection::Object *)> func) {
+  for (auto it = objects->cbegin(); it != objects->cend(); ++it) { func(*it); }
+}
+
+void ForAllEnumValues(const reflection::Enum *enum_def,
+                      std::function<void(const reflection::EnumVal *)> func) {
+  for (auto it = enum_def->values()->cbegin(); it != enum_def->values()->cend();
+       ++it) {
+    func(*it);
+  }
+}
+
+void ForAllDocumentation(
+    const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>
+        *documentation,
+    std::function<void(const flatbuffers::String *)> func) {
+  if (!documentation) { return; }
+  for (auto it = documentation->cbegin(); it != documentation->cend(); ++it) {
+    func(*it);
+  }
+}
+
+// Maps the field index into object->fields() to the field's ID (the ith element
+// in the return vector).
+static std::vector<uint32_t> FieldIdToIndex(const reflection::Object *object) {
+  std::vector<uint32_t> field_index_by_id;
+  field_index_by_id.resize(object->fields()->size());
+
+  // Create the mapping of field ID to the index into the vector.
+  for (uint32_t i = 0; i < object->fields()->size(); ++i) {
+    auto field = object->fields()->Get(i);
+    field_index_by_id[field->id()] = i;
+  }
+
+  return field_index_by_id;
+}
+
+static bool IsStructOrTable(const reflection::BaseType base_type) {
+  return base_type == reflection::Obj;
+}
+
+static bool IsScalar(const reflection::BaseType base_type) {
+  return base_type >= reflection::UType && base_type <= reflection::Double;
+}
+
+static bool IsFloatingPoint(const reflection::BaseType base_type) {
+  return base_type == reflection::Float || base_type == reflection::Double;
+}
+
+static bool IsBool(const reflection::BaseType base_type) {
+  return base_type == reflection::Bool;
+}
+
+static bool IsSingleByte(const reflection::BaseType base_type) {
+  return base_type >= reflection::UType && base_type <= reflection::UByte;
+}
+
+static bool IsVector(const reflection::BaseType base_type) {
+  return base_type == reflection::Vector;
+}
+
+static std::string MakeCamelCase(const std::string &in,
+                                 bool uppercase_first = true) {
+  std::string s;
+  for (size_t i = 0; i < in.length(); i++) {
+    if (!i && uppercase_first)
+      s += static_cast<char>(::toupper(static_cast<unsigned char>(in[0])));
+    else if (in[i] == '_' && i + 1 < in.length())
+      s += static_cast<char>(::toupper(static_cast<unsigned char>(in[++i])));
+    else
+      s += in[i];
+  }
+  return s;
+}
+
+static std::string Denamespace(const flatbuffers::String *name,
+                               std::string &ns) {
+  const size_t pos = name->str().find_last_of('.');
+  if (pos == std::string::npos) {
+    ns = "";
+    return name->str();
+  }
+  ns = name->str().substr(0, pos);
+  return name->str().substr(pos + 1);
+}
+
+static std::string Denamespace(const flatbuffers::String *name) {
+  std::string ns;
+  return Denamespace(name, ns);
+}
+
+// A concrete base Flatbuffer Generator that specific language generators can
+// derive from.
+class BaseBfbsGenerator : public BfbsGenerator {
+ public:
+  virtual ~BaseBfbsGenerator() {}
+  BaseBfbsGenerator() : schema_(nullptr) {}
+
+  virtual GeneratorStatus GenerateFromSchema(
+      const reflection::Schema *schema) = 0;
+
+  //
+  virtual uint64_t SupportedAdvancedFeatures() const = 0;
+
+  // Override of the Generator::generate method that does the initial
+  // deserialization and verification steps.
+  GeneratorStatus Generate(const uint8_t *buffer,
+                           int64_t length) FLATBUFFERS_OVERRIDE {
+    flatbuffers::Verifier verifier(buffer, static_cast<size_t>(length));
+    if (!reflection::VerifySchemaBuffer(verifier)) {
+      return FAILED_VERIFICATION;
+    }
+
+    // Store the root schema since there are cases where leaf nodes refer to
+    // things in the root schema (e.g., indexing the objects).
+    schema_ = reflection::GetSchema(buffer);
+
+    const uint64_t advance_features = schema_->advanced_features();
+    if (advance_features > SupportedAdvancedFeatures()) {
+      return FAILED_VERIFICATION;
+    }
+
+    GeneratorStatus status = GenerateFromSchema(schema_);
+    schema_ = nullptr;
+    return status;
+  }
+
+ protected:
+  const reflection::Object *GetObject(const reflection::Type *type) const {
+    if (type->index() >= 0 && IsStructOrTable(type->base_type())) {
+      return GetObjectByIndex(type->index());
+    }
+    return nullptr;
+  }
+
+  const reflection::Enum *GetEnum(const reflection::Type *type) const {
+    // TODO(derekbailey): it would be better to have a explicit list of allowed
+    // base types, instead of negating Obj types.
+    if (type->index() >= 0 && !IsStructOrTable(type->base_type())) {
+      return GetEnumByIndex(type->index());
+    }
+    return nullptr;
+  }
+
+  // Used to get a object that is reference by index. (e.g.
+  // reflection::Type::index). Returns nullptr if no object is available.
+  const reflection::Object *GetObjectByIndex(int32_t index) const {
+    if (!schema_ || index < 0 ||
+        index >= static_cast<int32_t>(schema_->objects()->size())) {
+      return nullptr;
+    }
+    return schema_->objects()->Get(index);
+  }
+
+  // Used to get a enum that is reference by index. (e.g.
+  // reflection::Type::index). Returns nullptr if no enum is available.
+  const reflection::Enum *GetEnumByIndex(int32_t index) const {
+    if (!schema_ || index < 0 ||
+        index >= static_cast<int32_t>(schema_->enums()->size())) {
+      return nullptr;
+    }
+    return schema_->enums()->Get(index);
+  }
+
+  void ForAllFields(const reflection::Object *object, bool reverse,
+                    std::function<void(const reflection::Field *)> func) const {
+    const std::vector<uint32_t> field_to_id_map = FieldIdToIndex(object);
+    for (size_t i = 0; i < field_to_id_map.size(); ++i) {
+      func(object->fields()->Get(
+          field_to_id_map[reverse ? field_to_id_map.size() - (i + 1) : i]));
+    }
+  }
+
+  bool IsTable(const reflection::Type *type, bool use_element = false) const {
+    return !IsStruct(type, use_element);
+  }
+
+  bool IsStruct(const reflection::Type *type, bool use_element = false) const {
+    const reflection::BaseType base_type =
+        use_element ? type->element() : type->base_type();
+    return IsStructOrTable(base_type) &&
+           GetObjectByIndex(type->index())->is_struct();
+  }
+
+  const reflection::Schema *schema_;
+};
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_BFBS_GEN_H_
\ No newline at end of file
diff -urN a/src/bfbs_gen_lua.cpp b/src/bfbs_gen_lua.cpp
--- a/src/bfbs_gen_lua.cpp	1970-01-01 00:00:00.000000000 +0000
+++ b/src/bfbs_gen_lua.cpp	2023-01-13 07:47:08.196245748 +0000
@@ -0,0 +1,620 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "bfbs_gen_lua.h"
+
+#include <cstdint>
+#include <map>
+#include <memory>
+#include <string>
+#include <unordered_set>
+#include <vector>
+
+// Ensure no includes to flatc internals. bfbs_gen.h and generator.h are OK.
+#include "bfbs_gen.h"
+#include "flatbuffers/bfbs_generator.h"
+
+// The intermediate representation schema.
+#include "flatbuffers/reflection_generated.h"
+
+namespace flatbuffers {
+namespace {
+
+// To reduce typing
+namespace r = ::reflection;
+
+class LuaBfbsGenerator : public BaseBfbsGenerator {
+ public:
+  explicit LuaBfbsGenerator(const std::string &flatc_version)
+      : BaseBfbsGenerator(),
+        keywords_(),
+        requires_(),
+        current_obj_(nullptr),
+        current_enum_(nullptr),
+        flatc_version_(flatc_version) {
+    static const char *const keywords[] = {
+      "and",      "break",  "do",   "else", "elseif", "end",  "false", "for",
+      "function", "goto",   "if",   "in",   "local",  "nil",  "not",   "or",
+      "repeat",   "return", "then", "true", "until",  "while"
+    };
+    keywords_.insert(std::begin(keywords), std::end(keywords));
+  }
+
+  GeneratorStatus GenerateFromSchema(const r::Schema *schema)
+      FLATBUFFERS_OVERRIDE {
+    if (!GenerateEnums(schema->enums())) { return FAILED; }
+    if (!GenerateObjects(schema->objects(), schema->root_table())) {
+      return FAILED;
+    }
+    return OK;
+  }
+
+  uint64_t SupportedAdvancedFeatures() const FLATBUFFERS_OVERRIDE {
+    return 0xF;
+  }
+
+ protected:
+  bool GenerateEnums(
+      const flatbuffers::Vector<flatbuffers::Offset<r::Enum>> *enums) {
+    ForAllEnums(enums, [&](const r::Enum *enum_def) {
+      std::string code;
+
+      StartCodeBlock(enum_def);
+
+      std::string ns;
+      const std::string enum_name =
+          NormalizeName(Denamespace(enum_def->name(), ns));
+
+      GenerateDocumentation(enum_def->documentation(), "", code);
+      code += "local " + enum_name + " = {\n";
+
+      ForAllEnumValues(enum_def, [&](const reflection::EnumVal *enum_val) {
+        GenerateDocumentation(enum_val->documentation(), "  ", code);
+        code += "  " + NormalizeName(enum_val->name()) + " = " +
+                NumToString(enum_val->value()) + ",\n";
+      });
+      code += "}\n";
+      code += "\n";
+
+      EmitCodeBlock(code, enum_name, ns, enum_def->declaration_file()->str());
+    });
+    return true;
+  }
+
+  bool GenerateObjects(
+      const flatbuffers::Vector<flatbuffers::Offset<r::Object>> *objects,
+      const r::Object *root_object) {
+    ForAllObjects(objects, [&](const r::Object *object) {
+      std::string code;
+
+      StartCodeBlock(object);
+
+      // Register the main flatbuffers module.
+      RegisterRequires("flatbuffers", "flatbuffers");
+
+      std::string ns;
+      const std::string object_name =
+          NormalizeName(Denamespace(object->name(), ns));
+
+      GenerateDocumentation(object->documentation(), "", code);
+
+      code += "local " + object_name + " = {}\n";
+      code += "local mt = {}\n";
+      code += "\n";
+      code += "function " + object_name + ".New()\n";
+      code += "  local o = {}\n";
+      code += "  setmetatable(o, {__index = mt})\n";
+      code += "  return o\n";
+      code += "end\n";
+      code += "\n";
+
+      if (object == root_object) {
+        code += "function " + object_name + ".GetRootAs" + object_name +
+                "(buf, offset)\n";
+        code += "  if type(buf) == \"string\" then\n";
+        code += "    buf = flatbuffers.binaryArray.New(buf)\n";
+        code += "  end\n";
+        code += "\n";
+        code += "  local n = flatbuffers.N.UOffsetT:Unpack(buf, offset)\n";
+        code += "  local o = " + object_name + ".New()\n";
+        code += "  o:Init(buf, n + offset)\n";
+        code += "  return o\n";
+        code += "end\n";
+        code += "\n";
+      }
+
+      // Generates a init method that receives a pre-existing accessor object,
+      // so that objects can be reused.
+
+      code += "function mt:Init(buf, pos)\n";
+      code += "  self.view = flatbuffers.view.New(buf, pos)\n";
+      code += "end\n";
+      code += "\n";
+
+      // Create all the field accessors.
+      ForAllFields(object, /*reverse=*/false, [&](const r::Field *field) {
+        // Skip writing deprecated fields altogether.
+        if (field->deprecated()) { return; }
+
+        const std::string field_name = NormalizeName(field->name());
+        const std::string field_name_camel_case = MakeCamelCase(field_name);
+        const r::BaseType base_type = field->type()->base_type();
+
+        // Generate some fixed strings so we don't repeat outselves later.
+        const std::string getter_signature =
+            "function mt:" + field_name_camel_case + "()\n";
+        const std::string offset_prefix = "local o = self.view:Offset(" +
+                                          NumToString(field->offset()) + ")\n";
+        const std::string offset_prefix_2 = "if o ~= 0 then\n";
+
+        GenerateDocumentation(field->documentation(), "", code);
+
+        if (IsScalar(base_type)) {
+          code += getter_signature;
+
+          if (object->is_struct()) {
+            // TODO(derekbailey): it would be nice to modify the view:Get to
+            // just pass in the offset and not have to add it its own
+            // self.view.pos.
+            code += "  return " + GenerateGetter(field->type()) +
+                    "self.view.pos + " + NumToString(field->offset()) + ")\n";
+          } else {
+            // Table accessors
+            code += "  " + offset_prefix;
+            code += "  " + offset_prefix_2;
+
+            std::string getter =
+                GenerateGetter(field->type()) + "self.view.pos + o)";
+            if (IsBool(base_type)) { getter = "(" + getter + " ~=0)"; }
+            code += "    return " + getter + "\n";
+            code += "  end\n";
+            code += "  return " + DefaultValue(field) + "\n";
+          }
+          code += "end\n";
+          code += "\n";
+        } else {
+          switch (base_type) {
+            case r::String: {
+              code += getter_signature;
+              code += "  " + offset_prefix;
+              code += "  " + offset_prefix_2;
+              code += "    return " + GenerateGetter(field->type()) +
+                      "self.view.pos + o)\n";
+              code += "  end\n";
+              code += "end\n";
+              code += "\n";
+              break;
+            }
+            case r::Obj: {
+              if (object->is_struct()) {
+                code += "function mt:" + field_name_camel_case + "(obj)\n";
+                code += "  obj:Init(self.view.bytes, self.view.pos + " +
+                        NumToString(field->offset()) + ")\n";
+                code += "  return obj\n";
+                code += "end\n";
+                code += "\n";
+              } else {
+                code += getter_signature;
+                code += "  " + offset_prefix;
+                code += "  " + offset_prefix_2;
+
+                const r::Object *field_object = GetObject(field->type());
+                if (!field_object) {
+                  // TODO(derekbailey): this is an error condition. we
+                  // should report it better.
+                  return;
+                }
+                code += "    local x = " +
+                        std::string(
+                            field_object->is_struct()
+                                ? "self.view.pos + o\n"
+                                : "self.view:Indirect(self.view.pos + o)\n");
+                const std::string require_name = RegisterRequires(field);
+                code += "    local obj = " + require_name + ".New()\n";
+                code += "    obj:Init(self.view.bytes, x)\n";
+                code += "    return obj\n";
+                code += "  end\n";
+                code += "end\n";
+                code += "\n";
+              }
+              break;
+            }
+            case r::Union: {
+              code += getter_signature;
+              code += "  " + offset_prefix;
+              code += "  " + offset_prefix_2;
+              code +=
+                  "   local obj = "
+                  "flatbuffers.view.New(flatbuffers.binaryArray.New("
+                  "0), 0)\n";
+              code += "    " + GenerateGetter(field->type()) + "obj, o)\n";
+              code += "    return obj\n";
+              code += "  end\n";
+              code += "end\n";
+              code += "\n";
+              break;
+            }
+            case r::Array:
+            case r::Vector: {
+              const r::BaseType vector_base_type = field->type()->element();
+              int32_t element_size = field->type()->element_size();
+              code += "function mt:" + field_name_camel_case + "(j)\n";
+              code += "  " + offset_prefix;
+              code += "  " + offset_prefix_2;
+
+              if (IsStructOrTable(vector_base_type)) {
+                code += "    local x = self.view:Vector(o)\n";
+                code +=
+                    "    x = x + ((j-1) * " + NumToString(element_size) + ")\n";
+                if (IsTable(field->type(), /*use_element=*/true)) {
+                  code += "    x = self.view:Indirect(x)\n";
+                } else {
+                  // Vector of structs are inline, so we need to query the
+                  // size of the struct.
+                  const reflection::Object *obj =
+                      GetObjectByIndex(field->type()->index());
+                  element_size = obj->bytesize();
+                }
+
+                // Include the referenced type, thus we need to make sure
+                // we set `use_element` to true.
+                const std::string require_name =
+                    RegisterRequires(field, /*use_element=*/true);
+                code += "    local obj = " + require_name + ".New()\n";
+                code += "    obj:Init(self.view.bytes, x)\n";
+                code += "    return obj\n";
+              } else {
+                code += "    local a = self.view:Vector(o)\n";
+                code += "    return " + GenerateGetter(field->type()) +
+                        "a + ((j-1) * " + NumToString(element_size) + "))\n";
+              }
+              code += "  end\n";
+              // Only generate a default value for those types that are
+              // supported.
+              if (!IsStructOrTable(vector_base_type)) {
+                code +=
+                    "  return " +
+                    std::string(vector_base_type == r::String ? "''\n" : "0\n");
+              }
+              code += "end\n";
+              code += "\n";
+
+              // If the vector is composed of single byte values, we
+              // generate a helper function to get it as a byte string in
+              // Lua.
+              if (IsSingleByte(vector_base_type)) {
+                code += "function mt:" + field_name_camel_case +
+                        "AsString(start, stop)\n";
+                code += "  return self.view:VectorAsString(" +
+                        NumToString(field->offset()) + ", start, stop)\n";
+                code += "end\n";
+                code += "\n";
+              }
+
+              // We also make a new accessor to query just the length of the
+              // vector.
+              code += "function mt:" + field_name_camel_case + "Length()\n";
+              code += "  " + offset_prefix;
+              code += "  " + offset_prefix_2;
+              code += "    return self.view:VectorLen(o)\n";
+              code += "  end\n";
+              code += "  return 0\n";
+              code += "end\n";
+              code += "\n";
+              break;
+            }
+            default: {
+              return;
+            }
+          }
+        }
+        return;
+      });
+
+      // Create all the builders
+      if (object->is_struct()) {
+        code += "function " + object_name + ".Create" + object_name +
+                "(builder" + GenerateStructBuilderArgs(object) + ")\n";
+        code += AppendStructBuilderBody(object);
+        code += "  return builder:Offset()\n";
+        code += "end\n";
+        code += "\n";
+      } else {
+        // Table builders
+        code += "function " + object_name + ".Start(builder)\n";
+        code += "  builder:StartObject(" +
+                NumToString(object->fields()->size()) + ")\n";
+        code += "end\n";
+        code += "\n";
+
+        ForAllFields(object, /*reverse=*/false, [&](const r::Field *field) {
+          if (field->deprecated()) { return; }
+
+          const std::string field_name = NormalizeName(field->name());
+
+          code += "function " + object_name + ".Add" +
+                  MakeCamelCase(field_name) + "(builder, " +
+                  MakeCamelCase(field_name, false) + ")\n";
+          code += "  builder:Prepend" + GenerateMethod(field) + "Slot(" +
+                  NumToString(field->id()) + ", " +
+                  MakeCamelCase(field_name, false) + ", " +
+                  DefaultValue(field) + ")\n";
+          code += "end\n";
+          code += "\n";
+
+          if (IsVector(field->type()->base_type())) {
+            code += "function " + object_name + ".Start" +
+                    MakeCamelCase(field_name) + "Vector(builder, numElems)\n";
+
+            const int32_t element_size = field->type()->element_size();
+            int32_t alignment = 0;
+            if (IsStruct(field->type(), /*use_element=*/true)) {
+              alignment = GetObjectByIndex(field->type()->index())->minalign();
+            } else {
+              alignment = element_size;
+            }
+
+            code += "  return builder:StartVector(" +
+                    NumToString(element_size) + ", numElems, " +
+                    NumToString(alignment) + ")\n";
+            code += "end\n";
+            code += "\n";
+          }
+        });
+
+        code += "function " + object_name + ".End(builder)\n";
+        code += "  return builder:EndObject()\n";
+        code += "end\n";
+        code += "\n";
+      }
+
+      EmitCodeBlock(code, object_name, ns, object->declaration_file()->str());
+    });
+    return true;
+  }
+
+ private:
+  void GenerateDocumentation(
+      const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>
+          *documentation,
+      std::string indent, std::string &code) const {
+    flatbuffers::ForAllDocumentation(
+        documentation, [&](const flatbuffers::String *str) {
+          code += indent + "--" + str->str() + "\n";
+        });
+  }
+
+  std::string GenerateStructBuilderArgs(const r::Object *object,
+                                        std::string prefix = "") const {
+    std::string signature;
+    ForAllFields(object, /*reverse=*/false, [&](const r::Field *field) {
+      if (IsStructOrTable(field->type()->base_type())) {
+        const r::Object *field_object = GetObject(field->type());
+        signature += GenerateStructBuilderArgs(
+            field_object, prefix + NormalizeName(field->name()) + "_");
+      } else {
+        signature +=
+            ", " + prefix + MakeCamelCase(NormalizeName(field->name()), false);
+      }
+    });
+    return signature;
+  }
+
+  std::string AppendStructBuilderBody(const r::Object *object,
+                                      std::string prefix = "") const {
+    std::string code;
+    code += "  builder:Prep(" + NumToString(object->minalign()) + ", " +
+            NumToString(object->bytesize()) + ")\n";
+
+    // We need to reverse the order we iterate over, since we build the
+    // buffer backwards.
+    ForAllFields(object, /*reverse=*/true, [&](const r::Field *field) {
+      const int32_t num_padding_bytes = field->padding();
+      if (num_padding_bytes) {
+        code += "  builder:Pad(" + NumToString(num_padding_bytes) + ")\n";
+      }
+      if (IsStructOrTable(field->type()->base_type())) {
+        const r::Object *field_object = GetObject(field->type());
+        code += AppendStructBuilderBody(
+            field_object, prefix + NormalizeName(field->name()) + "_");
+      } else {
+        code += "  builder:Prepend" + GenerateMethod(field) + "(" + prefix +
+                MakeCamelCase(NormalizeName(field->name()), false) + ")\n";
+      }
+    });
+
+    return code;
+  }
+
+  std::string GenerateMethod(const r::Field *field) const {
+    const r::BaseType base_type = field->type()->base_type();
+    if (IsScalar(base_type)) { return MakeCamelCase(GenerateType(base_type)); }
+    if (IsStructOrTable(base_type)) { return "Struct"; }
+    return "UOffsetTRelative";
+  }
+
+  std::string GenerateGetter(const r::Type *type,
+                             bool element_type = false) const {
+    switch (element_type ? type->element() : type->base_type()) {
+      case r::String: return "self.view:String(";
+      case r::Union: return "self.view:Union(";
+      case r::Vector: return GenerateGetter(type, true);
+      default:
+        return "self.view:Get(flatbuffers.N." +
+               MakeCamelCase(GenerateType(type, element_type)) + ", ";
+    }
+  }
+
+  std::string GenerateType(const r::Type *type,
+                           bool element_type = false) const {
+    const r::BaseType base_type =
+        element_type ? type->element() : type->base_type();
+    if (IsScalar(base_type)) { return GenerateType(base_type); }
+    switch (base_type) {
+      case r::String: return "string";
+      case r::Vector: return GenerateGetter(type, true);
+      case r::Obj: {
+        const r::Object *obj = GetObject(type);
+        return NormalizeName(Denamespace(obj->name()));
+      };
+      default: return "*flatbuffers.Table";
+    }
+  }
+
+  std::string GenerateType(const r::BaseType base_type) const {
+    // Need to override the default naming to match the Lua runtime libraries.
+    // TODO(derekbailey): make overloads in the runtime libraries to avoid this.
+    switch (base_type) {
+      case r::None: return "uint8";
+      case r::UType: return "uint8";
+      case r::Byte: return "int8";
+      case r::UByte: return "uint8";
+      case r::Short: return "int16";
+      case r::UShort: return "uint16";
+      case r::Int: return "int32";
+      case r::UInt: return "uint32";
+      case r::Long: return "int64";
+      case r::ULong: return "uint64";
+      case r::Float: return "Float32";
+      case r::Double: return "Float64";
+      default: return r::EnumNameBaseType(base_type);
+    }
+  }
+
+  std::string DefaultValue(const r::Field *field) const {
+    const r::BaseType base_type = field->type()->base_type();
+    if (IsFloatingPoint(base_type)) {
+      return NumToString(field->default_real());
+    }
+    if (IsBool(base_type)) {
+      return field->default_integer() ? "true" : "false";
+    }
+    if (IsScalar(base_type)) { return NumToString((field->default_integer())); }
+    // represents offsets
+    return "0";
+  }
+
+  std::string NormalizeName(const std::string name) const {
+    return keywords_.find(name) == keywords_.end() ? name : "_" + name;
+  }
+
+  std::string NormalizeName(const flatbuffers::String *name) const {
+    return NormalizeName(name->str());
+  }
+
+  void StartCodeBlock(const reflection::Enum *enum_def) {
+    current_enum_ = enum_def;
+    current_obj_ = nullptr;
+    requires_.clear();
+  }
+
+  void StartCodeBlock(const reflection::Object *object) {
+    current_obj_ = object;
+    current_enum_ = nullptr;
+    requires_.clear();
+  }
+
+  std::string RegisterRequires(const r::Field *field,
+                               bool use_element = false) {
+    std::string type_name;
+
+    const r::BaseType type =
+        use_element ? field->type()->element() : field->type()->base_type();
+
+    if (IsStructOrTable(type)) {
+      const r::Object *object = GetObjectByIndex(field->type()->index());
+      if (object == current_obj_) { return Denamespace(object->name()); }
+      type_name = object->name()->str();
+    } else {
+      const r::Enum *enum_def = GetEnumByIndex(field->type()->index());
+      if (enum_def == current_enum_) { return Denamespace(enum_def->name()); }
+      type_name = enum_def->name()->str();
+    }
+
+    // Prefix with double __ to avoid name clashing, since these are defined
+    // at the top of the file and have lexical scoping. Replace '.' with '_'
+    // so it can be a legal identifier.
+    std::string name = "__" + type_name;
+    std::replace(name.begin(), name.end(), '.', '_');
+
+    return RegisterRequires(name, type_name);
+  }
+
+  std::string RegisterRequires(const std::string &local_name,
+                               const std::string &requires_name) {
+    requires_[local_name] = requires_name;
+    return local_name;
+  }
+
+  void EmitCodeBlock(const std::string &code_block, const std::string &name,
+                     const std::string &ns,
+                     const std::string &declaring_file) const {
+    const std::string root_type = schema_->root_table()->name()->str();
+    const std::string root_file =
+        schema_->root_table()->declaration_file()->str();
+    const std::string full_qualified_name = ns.empty() ? name : ns + "." + name;
+
+    std::string code = "--[[ " + full_qualified_name + "\n\n";
+    code +=
+        "  Automatically generated by the FlatBuffers compiler, do not "
+        "modify.\n";
+    code += "  Or modify. I'm a message, not a cop.\n";
+    code += "\n";
+    code += "  flatc version: " + flatc_version_ + "\n";
+    code += "\n";
+    code += "  Declared by  : " + declaring_file + "\n";
+    code += "  Rooting type : " + root_type + " (" + root_file + ")\n";
+    code += "\n--]]\n\n";
+
+    if (!requires_.empty()) {
+      for (auto it = requires_.cbegin(); it != requires_.cend(); ++it) {
+        code += "local " + it->first + " = require('" + it->second + "')\n";
+      }
+      code += "\n";
+    }
+
+    code += code_block;
+    code += "return " + name;
+
+    // Namespaces are '.' deliminted, so replace it with the path separator.
+    std::string path = ns;
+
+    if (path.empty()) {
+      path = ".";
+    } else {
+      std::replace(path.begin(), path.end(), '.', '/');
+    }
+
+    // TODO(derekbailey): figure out a save file without depending on util.h
+    EnsureDirExists(path);
+    const std::string file_name = path + "/" + name + ".lua";
+    SaveFile(file_name.c_str(), code, false);
+  }
+
+  std::unordered_set<std::string> keywords_;
+  std::map<std::string, std::string> requires_;
+  const r::Object *current_obj_;
+  const r::Enum *current_enum_;
+  const std::string flatc_version_;
+};
+}  // namespace
+
+std::unique_ptr<BfbsGenerator> NewLuaBfbsGenerator(
+    const std::string &flatc_version) {
+  return std::unique_ptr<LuaBfbsGenerator>(new LuaBfbsGenerator(flatc_version));
+}
+
+}  // namespace flatbuffers
\ No newline at end of file
diff -urN a/src/bfbs_gen_lua.h b/src/bfbs_gen_lua.h
--- a/src/bfbs_gen_lua.h	1970-01-01 00:00:00.000000000 +0000
+++ b/src/bfbs_gen_lua.h	2023-01-13 07:47:08.200245785 +0000
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef FLATBUFFERS_BFBS_GEN_LUA_H_
+#define FLATBUFFERS_BFBS_GEN_LUA_H_
+
+#include <memory>
+#include <string>
+
+#include "flatbuffers/bfbs_generator.h"
+
+namespace flatbuffers {
+
+// Constructs a new Lua Code generator.
+std::unique_ptr<BfbsGenerator> NewLuaBfbsGenerator(
+    const std::string &flatc_version);
+
+}  // namespace flatbuffers
+
+#endif  // FLATBUFFERS_BFBS_GEN_LUA_H_
\ No newline at end of file
diff -urN a/src/clang-format-all.sh b/src/clang-format-all.sh
--- a/src/clang-format-all.sh	2021-05-10 18:45:16.000000000 +0000
+++ b/src/clang-format-all.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-# Running it twice corrects some bugs in clang-format.
-for run in {1..2}
-do
-  clang-format -i -style=file include/flatbuffers/* src/*.cpp tests/*.cpp samples/*.cpp grpc/src/compiler/schema_interface.h grpc/tests/*.cpp
-done
-git checkout include/flatbuffers/reflection_generated.h
diff -urN a/src/clang-format-git.sh b/src/clang-format-git.sh
--- a/src/clang-format-git.sh	2021-05-10 18:45:16.000000000 +0000
+++ b/src/clang-format-git.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-# Running it twice corrects some bugs in clang-format.
-for run in {1..2}
-do
-  git clang-format HEAD^ -- include/flatbuffers/* src/*.cpp tests/*.cpp samples/*.cpp grpc/src/compiler/schema_interface.h grpc/tests/*.cpp
-done
-git checkout include/flatbuffers/reflection_generated.h
diff -urN a/src/code_generators.cpp b/src/code_generators.cpp
--- a/src/code_generators.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/code_generators.cpp	2023-01-13 07:47:08.223245997 +0000
@@ -60,7 +60,7 @@
     // Update the text to everything after the }}.
     text = text.substr(end + 2);
   }
-  if (!text.empty() && string_back(text) == '\\') {
+  if (!text.empty() && text.back() == '\\') {
     text.pop_back();
     ignore_ident_ = true;
     stream_ << text;
@@ -314,14 +314,10 @@
   return this->NaN(static_cast<double>(v));
 }
 
-std::string JavaCSharpMakeRule(const Parser &parser, const std::string &path,
+std::string JavaCSharpMakeRule(const bool java, const Parser &parser,
+                               const std::string &path,
                                const std::string &file_name) {
-  FLATBUFFERS_ASSERT(parser.opts.lang == IDLOptions::kJava ||
-                     parser.opts.lang == IDLOptions::kCSharp);
-
-  std::string file_extension =
-      (parser.opts.lang == IDLOptions::kJava) ? ".java" : ".cs";
-
+  const std::string file_extension = java ? ".java" : ".cs";
   std::string make_rule;
 
   for (auto it = parser.enums_.vec.begin(); it != parser.enums_.vec.end();
@@ -350,6 +346,15 @@
   return make_rule;
 }
 
+std::string JavaMakeRule(const Parser &parser, const std::string &path,
+                         const std::string &file_name) {
+  return JavaCSharpMakeRule(true, parser, path, file_name);
+}
+std::string CSharpMakeRule(const Parser &parser, const std::string &path,
+                           const std::string &file_name) {
+  return JavaCSharpMakeRule(false, parser, path, file_name);
+}
+
 std::string BinaryFileName(const Parser &parser, const std::string &path,
                            const std::string &file_name) {
   auto ext = parser.file_extension_.length() ? parser.file_extension_ : "bin";
diff -urN a/src/flatc.cpp b/src/flatc.cpp
--- a/src/flatc.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/flatc.cpp	2023-01-13 07:47:08.223245997 +0000
@@ -17,6 +17,9 @@
 #include "flatbuffers/flatc.h"
 
 #include <list>
+#include <sstream>
+
+#include "flatbuffers/util.h"
 
 namespace flatbuffers {
 
@@ -56,127 +59,271 @@
   params_.error_fn(this, err, usage, show_exe_name);
 }
 
+const static FlatCOption options[] = {
+  { "o", "", "PATH", "Prefix PATH to all generated files." },
+  { "I", "", "PATH", "Search for includes in the specified path." },
+  { "M", "", "", "Print make rules for generated files." },
+  { "", "version", "", "Print the version number of flatc and exit." },
+  { "h", "help", "", "Prints this help text and exit." },
+  { "", "string-json", "",
+    "Strict JSON: field names must be / will be quoted, no trailing commas in "
+    "tables/vectors." },
+  { "", "allow-non-utf8", "",
+    "Pass non-UTF-8 input through parser and emit nonstandard \\x escapes in "
+    "JSON. (Default is to raise parse error on non-UTF-8 input.)" },
+  { "", "natural-utf8", "",
+    "Output strings with UTF-8 as human-readable strings. By default, UTF-8 "
+    "characters are printed as \\uXXXX escapes." },
+  { "", "defaults-json", "",
+    "Output fields whose value is the default when writing JSON" },
+  { "", "unknown-json", "",
+    "Allow fields in JSON that are not defined in the schema. These fields "
+    "will be discared when generating binaries." },
+  { "", "no-prefix", "",
+    "Don\'t prefix enum values with the enum type in C++." },
+  { "", "scoped-enums", "",
+    "Use C++11 style scoped and strongly typed enums. Also implies "
+    "--no-prefix." },
+  { "", "gen-inclues", "",
+    "(deprecated), this is the default behavior. If the original behavior is "
+    "required (no include statements) use --no-includes." },
+  { "", "no-includes", "",
+    "Don\'t generate include statements for included schemas the generated "
+    "file depends on (C++ / Python)." },
+  { "", "gen-mutable", "",
+    "Generate accessors that can mutate buffers in-place." },
+  { "", "gen-onefile", "",
+    "Generate single output file for C#, Go, and Python." },
+  { "", "gen-name-strings", "",
+    "Generate type name functions for C++ and Rust." },
+  { "", "gen-object-api", "", "Generate an additional object-based API." },
+  { "", "gen-compare", "", "Generate operator== for object-based API types." },
+  { "", "gen-nullable", "",
+    "Add Clang _Nullable for C++ pointer. or @Nullable for Java" },
+  { "", "java-checkerframe", "", "Add @Pure for Java." },
+  { "", "gen-generated", "", "Add @Generated annotation for Java." },
+  { "", "gen-jvmstatic", "",
+    "Add @JvmStatic annotation for Kotlin methods in companion object for "
+    "interop from Java to Kotlin." },
+  { "", "gen-all", "",
+    "Generate not just code for the current schema files, but for all files it "
+    "includes as well. If the language uses a single file for output (by "
+    "default the case for C++ and JS), all code will end up in this one "
+    "file." },
+  { "", "gen-json-emit", "",
+    "Generates encoding code which emits Flatbuffers into JSON" },
+  { "", "cpp-include", "", "Adds an #include in generated file." },
+  { "", "cpp-ptr-type", "T",
+    "Set object API pointer type (default std::unique_ptr)." },
+  { "", "cpp-str-type", "T",
+    "Set object API string type (default std::string). T::c_str(), T::length() "
+    "and T::empty() must be supported. The custom type also needs to be "
+    "constructible from std::string (see the --cpp-str-flex-ctor option to "
+    "change this behavior)" },
+  { "", "cpp-str-flex-ctor", "",
+    "Don't construct custom string types by passing std::string from "
+    "Flatbuffers, but (char* + length)." },
+  { "", "cpp-field-case-style", "STYLE",
+    "Generate C++ fields using selected case style. Supported STYLE values: * "
+    "'unchanged' - leave unchanged (default) * 'upper' - schema snake_case "
+    "emits UpperCamel; * 'lower' - schema snake_case emits lowerCamel." },
+  { "", "cpp-std", "CPP_STD",
+    "Generate a C++ code using features of selected C++ standard. Supported "
+    "CPP_STD values: * 'c++0x' - generate code compatible with old compilers; "
+    "'c++11' - use C++11 code generator (default); * 'c++17' - use C++17 "
+    "features in generated code (experimental)." },
+  { "", "cpp-static-reflection", "",
+    "When using C++17, generate extra code to provide compile-time (static) "
+    "reflection of Flatbuffers types. Requires --cpp-std to be \"c++17\" or "
+    "higher." },
+  { "", "object-prefix", "PREFIX",
+    "Customize class prefix for C++ object-based API." },
+  { "", "object-suffix", "SUFFIX",
+    "Customize class suffix for C++ object-based API. Default Value is "
+    "\"T\"." },
+  { "", "go-namespace", "", "Generate the overriding namespace in Golang." },
+  { "", "go-import", "IMPORT",
+    "Generate the overriding import for flatbuffers in Golang (default is "
+    "\"github.com/google/flatbuffers/go\")." },
+  { "", "raw-binary", "",
+    "Allow binaries without file_identifier to be read. This may crash flatc "
+    "given a mismatched schema." },
+  { "", "size-prefixed", "", "Input binaries are size prefixed buffers." },
+  { "", "proto", "", "Input is a .proto, translate to .fbs." },
+  { "", "proto-namespace-suffix", "SUFFIX",
+    "Add this namespace to any flatbuffers generated from protobufs." },
+  { "", "oneof-union", "", "Translate .proto oneofs to flatbuffer unions." },
+  { "", "grpc", "", "Generate GRPC interfaces for the specified languages." },
+  { "", "schema", "", "Serialize schemas instead of JSON (use with -b)." },
+  { "", "bfbs-filenames", "PATH",
+    "Sets the root path where reflection filenames in reflection.fbs are "
+    "relative to. The 'root' is denoted with  `//`. E.g. if PATH=/a/b/c "
+    "then /a/d/e.fbs will be serialized as //../d/e.fbs. (PATH defaults to the "
+    "directory of the first provided schema file." },
+  { "", "bfbs-comments", "", "Add doc comments to the binary schema files." },
+  { "", "bfbs-builtins", "",
+    "Add builtin attributes to the binary schema files." },
+  { "", "bfbs-gen-embed", "",
+    "Generate code to embed the bfbs schema to the source." },
+  { "", "conform", "FILE",
+    "Specify a schema the following schemas should be an evolution of. Gives "
+    "errors if not." },
+  { "", "conform-includes", "PATH",
+    "Include path for the schema given with --conform PATH" },
+  { "", "filename-suffix", "SUFFIX",
+    "The suffix appended to the generated file names (Default is "
+    "'_generated')." },
+  { "", "filename-ext", "EXT",
+    "The extension appended to the generated file names. Default is "
+    "language-specific (e.g., '.h' for C++)" },
+  { "", "include-prefix", "PATH",
+    "Prefix this PATH to any generated include statements." },
+  { "", "keep-prefix", "",
+    "Keep original prefix of schema include statement." },
+  { "", "reflect-types", "",
+    "Add minimal type reflection to code generation." },
+  { "", "reflect-names", "", "Add minimal type/name reflection." },
+  { "", "rust-serialize", "",
+    "Implement serde::Serialize on generated Rust types." },
+  {"", "rust-module-root-file", "",
+   "Generate rust code in individual files with a module root file."},
+  { "", "root-type", "T", "Select or override the default root_type." },
+  { "", "require-explicit-ids", "",
+    "When parsing schemas, require explicit ids (id: x)." },
+  { "", "force-defaults", "",
+    "Emit default values in binary output from JSON" },
+  { "", "force-empty", "",
+    "When serializing from object API representation, force strings and "
+    "vectors to empty rather than null." },
+  { "", "force-empty-vectors", "",
+    "When serializing from object API representation, force vectors to empty "
+    "rather than null." },
+  { "", "flexbuffers", "",
+    "Used with \"binary\" and \"json\" options, it generates data using "
+    "schema-less FlexBuffers." },
+  { "", "no-warnings", "", "Inhibit all warnings messages." },
+  { "", "warning-as-errors", "", "Treat all warnings as errors." },
+  { "", "cs-global-alias", "",
+    "Prepend \"global::\" to all user generated csharp classes and "
+    "structs." },
+  { "", "cs-gen-json-serializer", "",
+    "Allows (de)serialization of JSON text in the Object API. (requires "
+    "--gen-object-api)." },
+  { "", "json-nested-bytes", "",
+    "Allow a nested_flatbuffer field to be parsed as a vector of bytes"
+    "in JSON, which is unsafe unless checked by a verifier afterwards." },
+};
+
+static void AppendTextWrappedString(std::stringstream &ss, std::string &text,
+                                    size_t max_col, size_t start_col) {
+  size_t max_line_length = max_col - start_col;
+
+  if (text.length() > max_line_length) {
+    size_t ideal_break_location = text.rfind(' ', max_line_length);
+    size_t length = std::min(max_line_length, ideal_break_location);
+    ss << text.substr(0, length) << "\n";
+    ss << std::string(start_col, ' ');
+    std::string rest_of_description = text.substr(
+        ((ideal_break_location < max_line_length || text.at(length) == ' ')
+             ? length + 1
+             : length));
+    AppendTextWrappedString(ss, rest_of_description, max_col, start_col);
+  } else {
+    ss << text;
+  }
+}
+
+static void AppendOption(std::stringstream &ss, const FlatCOption &option,
+                         size_t max_col, size_t min_col_for_description) {
+  size_t chars = 2;
+  ss << "  ";
+  if (!option.short_opt.empty()) {
+    chars += 2 + option.short_opt.length();
+    ss << "-" << option.short_opt;
+    if (!option.long_opt.empty()) {
+      chars++;
+      ss << ",";
+    }
+    ss << " ";
+  }
+  if (!option.long_opt.empty()) {
+    chars += 3 + option.long_opt.length();
+    ss << "--" << option.long_opt << " ";
+  }
+  if (!option.parameter.empty()) {
+    chars += 1 + option.parameter.length();
+    ss << option.parameter << " ";
+  }
+  size_t start_of_description = chars;
+  if (start_of_description > min_col_for_description) {
+    ss << "\n";
+    start_of_description = min_col_for_description;
+    ss << std::string(start_of_description, ' ');
+  } else {
+    while (start_of_description < min_col_for_description) {
+      ss << " ";
+      start_of_description++;
+    }
+  }
+  if (!option.description.empty()) {
+    std::string description = option.description;
+    AppendTextWrappedString(ss, description, max_col, start_of_description);
+  }
+  ss << "\n";
+}
+
+static void AppendShortOption(std::stringstream &ss,
+                              const FlatCOption &option) {
+  if (!option.short_opt.empty()) {
+    ss << "-" << option.short_opt;
+    if (!option.long_opt.empty()) { ss << "|"; }
+  }
+  if (!option.long_opt.empty()) { ss << "--" << option.long_opt; }
+}
+
+std::string FlatCompiler::GetShortUsageString(const char *program_name) const {
+  std::stringstream ss;
+  ss << "Usage: " << program_name << " [";
+  for (size_t i = 0; i < params_.num_generators; ++i) {
+    const Generator &g = params_.generators[i];
+    AppendShortOption(ss, g.option);
+    ss << ", ";
+  }
+  for (const FlatCOption &option : options) {
+    AppendShortOption(ss, option);
+    ss << ", ";
+  }
+  ss.seekp(-2, ss.cur);
+  ss << "]... FILE... [-- FILE...]";
+  std::string help = ss.str();
+  std::stringstream ss_textwrap;
+  AppendTextWrappedString(ss_textwrap, help, 80, 0);
+  return ss_textwrap.str();
+}
+
 std::string FlatCompiler::GetUsageString(const char *program_name) const {
   std::stringstream ss;
   ss << "Usage: " << program_name << " [OPTION]... FILE... [-- FILE...]\n";
   for (size_t i = 0; i < params_.num_generators; ++i) {
     const Generator &g = params_.generators[i];
+    AppendOption(ss, g.option, 80, 25);
+  }
 
-    std::stringstream full_name;
-    full_name << std::setw(16) << std::left << g.generator_opt_long;
-    const char *name = g.generator_opt_short ? g.generator_opt_short : "  ";
-    const char *help = g.generator_help;
-
-    ss << "  " << full_name.str() << " " << name << "    " << help << ".\n";
-  }
-  // clang-format off
-
-  // Output width
-  // 12345678901234567890123456789012345678901234567890123456789012345678901234567890
-  ss <<
-    "  -o PATH                Prefix PATH to all generated files.\n"
-    "  -I PATH                Search for includes in the specified path.\n"
-    "  -M                     Print make rules for generated files.\n"
-    "  --version              Print the version number of flatc and exit.\n"
-    "  --strict-json          Strict JSON: field names must be / will be quoted,\n"
-    "                         no trailing commas in tables/vectors.\n"
-    "  --allow-non-utf8       Pass non-UTF-8 input through parser and emit nonstandard\n"
-    "                         \\x escapes in JSON. (Default is to raise parse error on\n"
-    "                         non-UTF-8 input.)\n"
-    "  --natural-utf8         Output strings with UTF-8 as human-readable strings.\n"
-    "                         By default, UTF-8 characters are printed as \\uXXXX escapes.\n"
-    "  --defaults-json        Output fields whose value is the default when\n"
-    "                         writing JSON\n"
-    "  --unknown-json         Allow fields in JSON that are not defined in the\n"
-    "                         schema. These fields will be discared when generating\n"
-    "                         binaries.\n"
-    "  --no-prefix            Don\'t prefix enum values with the enum type in C++.\n"
-    "  --scoped-enums         Use C++11 style scoped and strongly typed enums.\n"
-    "                         also implies --no-prefix.\n"
-    "  --gen-includes         (deprecated), this is the default behavior.\n"
-    "                         If the original behavior is required (no include\n"
-    "                         statements) use --no-includes.\n"
-    "  --no-includes          Don\'t generate include statements for included\n"
-    "                         schemas the generated file depends on (C++ / Python).\n"
-    "  --gen-mutable          Generate accessors that can mutate buffers in-place.\n"
-    "  --gen-onefile          Generate single output file for C# and Go.\n"
-    "  --gen-name-strings     Generate type name functions for C++ and Rust.\n"
-    "  --gen-object-api       Generate an additional object-based API.\n"
-    "  --gen-compare          Generate operator== for object-based API types.\n"
-    "  --gen-nullable         Add Clang _Nullable for C++ pointer. or @Nullable for Java\n"
-    "  --java-checkerframe    work Add @Pure for Java.\n"
-    "  --gen-generated        Add @Generated annotation for Java\n"
-    "  --gen-jvmstatic        Add @JvmStatic annotation for Kotlin methods\n"
-    "                         in companion object for interop from Java to Kotlin.\n"
-    "  --gen-all              Generate not just code for the current schema files,\n"
-    "                         but for all files it includes as well.\n"
-    "                         If the language uses a single file for output (by default\n"
-    "                         the case for C++ and JS), all code will end up in this one\n"
-    "                         file.\n"
-    "  --cpp-include          Adds an #include in generated file.\n"
-    "  --cpp-ptr-type T       Set object API pointer type (default std::unique_ptr).\n"
-    "  --cpp-str-type T       Set object API string type (default std::string).\n"
-    "                         T::c_str(), T::length() and T::empty() must be supported.\n"
-    "                         The custom type also needs to be constructible from std::string\n"
-    "                         (see the --cpp-str-flex-ctor option to change this behavior).\n"
-    "  --cpp-str-flex-ctor    Don't construct custom string types by passing std::string\n"
-    "                         from Flatbuffers, but (char* + length).\n"
-    "  --cpp-std CPP_STD      Generate a C++ code using features of selected C++ standard.\n"
-    "                         Supported CPP_STD values:\n"
-    "                          * 'c++0x' - generate code compatible with old compilers;\n"
-    "                          * 'c++11' - use C++11 code generator (default);\n"
-    "                          * 'c++17' - use C++17 features in generated code (experimental).\n"
-    "  --cpp-static-reflection When using C++17, generate extra code to provide compile-time\n"
-    "                          (static) reflection of Flatbuffers types.  Requires --cpp-std\n"
-    "                          to be \"c++17\" or higher.\n"
-    "  --object-prefix        Customise class prefix for C++ object-based API.\n"
-    "  --object-suffix        Customise class suffix for C++ object-based API.\n"
-    "                         Default value is \"T\".\n"
-    "  --go-namespace         Generate the overriding namespace in Golang.\n"
-    "  --go-import            Generate the overriding import for flatbuffers in Golang\n"
-    "                         (default is \"github.com/google/flatbuffers/go\").\n"
-    "  --raw-binary           Allow binaries without file_identifier to be read.\n"
-    "                         This may crash flatc given a mismatched schema.\n"
-    "  --size-prefixed        Input binaries are size prefixed buffers.\n"
-    "  --proto                Input is a .proto, translate to .fbs.\n"
-    "  --proto-namespace-suffix Add this namespace to any flatbuffers generated\n"
-    "    SUFFIX                 from protobufs.\n"
-    "  --oneof-union          Translate .proto oneofs to flatbuffer unions.\n"
-    "  --grpc                 Generate GRPC interfaces for the specified languages.\n"
-    "  --schema               Serialize schemas instead of JSON (use with -b).\n"
-    "  --bfbs-comments        Add doc comments to the binary schema files.\n"
-    "  --bfbs-builtins        Add builtin attributes to the binary schema files.\n"
-    "  --bfbs-gen-embed       Generate code to embed the bfbs schema to the source.\n"
-    "  --conform FILE         Specify a schema the following schemas should be\n"
-    "                         an evolution of. Gives errors if not.\n"
-    "  --conform-includes     Include path for the schema given with --conform PATH\n"
-    "  --filename-suffix      The suffix appended to the generated file names.\n"
-    "                         Default is '_generated'.\n"
-    "  --filename-ext         The extension appended to the generated file names.\n"
-    "                         Default is language-specific (e.g., '.h' for C++)\n"
-    "  --include-prefix       Prefix this path to any generated include statements.\n"
-    "    PATH\n"
-    "  --keep-prefix          Keep original prefix of schema include statement.\n"
-    "  --reflect-types        Add minimal type reflection to code generation.\n"
-    "  --reflect-names        Add minimal type/name reflection.\n"
-    "  --root-type T          Select or override the default root_type\n"
-    "  --require-explicit-ids When parsing schemas, require explicit ids (id: x).\n"
-    "  --force-defaults       Emit default values in binary output from JSON\n"
-    "  --force-empty          When serializing from object API representation,\n"
-    "                         force strings and vectors to empty rather than null.\n"
-    "  --force-empty-vectors  When serializing from object API representation,\n"
-    "                         force vectors to empty rather than null.\n"
-    "  --flexbuffers          Used with \"binary\" and \"json\" options, it generates\n"
-    "                         data using schema-less FlexBuffers.\n"
-    "  --no-warnings          Inhibit all warning messages.\n"
-    "FILEs may be schemas (must end in .fbs), binary schemas (must end in .bfbs),\n"
-    "or JSON files (conforming to preceding schema). FILEs after the -- must be\n"
-    "binary flatbuffer format files.\n"
-    "Output files are named using the base file name of the input,\n"
-    "and written to the current directory or the path given by -o.\n"
-    "example: " << program_name << " -c -b schema1.fbs schema2.fbs data.json\n";
-  // 12345678901234567890123456789012345678901234567890123456789012345678901234567890
-  // clang-format on
+  ss << "\n";
+  for (const FlatCOption &option : options) {
+    AppendOption(ss, option, 80, 25);
+  }
+  ss << "\n";
+
+  std::string files_description =
+      "FILEs may be schemas (must end in .fbs), binary schemas (must end in "
+      ".bfbs) or JSON files (conforming to preceding schema). FILEs after the "
+      "-- must be binary flatbuffer format files. Output files are named using "
+      "the base file name of the input, and written to the current directory "
+      "or the path given by -o. example: " +
+      std::string(program_name) + " -c -b schema1.fbs schema2.fbs data.json";
+  AppendTextWrappedString(ss, files_description, 80, 0);
+  ss << "\n";
   return ss.str();
 }
 
@@ -185,6 +332,8 @@
     return 0;
   }
 
+  if (argc <= 1) { Error("Need to provide at least one argument."); }
+
   flatbuffers::IDLOptions opts;
   std::string output_path;
 
@@ -193,6 +342,7 @@
   bool raw_binary = false;
   bool schema_binary = false;
   bool grpc_enabled = false;
+  bool requires_bfbs = false;
   std::vector<std::string> filenames;
   std::list<std::string> include_directories_storage;
   std::vector<const char *> include_directories;
@@ -201,7 +351,9 @@
   size_t binary_files_from = std::numeric_limits<size_t>::max();
   std::string conform_to_schema;
 
-  for (int argi = 0; argi < argc; argi++) {
+  const char *program_name = argv[0];
+
+  for (int argi = 1; argi < argc; argi++) {
     std::string arg = argv[argi];
     if (arg[0] == '-') {
       if (filenames.size() && arg[1] != '-')
@@ -216,6 +368,11 @@
             flatbuffers::PosixPath(argv[argi]));
         include_directories.push_back(
             include_directories_storage.back().c_str());
+      } else if (arg == "--bfbs-filenames") {
+        if (++argi > argc) Error("missing path following: " + arg, true);
+        opts.project_root = argv[argi];
+        if (!DirExists(opts.project_root.c_str()))
+          Error(arg + " is not a directory: " + opts.project_root);
       } else if (arg == "--conform") {
         if (++argi >= argc) Error("missing path following: " + arg, true);
         conform_to_schema = flatbuffers::PosixPath(argv[argi]);
@@ -275,12 +432,25 @@
         opts.cpp_object_api_string_flexible_constructor = true;
       } else if (arg == "--no-cpp-direct-copy") {
         opts.cpp_direct_copy = false;
+      } else if (arg == "--cpp-field-case-style") {
+        if (++argi >= argc) Error("missing case style following: " + arg, true);
+        if (!strcmp(argv[argi], "unchanged"))
+          opts.cpp_object_api_field_case_style =
+              IDLOptions::CaseStyle_Unchanged;
+        else if (!strcmp(argv[argi], "upper"))
+          opts.cpp_object_api_field_case_style = IDLOptions::CaseStyle_Upper;
+        else if (!strcmp(argv[argi], "lower"))
+          opts.cpp_object_api_field_case_style = IDLOptions::CaseStyle_Lower;
+        else
+          Error("unknown case style: " + std::string(argv[argi]), true);
       } else if (arg == "--gen-nullable") {
         opts.gen_nullable = true;
       } else if (arg == "--java-checkerframework") {
         opts.java_checkerframework = true;
       } else if (arg == "--gen-generated") {
         opts.gen_generated = true;
+      } else if (arg == "--gen-json-emit") {
+        opts.gen_json_coders = true;
       } else if (arg == "--object-prefix") {
         if (++argi >= argc) Error("missing prefix following: " + arg, true);
         opts.object_prefix = argv[argi];
@@ -297,6 +467,7 @@
         opts.include_dependence_headers = false;
       } else if (arg == "--gen-onefile") {
         opts.one_file = true;
+        opts.include_dependence_headers = false;
       } else if (arg == "--raw-binary") {
         raw_binary = true;
       } else if (arg == "--size-prefixed") {
@@ -317,6 +488,9 @@
       } else if (arg == "--version") {
         printf("flatc version %s\n", FLATC_VERSION());
         exit(0);
+      } else if (arg == "--help" || arg == "-h") {
+        printf("%s\n", GetUsageString(program_name).c_str());
+        exit(0);
       } else if (arg == "--grpc") {
         grpc_enabled = true;
       } else if (arg == "--bfbs-comments") {
@@ -329,6 +503,10 @@
         opts.mini_reflect = IDLOptions::kTypes;
       } else if (arg == "--reflect-names") {
         opts.mini_reflect = IDLOptions::kTypesAndNames;
+      } else if (arg == "--rust-serialize") {
+        opts.rust_serialize = true;
+      } else if (arg == "--rust-module-root-file") {
+        opts.rust_module_root_file = true;
       } else if (arg == "--require-explicit-ids") {
         opts.require_explicit_ids = true;
       } else if (arg == "--root-type") {
@@ -357,6 +535,8 @@
         opts.gen_jvmstatic = true;
       } else if (arg == "--no-warnings") {
         opts.no_warnings = true;
+      } else if (arg == "--warnings-as-errors") {
+        opts.warnings_as_errors = true;
       } else if (arg == "--cpp-std") {
         if (++argi >= argc)
           Error("missing C++ standard specification" + arg, true);
@@ -365,18 +545,26 @@
         opts.cpp_std = arg.substr(std::string("--cpp-std=").size());
       } else if (arg == "--cpp-static-reflection") {
         opts.cpp_static_reflection = true;
+      } else if (arg == "--cs-global-alias") {
+        opts.cs_global_alias = true;
+      } else if (arg == "--json-nested-bytes") {
+        opts.json_nested_legacy_flatbuffers = true;
       } else {
         for (size_t i = 0; i < params_.num_generators; ++i) {
-          if (arg == params_.generators[i].generator_opt_long ||
-              (params_.generators[i].generator_opt_short &&
-               arg == params_.generators[i].generator_opt_short)) {
+          if (arg == "--" + params_.generators[i].option.long_opt ||
+              arg == "-" + params_.generators[i].option.short_opt) {
             generator_enabled[i] = true;
             any_generator = true;
             opts.lang_to_generate |= params_.generators[i].lang;
+            if (params_.generators[i].bfbs_generator) {
+              opts.binary_schema_comments = true;
+              requires_bfbs = true;
+            }
             goto found;
           }
         }
         Error("unknown commandline argument: " + arg, true);
+
       found:;
       }
     } else {
@@ -393,6 +581,12 @@
     Error("no options: specify at least one generator.", true);
   }
 
+  if (opts.cs_gen_json_serializer && !opts.generate_object_based_api) {
+    Error(
+        "--cs-gen-json-serializer requires --gen-object-api to be set as "
+        "well.");
+  }
+
   flatbuffers::Parser conform_parser;
   if (!conform_to_schema.empty()) {
     std::string contents;
@@ -420,8 +614,11 @@
     bool is_binary =
         static_cast<size_t>(file_it - filenames.begin()) >= binary_files_from;
     auto ext = flatbuffers::GetExtension(filename);
-    auto is_schema = ext == "fbs" || ext == "proto";
-    auto is_binary_schema = ext == reflection::SchemaExtension();
+    const bool is_schema = ext == "fbs" || ext == "proto";
+    if (is_schema && opts.project_root.empty()) {
+      opts.project_root = StripFileName(filename);
+    }
+    const bool is_binary_schema = ext == reflection::SchemaExtension();
     if (is_binary) {
       parser->builder_.Clear();
       parser->builder_.PushFlatBuffer(
@@ -453,20 +650,24 @@
           contents.length() != strlen(contents.c_str())) {
         Error("input file appears to be binary: " + filename, true);
       }
-      if (is_schema) {
+      if (is_schema || is_binary_schema) {
         // If we're processing multiple schemas, make sure to start each
         // one from scratch. If it depends on previous schemas it must do
         // so explicitly using an include.
         parser.reset(new flatbuffers::Parser(opts));
       }
+      // Try to parse the file contents (binary schema/flexbuffer/textual
+      // schema)
       if (is_binary_schema) {
         LoadBinarySchema(*parser.get(), filename, contents);
-      }
-      if (opts.use_flexbuffers) {
+      } else if (opts.use_flexbuffers) {
         if (opts.lang_to_generate == IDLOptions::kJson) {
-          parser->flex_root_ = flexbuffers::GetRoot(
-              reinterpret_cast<const uint8_t *>(contents.c_str()),
-              contents.size());
+          auto data = reinterpret_cast<const uint8_t *>(contents.c_str());
+          auto size = contents.size();
+          std::vector<uint8_t> reuse_tracker;
+          if (!flexbuffers::VerifyBuffer(data, size, &reuse_tracker))
+            Error("flexbuffers file failed to verify: " + filename, false);
+          parser->flex_root_ = flexbuffers::GetRoot(data, size);
         } else {
           parser->flex_builder_.Clear();
           ParseFile(*parser.get(), filename, contents, include_directories);
@@ -483,7 +684,7 @@
       }
       if ((is_schema || is_binary_schema) && !conform_to_schema.empty()) {
         auto err = parser->ConformTo(conform_parser);
-        if (!err.empty()) Error("schemas don\'t conform: " + err);
+        if (!err.empty()) Error("schemas don\'t conform: " + err, false);
       }
       if (schema_binary || opts.binary_schema_gen_embed) {
         parser->Serialize();
@@ -492,21 +693,42 @@
         parser->file_extension_ = reflection::SchemaExtension();
       }
     }
-
     std::string filebase =
         flatbuffers::StripPath(flatbuffers::StripExtension(filename));
 
+    // If one of the generators uses bfbs, serialize the parser and get
+    // the serialized buffer and length.
+    const uint8_t *bfbs_buffer = nullptr;
+    int64_t bfbs_length = 0;
+    if (requires_bfbs) {
+      parser->Serialize();
+      bfbs_buffer = parser->builder_.GetBufferPointer();
+      bfbs_length = parser->builder_.GetSize();
+    }
+
     for (size_t i = 0; i < params_.num_generators; ++i) {
-      parser->opts.lang = params_.generators[i].lang;
       if (generator_enabled[i]) {
         if (!print_make_rules) {
           flatbuffers::EnsureDirExists(output_path);
-          if ((!params_.generators[i].schema_only ||
-               (is_schema || is_binary_schema)) &&
-              !params_.generators[i].generate(*parser.get(), output_path,
-                                              filebase)) {
-            Error(std::string("Unable to generate ") +
-                  params_.generators[i].lang_name + " for " + filebase);
+
+          // Prefer bfbs generators if present.
+          if (params_.generators[i].bfbs_generator) {
+            const GeneratorStatus status =
+                params_.generators[i].bfbs_generator->Generate(bfbs_buffer,
+                                                               bfbs_length);
+            if (status != OK) {
+              Error(std::string("Unable to generate ") +
+                    params_.generators[i].lang_name + " for " + filebase +
+                    " using bfbs generator.");
+            }
+          } else {
+            if ((!params_.generators[i].schema_only ||
+                 (is_schema || is_binary_schema)) &&
+                !params_.generators[i].generate(*parser.get(), output_path,
+                                                filebase)) {
+              Error(std::string("Unable to generate ") +
+                    params_.generators[i].lang_name + " for " + filebase);
+            }
           }
         } else {
           if (params_.generators[i].make_rule == nullptr) {
@@ -548,6 +770,19 @@
     // in any files coming up next.
     parser->MarkGenerated();
   }
+
+  // Once all the files have been parsed, run any generators Parsing Completed
+  // function for final generation.
+  for (size_t i = 0; i < params_.num_generators; ++i) {
+    if (generator_enabled[i] &&
+        params_.generators[i].parsing_completed != nullptr) {
+      if (!params_.generators[i].parsing_completed(*parser, output_path)) {
+        Error("failed running parsing completed for " +
+              std::string(params_.generators[i].lang_name));
+      }
+    }
+  }
+
   return 0;
 }
 
diff -urN a/src/flatc_main.cpp b/src/flatc_main.cpp
--- a/src/flatc_main.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/flatc_main.cpp	2023-01-13 07:47:08.249246239 +0000
@@ -14,6 +14,11 @@
  * limitations under the License.
  */
 
+#include <cstdio>
+#include <memory>
+
+#include "bfbs_gen_lua.h"
+#include "flatbuffers/base.h"
 #include "flatbuffers/flatc.h"
 #include "flatbuffers/util.h"
 
@@ -23,16 +28,16 @@
                  const std::string &warn, bool show_exe_name) {
   (void)flatc;
   if (show_exe_name) { printf("%s: ", g_program_name); }
-  printf("warning: %s\n", warn.c_str());
+  fprintf(stderr, "\nwarning:\n  %s\n\n", warn.c_str());
 }
 
 static void Error(const flatbuffers::FlatCompiler *flatc,
                   const std::string &err, bool usage, bool show_exe_name) {
   if (show_exe_name) { printf("%s: ", g_program_name); }
-  printf("error: %s\n", err.c_str());
   if (usage && flatc) {
-    printf("%s", flatc->GetUsageString(g_program_name).c_str());
+    fprintf(stderr, "%s\n", flatc->GetShortUsageString(g_program_name).c_str());
   }
+  fprintf(stderr, "\nerror:\n  %s\n\n", err.c_str());
   exit(1);
 }
 
@@ -50,61 +55,96 @@
   // Prevent Appveyor-CI hangs.
   flatbuffers::SetupDefaultCRTReportMode();
 
+  const std::string flatbuffers_version(flatbuffers::FLATBUFFERS_VERSION());
+
+  std::unique_ptr<flatbuffers::BfbsGenerator> bfbs_gen_lua =
+      flatbuffers::NewLuaBfbsGenerator(flatbuffers_version);
+
   g_program_name = argv[0];
 
   const flatbuffers::FlatCompiler::Generator generators[] = {
-    { flatbuffers::GenerateBinary, "-b", "--binary", "binary", false, nullptr,
+    { flatbuffers::GenerateBinary, "binary", false, nullptr,
       flatbuffers::IDLOptions::kBinary,
-      "Generate wire format binaries for any data definitions",
-      flatbuffers::BinaryMakeRule },
-    { flatbuffers::GenerateTextFile, "-t", "--json", "text", false, nullptr,
+      flatbuffers::FlatCOption{
+          "b", "binary", "",
+          "Generate wire format binaries for any data definitions" },
+      flatbuffers::BinaryMakeRule, nullptr, nullptr },
+    { flatbuffers::GenerateTextFile, "text", false, nullptr,
       flatbuffers::IDLOptions::kJson,
-      "Generate text output for any data definitions",
-      flatbuffers::TextMakeRule },
-    { flatbuffers::GenerateCPP, "-c", "--cpp", "C++", true,
-      flatbuffers::GenerateCppGRPC, flatbuffers::IDLOptions::kCpp,
-      "Generate C++ headers for tables/structs", flatbuffers::CPPMakeRule },
-    { flatbuffers::GenerateGo, "-g", "--go", "Go", true,
-      flatbuffers::GenerateGoGRPC, flatbuffers::IDLOptions::kGo,
-      "Generate Go files for tables/structs", nullptr },
-    { flatbuffers::GenerateJava, "-j", "--java", "Java", true,
-      flatbuffers::GenerateJavaGRPC, flatbuffers::IDLOptions::kJava,
-      "Generate Java classes for tables/structs",
-      flatbuffers::JavaCSharpMakeRule },
-    { flatbuffers::GenerateDart, "-d", "--dart", "Dart", true, nullptr,
+      flatbuffers::FlatCOption{
+          "t", "json", "", "Generate text output for any data definitions" },
+
+      flatbuffers::TextMakeRule, nullptr, nullptr },
+    { flatbuffers::GenerateCPP, "C++", true, flatbuffers::GenerateCppGRPC,
+      flatbuffers::IDLOptions::kCpp,
+      flatbuffers::FlatCOption{ "c", "cpp", "",
+                                "Generate C++ headers for tables/structs" },
+      flatbuffers::CPPMakeRule, nullptr, nullptr },
+    { flatbuffers::GenerateGo, "Go", true, flatbuffers::GenerateGoGRPC,
+      flatbuffers::IDLOptions::kGo,
+      flatbuffers::FlatCOption{ "g", "go", "",
+                                "Generate Go files for tables/structs" },
+      nullptr, nullptr, nullptr },
+    { flatbuffers::GenerateJava, "Java", true, flatbuffers::GenerateJavaGRPC,
+      flatbuffers::IDLOptions::kJava,
+      flatbuffers::FlatCOption{ "j", "java", "",
+                                "Generate Java classes for tables/structs" },
+      flatbuffers::JavaMakeRule, nullptr, nullptr },
+    { flatbuffers::GenerateDart, "Dart", true, nullptr,
       flatbuffers::IDLOptions::kDart,
-      "Generate Dart classes for tables/structs", flatbuffers::DartMakeRule },
-    { flatbuffers::GenerateTS, "-T", "--ts", "TypeScript", true,
-      flatbuffers::GenerateTSGRPC, flatbuffers::IDLOptions::kTs,
-      "Generate TypeScript code for tables/structs", flatbuffers::TSMakeRule },
-    { flatbuffers::GenerateCSharp, "-n", "--csharp", "C#", true, nullptr,
+      flatbuffers::FlatCOption{ "d", "dart", "",
+                                "Generate Dart classes for tables/structs" },
+      flatbuffers::DartMakeRule, nullptr, nullptr },
+    { flatbuffers::GenerateTS, "TypeScript", true, flatbuffers::GenerateTSGRPC,
+      flatbuffers::IDLOptions::kTs,
+      flatbuffers::FlatCOption{ "T", "ts", "",
+                                "Generate TypeScript code for tables/structs" },
+      flatbuffers::TSMakeRule, nullptr, nullptr },
+    { flatbuffers::GenerateCSharp, "C#", true, nullptr,
       flatbuffers::IDLOptions::kCSharp,
-      "Generate C# classes for tables/structs",
-      flatbuffers::JavaCSharpMakeRule },
-    { flatbuffers::GeneratePython, "-p", "--python", "Python", true,
+      flatbuffers::FlatCOption{ "n", "csharp", "",
+                                "Generate C# classes for tables/structs" },
+      flatbuffers::CSharpMakeRule, nullptr, nullptr },
+    { flatbuffers::GeneratePython, "Python", true,
       flatbuffers::GeneratePythonGRPC, flatbuffers::IDLOptions::kPython,
-      "Generate Python files for tables/structs", nullptr },
-    { flatbuffers::GenerateLobster, nullptr, "--lobster", "Lobster", true,
-      nullptr, flatbuffers::IDLOptions::kLobster,
-      "Generate Lobster files for tables/structs", nullptr },
-    { flatbuffers::GenerateLua, "-l", "--lua", "Lua", true, nullptr,
-      flatbuffers::IDLOptions::kLua, "Generate Lua files for tables/structs",
-      nullptr },
-    { flatbuffers::GenerateRust, "-r", "--rust", "Rust", true, nullptr,
-      flatbuffers::IDLOptions::kRust, "Generate Rust files for tables/structs",
-      flatbuffers::RustMakeRule },
-    { flatbuffers::GeneratePhp, nullptr, "--php", "PHP", true, nullptr,
-      flatbuffers::IDLOptions::kPhp, "Generate PHP files for tables/structs",
-      nullptr },
-    { flatbuffers::GenerateKotlin, nullptr, "--kotlin", "Kotlin", true, nullptr,
+      flatbuffers::FlatCOption{ "p", "python", "",
+                                "Generate Python files for tables/structs" },
+      nullptr, nullptr, nullptr },
+    { flatbuffers::GenerateLobster, "Lobster", true, nullptr,
+      flatbuffers::IDLOptions::kLobster,
+      flatbuffers::FlatCOption{ "", "lobster", "",
+                                "Generate Lobster files for tables/structs" },
+      nullptr, nullptr, nullptr },
+    { flatbuffers::GenerateLua, "Lua", true, nullptr,
+      flatbuffers::IDLOptions::kLua,
+      flatbuffers::FlatCOption{ "l", "lua", "",
+                                "Generate Lua files for tables/structs" },
+      nullptr, bfbs_gen_lua.get(), nullptr },
+    { flatbuffers::GenerateRust, "Rust", true, nullptr,
+      flatbuffers::IDLOptions::kRust,
+      flatbuffers::FlatCOption{ "r", "rust", "",
+                                "Generate Rust files for tables/structs" },
+      flatbuffers::RustMakeRule, nullptr,
+      flatbuffers::GenerateRustModuleRootFile },
+    { flatbuffers::GeneratePhp, "PHP", true, nullptr,
+      flatbuffers::IDLOptions::kPhp,
+      flatbuffers::FlatCOption{ "", "php", "",
+                                "Generate PHP files for tables/structs" },
+      nullptr, nullptr, nullptr },
+    { flatbuffers::GenerateKotlin, "Kotlin", true, nullptr,
       flatbuffers::IDLOptions::kKotlin,
-      "Generate Kotlin classes for tables/structs", nullptr },
-    { flatbuffers::GenerateJsonSchema, nullptr, "--jsonschema", "JsonSchema",
-      true, nullptr, flatbuffers::IDLOptions::kJsonSchema,
-      "Generate Json schema", nullptr },
-    { flatbuffers::GenerateSwift, nullptr, "--swift", "swift", true,
-      flatbuffers::GenerateSwiftGRPC, flatbuffers::IDLOptions::kSwift,
-      "Generate Swift files for tables/structs", nullptr },
+      flatbuffers::FlatCOption{ "", "kotlin", "",
+                                "Generate Kotlin classes for tables/structs" },
+      nullptr, nullptr, nullptr },
+    { flatbuffers::GenerateJsonSchema, "JsonSchema", true, nullptr,
+      flatbuffers::IDLOptions::kJsonSchema,
+      flatbuffers::FlatCOption{ "", "jsonschema", "", "Generate Json schema" },
+      nullptr, nullptr, nullptr },
+    { flatbuffers::GenerateSwift, "swift", true, flatbuffers::GenerateSwiftGRPC,
+      flatbuffers::IDLOptions::kSwift,
+      flatbuffers::FlatCOption{ "", "swift", "",
+                                "Generate Swift files for tables/structs" },
+      nullptr, nullptr, nullptr },
   };
 
   flatbuffers::FlatCompiler::InitParams params;
@@ -114,5 +154,5 @@
   params.error_fn = Error;
 
   flatbuffers::FlatCompiler flatc(params);
-  return flatc.Compile(argc - 1, argv + 1);
+  return flatc.Compile(argc, argv);
 }
diff -urN a/src/idl_gen_cpp.cpp b/src/idl_gen_cpp.cpp
--- a/src/idl_gen_cpp.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_cpp.cpp	2023-01-13 07:47:08.250246248 +0000
@@ -233,6 +233,30 @@
     return keywords_.find(name) == keywords_.end() ? name : name + "_";
   }
 
+  std::string Name(const FieldDef &field) const {
+    // the union type field suffix is immutable.
+    static size_t union_suffix_len = strlen(UnionTypeFieldSuffix());
+    const bool is_union_type = field.value.type.base_type == BASE_TYPE_UTYPE;
+    // early return if no case transformation required
+    if (opts_.cpp_object_api_field_case_style ==
+        IDLOptions::CaseStyle_Unchanged)
+      return EscapeKeyword(field.name);
+    std::string name = field.name;
+    // do not change the case style of the union type field suffix
+    if (is_union_type) {
+      FLATBUFFERS_ASSERT(name.length() > union_suffix_len);
+      name.erase(name.length() - union_suffix_len, union_suffix_len);
+    }
+    if (opts_.cpp_object_api_field_case_style == IDLOptions::CaseStyle_Upper)
+      name = MakeCamel(name, true); /* upper */
+    else if (opts_.cpp_object_api_field_case_style ==
+             IDLOptions::CaseStyle_Lower)
+      name = MakeCamel(name, false); /* lower */
+    // restore the union field type suffix
+    if (is_union_type) name.append(UnionTypeFieldSuffix(), union_suffix_len);
+    return EscapeKeyword(name);
+  }
+
   std::string Name(const Definition &def) const {
     return EscapeKeyword(def.name);
   }
@@ -259,6 +283,9 @@
         code_ += "#pragma clang system_header\n\n";
       }
 
+      code_ += "#include \"flatbuffers/flatbuffers.h\"";
+      code_ += "";
+
       SetNameSpace(struct_def.defined_namespace);
       auto name = Name(struct_def);
       code_.SetValue("STRUCT_NAME", name);
@@ -481,6 +508,17 @@
         code_ += "  return flatbuffers::GetMutableRoot<{{STRUCT_NAME}}>(buf);";
         code_ += "}";
         code_ += "";
+
+        code_ += "inline \\";
+        code_ +=
+            "{{CPP_NAME}} "
+            "*{{NULLABLE_EXT}}GetMutableSizePrefixed{{STRUCT_NAME}}(void "
+            "*buf) {";
+        code_ +=
+            "  return "
+            "flatbuffers::GetMutableSizePrefixedRoot<{{CPP_NAME}}>(buf);";
+        code_ += "}";
+        code_ += "";
       }
 
       if (parser_.file_identifier_.length()) {
@@ -497,6 +535,16 @@
         code_ += "      buf, {{STRUCT_NAME}}Identifier());";
         code_ += "}";
         code_ += "";
+
+        // Check if a size-prefixed buffer has the identifier.
+        code_ += "inline \\";
+        code_ +=
+            "bool SizePrefixed{{STRUCT_NAME}}BufferHasIdentifier(const void "
+            "*buf) {";
+        code_ += "  return flatbuffers::BufferHasIdentifier(";
+        code_ += "      buf, {{STRUCT_NAME}}Identifier(), true);";
+        code_ += "}";
+        code_ += "";
       }
 
       // The root verifier.
@@ -623,8 +671,9 @@
   }
 
   bool VectorElementUserFacing(const Type &type) const {
-    return opts_.g_cpp_std >= cpp::CPP_STD_17 && opts_.g_only_fixed_enums &&
-           IsEnum(type);
+    return (opts_.scoped_enums && IsEnum(type)) ||
+           (opts_.g_cpp_std >= cpp::CPP_STD_17 && opts_.g_only_fixed_enums &&
+            IsEnum(type));
   }
 
   void GenComment(const std::vector<std::string> &dc, const char *prefix = "") {
@@ -764,7 +813,7 @@
   }
 
   std::string GenTypeNative(const Type &type, bool invector,
-                            const FieldDef &field) {
+                            const FieldDef &field, bool forcopy = false) {
     switch (type.base_type) {
       case BASE_TYPE_STRING: {
         return NativeString(&field);
@@ -785,15 +834,14 @@
         if (IsStruct(type)) {
           auto native_type = type.struct_def->attributes.Lookup("native_type");
           if (native_type) { type_name = native_type->constant; }
-          if (invector || field.native_inline) {
+          if (invector || field.native_inline || forcopy) {
             return type_name;
           } else {
             return GenTypeNativePtr(type_name, &field, false);
           }
         } else {
-          return GenTypeNativePtr(
-              WrapNativeNameInNameSpace(*type.struct_def, opts_), &field,
-              false);
+          const auto nn = WrapNativeNameInNameSpace(*type.struct_def, opts_);
+          return forcopy ? nn : GenTypeNativePtr(nn, &field, false);
         }
       }
       case BASE_TYPE_UNION: {
@@ -907,10 +955,12 @@
   }
 
   std::string UnionVectorVerifySignature(const EnumDef &enum_def) {
-    return "bool Verify" + Name(enum_def) + "Vector" +
+    auto name = Name(enum_def);
+    auto type = opts_.scoped_enums ? name : "uint8_t";
+    return "bool Verify" + name + "Vector" +
            "(flatbuffers::Verifier &verifier, " +
            "const flatbuffers::Vector<flatbuffers::Offset<void>> *values, " +
-           "const flatbuffers::Vector<uint8_t> *types)";
+           "const flatbuffers::Vector<" + type + "> *types)";
   }
 
   std::string UnionUnPackSignature(const EnumDef &enum_def, bool inclass) {
@@ -1009,10 +1059,9 @@
                     ? bt - BASE_TYPE_UTYPE + ET_UTYPE
                     : ET_SEQUENCE;
       int ref_idx = -1;
-      std::string ref_name =
-          type.struct_def
-              ? WrapInNameSpace(*type.struct_def)
-              : type.enum_def ? WrapInNameSpace(*type.enum_def) : "";
+      std::string ref_name = type.struct_def ? WrapInNameSpace(*type.struct_def)
+                             : type.enum_def ? WrapInNameSpace(*type.enum_def)
+                                             : "";
       if (!ref_name.empty()) {
         auto rit = type_refs.begin();
         for (; rit != type_refs.end(); ++rit) {
@@ -1276,11 +1325,30 @@
     }
 
     if (opts_.generate_object_based_api && enum_def.is_union) {
-      // Generate a union type
+      // Generate a union type and a trait type for it.
       code_.SetValue("NAME", Name(enum_def));
       FLATBUFFERS_ASSERT(enum_def.Lookup("NONE"));
       code_.SetValue("NONE", GetEnumValUse(enum_def, *enum_def.Lookup("NONE")));
 
+      if (!enum_def.uses_multiple_type_instances) {
+        for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end();
+             ++it) {
+          const auto &ev = **it;
+
+          if (it == enum_def.Vals().begin()) {
+            code_ += "template<typename T> struct {{NAME}}UnionTraits {";
+          } else {
+            auto name = GetUnionElement(ev, true, opts_);
+            code_ += "template<> struct {{NAME}}UnionTraits<" + name + "> {";
+          }
+
+          auto value = GetEnumValUse(enum_def, ev);
+          code_ += "  static const {{ENUM_NAME}} enum_value = " + value + ";";
+          code_ += "};";
+          code_ += "";
+        }
+      }
+
       code_ += "struct {{NAME}}Union {";
       code_ += "  {{NAME}} type;";
       code_ += "  void *value;";
@@ -1304,18 +1372,15 @@
       code_ += "  void Reset();";
       code_ += "";
       if (!enum_def.uses_multiple_type_instances) {
-        code_ += "#ifndef FLATBUFFERS_CPP98_STL";
         code_ += "  template <typename T>";
         code_ += "  void Set(T&& val) {";
-        code_ += "    using RT = typename std::remove:reference<T>::type;";
+        code_ += "    typedef typename std::remove:reference<T>::type RT;";
         code_ += "    Reset();";
-        code_ +=
-            "    type = {{NAME}}Traits<typename RT::TableType>::enum_value;";
+        code_ += "    type = {{NAME}}UnionTraits<RT>::enum_value;";
         code_ += "    if (type != {{NONE}}) {";
         code_ += "      value = new RT(std::forward<T>(val));";
         code_ += "    }";
         code_ += "  }";
-        code_ += "#endif  // FLATBUFFERS_CPP98_STL";
         code_ += "";
       }
       code_ += "  " + UnionUnPackSignature(enum_def, true) + ";";
@@ -1419,9 +1484,11 @@
             "      auto ptr = reinterpret_cast<const {{TYPE}} *>(obj);";
         if (ev.union_type.base_type == BASE_TYPE_STRUCT) {
           if (ev.union_type.struct_def->fixed) {
+            code_.SetValue("ALIGN",
+                           NumToString(ev.union_type.struct_def->minalign));
             code_ +=
-                "      return verifier.Verify<{{TYPE}}>(static_cast<const "
-                "uint8_t *>(obj), 0);";
+                "      return verifier.VerifyField<{{TYPE}}>("
+                "static_cast<const uint8_t *>(obj), 0, {{ALIGN}});";
           } else {
             code_ += getptr;
             code_ += "      return verifier.VerifyTable(ptr);";
@@ -1461,6 +1528,7 @@
     if (opts_.generate_object_based_api) {
       // Generate union Unpack() and Pack() functions.
       code_ += "inline " + UnionUnPackSignature(enum_def, false) + " {";
+      code_ += "  (void)resolver;";
       code_ += "  switch (type) {";
       for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end();
            ++it) {
@@ -1491,6 +1559,7 @@
       code_ += "";
 
       code_ += "inline " + UnionPackSignature(enum_def, false) + " {";
+      code_ += "  (void)_rehasher;";
       code_ += "  switch (type) {";
       for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end();
            ++it) {
@@ -1534,7 +1603,8 @@
         code_.SetValue("TYPE", GetUnionElement(ev, true, opts_));
         code_ += "    case {{LABEL}}: {";
         bool copyable = true;
-        if (ev.union_type.base_type == BASE_TYPE_STRUCT &&
+        if (opts_.g_cpp_std < cpp::CPP_STD_11 &&
+            ev.union_type.base_type == BASE_TYPE_STRUCT &&
             !ev.union_type.struct_def->fixed) {
           // Don't generate code to copy if table is not copyable.
           // TODO(wvo): make tables copyable instead.
@@ -1621,7 +1691,7 @@
     if (!opts_.generate_name_strings) { return; }
     auto fullname = struct_def.defined_namespace->GetFullyQualifiedName(name);
     code_.SetValue("NAME", fullname);
-    code_.SetValue("CONSTEXPR", "FLATBUFFERS_CONSTEXPR");
+    code_.SetValue("CONSTEXPR", "FLATBUFFERS_CONSTEXPR_CPP11");
     code_ += "  static {{CONSTEXPR}} const char *GetFullyQualifiedName() {";
     code_ += "    return \"{{NAME}}\";";
     code_ += "  }";
@@ -1659,6 +1729,8 @@
       } else {
         return "0";
       }
+    } else if (IsStruct(type) && (field.value.constant == "0")) {
+      return "nullptr";
     } else {
       return GenDefaultConstant(field);
     }
@@ -1735,13 +1807,50 @@
     }
   }
 
+  // Returns true if `struct_def` needs a copy constructor and assignment
+  // operator because it has one or more table members, struct members with a
+  // custom cpp_type and non-naked pointer type, or vector members of those.
+  bool NeedsCopyCtorAssignOp(const StructDef &struct_def) {
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      const auto &field = **it;
+      const auto &type = field.value.type;
+      if (field.deprecated) continue;
+      if (type.base_type == BASE_TYPE_STRUCT) {
+        const auto cpp_type = field.attributes.Lookup("cpp_type");
+        const auto cpp_ptr_type = field.attributes.Lookup("cpp_ptr_type");
+        const bool is_ptr = !(IsStruct(type) && field.native_inline) ||
+                            (cpp_type && cpp_ptr_type->constant != "naked");
+        if (is_ptr) { return true; }
+      } else if (IsVector(type)) {
+        const auto vec_type = type.VectorType();
+        if (vec_type.base_type == BASE_TYPE_UTYPE) continue;
+        const auto cpp_type = field.attributes.Lookup("cpp_type");
+        const auto cpp_ptr_type = field.attributes.Lookup("cpp_ptr_type");
+        const bool is_ptr =
+            (vec_type.base_type == BASE_TYPE_STRUCT && !IsStruct(vec_type)) ||
+            (cpp_type && cpp_ptr_type->constant != "naked");
+        if (is_ptr) { return true; }
+      }
+    }
+    return false;
+  }
+
   // Generate the default constructor for this struct. Properly initialize all
   // scalar members with default values.
   void GenDefaultConstructor(const StructDef &struct_def) {
     code_.SetValue("NATIVE_NAME",
                    NativeName(Name(struct_def), &struct_def, opts_));
-    // In >= C++11, default member initializers are generated.
-    if (opts_.g_cpp_std >= cpp::CPP_STD_11) { return; }
+    // In >= C++11, default member initializers are generated. To allow for
+    // aggregate initialization, do not emit a default constructor at all, with
+    // the exception of types that need a copy/move ctors and assignment
+    // operators.
+    if (opts_.g_cpp_std >= cpp::CPP_STD_11) {
+      if (NeedsCopyCtorAssignOp(struct_def)) {
+        code_ += "  {{NATIVE_NAME}}() = default;";
+      }
+      return;
+    }
     std::string initializer_list;
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
@@ -1785,6 +1894,125 @@
     code_ += "  }";
   }
 
+  // Generate the >= C++11 copy/move constructor and assignment operator
+  // declarations if required. Tables that are default-copyable do not get
+  // user-provided copy/move constructors and assignment operators so they
+  // remain aggregates.
+  void GenCopyMoveCtorAndAssigOpDecls(const StructDef &struct_def) {
+    if (opts_.g_cpp_std < cpp::CPP_STD_11) return;
+    if (!NeedsCopyCtorAssignOp(struct_def)) return;
+    code_.SetValue("NATIVE_NAME",
+                   NativeName(Name(struct_def), &struct_def, opts_));
+    code_ += "  {{NATIVE_NAME}}(const {{NATIVE_NAME}} &o);";
+    code_ +=
+        "  {{NATIVE_NAME}}({{NATIVE_NAME}}&&) FLATBUFFERS_NOEXCEPT = "
+        "default;";
+    code_ +=
+        "  {{NATIVE_NAME}} &operator=({{NATIVE_NAME}} o) FLATBUFFERS_NOEXCEPT;";
+  }
+
+  // Generate the >= C++11 copy constructor and assignment operator definitions.
+  void GenCopyCtorAssignOpDefs(const StructDef &struct_def) {
+    if (opts_.g_cpp_std < cpp::CPP_STD_11) return;
+    if (!NeedsCopyCtorAssignOp(struct_def)) return;
+    std::string initializer_list;
+    std::string vector_copies;
+    std::string swaps;
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      const auto &field = **it;
+      const auto &type = field.value.type;
+      if (field.deprecated || type.base_type == BASE_TYPE_UTYPE) continue;
+      if (type.base_type == BASE_TYPE_STRUCT) {
+        if (!initializer_list.empty()) { initializer_list += ",\n        "; }
+        const auto cpp_type = field.attributes.Lookup("cpp_type");
+        const auto cpp_ptr_type = field.attributes.Lookup("cpp_ptr_type");
+        auto type_name = (cpp_type) ? cpp_type->constant
+                                    : GenTypeNative(type, /*invector*/ false,
+                                                    field, /*forcopy*/ true);
+        const bool is_ptr = !(IsStruct(type) && field.native_inline) ||
+                            (cpp_type && cpp_ptr_type->constant != "naked");
+        CodeWriter cw;
+        cw.SetValue("FIELD", Name(field));
+        cw.SetValue("TYPE", type_name);
+        if (is_ptr) {
+          cw +=
+              "{{FIELD}}((o.{{FIELD}}) ? new {{TYPE}}(*o.{{FIELD}}) : "
+              "nullptr)\\";
+          initializer_list += cw.ToString();
+        } else {
+          cw += "{{FIELD}}(o.{{FIELD}})\\";
+          initializer_list += cw.ToString();
+        }
+      } else if (IsVector(type)) {
+        const auto vec_type = type.VectorType();
+        if (vec_type.base_type == BASE_TYPE_UTYPE) continue;
+        const auto cpp_type = field.attributes.Lookup("cpp_type");
+        const auto cpp_ptr_type = field.attributes.Lookup("cpp_ptr_type");
+        const auto type_name = (cpp_type)
+                                   ? cpp_type->constant
+                                   : GenTypeNative(vec_type, /*invector*/ true,
+                                                   field, /*forcopy*/ true);
+        const bool is_ptr =
+            (vec_type.base_type == BASE_TYPE_STRUCT && !IsStruct(vec_type)) ||
+            (cpp_type && cpp_ptr_type->constant != "naked");
+        CodeWriter cw("  ");
+        cw.SetValue("FIELD", Name(field));
+        cw.SetValue("TYPE", type_name);
+        if (is_ptr) {
+          // Use emplace_back to construct the potentially-smart pointer element
+          // from a raw pointer to a new-allocated copy.
+          cw.IncrementIdentLevel();
+          cw += "{{FIELD}}.reserve(o.{{FIELD}}.size());";
+          cw +=
+              "for (const auto &v : o.{{FIELD}}) { "
+              "{{FIELD}}.emplace_back((v) ? new {{TYPE}}(*v) : nullptr); }";
+          vector_copies += cw.ToString();
+        } else {
+          // For non-pointer elements, use std::vector's copy constructor in the
+          // initializer list. This will yield better performance than an insert
+          // range loop for trivially-copyable element types.
+          if (!initializer_list.empty()) { initializer_list += ",\n        "; }
+          cw += "{{FIELD}}(o.{{FIELD}})\\";
+          initializer_list += cw.ToString();
+        }
+      } else {
+        if (!initializer_list.empty()) { initializer_list += ",\n        "; }
+        CodeWriter cw;
+        cw.SetValue("FIELD", Name(field));
+        cw += "{{FIELD}}(o.{{FIELD}})\\";
+        initializer_list += cw.ToString();
+      }
+      {
+        if (!swaps.empty()) { swaps += "\n  "; }
+        CodeWriter cw;
+        cw.SetValue("FIELD", Name(field));
+        cw += "std::swap({{FIELD}}, o.{{FIELD}});\\";
+        swaps += cw.ToString();
+      }
+    }
+    if (!initializer_list.empty()) {
+      initializer_list = "\n      : " + initializer_list;
+    }
+    if (!swaps.empty()) { swaps = "  " + swaps; }
+
+    code_.SetValue("NATIVE_NAME",
+                   NativeName(Name(struct_def), &struct_def, opts_));
+    code_.SetValue("INIT_LIST", initializer_list);
+    code_.SetValue("VEC_COPY", vector_copies);
+    code_.SetValue("SWAPS", swaps);
+
+    code_ +=
+        "inline {{NATIVE_NAME}}::{{NATIVE_NAME}}(const {{NATIVE_NAME}} &o)"
+        "{{INIT_LIST}} {";
+    code_ += "{{VEC_COPY}}}\n";
+    code_ +=
+        "inline {{NATIVE_NAME}} &{{NATIVE_NAME}}::operator="
+        "({{NATIVE_NAME}} o) FLATBUFFERS_NOEXCEPT {";
+    code_ += "{{SWAPS}}";
+    code_ += "  return *this;\n}\n";
+  }
+
   void GenCompareOperator(const StructDef &struct_def,
                           std::string accessSuffix = "") {
     std::string compare_op;
@@ -1797,7 +2025,18 @@
            field.value.type.element != BASE_TYPE_UTYPE)) {
         if (!compare_op.empty()) { compare_op += " &&\n      "; }
         auto accessor = Name(field) + accessSuffix;
-        compare_op += "(lhs." + accessor + " == rhs." + accessor + ")";
+        if (struct_def.fixed || field.native_inline ||
+            field.value.type.base_type != BASE_TYPE_STRUCT) {
+          compare_op += "(lhs." + accessor + " == rhs." + accessor + ")";
+        } else {
+          // Deep compare of std::unique_ptr. Null is not equal to empty.
+          std::string both_null =
+              "(lhs." + accessor + " == rhs." + accessor + ")";
+          std::string not_null_and_equal = "(lhs." + accessor + " && rhs." +
+                                           accessor + " && *lhs." + accessor +
+                                           " == *rhs." + accessor + ")";
+          compare_op += "(" + both_null + " || " + not_null_and_equal + ")";
+        }
       }
     }
 
@@ -1862,11 +2101,21 @@
     }
     GenOperatorNewDelete(struct_def);
     GenDefaultConstructor(struct_def);
+    GenCopyMoveCtorAndAssigOpDecls(struct_def);
     code_ += "};";
-    if (opts_.gen_compare) GenCompareOperator(struct_def);
     code_ += "";
   }
 
+  void GenNativeTablePost(const StructDef &struct_def) {
+    if (opts_.gen_compare) {
+      const auto native_name = NativeName(Name(struct_def), &struct_def, opts_);
+      code_.SetValue("STRUCT_NAME", Name(struct_def));
+      code_.SetValue("NATIVE_NAME", native_name);
+      GenCompareOperator(struct_def);
+      code_ += "";
+    }
+  }
+
   // Generate the code to call the appropriate Verify function(s) for a field.
   void GenVerifyCall(const FieldDef &field, const char *prefix) {
     code_.SetValue("PRE", prefix);
@@ -1875,8 +2124,10 @@
     code_.SetValue("SIZE", GenTypeSize(field.value.type));
     code_.SetValue("OFFSET", GenFieldOffsetName(field));
     if (IsScalar(field.value.type.base_type) || IsStruct(field.value.type)) {
+      code_.SetValue("ALIGN", NumToString(InlineAlignment(field.value.type)));
       code_ +=
-          "{{PRE}}VerifyField{{REQUIRED}}<{{SIZE}}>(verifier, {{OFFSET}})\\";
+          "{{PRE}}VerifyField{{REQUIRED}}<{{SIZE}}>(verifier, "
+          "{{OFFSET}}, {{ALIGN}})\\";
     } else {
       code_ += "{{PRE}}VerifyOffset{{REQUIRED}}(verifier, {{OFFSET}})\\";
     }
@@ -1923,6 +2174,19 @@
           }
           default: break;
         }
+
+        auto nfn = GetNestedFlatBufferName(field);
+        if (!nfn.empty()) {
+          code_.SetValue("CPP_NAME", nfn);
+          // FIXME: file_identifier.
+          code_ +=
+              "{{PRE}}verifier.VerifyNestedFlatBuffer<{{CPP_NAME}}>"
+              "({{NAME}}(), nullptr)\\";
+        } else if (field.flexbuffer) {
+          code_ +=
+              "{{PRE}}flexbuffers::VerifyNestedFlexBuffer"
+              "({{NAME}}(), verifier)\\";
+        }
         break;
       }
       default: {
@@ -1946,8 +2210,8 @@
     code_ += "  }";
 
     if (is_string) {
-      code_ += "  int KeyCompareWithValue(const char *val) const {";
-      code_ += "    return strcmp({{FIELD_NAME}}()->c_str(), val);";
+      code_ += "  int KeyCompareWithValue(const char *_{{FIELD_NAME}}) const {";
+      code_ += "    return strcmp({{FIELD_NAME}}()->c_str(), _{{FIELD_NAME}});";
       code_ += "  }";
     } else {
       FLATBUFFERS_ASSERT(IsScalar(field.value.type.base_type));
@@ -1958,10 +2222,11 @@
       }
       // Returns {field<val: -1, field==val: 0, field>val: +1}.
       code_.SetValue("KEY_TYPE", type);
-      code_ += "  int KeyCompareWithValue({{KEY_TYPE}} val) const {";
       code_ +=
-          "    return static_cast<int>({{FIELD_NAME}}() > val) - "
-          "static_cast<int>({{FIELD_NAME}}() < val);";
+          "  int KeyCompareWithValue({{KEY_TYPE}} _{{FIELD_NAME}}) const {";
+      code_ +=
+          "    return static_cast<int>({{FIELD_NAME}}() > _{{FIELD_NAME}}) - "
+          "static_cast<int>({{FIELD_NAME}}() < _{{FIELD_NAME}});";
       code_ += "  }";
     }
   }
@@ -2112,14 +2377,8 @@
   //   };
   //
   void GenFieldNames(const StructDef &struct_def) {
-    auto non_deprecated_field_count = std::count_if(
-        struct_def.fields.vec.begin(), struct_def.fields.vec.end(),
-        [](const FieldDef *field) { return !field->deprecated; });
     code_ += "  static constexpr std::array<\\";
-    code_.SetValue(
-        "FIELD_COUNT",
-        std::to_string(static_cast<long long>(non_deprecated_field_count)));
-    code_ += "const char *, {{FIELD_COUNT}}> field_names = {\\";
+    code_ += "const char *, fields_number> field_names = {\\";
     if (struct_def.fields.vec.empty()) {
       code_ += "};";
       return;
@@ -2141,7 +2400,7 @@
   }
 
   void GenFieldsNumber(const StructDef &struct_def) {
-    auto non_deprecated_field_count = std::count_if(
+    const auto non_deprecated_field_count = std::count_if(
         struct_def.fields.vec.begin(), struct_def.fields.vec.end(),
         [](const FieldDef *field) { return !field->deprecated; });
     code_.SetValue(
@@ -2165,9 +2424,9 @@
       code_ +=
           "  static constexpr auto fully_qualified_name = "
           "\"{{FULLY_QUALIFIED_NAME}}\";";
+      GenFieldsNumber(struct_def);
       GenFieldNames(struct_def);
       GenFieldTypeHelper(struct_def);
-      GenFieldsNumber(struct_def);
     }
     code_ += "};";
     code_ += "";
@@ -2188,15 +2447,25 @@
       code_.SetValue("FIELD_VALUE",
                      GenUnderlyingCast(field, false, "_" + Name(field)));
 
-      code_ +=
-          "  bool mutate_{{FIELD_NAME}}({{FIELD_TYPE}} "
-          "_{{FIELD_NAME}}) {";
+      code_ += "  bool mutate_{{FIELD_NAME}}({{FIELD_TYPE}} _{{FIELD_NAME}}\\";
       if (false == field.IsScalarOptional()) {
         code_.SetValue("DEFAULT_VALUE", GenDefaultConstant(field));
+        code_.SetValue(
+            "INTERFACE_DEFAULT_VALUE",
+            GenUnderlyingCast(field, true, GenDefaultConstant(field)));
+
+        // GenUnderlyingCast for a bool field generates 0 != 0
+        // So the type has to be checked and the appropriate default chosen
+        if (IsBool(field.value.type.base_type)) {
+          code_ += " = {{DEFAULT_VALUE}}) {";
+        } else {
+          code_ += " = {{INTERFACE_DEFAULT_VALUE}}) {";
+        }
         code_ +=
             "    return {{SET_FN}}({{OFFSET_NAME}}, {{FIELD_VALUE}}, "
             "{{DEFAULT_VALUE}});";
       } else {
+        code_ += ") {";
         code_ += "    return {{SET_FN}}({{OFFSET_NAME}}, {{FIELD_VALUE}});";
       }
       code_ += "  }";
@@ -2214,6 +2483,21 @@
     }
   }
 
+  std::string GetNestedFlatBufferName(const FieldDef &field) {
+    auto nested = field.attributes.Lookup("nested_flatbuffer");
+    if (!nested) return "";
+    std::string qualified_name = nested->constant;
+    auto nested_root = parser_.LookupStruct(nested->constant);
+    if (nested_root == nullptr) {
+      qualified_name =
+          parser_.current_namespace_->GetFullyQualifiedName(nested->constant);
+      nested_root = parser_.LookupStruct(qualified_name);
+    }
+    FLATBUFFERS_ASSERT(nested_root);  // Guaranteed to exist by parser.
+    (void)nested_root;
+    return TranslateNameSpace(qualified_name);
+  }
+
   // Generate an accessor struct, builder structs & function for a table.
   void GenTable(const StructDef &struct_def) {
     if (opts_.generate_object_based_api) { GenNativeTable(struct_def); }
@@ -2277,19 +2561,9 @@
       GenTableFieldGetter(field);
       if (opts_.mutable_buffer) { GenTableFieldSetter(field); }
 
-      auto nested = field.attributes.Lookup("nested_flatbuffer");
-      if (nested) {
-        std::string qualified_name = nested->constant;
-        auto nested_root = parser_.LookupStruct(nested->constant);
-        if (nested_root == nullptr) {
-          qualified_name = parser_.current_namespace_->GetFullyQualifiedName(
-              nested->constant);
-          nested_root = parser_.LookupStruct(qualified_name);
-        }
-        FLATBUFFERS_ASSERT(nested_root);  // Guaranteed to exist by parser.
-        (void)nested_root;
-        code_.SetValue("CPP_NAME", TranslateNameSpace(qualified_name));
-
+      auto nfn = GetNestedFlatBufferName(field);
+      if (!nfn.empty()) {
+        code_.SetValue("CPP_NAME", nfn);
         code_ += "  const {{CPP_NAME}} *{{FIELD_NAME}}_nested_root() const {";
         code_ +=
             "    return "
@@ -2723,9 +2997,19 @@
               code += "/* else do nothing */";
             }
           } else {
+            const bool is_pointer =
+                field.value.type.VectorType().base_type == BASE_TYPE_STRUCT &&
+                !IsStruct(field.value.type.VectorType());
+            if (is_pointer) {
+              code += "if(_o->" + name + "[_i]" + ") { ";
+              code += indexing + "->UnPackTo(_o->" + name +
+                      "[_i].get(), _resolver);";
+              code += " } else { ";
+            }
             code += "_o->" + name + "[_i]" + access + " = ";
             code += GenUnpackVal(field.value.type.VectorType(), indexing, true,
                                  field);
+            if (is_pointer) { code += "; }"; }
           }
           code += "; } }";
         }
@@ -2772,8 +3056,17 @@
         } else {
           // Generate code for assigning the value, of the form:
           //  _o->field = value;
+          const bool is_pointer =
+              field.value.type.base_type == BASE_TYPE_STRUCT &&
+              !IsStruct(field.value.type);
+          if (is_pointer) {
+            code += "{ if(_o->" + Name(field) + ") { ";
+            code += "_e->UnPackTo(_o->" + Name(field) + ".get(), _resolver);";
+            code += " } else { ";
+          }
           code += "_o->" + Name(field) + " = ";
           code += GenUnpackVal(field.value.type, "_e", false, field) + ";";
+          if (is_pointer) { code += " } }"; }
         }
         break;
       }
@@ -2901,10 +3194,15 @@
           }
           case BASE_TYPE_UTYPE: {
             value = StripUnionType(value);
-            code += "_fbb.CreateVector<uint8_t>(" + value +
-                    ".size(), [](size_t i, _VectorArgs *__va) { "
-                    "return static_cast<uint8_t>(__va->_" +
-                    value + "[i].type); }, &_va)";
+            auto type = opts_.scoped_enums ? Name(*field.value.type.enum_def)
+                                           : "uint8_t";
+            auto enum_value = "__va->_" + value + "[i].type";
+            if (!opts_.scoped_enums)
+              enum_value = "static_cast<uint8_t>(" + enum_value + ")";
+
+            code += "_fbb.CreateVector<" + type + ">(" + value +
+                    ".size(), [](size_t i, _VectorArgs *__va) { return " +
+                    enum_value + "; }, &_va)";
             break;
           }
           default: {
@@ -2979,11 +3277,16 @@
 
   // Generate code for tables that needs to come after the regular definition.
   void GenTablePost(const StructDef &struct_def) {
+    if (opts_.generate_object_based_api) { GenNativeTablePost(struct_def); }
+
     code_.SetValue("STRUCT_NAME", Name(struct_def));
     code_.SetValue("NATIVE_NAME",
                    NativeName(Name(struct_def), &struct_def, opts_));
 
     if (opts_.generate_object_based_api) {
+      // Generate the >= C++11 copy ctor and assignment operator definitions.
+      GenCopyCtorAssignOpDefs(struct_def);
+
       // Generate the X::UnPack() method.
       code_ +=
           "inline " + TableUnPackSignature(struct_def, false, opts_) + " {";
diff -urN a/src/idl_gen_csharp.cpp b/src/idl_gen_csharp.cpp
--- a/src/idl_gen_csharp.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_csharp.cpp	2023-01-13 07:47:08.830251603 +0000
@@ -16,15 +16,13 @@
 
 // independent from idl_parser, since this code is not needed for most clients
 
+#include <unordered_set>
+
 #include "flatbuffers/code_generators.h"
 #include "flatbuffers/flatbuffers.h"
 #include "flatbuffers/idl.h"
 #include "flatbuffers/util.h"
 
-#if defined(FLATBUFFERS_CPP98_STL)
-#  include <cctype>
-#endif  // defined(FLATBUFFERS_CPP98_STL)
-
 namespace flatbuffers {
 
 static TypedFloatConstantGenerator CSharpFloatGen("Double.", "Single.", "NaN",
@@ -46,8 +44,100 @@
  public:
   CSharpGenerator(const Parser &parser, const std::string &path,
                   const std::string &file_name)
-      : BaseGenerator(parser, path, file_name, "", ".", "cs"),
-        cur_name_space_(nullptr) {}
+      : BaseGenerator(parser, path, file_name,
+                      parser.opts.cs_global_alias ? "global::" : "", ".", "cs"),
+        cur_name_space_(nullptr) {
+    // clang-format off
+
+    // List of keywords retrieved from here:
+    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/
+
+    // One per line to ease comparisons to that list are easier
+
+    static const char *const keywords[] = {
+      "abstract",
+      "as",
+      "base",
+      "bool",
+      "break",
+      "byte",
+      "case",
+      "catch",
+      "char",
+      "checked",
+      "class",
+      "const",
+      "continue",
+      "decimal",
+      "default",
+      "delegate",
+      "do",
+      "double",
+      "else",
+      "enum",
+      "event",
+      "explicit",
+      "extern",
+      "false",
+      "finally",
+      "fixed",
+      "float",
+      "for",
+      "foreach",
+      "goto",
+      "if",
+      "implicit",
+      "in",
+      "int",
+      "interface",
+      "internal",
+      "is",
+      "lock",
+      "long",
+      "namespace",
+      "new",
+      "null",
+      "object",
+      "operator",
+      "out",
+      "override",
+      "params",
+      "private",
+      "protected",
+      "public",
+      "readonly",
+      "ref",
+      "return",
+      "sbyte",
+      "sealed",
+      "short",
+      "sizeof",
+      "stackalloc",
+      "static",
+      "string",
+      "struct",
+      "switch",
+      "this",
+      "throw",
+      "true",
+      "try",
+      "typeof",
+      "uint",
+      "ulong",
+      "unchecked",
+      "unsafe",
+      "ushort",
+      "using",
+      "virtual",
+      "void",
+      "volatile",
+      "while",
+      nullptr,
+      // clang-format on
+    };
+
+    for (auto kw = keywords; *kw; kw++) keywords_.insert(*kw);
+  }
 
   CSharpGenerator &operator=(const CSharpGenerator &);
 
@@ -65,7 +155,7 @@
         one_file_code += enumcode;
       } else {
         if (!SaveType(enum_def.name, *enum_def.defined_namespace, enumcode,
-                      false))
+                      false, parser_.opts))
           return false;
       }
     }
@@ -81,22 +171,45 @@
         one_file_code += declcode;
       } else {
         if (!SaveType(struct_def.name, *struct_def.defined_namespace, declcode,
-                      true))
+                      true, parser_.opts))
           return false;
       }
     }
 
     if (parser_.opts.one_file) {
       return SaveType(file_name_, *parser_.current_namespace_, one_file_code,
-                      true);
+                      true, parser_.opts);
     }
     return true;
   }
 
+ private:
+  std::unordered_set<std::string> keywords_;
+
+  std::string EscapeKeyword(const std::string &name) const {
+    return keywords_.find(name) == keywords_.end() ? name : "@" + name;
+  }
+
+  std::string Name(const FieldDef &field) const {
+    std::string name = MakeCamel(field.name, true);
+    return EscapeKeyword(name);
+  }
+
+  std::string Name(const Definition &def) const {
+    return EscapeKeyword(def.name);
+  }
+
+  std::string NamespacedName(const Definition &def) const {
+    return WrapInNameSpace(def.defined_namespace, Name(def));
+  }
+
+  std::string Name(const EnumVal &ev) const { return EscapeKeyword(ev.name); }
+
   // Save out the generated code for a single class while adding
   // declaration boilerplate.
   bool SaveType(const std::string &defname, const Namespace &ns,
-                const std::string &classcode, bool needs_includes) const {
+                const std::string &classcode, bool needs_includes,
+                const IDLOptions &options) const {
     if (!classcode.length()) return true;
 
     std::string code =
@@ -117,7 +230,10 @@
     }
     code += classcode;
     if (!namespace_name.empty()) { code += "\n}\n"; }
-    auto filename = NamespaceDir(ns) + defname + ".cs";
+    auto filename = NamespaceDir(ns) + defname;
+    if (options.one_file) { filename += options.filename_suffix; }
+    filename +=
+        options.filename_extension.empty() ? ".cs" : options.filename_extension;
     return SaveFile(filename.c_str(), code, false);
   }
 
@@ -134,9 +250,9 @@
     // clang-format on
 
     if (enableLangOverrides) {
-      if (IsEnum(type)) return WrapInNameSpace(*type.enum_def);
+      if (IsEnum(type)) return NamespacedName(*type.enum_def);
       if (type.base_type == BASE_TYPE_STRUCT) {
-        return "Offset<" + WrapInNameSpace(*type.struct_def) + ">";
+        return "Offset<" + NamespacedName(*type.struct_def) + ">";
       }
     }
 
@@ -151,7 +267,7 @@
     switch (type.base_type) {
       case BASE_TYPE_STRING: return "string";
       case BASE_TYPE_VECTOR: return GenTypeGet(type.VectorType());
-      case BASE_TYPE_STRUCT: return WrapInNameSpace(*type.struct_def);
+      case BASE_TYPE_STRUCT: return NamespacedName(*type.struct_def);
       case BASE_TYPE_UNION: return "TTable";
       default: return "Table";
     }
@@ -165,12 +281,12 @@
   }
 
   std::string GenOffsetType(const StructDef &struct_def) const {
-    return "Offset<" + WrapInNameSpace(struct_def) + ">";
+    return "Offset<" + NamespacedName(struct_def) + ">";
   }
 
   std::string GenOffsetConstruct(const StructDef &struct_def,
                                  const std::string &variable_name) const {
-    return "new Offset<" + WrapInNameSpace(struct_def) + ">(" + variable_name +
+    return "new Offset<" + NamespacedName(struct_def) + ">(" + variable_name +
            ")";
   }
 
@@ -179,7 +295,7 @@
     if (IsSeries(type)) {
       return DestinationCast(type.VectorType());
     } else {
-      if (IsEnum(type)) return "(" + WrapInNameSpace(*type.enum_def) + ")";
+      if (IsEnum(type)) return "(" + NamespacedName(*type.enum_def) + ")";
     }
     return "";
   }
@@ -190,17 +306,19 @@
   // would be cast down to int before being put onto the buffer. In C#, one cast
   // directly cast an Enum to its underlying type, which is essential before
   // putting it onto the buffer.
-  std::string SourceCast(const Type &type) const {
+  std::string SourceCast(const Type &type,
+                         const bool isOptional = false) const {
     if (IsSeries(type)) {
       return SourceCast(type.VectorType());
     } else {
-      if (IsEnum(type)) return "(" + GenTypeBasic(type, false) + ")";
+      if (IsEnum(type))
+        return "(" + GenTypeBasic(type, false) + (isOptional ? "?" : "") + ")";
     }
     return "";
   }
 
-  std::string SourceCastBasic(const Type &type) const {
-    return IsScalar(type.base_type) ? SourceCast(type) : "";
+  std::string SourceCastBasic(const Type &type, const bool isOptional) const {
+    return IsScalar(type.base_type) ? SourceCast(type, isOptional) : "";
   }
 
   std::string GenEnumDefaultValue(const FieldDef &field) const {
@@ -208,7 +326,7 @@
     FLATBUFFERS_ASSERT(value.type.enum_def);
     auto &enum_def = *value.type.enum_def;
     auto enum_val = enum_def.FindByValue(value.constant);
-    return enum_val ? (WrapInNameSpace(enum_def) + "." + enum_val->name)
+    return enum_val ? (NamespacedName(enum_def) + "." + Name(*enum_val))
                     : value.constant;
   }
 
@@ -252,7 +370,7 @@
         switch (value.type.base_type) {
           case BASE_TYPE_STRING: return "default(StringOffset)";
           case BASE_TYPE_STRUCT:
-            return "default(Offset<" + WrapInNameSpace(*value.type.struct_def) +
+            return "default(Offset<" + NamespacedName(*value.type.struct_def) +
                    ">)";
           case BASE_TYPE_VECTOR: return "default(VectorOffset)";
           default: break;
@@ -293,14 +411,14 @@
     } else {
       code += "public ";
     }
-    code += "enum " + enum_def.name;
+    code += "enum " + Name(enum_def);
     code += " : " + GenTypeBasic(enum_def.underlying_type, false);
     code += "\n{\n";
     for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
       auto &ev = **it;
       GenComment(ev.doc_comment, code_ptr, &comment_config, "  ");
       code += "  ";
-      code += ev.name + " = ";
+      code += Name(ev) + " = ";
       code += enum_def.ToString(ev);
       code += ",\n";
     }
@@ -395,7 +513,8 @@
         // don't clash, and to make it obvious these arguments are constructing
         // a nested struct, prefix the name with the field name.
         GenStructArgs(*field_type.struct_def, code_ptr,
-                      (nameprefix + (field.name + "_")).c_str(), array_cnt);
+                      (nameprefix + (EscapeKeyword(field.name) + "_")).c_str(),
+                      array_cnt);
       } else {
         code += ", ";
         code += GenTypeBasic(type);
@@ -407,7 +526,7 @@
         }
         code += " ";
         code += nameprefix;
-        code += MakeCamel(field.name, true);
+        code += Name(field);
       }
     }
   }
@@ -454,7 +573,7 @@
           code += indent + "  builder.Put";
           code += GenMethod(type) + "(";
           code += SourceCast(type);
-          auto argname = nameprefix + MakeCamel(field.name, true);
+          auto argname = nameprefix + Name(field);
           code += argname;
           size_t array_cnt = index + (IsArray(field_type) ? 1 : 0);
           if (array_cnt > 0) {
@@ -618,7 +737,8 @@
       std::string dest_mask = "";
       std::string dest_cast = DestinationCast(field.value.type);
       std::string src_cast = SourceCast(field.value.type);
-      std::string field_name_camel = MakeCamel(field.name, true);
+      std::string field_name_camel = Name(field);
+      if (field_name_camel == struct_def.name) { field_name_camel += "_"; }
       std::string method_start =
           "  public " + type_name_dest + optional + " " + field_name_camel;
       std::string obj = "(new " + type_name + "())";
@@ -745,8 +865,7 @@
                 HasUnionStringValue(*vectortype.enum_def)) {
               code += member_suffix;
               code += "}\n";
-              code += "  public string " + MakeCamel(field.name, true) +
-                      "AsString(int j)";
+              code += "  public string " + Name(field) + "AsString(int j)";
               code += offset_prefix + GenGetter(Type(BASE_TYPE_STRING));
               code += "(" + index + ") : null";
             }
@@ -759,8 +878,7 @@
             if (HasUnionStringValue(*field.value.type.enum_def)) {
               code += member_suffix;
               code += "}\n";
-              code += "  public string " + MakeCamel(field.name, true) +
-                      "AsString()";
+              code += "  public string " + Name(field) + "AsString()";
               code += offset_prefix + GenGetter(Type(BASE_TYPE_STRING));
               code += "(o + __p.bb_pos) : null";
             }
@@ -795,7 +913,7 @@
       code += member_suffix;
       code += "}\n";
       if (IsVector(field.value.type)) {
-        code += "  public int " + MakeCamel(field.name, true);
+        code += "  public int " + Name(field);
         code += "Length";
         code += " { get";
         code += offset_prefix;
@@ -810,9 +928,9 @@
           for (auto kit = fields.begin(); kit != fields.end(); ++kit) {
             auto &key_field = **kit;
             if (key_field.key) {
-              auto qualified_name = WrapInNameSpace(sd);
+              auto qualified_name = NamespacedName(sd);
               code += "  public " + qualified_name + "? ";
-              code += MakeCamel(field.name, true) + "ByKey(";
+              code += Name(field) + "ByKey(";
               code += GenTypeGet(key_field.value.type) + " key)";
               code += offset_prefix;
               code += qualified_name + ".__lookup_by_key(";
@@ -831,7 +949,7 @@
         code += "#if ENABLE_SPAN_T\n";
         code += "  public Span<" + GenTypeBasic(field.value.type.VectorType()) +
                 "> Get";
-        code += MakeCamel(field.name, true);
+        code += Name(field);
         code += "Bytes() { return ";
         code += "__p.__vector_as_span<" +
                 GenTypeBasic(field.value.type.VectorType()) + ">(";
@@ -841,7 +959,7 @@
         code += "); }\n";
         code += "#else\n";
         code += "  public ArraySegment<byte>? Get";
-        code += MakeCamel(field.name, true);
+        code += Name(field);
         code += "Bytes() { return ";
         code += "__p.__vector_as_arraysegment(";
         code += NumToString(field.value.offset);
@@ -852,7 +970,7 @@
         code += "  public ";
         code += GenTypeBasic(field.value.type.VectorType());
         code += "[] Get";
-        code += MakeCamel(field.name, true);
+        code += Name(field);
         code += "Array() { ";
         if (IsEnum(field.value.type.VectorType())) {
           // Since __vector_as_array does not work for enum types,
@@ -881,9 +999,9 @@
       }
       // generate object accessors if is nested_flatbuffer
       if (field.nested_flatbuffer) {
-        auto nested_type_name = WrapInNameSpace(*field.nested_flatbuffer);
+        auto nested_type_name = NamespacedName(*field.nested_flatbuffer);
         auto nested_method_name =
-            MakeCamel(field.name, true) + "As" + field.nested_flatbuffer->name;
+            Name(field) + "As" + field.nested_flatbuffer->name;
         auto get_nested_method_name = nested_method_name;
         get_nested_method_name = "Get" + nested_method_name;
         conditional_cast = "(" + nested_type_name + "?)";
@@ -904,15 +1022,16 @@
             is_series ? field.value.type.VectorType() : field.value.type;
         // Boolean parameters have to be explicitly converted to byte
         // representation.
-        auto setter_parameter = underlying_type.base_type == BASE_TYPE_BOOL
-                                    ? "(byte)(" + field.name + " ? 1 : 0)"
-                                    : field.name;
+        auto setter_parameter =
+            underlying_type.base_type == BASE_TYPE_BOOL
+                ? "(byte)(" + EscapeKeyword(field.name) + " ? 1 : 0)"
+                : EscapeKeyword(field.name);
         auto mutator_prefix = MakeCamel("mutate", true);
         // A vector mutator also needs the index of the vector element it should
         // mutate.
         auto mutator_params = (is_series ? "(int j, " : "(") +
-                              GenTypeGet(underlying_type) + " " + field.name +
-                              ") { ";
+                              GenTypeGet(underlying_type) + " " +
+                              EscapeKeyword(field.name) + ") { ";
         auto setter_index =
             is_series
                 ? "__p." +
@@ -926,7 +1045,7 @@
         if (IsScalar(underlying_type.base_type) && !IsUnion(field.value.type)) {
           code += "  public ";
           code += struct_def.fixed ? "void " : "bool ";
-          code += mutator_prefix + MakeCamel(field.name, true);
+          code += mutator_prefix + Name(field);
           code += mutator_params;
           if (struct_def.fixed) {
             code += GenSetter(underlying_type) + "(" + setter_index + ", ";
@@ -1002,13 +1121,13 @@
                 field.value.type.struct_def->defined_namespace,
                 GenTypeName_ObjectAPI(field.value.type.struct_def->name, opts));
             code += " ";
-            code += field.name;
+            code += EscapeKeyword(field.name);
             code += " = null";
           } else {
             code += GenTypeBasic(field.value.type);
             if (field.IsScalarOptional()) { code += "?"; }
             code += " ";
-            code += field.name;
+            code += EscapeKeyword(field.name);
             if (!IsScalar(field.value.type.base_type)) code += "Offset";
 
             code += " = ";
@@ -1028,13 +1147,13 @@
                  size == SizeOf(field.value.type.base_type))) {
               code += "    " + struct_def.name + ".";
               code += "Add";
-              code += MakeCamel(field.name) + "(builder, ";
+              code += Name(field) + "(builder, ";
               if (IsStruct(field.value.type) &&
                   opts.generate_object_based_api) {
                 code += GenTypePointer(field.value.type) + ".Pack(builder, " +
-                        field.name + ")";
+                        EscapeKeyword(field.name) + ")";
               } else {
-                code += field.name;
+                code += EscapeKeyword(field.name);
                 if (!IsScalar(field.value.type.base_type)) code += "Offset";
               }
 
@@ -1062,17 +1181,17 @@
         if (field.deprecated) continue;
         if (field.key) key_field = &field;
         code += "  public static void Add";
-        code += MakeCamel(field.name);
+        code += Name(field);
         code += "(FlatBufferBuilder builder, ";
         code += GenTypeBasic(field.value.type);
         auto argname = MakeCamel(field.name, false);
         if (!IsScalar(field.value.type.base_type)) argname += "Offset";
         if (field.IsScalarOptional()) { code += "?"; }
-        code += " " + argname + ") { builder.Add";
+        code += " " + EscapeKeyword(argname) + ") { builder.Add";
         code += GenMethod(field.value.type) + "(";
         code += NumToString(it - struct_def.fields.vec.begin()) + ", ";
-        code += SourceCastBasic(field.value.type);
-        code += argname;
+        code += SourceCastBasic(field.value.type, field.IsScalarOptional());
+        code += EscapeKeyword(argname);
         if (!IsScalar(field.value.type.base_type) &&
             field.value.type.base_type != BASE_TYPE_UNION) {
           code += ".Value";
@@ -1093,7 +1212,7 @@
             field_has_create_set.insert(&field);
             code += "  public static VectorOffset ";
             code += "Create";
-            code += MakeCamel(field.name);
+            code += Name(field);
             code += "Vector(FlatBufferBuilder builder, ";
             code += GenTypeBasic(vector_type) + "[] data) ";
             code += "{ builder.StartVector(";
@@ -1105,7 +1224,11 @@
             code += "Add";
             code += GenMethod(vector_type);
             code += "(";
-            code += SourceCastBasic(vector_type);
+            // At the moment there is no support of the type Vector with
+            // optional enum, e.g. if we have enum type SomeEnum there is no way
+            // to define `SomeEmum?[] enums` in FlatBuffer schema, so isOptional
+            // = false
+            code += SourceCastBasic(vector_type, false);
             code += "data[i]";
             if (vector_type.base_type == BASE_TYPE_STRUCT ||
                 IsString(vector_type))
@@ -1115,7 +1238,7 @@
 
             code += "  public static VectorOffset ";
             code += "Create";
-            code += MakeCamel(field.name);
+            code += Name(field);
             code += "VectorBlock(FlatBufferBuilder builder, ";
             code += GenTypeBasic(vector_type) + "[] data) ";
             code += "{ builder.StartVector(";
@@ -1127,7 +1250,7 @@
           // Generate a method to start a vector, data to be added manually
           // after.
           code += "  public static void Start";
-          code += MakeCamel(field.name);
+          code += Name(field);
           code += "Vector(FlatBufferBuilder builder, int numElems) ";
           code += "{ builder.StartVector(";
           code += NumToString(elem_size);
@@ -1215,7 +1338,7 @@
       GenPackUnPack_ObjectAPI(struct_def, code_ptr, opts, struct_has_create,
                               field_has_create_set);
     }
-    code += "};\n\n";
+    code += "}\n\n";
 
     if (opts.generate_object_based_api) {
       GenStruct_ObjectAPI(struct_def, code_ptr, opts);
@@ -1305,19 +1428,27 @@
     code += "  }\n\n";
     // As<T>
     code += "  public T As<T>() where T : class { return this.Value as T; }\n";
-    // As
+    // As, From
     for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
       auto &ev = **it;
       if (ev.union_type.base_type == BASE_TYPE_NONE) continue;
       auto type_name = GenTypeGet_ObjectAPI(ev.union_type, opts);
-      if (ev.union_type.base_type == BASE_TYPE_STRUCT &&
-          ev.union_type.struct_def->attributes.Lookup("private")) {
-        code += "  internal ";
-      } else {
-        code += "  public ";
-      }
-      code += type_name + " As" + ev.name + "() { return this.As<" + type_name +
-              ">(); }\n";
+      std::string accessibility =
+          (ev.union_type.base_type == BASE_TYPE_STRUCT &&
+           ev.union_type.struct_def->attributes.Lookup("private"))
+              ? "internal"
+              : "public";
+      // As
+      code += "  " + accessibility + " " + type_name + " As" + ev.name +
+              "() { return this.As<" + type_name + ">(); }\n";
+      // From
+      auto lower_ev_name = ev.name;
+      std::transform(lower_ev_name.begin(), lower_ev_name.end(),
+                     lower_ev_name.begin(), CharToLower);
+      code += "  " + accessibility + " static " + union_name + " From" +
+              ev.name + "(" + type_name + " _" + lower_ev_name +
+              ") { return new " + union_name + "{ Type = " + Name(enum_def) +
+              "." + Name(ev) + ", Value = _" + lower_ev_name + " }; }\n";
     }
     code += "\n";
     // Pack()
@@ -1329,7 +1460,7 @@
       if (ev.union_type.base_type == BASE_TYPE_NONE) {
         code += "      default: return 0;\n";
       } else {
-        code += "      case " + enum_def.name + "." + ev.name + ": return ";
+        code += "      case " + Name(enum_def) + "." + Name(ev) + ": return ";
         if (IsString(ev.union_type)) {
           code += "builder.CreateString(_o.As" + ev.name + "()).Value;\n";
         } else {
@@ -1414,7 +1545,7 @@
           code += "      default: break;\n";
         } else {
           auto type_name = GenTypeGet_ObjectAPI(ev.union_type, opts);
-          code += "      case " + enum_def.name + "." + ev.name +
+          code += "      case " + Name(enum_def) + "." + Name(ev) +
                   ": _o.Value = serializer.Deserialize<" + type_name +
                   ">(reader); break;\n";
         }
@@ -1450,7 +1581,7 @@
     } else {
       code += indent + varialbe_name + " = new ";
     }
-    code += WrapInNameSpace(enum_def) + "Union();\n";
+    code += NamespacedName(enum_def) + "Union();\n";
     code += indent + varialbe_name + ".Type = this." + camel_name + "Type" +
             type_suffix + ";\n";
     code +=
@@ -1461,7 +1592,7 @@
       if (ev.union_type.base_type == BASE_TYPE_NONE) {
         code += indent + "  default: break;\n";
       } else {
-        code += indent + "  case " + WrapInNameSpace(enum_def) + "." + ev.name +
+        code += indent + "  case " + NamespacedName(enum_def) + "." + ev.name +
                 ":\n";
         code += indent + "    " + varialbe_name + ".Value = this." + camel_name;
         if (IsString(ev.union_type)) {
@@ -1499,7 +1630,7 @@
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       if (field.deprecated) continue;
-      auto camel_name = MakeCamel(field.name);
+      auto camel_name = Name(field);
       auto start = "    _o." + camel_name + " = ";
       switch (field.value.type.base_type) {
         case BASE_TYPE_STRUCT: {
@@ -1515,11 +1646,10 @@
         case BASE_TYPE_ARRAY: {
           auto type_name = GenTypeGet_ObjectAPI(field.value.type, opts);
           auto length_str = NumToString(field.value.type.fixed_length);
-          auto unpack_method = field.value.type.struct_def == nullptr
-                                   ? ""
-                                   : field.value.type.struct_def->fixed
-                                         ? ".UnPack()"
-                                         : "?.UnPack()";
+          auto unpack_method = field.value.type.struct_def == nullptr ? ""
+                               : field.value.type.struct_def->fixed
+                                   ? ".UnPack()"
+                                   : "?.UnPack()";
           code += start + "new " + type_name.substr(0, type_name.length() - 1) +
                   length_str + "];\n";
           code += "    for (var _j = 0; _j < " + length_str + "; ++_j) { _o." +
@@ -1574,7 +1704,7 @@
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
       if (field.deprecated) continue;
-      auto camel_name = MakeCamel(field.name);
+      auto camel_name = Name(field);
       // pre
       switch (field.value.type.base_type) {
         case BASE_TYPE_STRUCT: {
@@ -1628,12 +1758,12 @@
                 break;
               case BASE_TYPE_UTYPE:
                 property_name = camel_name.substr(0, camel_name.size() - 4);
-                array_type = WrapInNameSpace(*field.value.type.enum_def);
+                array_type = NamespacedName(*field.value.type.enum_def);
                 to_array = "_o." + property_name + "[_j].Type";
                 break;
               case BASE_TYPE_UNION:
                 array_type = "int";
-                to_array = WrapInNameSpace(*field.value.type.enum_def) +
+                to_array = NamespacedName(*field.value.type.enum_def) +
                            "Union.Pack(builder,  _o." + property_name + "[_j])";
                 break;
               default: gen_for_loop = false; break;
@@ -1688,7 +1818,7 @@
         }
         case BASE_TYPE_UNION: {
           code += "    var _" + field.name + "_type = _o." + camel_name +
-                  " == null ? " + WrapInNameSpace(*field.value.type.enum_def) +
+                  " == null ? " + NamespacedName(*field.value.type.enum_def) +
                   ".NONE : " + "_o." + camel_name + ".Type;\n";
           code +=
               "    var _" + field.name + " = _o." + camel_name +
@@ -1707,7 +1837,7 @@
            it != struct_def.fields.vec.end(); ++it) {
         auto &field = **it;
         if (field.deprecated) continue;
-        auto camel_name = MakeCamel(field.name);
+        auto camel_name = Name(field);
         switch (field.value.type.base_type) {
           case BASE_TYPE_STRUCT: {
             if (struct_def.fixed) {
@@ -1761,7 +1891,7 @@
            it != struct_def.fields.vec.end(); ++it) {
         auto &field = **it;
         if (field.deprecated) continue;
-        auto camel_name = MakeCamel(field.name);
+        auto camel_name = Name(field);
         switch (field.value.type.base_type) {
           case BASE_TYPE_STRUCT: {
             if (field.value.type.struct_def->fixed) {
@@ -1857,7 +1987,7 @@
           }
           code += "] = _o";
           for (size_t i = 0, j = 0; i < array_lengths.size(); ++i) {
-            code += "." + MakeCamel(array_lengths[i].name);
+            code += "." + MakeCamel(array_lengths[i].name, true);
             if (array_lengths[i].length <= 0) continue;
             code += "[idx" + NumToString(j++) + "]";
           }
@@ -1868,7 +1998,7 @@
         } else {
           code += "_o";
           for (size_t i = 0; i < array_lengths.size(); ++i) {
-            code += "." + MakeCamel(array_lengths[i].name);
+            code += "." + MakeCamel(array_lengths[i].name, true);
           }
           code += ";";
         }
@@ -1911,13 +2041,13 @@
           type_name.replace(type_name.length() - type_name_length,
                             type_name_length, new_type_name);
         } else if (type.element == BASE_TYPE_UNION) {
-          type_name = WrapInNameSpace(*type.enum_def) + "Union";
+          type_name = NamespacedName(*type.enum_def) + "Union";
         }
         break;
       }
 
       case BASE_TYPE_UNION: {
-        type_name = WrapInNameSpace(*type.enum_def) + "Union";
+        type_name = NamespacedName(*type.enum_def) + "Union";
         break;
       }
       default: break;
@@ -1961,10 +2091,10 @@
       if (field.value.type.element == BASE_TYPE_UTYPE) continue;
       auto type_name = GenTypeGet_ObjectAPI(field.value.type, opts);
       if (field.IsScalarOptional()) type_name += "?";
-      auto camel_name = MakeCamel(field.name, true);
+      auto camel_name = Name(field);
       if (opts.cs_gen_json_serializer) {
         if (IsUnion(field.value.type)) {
-          auto utype_name = WrapInNameSpace(*field.value.type.enum_def);
+          auto utype_name = NamespacedName(*field.value.type.enum_def);
           code +=
               "  [Newtonsoft.Json.JsonProperty(\"" + field.name + "_type\")]\n";
           if (IsVector(field.value.type)) {
@@ -2027,7 +2157,7 @@
       if (field.deprecated) continue;
       if (field.value.type.base_type == BASE_TYPE_UTYPE) continue;
       if (field.value.type.element == BASE_TYPE_UTYPE) continue;
-      code += "    this." + MakeCamel(field.name) + " = ";
+      code += "    this." + Name(field) + " = ";
       auto type_name = GenTypeGet_ObjectAPI(field.value.type, opts);
       if (IsScalar(field.value.type.base_type)) {
         code += GenDefaultValue(field) + ";\n";
diff -urN a/src/idl_gen_dart.cpp b/src/idl_gen_dart.cpp
--- a/src/idl_gen_dart.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_dart.cpp	2023-01-13 07:47:08.831251612 +0000
@@ -63,7 +63,7 @@
       code.clear();
       code = code + "// " + FlatBuffersGeneratedWarning() + "\n";
       code = code +
-             "// ignore_for_file: unused_import, unused_field, "
+             "// ignore_for_file: unused_import, unused_field, unused_element, "
              "unused_local_variable\n\n";
 
       if (!kv->first.empty()) { code += "library " + kv->first + ";\n\n"; }
@@ -231,17 +231,18 @@
     code += "  final int value;\n";
     code += "  const " + name + "._(this.value);\n\n";
     code += "  factory " + name + ".fromValue(int value) {\n";
-    code += "    if (value == null) value = 0;\n";
-
-    code += "    if (!values.containsKey(value)) {\n";
-    code +=
-        "      throw new StateError('Invalid value $value for bit flag enum ";
+    code += "    final result = values[value];\n";
+    code += "    if (result == null) {\n";
+    code += "      throw StateError('Invalid value $value for bit flag enum ";
     code += name + "');\n";
     code += "    }\n";
 
-    code += "    return values[value];\n";
+    code += "    return result;\n";
     code += "  }\n\n";
 
+    code += "  static " + name + "? _createOrNull(int? value) => \n";
+    code += "      value == null ? null : " + name + ".fromValue(value);\n\n";
+
     // this is meaningless for bit_flags
     // however, note that unlike "regular" dart enums this enum can still have
     // holes.
@@ -263,19 +264,20 @@
         if (it != enum_def.Vals().begin()) { code += '\n'; }
         GenDocComment(ev.doc_comment, &code, "", "  ");
       }
-      code += "  static const " + name + " " + ev.name + " = ";
-      code += "const " + name + "._(" + enum_def.ToString(ev) + ");\n";
+      code += "  static const " + name + " " + ev.name + " = " + name + "._(" +
+              enum_def.ToString(ev) + ");\n";
     }
 
-    code += "  static const Map<int," + name + "> values = {";
+    code += "  static const Map<int, " + name + "> values = {\n";
     for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
       auto &ev = **it;
-      code += enum_def.ToString(ev) + ": " + ev.name + ",";
+      if (it != enum_def.Vals().begin()) code += ",\n";
+      code += "    " + enum_def.ToString(ev) + ": " + ev.name;
     }
     code += "};\n\n";
 
-    code += "  static const " + _kFb + ".Reader<" + name +
-            "> reader = const _" + name + "Reader();\n\n";
+    code += "  static const " + _kFb + ".Reader<" + name + "> reader = _" +
+            name + "Reader();\n\n";
     code += "  @override\n";
     code += "  String toString() {\n";
     code += "    return '" + name + "{value: $value}';\n";
@@ -298,7 +300,7 @@
     code += "  @override\n";
     code +=
         "  " + name + " read(" + _kFb + ".BufferContext bc, int offset) =>\n";
-    code += "      new " + name + ".fromValue(const " + _kFb + "." +
+    code += "      " + name + ".fromValue(const " + _kFb + "." +
             GenType(enum_def.underlying_type) + "Reader().read(bc, offset));\n";
     code += "}\n\n";
   }
@@ -327,30 +329,41 @@
 
   std::string GenReaderTypeName(const Type &type, Namespace *current_namespace,
                                 const FieldDef &def,
-                                bool parent_is_vector = false) {
+                                bool parent_is_vector = false, bool lazy = true,
+                                bool constConstruct = true) {
+    std::string prefix = (constConstruct ? "const " : "") + _kFb;
     if (type.base_type == BASE_TYPE_BOOL) {
-      return "const " + _kFb + ".BoolReader()";
+      return prefix + ".BoolReader()";
     } else if (IsVector(type)) {
-      return "const " + _kFb + ".ListReader<" +
+      if (!type.VectorType().enum_def) {
+        if (type.VectorType().base_type == BASE_TYPE_CHAR) {
+          return prefix + ".Int8ListReader(" + (lazy ? ")" : "lazy: false)");
+        }
+        if (type.VectorType().base_type == BASE_TYPE_UCHAR) {
+          return prefix + ".Uint8ListReader(" + (lazy ? ")" : "lazy: false)");
+        }
+      }
+      return prefix + ".ListReader<" +
              GenDartTypeName(type.VectorType(), current_namespace, def) + ">(" +
-             GenReaderTypeName(type.VectorType(), current_namespace, def,
-                               true) +
-             ")";
+             GenReaderTypeName(type.VectorType(), current_namespace, def, true,
+                               true, false) +
+             (lazy ? ")" : ", lazy: false)");
     } else if (IsString(type)) {
-      return "const " + _kFb + ".StringReader()";
+      return prefix + ".StringReader()";
     }
     if (IsScalar(type.base_type)) {
       if (type.enum_def && parent_is_vector) {
         return GenDartTypeName(type, current_namespace, def) + ".reader";
       }
-      return "const " + _kFb + "." + GenType(type) + "Reader()";
+      return prefix + "." + GenType(type) + "Reader()";
     } else {
       return GenDartTypeName(type, current_namespace, def) + ".reader";
     }
   }
 
   std::string GenDartTypeName(const Type &type, Namespace *current_namespace,
-                              const FieldDef &def, bool addBuilder = false) {
+                              const FieldDef &def,
+                              std::string struct_type_suffix = "") {
     if (type.enum_def) {
       if (type.enum_def->is_union && type.base_type != BASE_TYPE_UNION) {
         return type.enum_def->name + "TypeId";
@@ -375,18 +388,26 @@
       case BASE_TYPE_DOUBLE: return "double";
       case BASE_TYPE_STRING: return "String";
       case BASE_TYPE_STRUCT:
-        return MaybeWrapNamespace(
-            type.struct_def->name + (addBuilder ? "ObjectBuilder" : ""),
-            current_namespace, def);
+        return MaybeWrapNamespace(type.struct_def->name + struct_type_suffix,
+                                  current_namespace, def);
       case BASE_TYPE_VECTOR:
         return "List<" +
                GenDartTypeName(type.VectorType(), current_namespace, def,
-                               addBuilder) +
+                               struct_type_suffix) +
                ">";
       default: assert(0); return "dynamic";
     }
   }
 
+  std::string GenDartTypeName(const Type &type, Namespace *current_namespace,
+                              const FieldDef &def, bool nullable,
+                              std::string struct_type_suffix) {
+    std::string typeName =
+        GenDartTypeName(type, current_namespace, def, struct_type_suffix);
+    if (nullable && typeName != "dynamic") typeName += "?";
+    return typeName;
+  }
+
   static const std::string MaybeWrapNamespace(const std::string &type_name,
                                               Namespace *current_ns,
                                               const FieldDef &field) {
@@ -432,15 +453,15 @@
     code += "  " + object_name + "._(this._bc, this._bcOffset);\n";
     if (!struct_def.fixed) {
       code += "  factory " + object_name + "(List<int> bytes) {\n";
-      code += "    " + _kFb + ".BufferContext rootRef = new " + _kFb +
-              ".BufferContext.fromBytes(bytes);\n";
+      code +=
+          "    final rootRef = " + _kFb + ".BufferContext.fromBytes(bytes);\n";
       code += "    return reader.read(rootRef, 0);\n";
       code += "  }\n";
     }
 
     code += "\n";
     code += "  static const " + _kFb + ".Reader<" + object_name +
-            "> reader = const " + reader_name + "();\n\n";
+            "> reader = " + reader_name + "();\n\n";
 
     code += "  final " + _kFb + ".BufferContext _bc;\n";
     code += "  final int _bcOffset;\n\n";
@@ -456,8 +477,23 @@
 
     GenImplementationGetters(struct_def, non_deprecated_fields, &code);
 
+    if (parser_.opts.generate_object_based_api) {
+      code +=
+          "\n" + GenStructObjectAPIUnpack(struct_def, non_deprecated_fields);
+
+      code += "\n  static int pack(fb.Builder fbBuilder, " + struct_def.name +
+              "T? object) {\n";
+      code += "    if (object == null) return 0;\n";
+      code += "    return object.pack(fbBuilder);\n";
+      code += "  }\n";
+    }
+
     code += "}\n\n";
 
+    if (parser_.opts.generate_object_based_api) {
+      code += GenStructObjectAPI(struct_def, non_deprecated_fields);
+    }
+
     GenReader(struct_def, &reader_name, &reader_code);
     GenBuilder(struct_def, non_deprecated_fields, &builder_name, &builder_code);
     GenObjectBuilder(struct_def, non_deprecated_fields, &object_builder_name,
@@ -469,6 +505,124 @@
     (*namespace_code)[object_namespace] += code;
   }
 
+  // Generate an accessor struct with constructor for a flatbuffers struct.
+  std::string GenStructObjectAPI(
+      const StructDef &struct_def,
+      const std::vector<std::pair<int, FieldDef *>> &non_deprecated_fields) {
+    std::string code;
+    GenDocComment(struct_def.doc_comment, &code, "");
+
+    std::string class_name = struct_def.name + "T";
+    code += "class " + class_name + " implements " + _kFb + ".Packable {\n";
+
+    std::string constructor_args;
+    for (auto it = non_deprecated_fields.begin();
+         it != non_deprecated_fields.end(); ++it) {
+      const FieldDef &field = *it->second;
+
+      std::string field_name = MakeCamel(field.name, false);
+      std::string defaultValue = getDefaultValue(field.value);
+      std::string type_name =
+          GenDartTypeName(field.value.type, struct_def.defined_namespace, field,
+                          defaultValue.empty() && !struct_def.fixed, "T");
+
+      GenDocComment(field.doc_comment, &code, "", "  ");
+      code += "  " + type_name + " " + field_name + ";\n";
+
+      if (!constructor_args.empty()) constructor_args += ",\n";
+      constructor_args += "      ";
+      constructor_args += (struct_def.fixed ? "required " : "");
+      constructor_args += "this." + field_name;
+      if (!struct_def.fixed && !defaultValue.empty()) {
+        if (IsEnum(field.value.type)) {
+          auto &enum_def = *field.value.type.enum_def;
+          for (auto enumIt = enum_def.Vals().begin();
+               enumIt != enum_def.Vals().end(); ++enumIt) {
+            auto &ev = **enumIt;
+            if (enum_def.ToString(ev) == defaultValue) {
+              constructor_args += " = " + enum_def.name + "." + ev.name;
+              break;
+            }
+          }
+        } else {
+          constructor_args += " = " + defaultValue;
+        }
+      }
+    }
+
+    if (!constructor_args.empty()) {
+      code += "\n  " + class_name + "({\n" + constructor_args + "});\n\n";
+    }
+
+    code += GenStructObjectAPIPack(struct_def, non_deprecated_fields);
+    code += "\n";
+    code += GenToString(class_name, non_deprecated_fields);
+
+    code += "}\n\n";
+    return code;
+  }
+
+  // Generate function `StructNameT unpack()`
+  std::string GenStructObjectAPIUnpack(
+      const StructDef &struct_def,
+      const std::vector<std::pair<int, FieldDef *>> &non_deprecated_fields) {
+    std::string constructor_args;
+    for (auto it = non_deprecated_fields.begin();
+         it != non_deprecated_fields.end(); ++it) {
+      const FieldDef &field = *it->second;
+
+      std::string field_name = MakeCamel(field.name, false);
+      if (!constructor_args.empty()) constructor_args += ",\n";
+      constructor_args += "      " + field_name + ": ";
+
+      const Type &type = field.value.type;
+      std::string defaultValue = getDefaultValue(field.value);
+      bool isNullable = defaultValue.empty() && !struct_def.fixed;
+      std::string nullableValueAccessOperator = isNullable ? "?" : "";
+      if (type.base_type == BASE_TYPE_STRUCT) {
+        constructor_args +=
+            field_name + nullableValueAccessOperator + ".unpack()";
+      } else if (type.base_type == BASE_TYPE_VECTOR) {
+        if (type.VectorType().base_type == BASE_TYPE_STRUCT) {
+          constructor_args += field_name + nullableValueAccessOperator +
+                              ".map((e) => e.unpack()).toList()";
+        } else {
+          constructor_args +=
+              GenReaderTypeName(field.value.type, struct_def.defined_namespace,
+                                field, false, false);
+          constructor_args += ".vTableGet";
+          std::string offset = NumToString(field.value.offset);
+          constructor_args +=
+              isNullable
+                  ? "Nullable(_bc, _bcOffset, " + offset + ")"
+                  : "(_bc, _bcOffset, " + offset + ", " + defaultValue + ")";
+        }
+      } else {
+        constructor_args += field_name;
+      }
+    }
+
+    std::string class_name = struct_def.name + "T";
+    std::string code = "  " + class_name + " unpack() => " + class_name + "(";
+    if (!constructor_args.empty()) code += "\n" + constructor_args;
+    code += ");\n";
+    return code;
+  }
+
+  // Generate function `StructNameT pack()`
+  std::string GenStructObjectAPIPack(
+      const StructDef &struct_def,
+      const std::vector<std::pair<int, FieldDef *>> &non_deprecated_fields) {
+    std::string code;
+
+    code += "  @override\n";
+    code += "  int pack(fb.Builder fbBuilder) {\n";
+    code += GenObjectBuilderImplementation(struct_def, non_deprecated_fields,
+                                           false, true);
+    code += "  }\n";
+    return code;
+  }
+
   std::string NamespaceAliasFromUnionType(Namespace *root_namespace,
                                           const Type &type) {
     const std::vector<std::string> qualified_name_parts =
@@ -511,8 +665,11 @@
       auto &field = *pair.second;
 
       std::string field_name = MakeCamel(field.name, false);
-      std::string type_name = GenDartTypeName(
-          field.value.type, struct_def.defined_namespace, field, false);
+      std::string defaultValue = getDefaultValue(field.value);
+      bool isNullable = defaultValue.empty() && !struct_def.fixed;
+      std::string type_name =
+          GenDartTypeName(field.value.type, struct_def.defined_namespace, field,
+                          isNullable, "");
 
       GenDocComment(field.doc_comment, &code, "", "  ");
 
@@ -528,8 +685,8 @@
           auto enum_name = NamespaceAliasFromUnionType(
               enum_def.defined_namespace, ev.union_type);
           code += "      case " + enum_def.ToString(ev) + ": return " +
-                  enum_name + ".reader.vTableGet(_bc, _bcOffset, " +
-                  NumToString(field.value.offset) + ", null);\n";
+                  enum_name + ".reader.vTableGetNullable(_bc, _bcOffset, " +
+                  NumToString(field.value.offset) + ");\n";
         }
         code += "      default: return null;\n";
         code += "    }\n";
@@ -538,10 +695,9 @@
         code += " => ";
         if (field.value.type.enum_def &&
             field.value.type.base_type != BASE_TYPE_VECTOR) {
-          code += "new " +
-                  GenDartTypeName(field.value.type,
+          code += GenDartTypeName(field.value.type,
                                   struct_def.defined_namespace, field) +
-                  ".fromValue(";
+                  (isNullable ? "._createOrNull(" : ".fromValue(");
         }
 
         code += GenReaderTypeName(field.value.type,
@@ -550,33 +706,13 @@
           code +=
               ".read(_bc, _bcOffset + " + NumToString(field.value.offset) + ")";
         } else {
-          code += ".vTableGet(_bc, _bcOffset, " +
-                  NumToString(field.value.offset) + ", ";
-          if (!field.value.constant.empty() && field.value.constant != "0") {
-            if (IsBool(field.value.type.base_type)) {
-              code += "true";
-            } else if (field.value.constant == "nan" ||
-                       field.value.constant == "+nan" ||
-                       field.value.constant == "-nan") {
-              code += "double.nan";
-            } else if (field.value.constant == "inf" ||
-                       field.value.constant == "+inf") {
-              code += "double.infinity";
-            } else if (field.value.constant == "-inf") {
-              code += "double.negativeInfinity";
-            } else {
-              code += field.value.constant;
-            }
+          code += ".vTableGet";
+          std::string offset = NumToString(field.value.offset);
+          if (isNullable) {
+            code += "Nullable(_bc, _bcOffset, " + offset + ")";
           } else {
-            if (IsBool(field.value.type.base_type)) {
-              code += "false";
-            } else if (IsScalar(field.value.type.base_type)) {
-              code += "0";
-            } else {
-              code += "null";
-            }
+            code += "(_bc, _bcOffset, " + offset + ", " + defaultValue + ")";
           }
-          code += ")";
         }
         if (field.value.type.enum_def &&
             field.value.type.base_type != BASE_TYPE_VECTOR) {
@@ -587,10 +723,16 @@
     }
 
     code += "\n";
+    code += GenToString(struct_def.name, non_deprecated_fields);
+  }
 
+  std::string GenToString(
+      const std::string &object_name,
+      const std::vector<std::pair<int, FieldDef *>> &non_deprecated_fields) {
+    std::string code;
     code += "  @override\n";
     code += "  String toString() {\n";
-    code += "    return '" + struct_def.name + "{";
+    code += "    return '" + object_name + "{";
     for (auto it = non_deprecated_fields.begin();
          it != non_deprecated_fields.end(); ++it) {
       auto pair = *it;
@@ -601,6 +743,30 @@
     }
     code += "}';\n";
     code += "  }\n";
+    return code;
+  }
+
+  std::string getDefaultValue(const Value &value) const {
+    if (!value.constant.empty() && value.constant != "0") {
+      if (IsBool(value.type.base_type)) {
+        return "true";
+      } else if (value.constant == "nan" || value.constant == "+nan" ||
+                 value.constant == "-nan") {
+        return "double.nan";
+      } else if (value.constant == "inf" || value.constant == "+inf") {
+        return "double.infinity";
+      } else if (value.constant == "-inf") {
+        return "double.negativeInfinity";
+      } else {
+        return value.constant;
+      }
+    } else if (IsBool(value.type.base_type)) {
+      return "false";
+    } else if (IsScalar(value.type.base_type) && !IsUnion(value.type)) {
+      return "0";
+    } else {
+      return "";
+    }
   }
 
   void GenReader(const StructDef &struct_def, std::string *reader_name_ptr,
@@ -624,7 +790,7 @@
     }
     code += "  @override\n";
     code += "  " + impl_name +
-            " createObject(fb.BufferContext bc, int offset) => \n    new " +
+            " createObject(fb.BufferContext bc, int offset) => \n    " +
             impl_name + "._(bc, offset);\n";
     code += "}\n\n";
   }
@@ -637,9 +803,7 @@
     auto &builder_name = *builder_name_ptr;
 
     code += "class " + builder_name + " {\n";
-    code += "  " + builder_name + "(this.fbBuilder) {\n";
-    code += "    assert(fbBuilder != null);\n";
-    code += "  }\n\n";
+    code += "  " + builder_name + "(this.fbBuilder);\n\n";
     code += "  final " + _kFb + ".Builder fbBuilder;\n\n";
 
     if (struct_def.fixed) {
@@ -688,7 +852,7 @@
       } else {
         code += "    fbBuilder.put" + GenType(field.value.type) + "(";
         code += field.name;
-        if (field.value.type.enum_def) { code += "?.value"; }
+        if (field.value.type.enum_def) { code += ".value"; }
         code += ");\n";
       }
     }
@@ -703,7 +867,8 @@
     auto &code = *code_ptr;
 
     code += "  void begin() {\n";
-    code += "    fbBuilder.startTable();\n";
+    code += "    fbBuilder.startTable(" +
+            NumToString(non_deprecated_fields.size()) + ");\n";
     code += "  }\n\n";
 
     for (auto it = non_deprecated_fields.begin();
@@ -716,7 +881,7 @@
         code += "  int add" + MakeCamel(field.name) + "(";
         code += GenDartTypeName(field.value.type, struct_def.defined_namespace,
                                 field);
-        code += " " + MakeCamel(field.name, false) + ") {\n";
+        code += "? " + MakeCamel(field.name, false) + ") {\n";
         code += "    fbBuilder.add" + GenType(field.value.type) + "(" +
                 NumToString(offset) + ", ";
         code += MakeCamel(field.name, false);
@@ -727,7 +892,7 @@
         code +=
             "    fbBuilder.addStruct(" + NumToString(offset) + ", offset);\n";
       } else {
-        code += "  int add" + MakeCamel(field.name) + "Offset(int offset) {\n";
+        code += "  int add" + MakeCamel(field.name) + "Offset(int? offset) {\n";
         code +=
             "    fbBuilder.addOffset(" + NumToString(offset) + ", offset);\n";
       }
@@ -756,7 +921,7 @@
 
       code += "  final " +
               GenDartTypeName(field.value.type, struct_def.defined_namespace,
-                              field, true) +
+                              field, !struct_def.fixed, "ObjectBuilder") +
               " _" + MakeCamel(field.name, false) + ";\n";
     }
     code += "\n";
@@ -769,9 +934,10 @@
         auto pair = *it;
         auto &field = *pair.second;
 
-        code += "    " +
+        code += "    ";
+        code += (struct_def.fixed ? "required " : "") +
                 GenDartTypeName(field.value.type, struct_def.defined_namespace,
-                                field, true) +
+                                field, !struct_def.fixed, "ObjectBuilder") +
                 " " + MakeCamel(field.name, false) + ",\n";
       }
       code += "  })\n";
@@ -795,75 +961,101 @@
 
     code += "  /// Finish building, and store into the [fbBuilder].\n";
     code += "  @override\n";
-    code += "  int finish(\n";
-    code += "    " + _kFb + ".Builder fbBuilder) {\n";
-    code += "    assert(fbBuilder != null);\n";
+    code += "  int finish(" + _kFb + ".Builder fbBuilder) {\n";
+    code += GenObjectBuilderImplementation(struct_def, non_deprecated_fields);
+    code += "  }\n\n";
 
+    code += "  /// Convenience method to serialize to byte list.\n";
+    code += "  @override\n";
+    code += "  Uint8List toBytes([String? fileIdentifier]) {\n";
+    code += "    final fbBuilder = " + _kFb +
+            ".Builder(deduplicateTables: false);\n";
+    code += "    fbBuilder.finish(finish(fbBuilder), fileIdentifier);\n";
+    code += "    return fbBuilder.buffer;\n";
+    code += "  }\n";
+    code += "}\n";
+  }
+
+  std::string GenObjectBuilderImplementation(
+      const StructDef &struct_def,
+      const std::vector<std::pair<int, FieldDef *>> &non_deprecated_fields,
+      bool prependUnderscore = true, bool pack = false) {
+    std::string code;
     for (auto it = non_deprecated_fields.begin();
          it != non_deprecated_fields.end(); ++it) {
-      auto pair = *it;
-      auto &field = *pair.second;
+      const FieldDef &field = *it->second;
 
       if (IsScalar(field.value.type.base_type) || IsStruct(field.value.type))
         continue;
 
-      code += "    final int " + MakeCamel(field.name, false) + "Offset";
-      if (IsVector(field.value.type)) {
+      std::string offset_name = MakeCamel(field.name, false) + "Offset";
+      std::string field_name =
+          (prependUnderscore ? "_" : "") + MakeCamel(field.name, false);
+
+      // custom handling for fixed-sized struct in pack()
+      if (pack && IsVector(field.value.type) &&
+          field.value.type.VectorType().base_type == BASE_TYPE_STRUCT &&
+          field.value.type.struct_def->fixed) {
+        code += "    int? " + offset_name + ";\n";
+        code += "    if (" + field_name + " != null) {\n";
         code +=
-            " = _" + MakeCamel(field.name, false) + "?.isNotEmpty == true\n";
-        code += "        ? fbBuilder.writeList";
+            "      for (var e in " + field_name + "!) { e.pack(fbBuilder); }\n";
+        code += "      " + MakeCamel(field.name, false) +
+                "Offset = fbBuilder.endStructVector(" + field_name +
+                "!.length);\n";
+        code += "    }\n";
+        continue;
+      }
+
+      code += "    final int? " + offset_name;
+      if (IsVector(field.value.type)) {
+        code += " = " + field_name + " == null ? null\n";
+        code += "        : fbBuilder.writeList";
         switch (field.value.type.VectorType().base_type) {
           case BASE_TYPE_STRING:
-            code += "(_" + MakeCamel(field.name, false) +
-                    ".map((b) => fbBuilder.writeString(b)).toList())";
+            code +=
+                "(" + field_name + "!.map(fbBuilder.writeString).toList());\n";
             break;
           case BASE_TYPE_STRUCT:
             if (field.value.type.struct_def->fixed) {
-              code += "OfStructs(_" + MakeCamel(field.name, false) + ")";
+              code += "OfStructs(" + field_name + "!);\n";
             } else {
-              code += "(_" + MakeCamel(field.name, false) +
-                      ".map((b) => b.getOrCreateOffset(fbBuilder)).toList())";
+              code += "(" + field_name + "!.map((b) => b." +
+                      (pack ? "pack" : "getOrCreateOffset") +
+                      "(fbBuilder)).toList());\n";
             }
             break;
           default:
-            code += GenType(field.value.type.VectorType()) + "(_" +
-                    MakeCamel(field.name, false);
-            if (field.value.type.enum_def) { code += ".map((f) => f.value)"; }
-            code += ")";
+            code +=
+                GenType(field.value.type.VectorType()) + "(" + field_name + "!";
+            if (field.value.type.enum_def) {
+              code += ".map((f) => f.value).toList()";
+            }
+            code += ");\n";
         }
-        code += "\n        : null;\n";
       } else if (IsString(field.value.type)) {
-        code += " = fbBuilder.writeString(_" + MakeCamel(field.name, false) +
-                ");\n";
+        code += " = " + field_name + " == null ? null\n";
+        code += "        : fbBuilder.writeString(" + field_name + "!);\n";
       } else {
-        code += " = _" + MakeCamel(field.name, false) +
-                "?.getOrCreateOffset(fbBuilder);\n";
+        code += " = " + field_name + "?." +
+                (pack ? "pack" : "getOrCreateOffset") + "(fbBuilder);\n";
       }
     }
 
-    code += "\n";
     if (struct_def.fixed) {
-      StructObjectBuilderBody(non_deprecated_fields, code_ptr);
+      code += StructObjectBuilderBody(non_deprecated_fields, prependUnderscore,
+                                      pack);
     } else {
-      TableObjectBuilderBody(non_deprecated_fields, code_ptr);
+      code += TableObjectBuilderBody(non_deprecated_fields, prependUnderscore,
+                                     pack);
     }
-    code += "  }\n\n";
-
-    code += "  /// Convenience method to serialize to byte list.\n";
-    code += "  @override\n";
-    code += "  Uint8List toBytes([String fileIdentifier]) {\n";
-    code += "    " + _kFb + ".Builder fbBuilder = new ";
-    code += _kFb + ".Builder();\n";
-    code += "    int offset = finish(fbBuilder);\n";
-    code += "    return fbBuilder.finish(offset, fileIdentifier);\n";
-    code += "  }\n";
-    code += "}\n";
+    return code;
   }
 
-  void StructObjectBuilderBody(
-      std::vector<std::pair<int, FieldDef *>> non_deprecated_fields,
-      std::string *code_ptr, bool prependUnderscore = true) {
-    auto &code = *code_ptr;
+  std::string StructObjectBuilderBody(
+      const std::vector<std::pair<int, FieldDef *>> &non_deprecated_fields,
+      bool prependUnderscore = true, bool pack = false) {
+    std::string code;
 
     for (auto it = non_deprecated_fields.rbegin();
          it != non_deprecated_fields.rend(); ++it) {
@@ -877,24 +1069,26 @@
       if (IsStruct(field.value.type)) {
         code += "    ";
         if (prependUnderscore) { code += "_"; }
-        code += field.name + ".finish(fbBuilder);\n";
+        code += field.name + (pack ? ".pack" : ".finish") + "(fbBuilder);\n";
       } else {
         code += "    fbBuilder.put" + GenType(field.value.type) + "(";
         if (prependUnderscore) { code += "_"; }
         code += field.name;
-        if (field.value.type.enum_def) { code += "?.value"; }
+        if (field.value.type.enum_def) { code += ".value"; }
         code += ");\n";
       }
     }
 
     code += "    return fbBuilder.offset;\n";
+    return code;
   }
 
-  void TableObjectBuilderBody(
-      std::vector<std::pair<int, FieldDef *>> non_deprecated_fields,
-      std::string *code_ptr, bool prependUnderscore = true) {
-    std::string &code = *code_ptr;
-    code += "    fbBuilder.startTable();\n";
+  std::string TableObjectBuilderBody(
+      const std::vector<std::pair<int, FieldDef *>> &non_deprecated_fields,
+      bool prependUnderscore = true, bool pack = false) {
+    std::string code;
+    code += "    fbBuilder.startTable(" +
+            NumToString(non_deprecated_fields.size()) + ");\n";
 
     for (auto it = non_deprecated_fields.begin();
          it != non_deprecated_fields.end(); ++it) {
@@ -902,29 +1096,29 @@
       auto &field = *pair.second;
       auto offset = pair.first;
 
+      std::string field_name =
+          (prependUnderscore ? "_" : "") + MakeCamel(field.name, false);
+
       if (IsScalar(field.value.type.base_type)) {
         code += "    fbBuilder.add" + GenType(field.value.type) + "(" +
-                NumToString(offset) + ", ";
-        if (prependUnderscore) { code += "_"; }
-        code += MakeCamel(field.name, false);
-        if (field.value.type.enum_def) { code += "?.value"; }
+                NumToString(offset) + ", " + field_name;
+        if (field.value.type.enum_def) {
+          bool isNullable = getDefaultValue(field.value).empty();
+          code += (isNullable || !pack) ? "?.value" : ".value";
+        }
         code += ");\n";
       } else if (IsStruct(field.value.type)) {
-        code += "    if (";
-        if (prependUnderscore) { code += "_"; }
-        code += MakeCamel(field.name, false) + " != null) {\n";
-        code += "      fbBuilder.addStruct(" + NumToString(offset) + ", ";
-        code += "_" + MakeCamel(field.name, false) + ".finish(fbBuilder));\n";
+        code += "    if (" + field_name + " != null) {\n";
+        code += "      fbBuilder.addStruct(" + NumToString(offset) + ", " +
+                field_name + (pack ? "!.pack" : "!.finish") + "(fbBuilder));\n";
         code += "    }\n";
       } else {
-        code +=
-            "    if (" + MakeCamel(field.name, false) + "Offset != null) {\n";
-        code += "      fbBuilder.addOffset(" + NumToString(offset) + ", " +
+        code += "    fbBuilder.addOffset(" + NumToString(offset) + ", " +
                 MakeCamel(field.name, false) + "Offset);\n";
-        code += "    }\n";
       }
     }
     code += "    return fbBuilder.endTable();\n";
+    return code;
   }
 };
 }  // namespace dart
@@ -937,8 +1131,6 @@
 
 std::string DartMakeRule(const Parser &parser, const std::string &path,
                          const std::string &file_name) {
-  assert(parser.opts.lang <= IDLOptions::kMAX);
-
   auto filebase =
       flatbuffers::StripPath(flatbuffers::StripExtension(file_name));
   dart::DartGenerator generator(parser, path, file_name);
diff -urN a/src/idl_gen_grpc.cpp b/src/idl_gen_grpc.cpp
--- a/src/idl_gen_grpc.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_grpc.cpp	2023-01-13 07:47:08.833251631 +0000
@@ -191,7 +191,7 @@
     }
   }
 
-  void SetIndentationSize(const int size) {
+  void SetIndentationSize(const size_t size) {
     FLATBUFFERS_ASSERT(str_->empty());
     indentation_size_ = size;
   }
@@ -199,15 +199,15 @@
   void Indent() { indent_++; }
 
   void Outdent() {
+    FLATBUFFERS_ASSERT(indent_ > 0);
     indent_--;
-    FLATBUFFERS_ASSERT(indent_ >= 0);
   }
 
  private:
   std::string *str_;
   char escape_char_;
-  int indent_;
-  int indentation_size_;
+  size_t indent_;
+  size_t indentation_size_;
   char indentation_type_;
 };
 
@@ -242,7 +242,9 @@
     return StripExtension(file_name_);
   }
 
-  std::string message_header_ext() const { return "_generated.h"; }
+  std::string message_header_ext() const {
+    return parser_.opts.filename_suffix + ".h";
+  }
 
   std::string service_header_ext() const { return ".grpc.fb.h"; }
 
diff -urN a/src/idl_gen_java.cpp b/src/idl_gen_java.cpp
--- a/src/idl_gen_java.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_java.cpp	2023-01-13 07:47:08.894252193 +0000
@@ -21,10 +21,6 @@
 #include "flatbuffers/idl.h"
 #include "flatbuffers/util.h"
 
-#if defined(FLATBUFFERS_CPP98_STL)
-#  include <cctype>
-#endif  // defined(FLATBUFFERS_CPP98_STL)
-
 namespace flatbuffers {
 namespace java {
 
@@ -39,6 +35,11 @@
 };
 
 class JavaGenerator : public BaseGenerator {
+  struct FieldArrayLength {
+    std::string name;
+    int length;
+  };
+
  public:
   JavaGenerator(const Parser &parser, const std::string &path,
                 const std::string &file_name)
@@ -63,6 +64,19 @@
                       /* needs_includes= */ false))
           return false;
       }
+
+      if (parser_.opts.generate_object_based_api && enum_def.is_union) {
+        enumcode = "";
+        GenEnum_ObjectAPI(enum_def, &enumcode, parser_.opts);
+        auto class_name = enum_def.name + "Union";
+        if (parser_.opts.one_file) {
+          one_file_code += enumcode;
+        } else {
+          if (!SaveType(class_name, *enum_def.defined_namespace, enumcode,
+                        /* needs_includes= */ false))
+            return false;
+        }
+      }
     }
 
     for (auto it = parser_.structs_.vec.begin();
@@ -71,7 +85,7 @@
       auto &struct_def = **it;
       if (!parser_.opts.one_file)
         cur_name_space_ = struct_def.defined_namespace;
-      GenStruct(struct_def, &declcode);
+      GenStruct(struct_def, &declcode, parser_.opts);
       if (parser_.opts.one_file) {
         one_file_code += declcode;
       } else {
@@ -79,6 +93,19 @@
                       /* needs_includes= */ true))
           return false;
       }
+
+      if (parser_.opts.generate_object_based_api) {
+        declcode = "";
+        GenStruct_ObjectAPI(struct_def, &declcode, parser_.opts);
+        auto class_name = GenTypeName_ObjectAPI(struct_def.name, parser_.opts);
+        if (parser_.opts.one_file) {
+          one_file_code += declcode;
+        } else {
+          if (!SaveType(class_name, *struct_def.defined_namespace, declcode,
+                        /* needs_includes= */ true))
+            return false;
+        }
+      }
     }
 
     if (parser_.opts.one_file) {
@@ -231,11 +258,11 @@
     } else {
       if (castFromDest) {
         if (type.base_type == BASE_TYPE_UINT)
-          return "(int)";
+          return "(int) ";
         else if (type.base_type == BASE_TYPE_USHORT)
-          return "(short)";
+          return "(short) ";
         else if (type.base_type == BASE_TYPE_UCHAR)
-          return "(byte)";
+          return "(byte) ";
       }
     }
     return "";
@@ -304,6 +331,7 @@
     // That, and Java Enums are expensive, and not universally liked.
     GenComment(enum_def.doc_comment, code_ptr, &comment_config);
 
+    code += "@SuppressWarnings(\"unused\")\n";
     if (enum_def.attributes.Lookup("private")) {
       // For Java, we leave the enum unmarked to indicate package-private
     } else {
@@ -323,7 +351,7 @@
       code += ";\n";
     }
 
-    // Generate a generate string table for enum values.
+    // Generate a string table for enum values.
     // Problem is, if values are very sparse that could generate really big
     // tables. Ideally in that case we generate a map lookup instead, but for
     // the moment we simply don't output a table at all.
@@ -331,7 +359,9 @@
     // Average distance between values above which we consider a table
     // "too sparse". Change at will.
     static const uint64_t kMaxSparseness = 5;
-    if (range / static_cast<uint64_t>(enum_def.size()) < kMaxSparseness) {
+    if (range / static_cast<uint64_t>(enum_def.size()) < kMaxSparseness &&
+        GenTypeBasic(DestinationType(enum_def.underlying_type, false)) !=
+            "long") {
       code += "\n  public static final String";
       code += "[] names = { ";
       auto val = enum_def.Vals().front();
@@ -433,7 +463,7 @@
                       (nameprefix + (field.name + "_")).c_str(), array_cnt);
       } else {
         code += ", ";
-        code += GenTypeBasic(type);
+        code += GenTypeNameDest(field.value.type);
         for (size_t i = 0; i < array_cnt; i++) code += "[]";
         code += " ";
         code += nameprefix;
@@ -560,7 +590,8 @@
     return key_getter;
   }
 
-  void GenStruct(StructDef &struct_def, std::string *code_ptr) const {
+  void GenStruct(StructDef &struct_def, std::string *code_ptr,
+                 const IDLOptions &opts) const {
     if (struct_def.generated) return;
     std::string &code = *code_ptr;
 
@@ -668,7 +699,7 @@
         code += MakeCamel(field.name, false);
         code += "(new ";
         code += type_name + "()); }\n";
-      } else if (IsVector(field.value.type) &&
+      } else if (IsSeries(field.value.type) &&
                  field.value.type.element == BASE_TYPE_STRUCT) {
         // Accessors for vectors of structs also take accessor objects, this
         // generates a variant without that argument.
@@ -937,8 +968,11 @@
       }
     }
     code += "\n";
+    auto struct_has_create = false;
+    std::set<flatbuffers::FieldDef *> field_has_create_set;
     flatbuffers::FieldDef *key_field = nullptr;
     if (struct_def.fixed) {
+      struct_has_create = true;
       // create a struct constructor function
       code += "  public static " + GenOffsetType() + " ";
       code += "create";
@@ -968,6 +1002,7 @@
       // JVM specifications restrict default constructor params to be < 255.
       // Longs and doubles take up 2 units, so we set the limit to be < 127.
       if (has_no_struct_fields && num_fields && num_fields < 127) {
+        struct_has_create = true;
         // Generate a table constructor of the form:
         // public static int createName(FlatBufferBuilder builder, args...)
         code += "  public static " + GenOffsetType() + " ";
@@ -976,11 +1011,12 @@
         for (auto it = struct_def.fields.vec.begin();
              it != struct_def.fields.vec.end(); ++it) {
           auto &field = **it;
+          auto field_name = MakeCamel(field.name, false);
           if (field.deprecated) continue;
           code += ",\n      ";
           code += GenTypeBasic(DestinationType(field.value.type, false));
           code += " ";
-          code += field.name;
+          code += field_name;
           if (!IsScalar(field.value.type.base_type)) code += "Offset";
         }
         code += ") {\n    builder.";
@@ -991,12 +1027,14 @@
           for (auto it = struct_def.fields.vec.rbegin();
                it != struct_def.fields.vec.rend(); ++it) {
             auto &field = **it;
+            auto field_name = MakeCamel(field.name, false);
+            auto method_name = MakeCamel(field.name, true);
             if (!field.deprecated &&
                 (!struct_def.sortbysize ||
                  size == SizeOf(field.value.type.base_type))) {
               code += "    " + struct_def.name + ".";
               code += "add";
-              code += MakeCamel(field.name) + "(builder, " + field.name;
+              code += method_name + "(builder, " + field_name;
               if (!IsScalar(field.value.type.base_type)) code += "Offset";
               code += ");\n";
             }
@@ -1041,6 +1079,7 @@
           auto alignment = InlineAlignment(vector_type);
           auto elem_size = InlineSize(vector_type);
           if (!IsStruct(vector_type)) {
+            field_has_create_set.insert(&field);
             // generate a method to create a vector from a java array.
             if ((vector_type.base_type == BASE_TYPE_CHAR ||
                  vector_type.base_type == BASE_TYPE_UCHAR)) {
@@ -1061,7 +1100,8 @@
               code += "create";
               code += MakeCamel(field.name);
               code += "Vector(FlatBufferBuilder builder, ";
-              code += GenTypeBasic(vector_type) + "[] data) ";
+              code += GenTypeBasic(DestinationType(vector_type, false)) +
+                      "[] data) ";
               code += "{ builder.startVector(";
               code += NumToString(elem_size);
               code += ", data.length, ";
@@ -1071,7 +1111,7 @@
               code += "add";
               code += GenMethod(vector_type);
               code += "(";
-              code += SourceCastBasic(vector_type, false);
+              code += SourceCastBasic(vector_type);
               code += "data[i]";
               code += "); return ";
               code += "builder.endVector(); }\n";
@@ -1157,8 +1197,11 @@
       code += "  }\n";
     }
     GenVectorAccessObject(struct_def, code_ptr);
-    code += "}";
-    code += "\n\n";
+    if (opts.generate_object_based_api) {
+      GenPackUnPack_ObjectAPI(struct_def, code_ptr, opts, struct_has_create,
+                              field_has_create_set);
+    }
+    code += "}\n\n";
   }
 
   std::string GenOptionalScalarCheck(FieldDef &field) const {
@@ -1229,6 +1272,866 @@
     code += "  }\n";
   }
 
+  std::string GenGetterFuncName_ObjectAPI(const std::string &field_name) const {
+    return "get" + MakeCamel(field_name, true);
+  }
+
+  void GenEnum_ObjectAPI(EnumDef &enum_def, std::string *code_ptr,
+                         const IDLOptions &opts) const {
+    auto &code = *code_ptr;
+    if (enum_def.generated) return;
+    code += "import com.google.flatbuffers.FlatBufferBuilder;\n\n";
+
+    if (!enum_def.attributes.Lookup("private")) { code += "public "; }
+    auto union_name = enum_def.name + "Union";
+    auto union_type =
+        GenTypeBasic(DestinationType(enum_def.underlying_type, false));
+    code += "class " + union_name + " {\n";
+    // Type
+    code += "  private " + union_type + " type;\n";
+    // Value
+    code += "  private Object value;\n";
+    code += "\n";
+    // getters and setters
+    code += "  public " + union_type + " getType() { return type; }\n\n";
+    code += "  public void setType(" + union_type +
+            " type) { this.type = type; }\n\n";
+    code += "  public Object getValue() { return value; }\n\n";
+    code += "  public void setValue(Object value) { this.value = value; }\n\n";
+    // Constructor
+    code += "  public " + union_name + "() {\n";
+    code += "    this.type = " + enum_def.name + "." +
+            enum_def.Vals()[0]->name + ";\n";
+    code += "    this.value = null;\n";
+    code += "  }\n\n";
+    // As
+    for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
+      auto &ev = **it;
+      if (ev.union_type.base_type == BASE_TYPE_NONE) continue;
+      auto type_name = GenTypeGet_ObjectAPI(ev.union_type, opts, false, true);
+      if (ev.union_type.base_type == BASE_TYPE_STRUCT &&
+          ev.union_type.struct_def->attributes.Lookup("private")) {
+        code += "  ";
+      } else {
+        code += "  public ";
+      }
+      code += type_name + " as" + ev.name + "() { return (" + type_name +
+              ") value; }\n";
+    }
+    code += "\n";
+    // pack()
+    code += "  public static int pack(FlatBufferBuilder builder, " +
+            union_name + " _o) {\n";
+    code += "    switch (_o.type) {\n";
+    for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
+      auto &ev = **it;
+      if (ev.union_type.base_type == BASE_TYPE_NONE) {
+        continue;
+      } else {
+        code += "      case " + enum_def.name + "." + ev.name + ": return ";
+        if (IsString(ev.union_type)) {
+          code += "builder.createString(_o.as" + ev.name + "());\n";
+        } else {
+          code += GenTypeGet(ev.union_type) + ".pack(builder, _o.as" + ev.name +
+                  "());\n";
+        }
+      }
+    }
+    code += "      default: return 0;\n";
+    code += "    }\n";
+    code += "  }\n";
+    code += "}\n\n";
+  }
+
+  std::string GenSetterFuncName_ObjectAPI(const std::string &field_name) const {
+    return "set" + MakeCamel(field_name, true);
+  }
+
+  std::string GenTypeName_ObjectAPI(const std::string &name,
+                                    const IDLOptions &opts) const {
+    return opts.object_prefix + name + opts.object_suffix;
+  }
+
+  void GenUnionUnPack_ObjectAPI(const EnumDef &enum_def, std::string *code_ptr,
+                                const std::string &type_name,
+                                const std::string &camel_name,
+                                bool is_vector) const {
+    auto &code = *code_ptr;
+
+    std::string variable_type = type_name;
+    std::string variable_name = "_o" + MakeCamel(camel_name, true);
+    std::string type_params = "";
+    std::string value_params = "";
+    std::string func_suffix = "()";
+    std::string indent = "    ";
+    if (is_vector) {
+      variable_type = type_name.substr(0, type_name.length() - 2);
+      variable_name += "Element";
+      type_params = "_j";
+      value_params = ", _j";
+      func_suffix = "(_j)";
+      indent = "      ";
+    }
+    code += indent + variable_type + " " + variable_name + " = new " +
+            variable_type + "();\n";
+    code += indent +
+            GenTypeBasic(DestinationType(enum_def.underlying_type, false)) +
+            " " + variable_name + "Type = " + camel_name + "Type(" +
+            type_params + ");\n";
+    code += indent + variable_name + ".setType(" + variable_name + "Type);\n";
+    code += indent + "Table " + variable_name + "Value;\n";
+    code += indent + "switch (" + variable_name + "Type) {\n";
+    for (auto eit = enum_def.Vals().begin(); eit != enum_def.Vals().end();
+         ++eit) {
+      auto &ev = **eit;
+      if (ev.union_type.base_type == BASE_TYPE_NONE) {
+        continue;
+      } else {
+        if (ev.union_type.base_type == BASE_TYPE_STRING ||
+            (ev.union_type.base_type == BASE_TYPE_STRUCT &&
+             ev.union_type.struct_def->fixed)) {
+          continue;  // This branch is due to bad implemantation of Unions in
+                     // Java which doesn't handle non Table types. Should be
+                     // deleted when issue #6561 is fixed.
+        }
+        code += indent + "  case " + WrapInNameSpace(enum_def) + "." + ev.name +
+                ":\n";
+        auto actual_type = GenTypeGet(ev.union_type);
+        code += indent + "    " + variable_name + "Value = " + camel_name +
+                "(new " + actual_type + "()" + value_params + ");\n";
+        code += indent + "    " + variable_name + ".setValue(" + variable_name +
+                "Value != null ? ((" + actual_type + ") " + variable_name +
+                "Value).unpack() : null);\n";
+        code += indent + "    break;\n";
+      }
+    }
+    code += indent + "  default: break;\n";
+    code += indent + "}\n";
+    if (is_vector) {
+      code += indent + "_o" + MakeCamel(camel_name, true) +
+              "[_j] = " + variable_name + ";\n";
+    }
+  }
+
+  void GenPackUnPack_ObjectAPI(
+      StructDef &struct_def, std::string *code_ptr, const IDLOptions &opts,
+      bool struct_has_create,
+      const std::set<FieldDef *> &field_has_create) const {
+    auto &code = *code_ptr;
+    auto struct_name = GenTypeName_ObjectAPI(struct_def.name, opts);
+    // unpack()
+    code += "  public " + struct_name + " unpack() {\n";
+    code += "    " + struct_name + " _o = new " + struct_name + "();\n";
+    code += "    unpackTo(_o);\n";
+    code += "    return _o;\n";
+    code += "  }\n";
+    // unpackTo()
+    code += "  public void unpackTo(" + struct_name + " _o) {\n";
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      if (field.value.type.base_type == BASE_TYPE_UTYPE) continue;
+      if (field.value.type.element == BASE_TYPE_UTYPE) continue;
+      auto camel_name = MakeCamel(field.name, false);
+      auto camel_name_with_first = MakeCamel(field.name, true);
+      auto type_name =
+          GenTypeGet_ObjectAPI(field.value.type, opts, false, true);
+      if (field.IsScalarOptional())
+        type_name = ConvertPrimitiveTypeToObjectWrapper_ObjectAPI(type_name);
+      auto start = "    " + type_name + " _o" + camel_name_with_first + " = ";
+      auto call_setter = true;
+      switch (field.value.type.base_type) {
+        case BASE_TYPE_STRUCT: {
+          auto fixed = struct_def.fixed && field.value.type.struct_def->fixed;
+          if (fixed) {
+            code += "    " + camel_name + "().unpackTo(_o.get" +
+                    camel_name_with_first + "());\n";
+          } else {
+            code += "    if (" + camel_name + "() != null) ";
+            if (field.value.type.struct_def->fixed) {
+              code += camel_name + "().unpackTo(_o.get" +
+                      camel_name_with_first + "());\n";
+            } else {
+              code += "_o." + GenSetterFuncName_ObjectAPI(field.name) + "(" +
+                      camel_name + "().unpack());\n";
+            }
+            code += "    else _o." + GenSetterFuncName_ObjectAPI(field.name) +
+                    "(null);\n";
+          }
+          call_setter = false;
+          break;
+        }
+        case BASE_TYPE_ARRAY: {
+          auto length_str = NumToString(field.value.type.fixed_length);
+          auto unpack_method =
+              field.value.type.struct_def == nullptr ? "" : ".unpack()";
+          code +=
+              start + "_o." + GenGetterFuncName_ObjectAPI(field.name) + "();\n";
+          code += "    for (int _j = 0; _j < " + length_str + "; ++_j) { _o" +
+                  camel_name_with_first + "[_j] = " + camel_name + "(_j)" +
+                  unpack_method + "; }\n";
+          call_setter = false;
+          break;
+        }
+        case BASE_TYPE_VECTOR:
+          if (field.value.type.element == BASE_TYPE_UNION) {
+            code += start + "new " +
+                    GenConcreteTypeGet_ObjectAPI(field.value.type, opts)
+                        .substr(0, type_name.length() - 1) +
+                    camel_name + "Length()];\n";
+            code += "    for (int _j = 0; _j < " + camel_name +
+                    "Length(); ++_j) {\n";
+            GenUnionUnPack_ObjectAPI(*field.value.type.enum_def, code_ptr,
+                                     type_name, camel_name, true);
+            code += "    }\n";
+          } else if (field.value.type.element != BASE_TYPE_UTYPE) {
+            auto fixed = field.value.type.struct_def == nullptr;
+            code += start + "new " +
+                    GenConcreteTypeGet_ObjectAPI(field.value.type, opts)
+                        .substr(0, type_name.length() - 1) +
+                    camel_name + "Length()];\n";
+            code +=
+                "    for (int _j = 0; _j < " + camel_name + "Length(); ++_j) {";
+            code += "_o" + camel_name_with_first + "[_j] = ";
+            if (fixed) {
+              code += camel_name + "(_j)";
+            } else {
+              code += "(" + camel_name + "(_j) != null ? " + camel_name +
+                      "(_j).unpack() : null)";
+            }
+            code += ";}\n";
+          }
+          break;
+        case BASE_TYPE_UTYPE: break;
+        case BASE_TYPE_UNION: {
+          GenUnionUnPack_ObjectAPI(*field.value.type.enum_def, code_ptr,
+                                   type_name, camel_name, false);
+          break;
+        }
+        default: {
+          if (field.IsScalarOptional()) {
+            code += start + "has" + camel_name_with_first + "() ? " +
+                    camel_name + "() : null;\n";
+          } else {
+            code += start + camel_name + "();\n";
+          }
+          break;
+        }
+      }
+      if (call_setter) {
+        code += "    _o." + GenSetterFuncName_ObjectAPI(field.name) + "(_o" +
+                camel_name_with_first + ");\n";
+      }
+    }
+    code += "  }\n";
+    // pack()
+    code += "  public static " + GenOffsetType() +
+            " pack(FlatBufferBuilder builder, " + struct_name + " _o) {\n";
+    code += "    if (_o == null) return 0;\n";
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      auto camel_name = MakeCamel(field.name, false);
+      auto camel_name_with_first = MakeCamel(field.name, true);
+      // pre
+      switch (field.value.type.base_type) {
+        case BASE_TYPE_STRUCT: {
+          if (!field.value.type.struct_def->fixed) {
+            code += "    " + GenOffsetType() + " _" + field.name + " = _o." +
+                    GenGetterFuncName_ObjectAPI(field.name) +
+                    "() == null ? 0 : " + GenTypeGet(field.value.type) +
+                    ".pack(builder, _o." +
+                    GenGetterFuncName_ObjectAPI(field.name) + "());\n";
+          } else if (struct_def.fixed && struct_has_create) {
+            std::vector<FieldArrayLength> array_lengths;
+            FieldArrayLength tmp_array_length = {
+              field.name,
+              field.value.type.fixed_length,
+            };
+            array_lengths.push_back(tmp_array_length);
+            GenStructPackDecl_ObjectAPI(*field.value.type.struct_def, code_ptr,
+                                        array_lengths);
+          }
+          break;
+        }
+        case BASE_TYPE_STRING: {
+          std::string create_string = "createString";
+          code += "    int _" + camel_name + " = _o." +
+                  GenGetterFuncName_ObjectAPI(field.name) +
+                  "() == null ? 0 : "
+                  "builder." +
+                  create_string + "(_o." +
+                  GenGetterFuncName_ObjectAPI(field.name) + "());\n";
+          break;
+        }
+        case BASE_TYPE_VECTOR: {
+          if (field_has_create.find(&field) != field_has_create.end()) {
+            auto property_name = camel_name;
+            auto gen_for_loop = true;
+            std::string array_name = "__" + camel_name;
+            std::string array_type = "";
+            std::string element_type = "";
+            std::string to_array = "";
+            switch (field.value.type.element) {
+              case BASE_TYPE_STRING: {
+                std::string create_string = "createString";
+                array_type = "int";
+                element_type = "String";
+                to_array += "builder." + create_string + "(_e)";
+                break;
+              }
+              case BASE_TYPE_STRUCT:
+                array_type = "int";
+                element_type =
+                    GenTypeGet_ObjectAPI(field.value.type, opts, true, true);
+                ;
+                to_array = GenTypeGet(field.value.type) + ".pack(builder, _e)";
+                break;
+              case BASE_TYPE_UTYPE:
+                property_name = camel_name.substr(0, camel_name.size() - 4);
+                array_type = GenTypeBasic(DestinationType(
+                    field.value.type.enum_def->underlying_type, false));
+                element_type = field.value.type.enum_def->name + "Union";
+                to_array = "_o." + GenGetterFuncName_ObjectAPI(property_name) +
+                           "()[_j].getType()";
+                break;
+              case BASE_TYPE_UNION:
+                array_type = "int";
+                element_type =
+                    WrapInNameSpace(*field.value.type.enum_def) + "Union";
+                to_array = WrapInNameSpace(*field.value.type.enum_def) +
+                           "Union.pack(builder,  _o." +
+                           GenGetterFuncName_ObjectAPI(property_name) +
+                           "()[_j])";
+                break;
+              case BASE_TYPE_UCHAR:  // TODO this branch of the switch is due to
+                                     // inconsistent behavior in unsigned byte.
+                                     // Read further at Issue #6574.
+                array_type = "byte";
+                element_type = "int";
+                to_array = "(byte) _e";
+                break;
+              default:
+                gen_for_loop = false;
+                array_name =
+                    "_o." + GenGetterFuncName_ObjectAPI(property_name) + "()";
+                array_type = GenTypeNameDest(field.value.type);
+                element_type = array_type;
+                to_array = "_e";
+                break;
+            }
+            code += "    int _" + camel_name + " = 0;\n";
+            code += "    if (_o." + GenGetterFuncName_ObjectAPI(property_name) +
+                    "() != null) {\n";
+            if (gen_for_loop) {
+              code += "      " + array_type + "[] " + array_name + " = new " +
+                      array_type + "[_o." +
+                      GenGetterFuncName_ObjectAPI(property_name) +
+                      "().length];\n";
+              code += "      int _j = 0;\n";
+              code += "      for (" + element_type + " _e : _o." +
+                      GenGetterFuncName_ObjectAPI(property_name) + "()) { ";
+              code += array_name + "[_j] = " + to_array + "; _j++;}\n";
+            }
+            code += "      _" + camel_name + " = create" +
+                    camel_name_with_first + "Vector(builder, " + array_name +
+                    ");\n";
+            code += "    }\n";
+          } else {
+            auto type_name = GenTypeGet(field.value.type);
+            auto element_type_name =
+                GenTypeGet_ObjectAPI(field.value.type, opts, true, true);
+            auto pack_method =
+                field.value.type.struct_def == nullptr
+                    ? "builder.add" + GenMethod(field.value.type.VectorType()) +
+                          "(_o" + camel_name_with_first + "[_j]);"
+                    : type_name + ".pack(builder, _o" + camel_name_with_first +
+                          "[_j]);";
+            code += "    int _" + camel_name + " = 0;\n";
+            code += "    " + element_type_name + "[] _o" +
+                    camel_name_with_first + " = _o." +
+                    GenGetterFuncName_ObjectAPI(field.name) + "();\n";
+            code += "    if (_o" + camel_name_with_first + " != null) {\n";
+            code += "      start" + camel_name_with_first +
+                    "Vector(builder, _o" + camel_name_with_first +
+                    ".length);\n";
+            code += "      for (int _j = _o" + camel_name_with_first +
+                    ".length - 1; _j >=0; _j--) { ";
+            code += pack_method + "}\n";
+            code += "      _" + camel_name + " = builder.endVector();\n";
+            code += "    }\n";
+          }
+          break;
+        }
+        case BASE_TYPE_ARRAY: {
+          if (field.value.type.struct_def != nullptr) {
+            std::vector<FieldArrayLength> array_lengths;
+            FieldArrayLength tmp_array_length = {
+              field.name,
+              field.value.type.fixed_length,
+            };
+            array_lengths.push_back(tmp_array_length);
+            GenStructPackDecl_ObjectAPI(*field.value.type.struct_def, code_ptr,
+                                        array_lengths);
+          } else {
+            code += "    " +
+                    GenTypeGet_ObjectAPI(field.value.type, opts, false, true) +
+                    " _" + camel_name + " = _o." +
+                    GenGetterFuncName_ObjectAPI(field.name) + "();\n";
+          }
+          break;
+        }
+        case BASE_TYPE_UNION: {
+          code +=
+              "    " +
+              GenTypeBasic(DestinationType(
+                  field.value.type.enum_def->underlying_type, false)) +
+              " _" + camel_name + "Type = _o.get" + camel_name_with_first +
+              "() == null ? " + WrapInNameSpace(*field.value.type.enum_def) +
+              ".NONE : " + "_o.get" + camel_name_with_first + "().getType();\n";
+          code += "    " + GenOffsetType() + " _" + camel_name + " = _o.get" +
+                  camel_name_with_first + "() == null ? 0 : " +
+                  WrapInNameSpace(*field.value.type.enum_def) +
+                  "Union.pack(builder, _o.get" + camel_name_with_first +
+                  "());\n";
+          break;
+        }
+        default: break;
+      }
+    }
+    if (struct_has_create) {
+      // Create
+      code += "    return create" + struct_def.name + "(\n";
+      code += "      builder";
+      for (auto it = struct_def.fields.vec.begin();
+           it != struct_def.fields.vec.end(); ++it) {
+        auto &field = **it;
+        if (field.deprecated) continue;
+        auto camel_name = MakeCamel(field.name, false);
+        switch (field.value.type.base_type) {
+          case BASE_TYPE_STRUCT: {
+            if (struct_def.fixed) {
+              GenStructPackCall_ObjectAPI(*field.value.type.struct_def,
+                                          code_ptr,
+                                          "      _" + camel_name + "_");
+            } else {
+              code += ",\n";
+              if (field.value.type.struct_def->fixed) {
+                if (opts.generate_object_based_api)
+                  code += "      _o." + camel_name;
+                else
+                  // Seems like unreachable code
+                  code += "      " + GenTypeGet(field.value.type) +
+                          ".Pack(builder, _o." + camel_name + ")";
+              } else {
+                code += "      _" + field.name;
+              }
+            }
+            break;
+          }
+          case BASE_TYPE_ARRAY: {
+            if (field.value.type.struct_def != nullptr) {
+              GenStructPackCall_ObjectAPI(*field.value.type.struct_def,
+                                          code_ptr,
+                                          "      _" + camel_name + "_");
+            } else {
+              code += ",\n";
+              code += "      _" + camel_name;
+            }
+            break;
+          }
+          case BASE_TYPE_UNION: FLATBUFFERS_FALLTHROUGH();   // fall thru
+          case BASE_TYPE_UTYPE: FLATBUFFERS_FALLTHROUGH();   // fall thru
+          case BASE_TYPE_STRING: FLATBUFFERS_FALLTHROUGH();  // fall thru
+          case BASE_TYPE_VECTOR: {
+            code += ",\n";
+            code += "      _" + camel_name;
+            break;
+          }
+          default:  // scalar
+            code += ",\n";
+            code +=
+                "      _o." + GenGetterFuncName_ObjectAPI(field.name) + "()";
+            break;
+        }
+      }
+      code += ");\n";
+    } else {
+      // Start, End
+      code += "    start" + struct_def.name + "(builder);\n";
+      for (auto it = struct_def.fields.vec.begin();
+           it != struct_def.fields.vec.end(); ++it) {
+        auto &field = **it;
+        if (field.deprecated) continue;
+        auto camel_name = MakeCamel(field.name, false);
+        auto camel_name_with_first = MakeCamel(field.name, true);
+        switch (field.value.type.base_type) {
+          case BASE_TYPE_STRUCT: {
+            if (field.value.type.struct_def->fixed) {
+              code += "    add" + camel_name_with_first + "(builder, " +
+                      GenTypeGet(field.value.type) + ".pack(builder, _o." +
+                      GenGetterFuncName_ObjectAPI(field.name) + "()));\n";
+            } else {
+              code += "    add" + camel_name_with_first + "(builder, _" +
+                      field.name + ");\n";
+            }
+            break;
+          }
+          case BASE_TYPE_STRING: FLATBUFFERS_FALLTHROUGH();  // fall thru
+          case BASE_TYPE_ARRAY: FLATBUFFERS_FALLTHROUGH();   // fall thru
+          case BASE_TYPE_VECTOR: {
+            code += "    add" + camel_name_with_first + "(builder, _" +
+                    camel_name + ");\n";
+            break;
+          }
+          case BASE_TYPE_UTYPE: break;
+          case BASE_TYPE_UNION: {
+            code += "    add" + camel_name_with_first + "Type(builder, _" +
+                    camel_name + "Type);\n";
+            code += "    add" + camel_name_with_first + "(builder, _" +
+                    camel_name + ");\n";
+            break;
+          }
+          // scalar
+          default: {
+            if (field.IsScalarOptional()) {
+              code += "    if (_o." + GenGetterFuncName_ObjectAPI(field.name) +
+                      "() != null) { add" + camel_name_with_first +
+                      "(builder, _o." +
+                      GenGetterFuncName_ObjectAPI(field.name) + "()); }\n";
+            } else {
+              code += "    add" + camel_name_with_first + "(builder, _o." +
+                      GenGetterFuncName_ObjectAPI(field.name) + "());\n";
+            }
+            break;
+          }
+        }
+      }
+      code += "    return end" + struct_def.name + "(builder);\n";
+    }
+    code += "  }\n";
+  }
+
+  void GenStructPackDecl_ObjectAPI(
+      const StructDef &struct_def, std::string *code_ptr,
+      std::vector<FieldArrayLength> &array_lengths) const {
+    auto &code = *code_ptr;
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      auto is_array = IsArray(field.value.type);
+      const auto &field_type =
+          is_array ? field.value.type.VectorType() : field.value.type;
+      FieldArrayLength tmp_array_length = {
+        field.name,
+        field_type.fixed_length,
+      };
+      array_lengths.push_back(tmp_array_length);
+      if (field_type.struct_def != nullptr) {
+        GenStructPackDecl_ObjectAPI(*field_type.struct_def, code_ptr,
+                                    array_lengths);
+      } else {
+        std::vector<FieldArrayLength> array_only_lengths;
+        for (size_t i = 0; i < array_lengths.size(); ++i) {
+          if (array_lengths[i].length > 0) {
+            array_only_lengths.push_back(array_lengths[i]);
+          }
+        }
+        std::string name;
+        for (size_t i = 0; i < array_lengths.size(); ++i) {
+          name += "_" + MakeCamel(array_lengths[i].name, false);
+        }
+        code += "    " + GenTypeBasic(field_type);
+        if (array_only_lengths.size() > 0) {
+          for (size_t i = 0; i < array_only_lengths.size(); ++i) {
+            code += "[]";
+          }
+          code += " " + name + " = ";
+          code += "new " + GenTypeBasic(field_type) + "[";
+          for (size_t i = 0; i < array_only_lengths.size(); ++i) {
+            if (i != 0) { code += "]["; }
+            code += NumToString(array_only_lengths[i].length);
+          }
+          code += "];\n";
+          code += "    ";
+          // initialize array
+          for (size_t i = 0; i < array_only_lengths.size(); ++i) {
+            auto idx = "idx" + NumToString(i);
+            code += "for (int " + idx + " = 0; " + idx + " < " +
+                    NumToString(array_only_lengths[i].length) + "; ++" + idx +
+                    ") {";
+          }
+          for (size_t i = 0; i < array_only_lengths.size(); ++i) {
+            auto idx = "idx" + NumToString(i);
+            if (i == 0) {
+              code += name + "[" + idx;
+            } else {
+              code += "][" + idx;
+            }
+          }
+          code += "] = _o";
+          for (size_t i = 0, j = 0; i < array_lengths.size(); ++i) {
+            code +=
+                "." + GenGetterFuncName_ObjectAPI(array_lengths[i].name) + "()";
+            if (array_lengths[i].length <= 0) continue;
+            code += "[idx" + NumToString(j++) + "]";
+          }
+          code += ";";
+          for (size_t i = 0; i < array_only_lengths.size(); ++i) {
+            code += "}";
+          }
+        } else {
+          code += " " + name + " = ";
+          code += "_o";
+          for (size_t i = 0; i < array_lengths.size(); ++i) {
+            code += "." + GenGetterFuncName_ObjectAPI(array_lengths[i].name) +
+                    "()";  // + MakeCamel(array_lengths[i].name);
+          }
+          code += ";";
+        }
+        code += "\n";
+      }
+      array_lengths.pop_back();
+    }
+  }
+
+  void GenStructPackCall_ObjectAPI(const StructDef &struct_def,
+                                   std::string *code_ptr,
+                                   std::string prefix) const {
+    auto &code = *code_ptr;
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      const auto &field_type = field.value.type;
+      if (field_type.struct_def != nullptr) {
+        GenStructPackCall_ObjectAPI(
+            *field_type.struct_def, code_ptr,
+            prefix + MakeCamel(field.name, false) + "_");
+      } else {
+        code += ",\n";
+        code += prefix + MakeCamel(field.name, false);
+      }
+    }
+  }
+
+  std::string ConvertPrimitiveTypeToObjectWrapper_ObjectAPI(
+      std::string type_name) const {
+    if (type_name == "boolean")
+      return "Boolean";
+    else if (type_name == "byte")
+      return "Byte";
+    else if (type_name == "char")
+      return "Character";
+    else if (type_name == "short")
+      return "Short";
+    else if (type_name == "int")
+      return "Integer";
+    else if (type_name == "long")
+      return "Long";
+    else if (type_name == "float")
+      return "Float";
+    else if (type_name == "double")
+      return "Double";
+    return type_name;
+  }
+
+  std::string GenTypeGet_ObjectAPI(flatbuffers::Type type,
+                                   const IDLOptions &opts, bool vectorelem,
+                                   bool wrap_in_namespace) const {
+    auto type_name = GenTypeNameDest(type);
+    // Replace to ObjectBaseAPI Type Name
+    switch (type.base_type) {
+      case BASE_TYPE_STRUCT: FLATBUFFERS_FALLTHROUGH();  // fall thru
+      case BASE_TYPE_ARRAY: FLATBUFFERS_FALLTHROUGH();   // fall thru
+      case BASE_TYPE_VECTOR: {
+        if (type.struct_def != nullptr) {
+          auto type_name_length = type.struct_def->name.length();
+          auto new_type_name =
+              GenTypeName_ObjectAPI(type.struct_def->name, opts);
+          type_name.replace(type_name.length() - type_name_length,
+                            type_name_length, new_type_name);
+        } else if (type.element == BASE_TYPE_UNION) {
+          if (wrap_in_namespace) {
+            type_name = WrapInNameSpace(*type.enum_def) + "Union";
+          } else {
+            type_name = type.enum_def->name + "Union";
+          }
+        }
+        break;
+      }
+
+      case BASE_TYPE_UNION: {
+        if (wrap_in_namespace) {
+          type_name = WrapInNameSpace(*type.enum_def) + "Union";
+        } else {
+          type_name = type.enum_def->name + "Union";
+        }
+        break;
+      }
+      default: break;
+    }
+    if (vectorelem) { return type_name; }
+    switch (type.base_type) {
+      case BASE_TYPE_ARRAY: FLATBUFFERS_FALLTHROUGH();  // fall thru
+      case BASE_TYPE_VECTOR: {
+        type_name = type_name + "[]";
+        break;
+      }
+      default: break;
+    }
+    return type_name;
+  }
+
+  std::string GenConcreteTypeGet_ObjectAPI(flatbuffers::Type type,
+                                           const IDLOptions &opts) const {
+    auto type_name = GenTypeNameDest(type);
+    // Replace to ObjectBaseAPI Type Name
+    switch (type.base_type) {
+      case BASE_TYPE_STRUCT: FLATBUFFERS_FALLTHROUGH();  // fall thru
+      case BASE_TYPE_ARRAY: FLATBUFFERS_FALLTHROUGH();   // fall thru
+      case BASE_TYPE_VECTOR: {
+        if (type.struct_def != nullptr) {
+          auto type_name_length = type.struct_def->name.length();
+          auto new_type_name =
+              GenTypeName_ObjectAPI(type.struct_def->name, opts);
+          type_name.replace(type_name.length() - type_name_length,
+                            type_name_length, new_type_name);
+        } else if (type.element == BASE_TYPE_UNION) {
+          type_name = WrapInNameSpace(*type.enum_def) + "Union";
+        }
+        break;
+      }
+
+      case BASE_TYPE_UNION: {
+        type_name = WrapInNameSpace(*type.enum_def) + "Union";
+        break;
+      }
+      default: break;
+    }
+
+    switch (type.base_type) {
+      case BASE_TYPE_ARRAY: FLATBUFFERS_FALLTHROUGH();  // fall thru
+      case BASE_TYPE_VECTOR: {
+        type_name = type_name + "[]";
+        break;
+      }
+      default: break;
+    }
+    return type_name;
+  }
+
+  void GenStruct_ObjectAPI(StructDef &struct_def, std::string *code_ptr,
+                           const IDLOptions &opts) const {
+    if (struct_def.generated) return;
+    auto &code = *code_ptr;
+    if (struct_def.attributes.Lookup("private")) {
+      // For Java, we leave the enum unmarked to indicate package-private
+    } else {
+      code += "public ";
+    }
+
+    auto class_name = GenTypeName_ObjectAPI(struct_def.name, opts);
+    code += "class " + class_name;
+    code += " {\n";
+    // Generate Properties
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      if (field.value.type.base_type == BASE_TYPE_UTYPE) continue;
+      if (field.value.type.element == BASE_TYPE_UTYPE) continue;
+      auto type_name =
+          GenTypeGet_ObjectAPI(field.value.type, opts, false, true);
+      if (field.IsScalarOptional())
+        type_name = ConvertPrimitiveTypeToObjectWrapper_ObjectAPI(type_name);
+      auto camel_name = MakeCamel(field.name, false);
+      code += "  private " + type_name + " " + camel_name + ";\n";
+    }
+    // Generate Java getters and setters
+    code += "\n";
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      if (field.value.type.base_type == BASE_TYPE_UTYPE) continue;
+      if (field.value.type.element == BASE_TYPE_UTYPE) continue;
+      auto type_name =
+          GenTypeGet_ObjectAPI(field.value.type, opts, false, true);
+      if (field.IsScalarOptional())
+        type_name = ConvertPrimitiveTypeToObjectWrapper_ObjectAPI(type_name);
+      auto camel_name = MakeCamel(field.name, false);
+      code += "  public " + type_name + " " +
+              GenGetterFuncName_ObjectAPI(field.name) + "() { return " +
+              camel_name + "; }\n\n";
+      std::string array_validation = "";
+      if (field.value.type.base_type == BASE_TYPE_ARRAY) {
+        array_validation =
+            "if (" + camel_name + " != null && " + camel_name +
+            ".length == " + NumToString(field.value.type.fixed_length) + ") ";
+      }
+      code += "  public void " + GenSetterFuncName_ObjectAPI(field.name) + "(" +
+              type_name + " " + camel_name + ") { " + array_validation +
+              "this." + camel_name + " = " + camel_name + "; }\n\n";
+    }
+    // Generate Constructor
+    code += "\n";
+    code += "  public " + class_name + "() {\n";
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      if (field.value.type.base_type == BASE_TYPE_UTYPE) continue;
+      if (field.value.type.element == BASE_TYPE_UTYPE) continue;
+      code += "    this." + MakeCamel(field.name, false) + " = ";
+      auto type_name =
+          GenTypeGet_ObjectAPI(field.value.type, opts, false, true);
+      if (IsScalar(field.value.type.base_type)) {
+        if (field.IsScalarOptional()) {
+          code += "null;\n";
+        } else {
+          code += GenDefaultValue(field) + ";\n";
+        }
+      } else {
+        switch (field.value.type.base_type) {
+          case BASE_TYPE_STRUCT: {
+            if (IsStruct(field.value.type)) {
+              code += "new " + type_name + "();\n";
+            } else {
+              code += "null;\n";
+            }
+            break;
+          }
+          case BASE_TYPE_ARRAY: {
+            code += "new " + type_name.substr(0, type_name.length() - 1) +
+                    NumToString(field.value.type.fixed_length) + "];\n";
+            break;
+          }
+          default: {
+            code += "null;\n";
+            break;
+          }
+        }
+      }
+    }
+    code += "  }\n";
+    if (parser_.root_struct_def_ == &struct_def) {
+      code += "  public static " + class_name +
+              " deserializeFromBinary(byte[] fbBuffer) {\n";
+      code += "    return " + struct_def.name + ".getRootAs" + struct_def.name +
+              "(ByteBuffer.wrap(fbBuffer)).unpack();\n";
+      code += "  }\n";
+      code += "  public byte[] serializeToBinary() {\n";
+      code += "    FlatBufferBuilder fbb = new FlatBufferBuilder();\n";
+      code += "    " + struct_def.name + ".finish" + struct_def.name +
+              "Buffer(fbb, " + struct_def.name + ".pack(fbb, this));\n";
+      code += "    return fbb.sizedByteArray();\n";
+      code += "  }\n";
+    }
+    code += "}\n\n";
+  }
+
   // This tracks the current namespace used to determine if a type need to be
   // prefixed by its namespace
   const Namespace *cur_name_space_;
diff -urN a/src/idl_gen_json_schema.cpp b/src/idl_gen_json_schema.cpp
--- a/src/idl_gen_json_schema.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_json_schema.cpp	2023-01-13 07:47:08.894252193 +0000
@@ -166,9 +166,45 @@
     return std::string(num_spaces, ' ');
   }
 
+  std::string PrepareDescription(
+      const std::vector<std::string> &comment_lines) {
+    std::string comment;
+    for (auto line_iterator = comment_lines.cbegin();
+         line_iterator != comment_lines.cend(); ++line_iterator) {
+      const auto &comment_line = *line_iterator;
+
+      // remove leading and trailing spaces from comment line
+      const auto start = std::find_if(comment_line.begin(), comment_line.end(),
+                                      [](char c) { return !isspace(c); });
+      const auto end =
+          std::find_if(comment_line.rbegin(), comment_line.rend(), [](char c) {
+            return !isspace(c);
+          }).base();
+      if (start < end) {
+        comment.append(start, end);
+      } else {
+        comment.append(comment_line);
+      }
+
+      if (line_iterator + 1 != comment_lines.cend()) comment.append("\n");
+    }
+    if (!comment.empty()) {
+      std::string description;
+      if (EscapeString(comment.c_str(), comment.length(), &description, true,
+                       true)) {
+        return description;
+      }
+      return "";
+    }
+    return "";
+  }
+
   bool generate() {
     code_ = "";
-    if (parser_.root_struct_def_ == nullptr) { return false; }
+    if (parser_.root_struct_def_ == nullptr) {
+      std::cerr << "Error: Binary schema not generated, no root struct found\n";
+      return false;
+    }
     code_ += "{" + NewLine();
     code_ += Indent(1) +
              "\"$schema\": \"https://json-schema.org/draft/2019-09/schema\"," +
@@ -193,21 +229,12 @@
       const auto &structure = *s;
       code_ += Indent(2) + "\"" + GenFullName(structure) + "\" : {" + NewLine();
       code_ += Indent(3) + GenType("object") + "," + NewLine();
-      std::string comment;
       const auto &comment_lines = structure->doc_comment;
-      for (auto comment_line = comment_lines.cbegin();
-           comment_line != comment_lines.cend(); ++comment_line) {
-        comment.append(*comment_line);
-      }
-      if (!comment.empty()) {
-        std::string description;
-        if (!EscapeString(comment.c_str(), comment.length(), &description, true,
-                          true)) {
-          return false;
-        }
-        code_ +=
-            Indent(3) + "\"description\" : " + description + "," + NewLine();
+      auto comment = PrepareDescription(comment_lines);
+      if (comment != "") {
+        code_ += Indent(3) + "\"description\" : " + comment + "," + NewLine();
       }
+
       code_ += Indent(3) + "\"properties\" : {" + NewLine();
 
       const auto &properties = structure->fields.vec;
@@ -223,13 +250,19 @@
         std::string deprecated_info = "";
         if (property->deprecated) {
           deprecated_info =
-              "," + NewLine() + Indent(8) + "\"deprecated\" : true,";
+              "," + NewLine() + Indent(8) + "\"deprecated\" : true";
         }
         std::string typeLine = Indent(4) + "\"" + property->name + "\"";
         typeLine += " : {" + NewLine() + Indent(8);
         typeLine += GenType(property->value.type);
         typeLine += arrayInfo;
         typeLine += deprecated_info;
+        auto description = PrepareDescription(property->doc_comment);
+        if (description != "") {
+          typeLine +=
+              "," + NewLine() + Indent(8) + "\"description\" : " + description;
+        }
+
         typeLine += NewLine() + Indent(7) + "}";
         if (property != properties.back()) { typeLine.append(","); }
         code_ += typeLine + NewLine();
diff -urN a/src/idl_gen_kotlin.cpp b/src/idl_gen_kotlin.cpp
--- a/src/idl_gen_kotlin.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_kotlin.cpp	2023-01-13 07:47:08.894252193 +0000
@@ -23,9 +23,6 @@
 #include "flatbuffers/flatbuffers.h"
 #include "flatbuffers/idl.h"
 #include "flatbuffers/util.h"
-#if defined(FLATBUFFERS_CPP98_STL)
-#  include <cctype>
-#endif  // defined(FLATBUFFERS_CPP98_STL)
 
 namespace flatbuffers {
 
@@ -262,7 +259,6 @@
     GenerateComment(enum_def.doc_comment, writer, &comment_config);
 
     writer += "@Suppress(\"unused\")";
-    writer += "@ExperimentalUnsignedTypes";
     writer += "class " + Esc(enum_def.name) + " private constructor() {";
     writer.IncrementIdentLevel();
 
@@ -425,7 +421,8 @@
                       (nameprefix + (field.name + "_")).c_str());
       } else {
         writer.SetValue("type", GenMethod(field.value.type));
-        writer.SetValue("argname", nameprefix + MakeCamel(field.name, false));
+        writer.SetValue("argname",
+                        nameprefix + MakeCamel(Esc(field.name), false));
         writer.SetValue("cast", CastToSigned(field.value.type));
         writer += "builder.put{{type}}({{argname}}{{cast}})";
       }
@@ -463,7 +460,6 @@
     writer.SetValue("superclass", fixed ? "Struct" : "Table");
 
     writer += "@Suppress(\"unused\")";
-    writer += "@ExperimentalUnsignedTypes";
     writer += "class {{struct_name}} : {{superclass}}() {\n";
 
     writer.IncrementIdentLevel();
diff -urN a/src/idl_gen_python.cpp b/src/idl_gen_python.cpp
--- a/src/idl_gen_python.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_python.cpp	2023-01-13 07:47:08.914252379 +0000
@@ -113,12 +113,6 @@
     code += enum_def.ToString(ev) + "\n";
   }
 
-  // End enum code.
-  void EndEnum(std::string *code_ptr) {
-    auto &code = *code_ptr;
-    code += "\n";
-  }
-
   // Initialize a new struct or table from existing data.
   void NewRootTypeFromBuffer(const StructDef &struct_def,
                              std::string *code_ptr) {
@@ -141,7 +135,9 @@
     code += Indent + "def GetRootAs";
     code += NormalizedName(struct_def);
     code += "(cls, buf, offset=0):\n";
-    code += Indent + Indent + "\"\"\"This method is deprecated. Please switch to GetRootAs.\"\"\"\n";
+    code +=
+        Indent + Indent +
+        "\"\"\"This method is deprecated. Please switch to GetRootAs.\"\"\"\n";
     code += Indent + Indent + "return cls.GetRootAs(buf, offset)\n";
   }
 
@@ -442,7 +438,7 @@
     code += Indent + Indent + Indent;
     code += "from " + qualified_name + " import " + unqualified_name + "\n";
     code += Indent + Indent + Indent + "return " + unqualified_name;
-    code += ".GetRootAs";
+    code += ".GetRootAs" + unqualified_name;
     code += "(self._tab.Bytes, self._tab.Vector(o))\n";
     code += Indent + Indent + "return 0\n";
     code += "\n";
@@ -476,7 +472,7 @@
         // a nested struct, prefix the name with the field name.
         auto subprefix = nameprefix;
         if (has_field_name) {
-          subprefix += NormalizedName(field) + fieldname_suffix;
+          subprefix += MakeLowerCamel(field) + fieldname_suffix;
         }
         StructBuilderArgs(*field.value.type.struct_def, subprefix, namesuffix,
                           has_field_name, fieldname_suffix, code_ptr);
@@ -516,7 +512,7 @@
             indent + "    builder.Pad(" + NumToString(field.padding) + ")\n";
       if (IsStruct(field_type)) {
         StructBuilderBody(*field_type.struct_def,
-                          (nameprefix + (NormalizedName(field) + "_")).c_str(),
+                          (nameprefix + (MakeLowerCamel(field) + "_")).c_str(),
                           code_ptr, index, in_array);
       } else {
         const auto index_var = "_idx" + NumToString(index);
@@ -529,7 +525,7 @@
         if (IsStruct(type)) {
           StructBuilderBody(
               *field_type.struct_def,
-              (nameprefix + (NormalizedName(field) + "_")).c_str(), code_ptr,
+              (nameprefix + (MakeLowerCamel(field) + "_")).c_str(), code_ptr,
               index + 1, in_array);
         } else {
           code += IsArray(field_type) ? "    " : "";
@@ -553,22 +549,29 @@
   // Get the value of a table's starting offset.
   void GetStartOfTable(const StructDef &struct_def, std::string *code_ptr) {
     auto &code = *code_ptr;
-    code += "def Start(builder): ";
+
+    // Generate method with struct name.
+    code += "def " + NormalizedName(struct_def) + "Start(builder): ";
     code += "builder.StartObject(";
     code += NumToString(struct_def.fields.vec.size());
     code += ")\n";
 
-    // Add alias with the old name.
-    code += "def " + NormalizedName(struct_def) + "Start(builder):\n";
-    code += Indent + "\"\"\"This method is deprecated. Please switch to Start.\"\"\"\n";
-    code += Indent + "return Start(builder)\n";
+    if (!parser_.opts.one_file) {
+      // Generate method without struct name.
+      code += "def Start(builder):\n";
+      code +=
+          Indent + "return " + NormalizedName(struct_def) + "Start(builder)\n";
+    }
   }
 
   // Set the value of a table's field.
   void BuildFieldOfTable(const StructDef &struct_def, const FieldDef &field,
                          const size_t offset, std::string *code_ptr) {
     auto &code = *code_ptr;
-    code += "def Add" + MakeCamel(NormalizedName(field));
+
+    // Generate method with struct name.
+    code += "def " + NormalizedName(struct_def) + "Add" +
+            MakeCamel(NormalizedName(field));
     code += "(builder, ";
     code += MakeCamel(NormalizedName(field), false);
     code += "): ";
@@ -588,26 +591,27 @@
                 : field.value.constant;
     code += ")\n";
 
-    // Add alias with the old name.
-    code += "def " + NormalizedName(struct_def) + "Add" + MakeCamel(NormalizedName(field));
-    code += "(builder, ";
-    code += MakeCamel(NormalizedName(field), false);
-    code += "):\n";
-    code += Indent + "\"\"\"This method is deprecated. Please switch to Add";
-    code += MakeCamel(NormalizedName(field)) + ".\"\"\"\n";
-    code += Indent + "return Add" + MakeCamel(NormalizedName(field));
-    code += "(builder, ";
-    code += MakeCamel(NormalizedName(field), false);
-    code += ")\n";
-
-    // Add alias with the old name.
+    if (!parser_.opts.one_file) {
+      // Generate method without struct name.
+      code += "def Add" + MakeCamel(NormalizedName(field));
+      code += "(builder, ";
+      code += MakeCamel(NormalizedName(field), false);
+      code += "):\n";
+      code += Indent + "return " + NormalizedName(struct_def) + "Add" +
+              MakeCamel(NormalizedName(field));
+      code += "(builder, ";
+      code += MakeCamel(NormalizedName(field), false);
+      code += ")\n";
+    }
   }
 
   // Set the value of one of the members of a table's vector.
   void BuildVectorOfTable(const StructDef &struct_def, const FieldDef &field,
                           std::string *code_ptr) {
     auto &code = *code_ptr;
-    code += "def Start";
+
+    // Generate method with struct name.
+    code += "def " + NormalizedName(struct_def) + "Start";
     code += MakeCamel(NormalizedName(field));
     code += "Vector(builder, numElems): return builder.StartVector(";
     auto vector_type = field.value.type.VectorType();
@@ -617,20 +621,23 @@
     code += ", numElems, " + NumToString(alignment);
     code += ")\n";
 
-    // Add alias with the old name.
-    code += "def " + NormalizedName(struct_def) + "Start";
-    code += MakeCamel(NormalizedName(field));
-    code += "Vector(builder, numElems):\n";
-    code += Indent + "\"\"\"This method is deprecated. Please switch to Start.\"\"\"\n";
-    code += Indent + "return Start";
-    code += MakeCamel(NormalizedName(field));
-    code += "Vector(builder, numElems)\n";
+    if (!parser_.opts.one_file) {
+      // Generate method without struct name.
+      code += "def Start";
+      code += MakeCamel(NormalizedName(field));
+      code += "Vector(builder, numElems):\n";
+      code += Indent + "return " + NormalizedName(struct_def) + "Start";
+      code += MakeCamel(NormalizedName(field));
+      code += "Vector(builder, numElems)\n";
+    }
   }
 
   // Set the value of one of the members of a table's vector and fills in the
   // elements from a bytearray. This is for simplifying the use of nested
   // flatbuffers.
-  void BuildVectorOfTableFromBytes(const FieldDef &field, std::string *code_ptr) {
+  void BuildVectorOfTableFromBytes(const StructDef &struct_def,
+                                   const FieldDef &field,
+                                   std::string *code_ptr) {
     auto nested = field.attributes.Lookup("nested_flatbuffer");
     if (!nested) { return; }  // There is no nested flatbuffer.
 
@@ -646,7 +653,11 @@
     (void)nested_root;
 
     auto &code = *code_ptr;
-    code += "def MakeVectorFromBytes(builder, bytes):\n";
+
+    // Generate method with struct and field name.
+    code += "def " + NormalizedName(struct_def) + "Make";
+    code += MakeCamel(NormalizedName(field));
+    code += "VectorFromBytes(builder, bytes):\n";
     code += Indent + "builder.StartVector(";
     auto vector_type = field.value.type.VectorType();
     auto alignment = InlineAlignment(vector_type);
@@ -659,28 +670,30 @@
     code += " = bytes\n";
     code += Indent + "return builder.EndVector()\n";
 
-    // Add alias with the old name.
-    code += "def Make" + MakeCamel(NormalizedName(field));
-    code += "VectorFromBytes(builder, bytes):\n";
-    code += Indent + "builder.StartVector(";
-    code += NumToString(elem_size);
-    code += ", len(bytes), " + NumToString(alignment);
-    code += ")\n";
-    code += Indent + "builder.head = builder.head - len(bytes)\n";
-    code += Indent + "builder.Bytes[builder.head : builder.head + len(bytes)]";
-    code += " = bytes\n";
-    code += Indent + "return builder.EndVector()\n";
+    if (!parser_.opts.one_file) {
+      // Generate method without struct and field name.
+      code += "def Make" + MakeCamel(NormalizedName(field)) +
+              "VectorFromBytes(builder, bytes):\n";
+      code += Indent + "return " + NormalizedName(struct_def) + "Make" +
+              MakeCamel(NormalizedName(field)) +
+              "VectorFromBytes(builder, bytes)\n";
+    }
   }
 
   // Get the offset of the end of a table.
   void GetEndOffsetOnTable(const StructDef &struct_def, std::string *code_ptr) {
     auto &code = *code_ptr;
-    code += "def End(builder): return builder.EndObject()\n";
 
-    // Add alias with the old name.
-    code += "def " + NormalizedName(struct_def) + "End(builder):\n";
-    code += Indent + "\"\"\"This method is deprecated. Please switch to End.\"\"\"\n";
-    code += Indent + "return End(builder)";
+    // Generate method with struct name.
+    code += "def " + NormalizedName(struct_def) + "End";
+    code += "(builder): ";
+    code += "return builder.EndObject()\n";
+
+    if (!parser_.opts.one_file) {
+      // Generate method without struct name.
+      code += "def End(builder):\n";
+      code += Indent + "return " + NormalizedName(struct_def) + "End(builder)";
+    }
   }
 
   // Generate the receiver for function signatures.
@@ -758,7 +771,7 @@
       BuildFieldOfTable(struct_def, field, offset, code_ptr);
       if (IsVector(field.value.type)) {
         BuildVectorOfTable(struct_def, field, code_ptr);
-        BuildVectorOfTableFromBytes(field, code_ptr);
+        BuildVectorOfTableFromBytes(struct_def, field, code_ptr);
       }
     }
 
@@ -1287,7 +1300,7 @@
     code_prefix +=
         GenIndents(2) + "if self." + field_instance_name + " is not None:";
     if (field.value.type.struct_def->fixed) {
-      code_prefix += GenIndents(3) + "Start" +
+      code_prefix += GenIndents(3) + struct_name + "Start" +
                      field_accessor_name + "Vector(builder, len(self." +
                      field_instance_name + "))";
       code_prefix += GenIndents(3) + "for i in reversed(range(len(self." +
@@ -1305,7 +1318,7 @@
       code_prefix += GenIndents(4) + field_instance_name + "list.append(self." +
                      field_instance_name + "[i].Pack(builder))";
 
-      code_prefix += GenIndents(3) + "Start" +
+      code_prefix += GenIndents(3) + struct_name + "Start" +
                      field_accessor_name + "Vector(builder, len(self." +
                      field_instance_name + "))";
       code_prefix += GenIndents(3) + "for i in reversed(range(len(self." +
@@ -1318,7 +1331,7 @@
 
     // Adds the field into the struct.
     code += GenIndents(2) + "if self." + field_instance_name + " is not None:";
-    code += GenIndents(3) + "Add" + field_accessor_name +
+    code += GenIndents(3) + struct_name + "Add" + field_accessor_name +
             "(builder, " + field_instance_name + ")";
   }
 
@@ -1331,7 +1344,7 @@
     auto struct_name = NormalizedName(struct_def);
     auto vectortype = field.value.type.VectorType();
 
-    code += GenIndents(indents) + "Start" + field_accessor_name +
+    code += GenIndents(indents) + struct_name + "Start" + field_accessor_name +
             "Vector(builder, len(self." + field_instance_name + "))";
     code += GenIndents(indents) + "for i in reversed(range(len(self." +
             field_instance_name + "))):";
@@ -1368,7 +1381,7 @@
 
     // Adds the field into the struct.
     code += GenIndents(2) + "if self." + field_instance_name + " is not None:";
-    code += GenIndents(3) + "Add" + field_accessor_name +
+    code += GenIndents(3) + struct_name + "Add" + field_accessor_name +
             "(builder, " + field_instance_name + ")";
 
     // Creates the field.
@@ -1431,7 +1444,7 @@
           GenIndents(2) + "if self." + field_instance_name + " is not None:";
     }
 
-    code += GenIndents(3) + "Add" + field_accessor_name +
+    code += GenIndents(3) + struct_name + "Add" + field_accessor_name +
             "(builder, " + field_instance_name + ")";
   }
 
@@ -1451,7 +1464,7 @@
     code_prefix += GenIndents(3) + field_instance_name + " = self." +
                    field_instance_name + ".Pack(builder)";
     code += GenIndents(2) + "if self." + field_instance_name + " is not None:";
-    code += GenIndents(3) + "Add" + field_accessor_name +
+    code += GenIndents(3) + struct_name + "Add" + field_accessor_name +
             "(builder, " + field_instance_name + ")";
   }
 
@@ -1463,7 +1476,7 @@
 
     GenReceiverForObjectAPI(struct_def, code_ptr);
     code_base += "Pack(self, builder):";
-    code += GenIndents(2) + "Start(builder)";
+    code += GenIndents(2) + struct_name + "Start(builder)";
     for (auto it = struct_def.fields.vec.begin();
          it != struct_def.fields.vec.end(); ++it) {
       auto &field = **it;
@@ -1502,7 +1515,7 @@
                          ")";
           code += GenIndents(2) + "if self." + field_instance_name +
                   " is not None:";
-          code += GenIndents(3) + "Add" + field_accessor_name +
+          code += GenIndents(3) + struct_name + "Add" + field_accessor_name +
                   "(builder, " + field_instance_name + ")";
           break;
         }
@@ -1510,13 +1523,14 @@
           // Generates code for scalar values. If the value equals to the
           // default value, builder will automatically ignore it. So we don't
           // need to check the value ahead.
-          code += GenIndents(2) + "Add" + field_accessor_name +
+          code += GenIndents(2) + struct_name + "Add" + field_accessor_name +
                   "(builder, self." + field_instance_name + ")";
           break;
       }
     }
 
-    code += GenIndents(2) + struct_instance_name + " = " + "End(builder)";
+    code += GenIndents(2) + struct_instance_name + " = " + struct_name +
+            "End(builder)";
     code += GenIndents(2) + "return " + struct_instance_name;
 
     code_base += code_prefix + code;
@@ -1590,6 +1604,8 @@
 
   // Creates an union object based on union type.
   void GenUnionCreator(const EnumDef &enum_def, std::string *code_ptr) {
+    if (enum_def.generated) return;
+
     auto &code = *code_ptr;
     auto union_name = MakeUpperCamel(enum_def);
 
@@ -1627,7 +1643,6 @@
       GenComment(ev.doc_comment, code_ptr, &def_comment, Indent.c_str());
       EnumMember(enum_def, ev, code_ptr);
     }
-    EndEnum(code_ptr);
   }
 
   // Returns the function name that is able to read a value of the given type.
@@ -1697,13 +1712,20 @@
   }
 
   bool generate() {
-    if (!generateEnums()) return false;
-    if (!generateStructs()) return false;
+    std::string one_file_code;
+    if (!generateEnums(&one_file_code)) return false;
+    if (!generateStructs(&one_file_code)) return false;
+
+    if (parser_.opts.one_file) {
+      return SaveType(file_name_ + "_generated", *parser_.current_namespace_,
+                      one_file_code, true);
+    }
+
     return true;
   }
 
  private:
-  bool generateEnums() {
+  bool generateEnums(std::string *one_file_code) {
     for (auto it = parser_.enums_.vec.begin(); it != parser_.enums_.vec.end();
          ++it) {
       auto &enum_def = **it;
@@ -1712,12 +1734,19 @@
       if (parser_.opts.generate_object_based_api & enum_def.is_union) {
         GenUnionCreator(enum_def, &enumcode);
       }
-      if (!SaveType(enum_def, enumcode, false)) return false;
+
+      if (parser_.opts.one_file && !enumcode.empty()) {
+        *one_file_code += enumcode + "\n\n";
+      } else {
+        if (!SaveType(enum_def.name, *enum_def.defined_namespace, enumcode,
+                      false))
+          return false;
+      }
     }
     return true;
   }
 
-  bool generateStructs() {
+  bool generateStructs(std::string *one_file_code) {
     for (auto it = parser_.structs_.vec.begin();
          it != parser_.structs_.vec.end(); ++it) {
       auto &struct_def = **it;
@@ -1726,7 +1755,14 @@
       if (parser_.opts.generate_object_based_api) {
         GenStructForObjectAPI(struct_def, &declcode);
       }
-      if (!SaveType(struct_def, declcode, true)) return false;
+
+      if (parser_.opts.one_file && !declcode.empty()) {
+        *one_file_code += declcode + "\n\n";
+      } else {
+        if (!SaveType(struct_def.name, *struct_def.defined_namespace, declcode,
+                      true))
+          return false;
+      }
     }
     return true;
   }
@@ -1745,12 +1781,12 @@
   }
 
   // Save out the generated code for a Python Table type.
-  bool SaveType(const Definition &def, const std::string &classcode,
-                bool needs_imports) {
+  bool SaveType(const std::string &defname, const Namespace &ns,
+                const std::string &classcode, bool needs_imports) {
     if (!classcode.length()) return true;
 
     std::string namespace_dir = path_;
-    auto &namespaces = def.defined_namespace->components;
+    auto &namespaces = ns.components;
     for (auto it = namespaces.begin(); it != namespaces.end(); ++it) {
       if (it != namespaces.begin()) namespace_dir += kPathSeparator;
       namespace_dir += *it;
@@ -1759,10 +1795,9 @@
     }
 
     std::string code = "";
-    BeginFile(LastNamespacePart(*def.defined_namespace), needs_imports, &code);
+    BeginFile(LastNamespacePart(ns), needs_imports, &code);
     code += classcode;
-    std::string filename =
-        NamespaceDir(*def.defined_namespace) + NormalizedName(def) + ".py";
+    std::string filename = NamespaceDir(ns) + defname + ".py";
     return SaveFile(filename.c_str(), code, false);
   }
 
diff -urN a/src/idl_gen_rust.cpp b/src/idl_gen_rust.cpp
--- a/src/idl_gen_rust.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_rust.cpp	2023-01-13 07:47:08.917252407 +0000
@@ -51,6 +51,10 @@
   return s;
 }
 
+std::string UnionTypeFieldName(const FieldDef &field) {
+  return MakeSnakeCase(field.name + "_type");
+}
+
 // Encapsulate all logical field types in this enum. This allows us to write
 // field logic based on type switches, instead of branches on the properties
 // set on the Type.
@@ -178,31 +182,9 @@
   return ftBool;
 }
 
-// If the second parameter is false then wrap the first with Option<...>
-std::string WrapInOptionIfNotRequired(std::string s, bool required) {
-  if (required) {
-    return s;
-  } else {
-    return "Option<" + s + ">";
-  }
-}
-
-// If the second parameter is false then add .unwrap()
-std::string AddUnwrapIfRequired(std::string s, bool required) {
-  if (required) {
-    return s + ".unwrap()";
-  } else {
-    return s;
-  }
-}
-
 bool IsBitFlagsEnum(const EnumDef &enum_def) {
   return enum_def.attributes.Lookup("bit_flags") != nullptr;
 }
-bool IsBitFlagsEnum(const FieldDef &field) {
-  EnumDef *ed = field.value.type.enum_def;
-  return ed && IsBitFlagsEnum(*ed);
-}
 
 // TableArgs make required non-scalars "Option<_>".
 // TODO(cneo): Rework how we do defaults and stuff.
@@ -210,6 +192,68 @@
   return field.IsOptional() || !IsScalar(field.value.type.base_type);
 }
 
+bool GenerateRustModuleRootFile(const Parser &parser,
+                                const std::string &output_dir) {
+  if (!parser.opts.rust_module_root_file) {
+    // Don't generate a root file when generating one file. This isn't an error
+    // so return true.
+    return true;
+  }
+  // We gather the symbols into a tree of namespaces (which are rust mods) and
+  // generate a file that gathers them all.
+  struct Module {
+    std::map<std::string, Module> sub_modules;
+    std::vector<std::string> generated_files;
+    // Add a symbol into the tree.
+    void Insert(const Definition *s, const std::string suffix) {
+      const Definition &symbol = *s;
+      Module *current_module = this;
+      for (auto it = symbol.defined_namespace->components.begin();
+           it != symbol.defined_namespace->components.end(); it++) {
+        std::string ns_component = MakeSnakeCase(*it);
+        current_module = &current_module->sub_modules[ns_component];
+      }
+      current_module->generated_files.push_back(MakeSnakeCase(symbol.name) +
+                                                suffix);
+    }
+    // Recursively create the importer file.
+    void GenerateImports(CodeWriter &code) {
+      for (auto it = sub_modules.begin(); it != sub_modules.end(); it++) {
+        code += "pub mod " + it->first + " {";
+        code.IncrementIdentLevel();
+        code += "use super::*;";
+        it->second.GenerateImports(code);
+        code.DecrementIdentLevel();
+        code += "} // " + it->first;
+      }
+      for (auto it = generated_files.begin(); it != generated_files.end();
+           it++) {
+        code += "mod " + *it + ";";
+        code += "pub use self::" + *it + "::*;";
+      }
+    }
+  };
+  Module root_module;
+  for (auto it = parser.enums_.vec.begin(); it != parser.enums_.vec.end();
+       it++) {
+    root_module.Insert(*it, parser.opts.filename_suffix);
+  }
+  for (auto it = parser.structs_.vec.begin(); it != parser.structs_.vec.end();
+       it++) {
+    root_module.Insert(*it, parser.opts.filename_suffix);
+  }
+  CodeWriter code("  ");
+  // TODO(caspern): Move generated warning out of BaseGenerator.
+  code +=
+      "// Automatically generated by the Flatbuffers compiler. "
+      "Do not modify.";
+  root_module.GenerateImports(code);
+  const bool success =
+      SaveFile((output_dir + "mod.rs").c_str(), code.ToString(), false);
+  code.Clear();
+  return success;
+}
+
 namespace rust {
 
 class RustGenerator : public BaseGenerator {
@@ -320,13 +364,85 @@
       "ENUM_MAX",
       "ENUM_MIN",
       "ENUM_VALUES",
+      // clang-format on
     };
     for (auto kw = keywords; *kw; kw++) keywords_.insert(*kw);
+    code_.SetPadding("  ");
+  }
+
+  bool generate() {
+    if (!parser_.opts.rust_module_root_file) {
+      return GenerateOneFile();
+    } else {
+      return GenerateIndividualFiles();
+    }
+  }
+
+  template<typename T>
+  bool GenerateSymbols(const SymbolTable<T> &symbols,
+                       std::function<void(const T &)> gen_symbol) {
+    for (auto it = symbols.vec.begin(); it != symbols.vec.end(); it++) {
+      const T &symbol = **it;
+      if (symbol.generated) continue;
+      code_.Clear();
+      code_ += "// " + std::string(FlatBuffersGeneratedWarning());
+      code_ += "extern crate flatbuffers;";
+      code_ += "use std::mem;";
+      code_ += "use std::cmp::Ordering;";
+      if (parser_.opts.rust_serialize) {
+        code_ += "extern crate serde;";
+        code_ +=
+            "use self::serde::ser::{Serialize, Serializer, SerializeStruct};";
+      }
+      code_ += "use self::flatbuffers::{EndianScalar, Follow};";
+      code_ += "use super::*;";
+      cur_name_space_ = symbol.defined_namespace;
+      gen_symbol(symbol);
+      std::stringstream file_path;
+      file_path << path_;
+      // Create filepath.
+      if (symbol.defined_namespace)
+        for (auto i = symbol.defined_namespace->components.begin();
+             i != symbol.defined_namespace->components.end(); i++) {
+          file_path << MakeSnakeCase(*i) << kPathSeparator;
+          EnsureDirExists(file_path.str());
+        }
+      file_path << MakeSnakeCase(symbol.name) << parser_.opts.filename_suffix
+                << ".rs";
+      const bool save_success =
+          SaveFile(file_path.str().c_str(), code_.ToString(),
+                   /*binary=*/false);
+      if (!save_success) return false;
+    }
+    return true;
   }
 
+  bool GenerateIndividualFiles() {
+    code_.Clear();
+    // Don't bother with imports. Use absolute paths everywhere.
+    return GenerateSymbols<EnumDef>(
+               parser_.enums_, [&](const EnumDef &e) { this->GenEnum(e); }) &&
+           GenerateSymbols<StructDef>(
+               parser_.structs_, [&](const StructDef &s) {
+                 if (s.fixed) {
+                   this->GenStruct(s);
+                 } else {
+                   this->GenTable(s);
+                   if (this->parser_.opts.generate_object_based_api) {
+                     this->GenTableObject(s);
+                   }
+                 }
+                 if (this->parser_.root_struct_def_ == &s) {
+                   this->GenRootTableFuncs(s);
+                 }
+               });
+  }
+
+  // Generates code organized by .fbs files. This is broken legacy behavior
+  // that does not work with multiple fbs files with shared namespaces.
   // Iterate through all definitions we haven't generated code for (enums,
   // structs, and tables) and output them to a single file.
-  bool generate() {
+  bool GenerateOneFile() {
     code_.Clear();
     code_ += "// " + std::string(FlatBuffersGeneratedWarning()) + "\n\n";
 
@@ -496,32 +612,25 @@
     // example: f(A, D::E)          -> super::D::E
     // does not include leaf object (typically a struct type).
 
-    size_t i = 0;
     std::stringstream stream;
-
-    auto s = src->components.begin();
-    auto d = dst->components.begin();
-    for (;;) {
-      if (s == src->components.end()) { break; }
-      if (d == dst->components.end()) { break; }
-      if (*s != *d) { break; }
-      ++s;
-      ++d;
-      ++i;
-    }
-
-    for (; s != src->components.end(); ++s) { stream << "super::"; }
-    for (; d != dst->components.end(); ++d) {
-      stream << MakeSnakeCase(*d) + "::";
-    }
+    size_t common = 0;
+    std::vector<std::string> s, d;
+    if (src) s = src->components;
+    if (dst) d = dst->components;
+    while (common < s.size() && common < d.size() && s[common] == d[common])
+      common++;
+    // If src namespace is empty, this must be an absolute path.
+    for (size_t i = common; i < s.size(); i++) stream << "super::";
+    for (size_t i = common; i < d.size(); i++)
+      stream << MakeSnakeCase(d[i]) + "::";
     return stream.str();
   }
 
   // Generate a comment from the schema.
   void GenComment(const std::vector<std::string> &dc, const char *prefix = "") {
-    std::string text;
-    ::flatbuffers::GenComment(dc, &text, nullptr, prefix);
-    code_ += text + "\\";
+    for (auto it = dc.begin(); it != dc.end(); it++) {
+      code_ += std::string(prefix) + "///" + *it;
+    }
   }
 
   // Return a Rust type from the table in idl.h.
@@ -618,7 +727,9 @@
       const auto &ev = **it;
       code_.SetValue("VARIANT", Name(ev));
       code_.SetValue("VALUE", enum_def.ToString(ev));
+      code_.IncrementIdentLevel();
       cb(ev);
+      code_.DecrementIdentLevel();
     }
   }
   void ForAllEnumValues(const EnumDef &enum_def, std::function<void()> cb) {
@@ -655,8 +766,8 @@
       code_ += "    #[derive(Default)]";
       code_ += "    pub struct {{ENUM_NAME}}: {{BASE_TYPE}} {";
       ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {
-        this->GenComment(ev.doc_comment, "      ");
-        code_ += "      const {{VARIANT}} = {{VALUE}};";
+        this->GenComment(ev.doc_comment, "    ");
+        code_ += "    const {{VARIANT}} = {{VALUE}};";
       });
       code_ += "    }";
       code_ += "  }";
@@ -686,7 +797,7 @@
       code_ += "pub const ENUM_VALUES_{{ENUM_NAME_CAPS}}: [{{ENUM_NAME}}; " +
                num_fields + "] = [";
       ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {
-        code_ += "  " + GetEnumValue(enum_def, ev) + ",";
+        code_ += GetEnumValue(enum_def, ev) + ",";
       });
       code_ += "];";
       code_ += "";
@@ -703,21 +814,21 @@
       code_ += "#[allow(non_upper_case_globals)]";
       code_ += "impl {{ENUM_NAME}} {";
       ForAllEnumValues1(enum_def, [&](const EnumVal &ev) {
-        this->GenComment(ev.doc_comment, "  ");
-        code_ += "  pub const {{VARIANT}}: Self = Self({{VALUE}});";
+        this->GenComment(ev.doc_comment);
+        code_ += "pub const {{VARIANT}}: Self = Self({{VALUE}});";
       });
       code_ += "";
       // Generate Associated constants
       code_ += "  pub const ENUM_MIN: {{BASE_TYPE}} = {{ENUM_MIN_BASE_VALUE}};";
       code_ += "  pub const ENUM_MAX: {{BASE_TYPE}} = {{ENUM_MAX_BASE_VALUE}};";
       code_ += "  pub const ENUM_VALUES: &'static [Self] = &[";
-      ForAllEnumValues(enum_def, [&]() { code_ += "    Self::{{VARIANT}},"; });
+      ForAllEnumValues(enum_def, [&]() { code_ += "  Self::{{VARIANT}},"; });
       code_ += "  ];";
       code_ += "  /// Returns the variant's name or \"\" if unknown.";
       code_ += "  pub fn variant_name(self) -> Option<&'static str> {";
       code_ += "    match self {";
       ForAllEnumValues(enum_def, [&]() {
-        code_ += "      Self::{{VARIANT}} => Some(\"{{VARIANT}}\"),";
+        code_ += "    Self::{{VARIANT}} => Some(\"{{VARIANT}}\"),";
       });
       code_ += "      _ => None,";
       code_ += "    }";
@@ -741,6 +852,27 @@
       code_.SetValue("INTO_BASE", "self.0");
     }
 
+    // Implement serde::Serialize
+    if (parser_.opts.rust_serialize) {
+      code_ += "impl Serialize for {{ENUM_NAME}} {";
+      code_ +=
+          "  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>";
+      code_ += "  where";
+      code_ += "    S: Serializer,";
+      code_ += "  {";
+      if (IsBitFlagsEnum(enum_def)) {
+        code_ += "    serializer.serialize_u32(self.bits() as u32)";
+      } else {
+        code_ +=
+            "    serializer.serialize_unit_variant(\"{{ENUM_NAME}}\", self.0 "
+            "as "
+            "u32, self.variant_name().unwrap())";
+      }
+      code_ += "  }";
+      code_ += "}";
+      code_ += "";
+    }
+
     // Generate Follow and Push so we can serialize and stuff.
     code_ += "impl<'a> flatbuffers::Follow<'a> for {{ENUM_NAME}} {";
     code_ += "  type Inner = Self;";
@@ -813,7 +945,9 @@
       code_.SetValue("U_ELEMENT_NAME", MakeSnakeCase(Name(enum_val)));
       code_.SetValue("U_ELEMENT_TABLE_TYPE",
                      NamespacedNativeName(*enum_val.union_type.struct_def));
+      code_.IncrementIdentLevel();
       cb();
+      code_.DecrementIdentLevel();
     }
   }
   void GenUnionObject(const EnumDef &enum_def) {
@@ -822,12 +956,14 @@
     code_.SetValue("NATIVE_NAME", NativeName(enum_def));
 
     // Generate native union.
+    code_ += "#[allow(clippy::upper_case_acronyms)]";  // NONE's spelling is
+                                                       // intended.
     code_ += "#[non_exhaustive]";
     code_ += "#[derive(Debug, Clone, PartialEq)]";
     code_ += "pub enum {{NATIVE_NAME}} {";
     code_ += "  NONE,";
     ForAllUnionObjectVariantsBesidesNone(enum_def, [&] {
-      code_ += "  {{NATIVE_VARIANT}}(Box<{{U_ELEMENT_TABLE_TYPE}}>),";
+      code_ += "{{NATIVE_VARIANT}}(Box<{{U_ELEMENT_TABLE_TYPE}}>),";
     });
     code_ += "}";
     // Generate Default (NONE).
@@ -847,7 +983,7 @@
     code_ += "      Self::NONE => {{ENUM_NAME}}::NONE,";
     ForAllUnionObjectVariantsBesidesNone(enum_def, [&] {
       code_ +=
-          "      Self::{{NATIVE_VARIANT}}(_) => {{ENUM_NAME}}::"
+          "    Self::{{NATIVE_VARIANT}}(_) => {{ENUM_NAME}}::"
           "{{VARIANT_NAME}},";
     });
     code_ += "    }";
@@ -860,9 +996,8 @@
     code_ += "    match self {";
     code_ += "      Self::NONE => None,";
     ForAllUnionObjectVariantsBesidesNone(enum_def, [&] {
-      code_ +=
-          "      Self::{{NATIVE_VARIANT}}(v) => "
-          "Some(v.pack(fbb).as_union_value()),";
+      code_ += "    Self::{{NATIVE_VARIANT}}(v) => \\";
+      code_ += "Some(v.pack(fbb).as_union_value()),";
     });
     code_ += "    }";
     code_ += "  }";
@@ -871,44 +1006,44 @@
     ForAllUnionObjectVariantsBesidesNone(enum_def, [&] {
       // Move accessor.
       code_ +=
-          "  /// If the union variant matches, return the owned "
+          "/// If the union variant matches, return the owned "
           "{{U_ELEMENT_TABLE_TYPE}}, setting the union to NONE.";
       code_ +=
-          "  pub fn take_{{U_ELEMENT_NAME}}(&mut self) -> "
+          "pub fn take_{{U_ELEMENT_NAME}}(&mut self) -> "
           "Option<Box<{{U_ELEMENT_TABLE_TYPE}}>> {";
-      code_ += "    if let Self::{{NATIVE_VARIANT}}(_) = self {";
-      code_ += "      let v = std::mem::replace(self, Self::NONE);";
-      code_ += "      if let Self::{{NATIVE_VARIANT}}(w) = v {";
-      code_ += "        Some(w)";
-      code_ += "      } else {";
-      code_ += "        unreachable!()";
-      code_ += "      }";
+      code_ += "  if let Self::{{NATIVE_VARIANT}}(_) = self {";
+      code_ += "    let v = std::mem::replace(self, Self::NONE);";
+      code_ += "    if let Self::{{NATIVE_VARIANT}}(w) = v {";
+      code_ += "      Some(w)";
       code_ += "    } else {";
-      code_ += "      None";
+      code_ += "      unreachable!()";
       code_ += "    }";
+      code_ += "  } else {";
+      code_ += "    None";
       code_ += "  }";
+      code_ += "}";
       // Immutable reference accessor.
       code_ +=
-          "  /// If the union variant matches, return a reference to the "
+          "/// If the union variant matches, return a reference to the "
           "{{U_ELEMENT_TABLE_TYPE}}.";
       code_ +=
-          "  pub fn as_{{U_ELEMENT_NAME}}(&self) -> "
+          "pub fn as_{{U_ELEMENT_NAME}}(&self) -> "
           "Option<&{{U_ELEMENT_TABLE_TYPE}}> {";
       code_ +=
-          "    if let Self::{{NATIVE_VARIANT}}(v) = self "
+          "  if let Self::{{NATIVE_VARIANT}}(v) = self "
           "{ Some(v.as_ref()) } else { None }";
-      code_ += "  }";
+      code_ += "}";
       // Mutable reference accessor.
       code_ +=
-          "  /// If the union variant matches, return a mutable reference"
+          "/// If the union variant matches, return a mutable reference"
           " to the {{U_ELEMENT_TABLE_TYPE}}.";
       code_ +=
-          "  pub fn as_{{U_ELEMENT_NAME}}_mut(&mut self) -> "
+          "pub fn as_{{U_ELEMENT_NAME}}_mut(&mut self) -> "
           "Option<&mut {{U_ELEMENT_TABLE_TYPE}}> {";
       code_ +=
-          "    if let Self::{{NATIVE_VARIANT}}(v) = self "
+          "  if let Self::{{NATIVE_VARIANT}}(v) = self "
           "{ Some(v.as_mut()) } else { None }";
-      code_ += "  }";
+      code_ += "}";
     });
     code_ += "}";  // End union methods impl.
   }
@@ -960,7 +1095,7 @@
             field.IsRequired() ? "\"\"" : "\"" + field.value.constant + "\"";
         if (context == kObject) return defval + ".to_string()";
         if (context == kAccessor) return "&" + defval;
-        FLATBUFFERS_ASSERT("Unreachable.");
+        FLATBUFFERS_ASSERT(false);
         return "INVALID_CODE_GENERATION";
       }
 
@@ -986,7 +1121,7 @@
         return "Default::default()";
       }
     }
-    FLATBUFFERS_ASSERT("Unreachable.");
+    FLATBUFFERS_ASSERT(false);
     return "INVALID_CODE_GENERATION";
   }
 
@@ -1478,10 +1613,11 @@
   // Generates a fully-qualified name getter for use with --gen-name-strings
   void GenFullyQualifiedNameGetter(const StructDef &struct_def,
                                    const std::string &name) {
-    code_ += "    pub const fn get_fully_qualified_name() -> &'static str {";
-    code_ += "        \"" +
-             struct_def.defined_namespace->GetFullyQualifiedName(name) + "\"";
-    code_ += "    }";
+    const std::string fully_qualified_name =
+        struct_def.defined_namespace->GetFullyQualifiedName(name);
+    code_ += "  pub const fn get_fully_qualified_name() -> &'static str {";
+    code_ += "    \"" + fully_qualified_name + "\"";
+    code_ += "  }";
     code_ += "";
   }
 
@@ -1516,7 +1652,10 @@
       code_.SetValue("OFFSET_VALUE", NumToString(field.value.offset));
       code_.SetValue("FIELD_NAME", Name(field));
       code_.SetValue("BLDR_DEF_VAL", GetDefaultValue(field, kBuilder));
+      code_.SetValue("DISCRIMINANT", UnionTypeFieldName(field));
+      code_.IncrementIdentLevel();
       cb(field);
+      code_.DecrementIdentLevel();
     };
     const auto &fields = struct_def.fields.vec;
     if (reversed) {
@@ -1545,41 +1684,47 @@
     code_ += "}";
     code_ += "";
     code_ += "impl<'a> flatbuffers::Follow<'a> for {{STRUCT_NAME}}<'a> {";
-    code_ += "    type Inner = {{STRUCT_NAME}}<'a>;";
-    code_ += "    #[inline]";
-    code_ += "    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {";
-    code_ += "        Self { _tab: flatbuffers::Table { buf, loc } }";
-    code_ += "    }";
+    code_ += "  type Inner = {{STRUCT_NAME}}<'a>;";
+    code_ += "  #[inline]";
+    code_ += "  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {";
+    code_ += "    Self { _tab: flatbuffers::Table { buf, loc } }";
+    code_ += "  }";
     code_ += "}";
     code_ += "";
     code_ += "impl<'a> {{STRUCT_NAME}}<'a> {";
 
+    // Generate field id constants.
+    ForAllTableFields(struct_def, [&](const FieldDef &unused) {
+      (void)unused;
+      code_ +=
+          "pub const {{OFFSET_NAME}}: flatbuffers::VOffsetT = "
+          "{{OFFSET_VALUE}};";
+    });
+    code_ += "";
+
     if (parser_.opts.generate_name_strings) {
       GenFullyQualifiedNameGetter(struct_def, struct_def.name);
     }
 
-    code_ += "    #[inline]";
+    code_ += "  #[inline]";
     code_ +=
-        "    pub fn init_from_table(table: flatbuffers::Table<'a>) -> "
+        "  pub fn init_from_table(table: flatbuffers::Table<'a>) -> "
         "Self {";
-    code_ += "        {{STRUCT_NAME}} { _tab: table }";
-    code_ += "    }";
+    code_ += "    {{STRUCT_NAME}} { _tab: table }";
+    code_ += "  }";
 
     // Generate a convenient create* function that uses the above builder
     // to create a table in one function call.
     code_.SetValue("MAYBE_US", struct_def.fields.vec.size() == 0 ? "_" : "");
     code_.SetValue("MAYBE_LT",
                    TableBuilderArgsNeedsLifetime(struct_def) ? "<'args>" : "");
-    code_ += "    #[allow(unused_mut)]";
-    code_ += "    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(";
-    code_ +=
-        "        _fbb: "
-        "&'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,";
-    code_ +=
-        "        {{MAYBE_US}}args: &'args {{STRUCT_NAME}}Args{{MAYBE_LT}})"
-        " -> flatbuffers::WIPOffset<{{STRUCT_NAME}}<'bldr>> {";
+    code_ += "  #[allow(unused_mut)]";
+    code_ += "  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(";
+    code_ += "    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,";
+    code_ += "    {{MAYBE_US}}args: &'args {{STRUCT_NAME}}Args{{MAYBE_LT}}";
+    code_ += "  ) -> flatbuffers::WIPOffset<{{STRUCT_NAME}}<'bldr>> {";
 
-    code_ += "      let mut builder = {{STRUCT_NAME}}Builder::new(_fbb);";
+    code_ += "    let mut builder = {{STRUCT_NAME}}Builder::new(_fbb);";
     for (size_t size = struct_def.sortbysize ? sizeof(largest_scalar_t) : 1;
          size; size /= 2) {
       ForAllTableFields(
@@ -1590,23 +1735,23 @@
               return;
             if (IsOptionalToBuilder(field)) {
               code_ +=
-                  "      if let Some(x) = args.{{FIELD_NAME}} "
+                  "  if let Some(x) = args.{{FIELD_NAME}} "
                   "{ builder.add_{{FIELD_NAME}}(x); }";
             } else {
-              code_ += "      builder.add_{{FIELD_NAME}}(args.{{FIELD_NAME}});";
+              code_ += "  builder.add_{{FIELD_NAME}}(args.{{FIELD_NAME}});";
             }
           },
           /*reverse=*/true);
     }
-    code_ += "      builder.finish()";
-    code_ += "    }";
+    code_ += "    builder.finish()";
+    code_ += "  }";
     code_ += "";
     // Generate Object API Packer function.
     if (parser_.opts.generate_object_based_api) {
       // TODO(cneo): Replace more for loops with ForAllX stuff.
       // TODO(cneo): Manage indentation with IncrementIdentLevel?
       code_.SetValue("OBJECT_NAME", NativeName(struct_def));
-      code_ += "    pub fn unpack(&self) -> {{OBJECT_NAME}} {";
+      code_ += "  pub fn unpack(&self) -> {{OBJECT_NAME}} {";
       ForAllObjectTableFields(struct_def, [&](const FieldDef &field) {
         const Type &type = field.value.type;
         switch (GetFullType(type)) {
@@ -1614,7 +1759,7 @@
           case ftBool:
           case ftFloat:
           case ftEnumKey: {
-            code_ += "      let {{FIELD_NAME}} = self.{{FIELD_NAME}}();";
+            code_ += "  let {{FIELD_NAME}} = self.{{FIELD_NAME}}();";
             return;
           }
           case ftUnionKey: return;
@@ -1623,27 +1768,22 @@
             code_.SetValue("ENUM_NAME", WrapInNameSpace(enum_def));
             code_.SetValue("NATIVE_ENUM_NAME", NamespacedNativeName(enum_def));
             code_ +=
-                "      let {{FIELD_NAME}} = match "
-                "self.{{FIELD_NAME}}_type() {";
-            code_ +=
-                "        {{ENUM_NAME}}::NONE =>"
-                " {{NATIVE_ENUM_NAME}}::NONE,";
+                "  let {{FIELD_NAME}} = match self.{{FIELD_NAME}}_type() {";
+            code_ += "    {{ENUM_NAME}}::NONE => {{NATIVE_ENUM_NAME}}::NONE,";
             ForAllUnionObjectVariantsBesidesNone(enum_def, [&] {
               code_ +=
-                  "        {{ENUM_NAME}}::{{VARIANT_NAME}} => "
+                  "  {{ENUM_NAME}}::{{VARIANT_NAME}} => "
                   "{{NATIVE_ENUM_NAME}}::{{NATIVE_VARIANT}}(Box::new(";
+              code_ += "    self.{{FIELD_NAME}}_as_{{U_ELEMENT_NAME}}()";
               code_ +=
-                  "          self.{{FIELD_NAME}}_as_"
-                  "{{U_ELEMENT_NAME}}()";
-              code_ +=
-                  "              .expect(\"Invalid union table, "
+                  "        .expect(\"Invalid union table, "
                   "expected `{{ENUM_NAME}}::{{VARIANT_NAME}}`.\")";
-              code_ += "              .unpack()";
-              code_ += "        )),";
+              code_ += "        .unpack()";
+              code_ += "  )),";
             });
             // Maybe we shouldn't throw away unknown discriminants?
-            code_ += "        _ => {{NATIVE_ENUM_NAME}}::NONE,";
-            code_ += "      };";
+            code_ += "    _ => {{NATIVE_ENUM_NAME}}::NONE,";
+            code_ += "  };";
             return;
           }
           // The rest of the types need special handling based on if the field
@@ -1698,32 +1838,25 @@
           }
         }
         if (field.IsOptional()) {
-          code_ += "      let {{FIELD_NAME}} = self.{{FIELD_NAME}}().map(|x| {";
-          code_ += "        {{EXPR}}";
-          code_ += "      });";
+          code_ += "  let {{FIELD_NAME}} = self.{{FIELD_NAME}}().map(|x| {";
+          code_ += "    {{EXPR}}";
+          code_ += "  });";
         } else {
-          code_ += "      let {{FIELD_NAME}} = {";
-          code_ += "        let x = self.{{FIELD_NAME}}();";
-          code_ += "        {{EXPR}}";
-          code_ += "      };";
+          code_ += "  let {{FIELD_NAME}} = {";
+          code_ += "    let x = self.{{FIELD_NAME}}();";
+          code_ += "    {{EXPR}}";
+          code_ += "  };";
         }
       });
-      code_ += "      {{OBJECT_NAME}} {";
+      code_ += "    {{OBJECT_NAME}} {";
       ForAllObjectTableFields(struct_def, [&](const FieldDef &field) {
         if (field.value.type.base_type == BASE_TYPE_UTYPE) return;
-        code_ += "        {{FIELD_NAME}},";
+        code_ += "    {{FIELD_NAME}},";
       });
-      code_ += "      }";
       code_ += "    }";
+      code_ += "  }";
     }
 
-    // Generate field id constants.
-    ForAllTableFields(struct_def, [&](const FieldDef &unused) {
-      (void)unused;
-      code_ +=
-          "    pub const {{OFFSET_NAME}}: flatbuffers::VOffsetT = "
-          "{{OFFSET_VALUE}};";
-    });
     if (struct_def.fields.vec.size() > 0) code_ += "";
 
     // Generate the accessors. Each has one of two forms:
@@ -1741,11 +1874,11 @@
       code_.SetValue("RETURN_TYPE",
                      GenTableAccessorFuncReturnType(field, "'a"));
 
-      this->GenComment(field.doc_comment, "  ");
-      code_ += "  #[inline]";
-      code_ += "  pub fn {{FIELD_NAME}}(&self) -> {{RETURN_TYPE}} {";
-      code_ += "    " + GenTableAccessorFuncBody(field, "'a");
-      code_ += "  }";
+      this->GenComment(field.doc_comment);
+      code_ += "#[inline]";
+      code_ += "pub fn {{FIELD_NAME}}(&self) -> {{RETURN_TYPE}} {";
+      code_ += "  " + GenTableAccessorFuncBody(field, "'a");
+      code_ += "}";
 
       // Generate a comparison function for this field if it is a key.
       if (field.key) { GenKeyFieldMethods(field); }
@@ -1763,38 +1896,37 @@
         FLATBUFFERS_ASSERT(nested_root);  // Guaranteed to exist by parser.
 
         code_.SetValue("NESTED", WrapInNameSpace(*nested_root));
-        code_ += "  pub fn {{FIELD_NAME}}_nested_flatbuffer(&'a self) -> \\";
+        code_ += "pub fn {{FIELD_NAME}}_nested_flatbuffer(&'a self) -> \\";
         if (field.IsRequired()) {
           code_ += "{{NESTED}}<'a> {";
-          code_ += "    let data = self.{{FIELD_NAME}}();";
-          code_ += "    use flatbuffers::Follow;";
+          code_ += "  let data = self.{{FIELD_NAME}}();";
+          code_ += "  use flatbuffers::Follow;";
           code_ +=
-              "    <flatbuffers::ForwardsUOffset<{{NESTED}}<'a>>>"
+              "  <flatbuffers::ForwardsUOffset<{{NESTED}}<'a>>>"
               "::follow(data, 0)";
         } else {
           code_ += "Option<{{NESTED}}<'a>> {";
-          code_ += "    self.{{FIELD_NAME}}().map(|data| {";
-          code_ += "      use flatbuffers::Follow;";
+          code_ += "  self.{{FIELD_NAME}}().map(|data| {";
+          code_ += "    use flatbuffers::Follow;";
           code_ +=
-              "      <flatbuffers::ForwardsUOffset<{{NESTED}}<'a>>>"
+              "    <flatbuffers::ForwardsUOffset<{{NESTED}}<'a>>>"
               "::follow(data, 0)";
-          code_ += "    })";
+          code_ += "  })";
         }
-        code_ += "  }";
+        code_ += "}";
       }
     });
 
     // Explicit specializations for union accessors
     ForAllTableFields(struct_def, [&](const FieldDef &field) {
       if (field.value.type.base_type != BASE_TYPE_UNION) return;
-      code_.SetValue("FIELD_TYPE_FIELD_NAME", field.name);
       ForAllUnionVariantsBesidesNone(
           *field.value.type.enum_def, [&](const EnumVal &unused) {
             (void)unused;
-            code_ += "  #[inline]";
-            code_ += "  #[allow(non_snake_case)]";
+            code_ += "#[inline]";
+            code_ += "#[allow(non_snake_case)]";
             code_ +=
-                "  pub fn {{FIELD_NAME}}_as_{{U_ELEMENT_NAME}}(&self) -> "
+                "pub fn {{FIELD_NAME}}_as_{{U_ELEMENT_NAME}}(&self) -> "
                 "Option<{{U_ELEMENT_TABLE_TYPE}}<'a>> {";
             // If the user defined schemas name a field that clashes with a
             // language reserved word, flatc will try to escape the field name
@@ -1808,24 +1940,22 @@
             //
             // To avoid this problem the type field name is used unescaped here:
             code_ +=
-                "    if self.{{FIELD_TYPE_FIELD_NAME}}_type() == "
-                "{{U_ELEMENT_ENUM_TYPE}} {";
+                "  if self.{{DISCRIMINANT}}() == {{U_ELEMENT_ENUM_TYPE}} {";
 
             // The following logic is not tested in the integration test,
             // as of April 10, 2020
             if (field.IsRequired()) {
-              code_ += "      let u = self.{{FIELD_NAME}}();";
-              code_ +=
-                  "      Some({{U_ELEMENT_TABLE_TYPE}}::init_from_table(u))";
+              code_ += "    let u = self.{{FIELD_NAME}}();";
+              code_ += "    Some({{U_ELEMENT_TABLE_TYPE}}::init_from_table(u))";
             } else {
               code_ +=
-                  "      self.{{FIELD_NAME}}().map("
+                  "    self.{{FIELD_NAME}}().map("
                   "{{U_ELEMENT_TABLE_TYPE}}::init_from_table)";
             }
-            code_ += "    } else {";
-            code_ += "      None";
-            code_ += "    }";
+            code_ += "  } else {";
+            code_ += "    None";
             code_ += "  }";
+            code_ += "}";
             code_ += "";
           });
     });
@@ -1850,29 +1980,34 @@
         // All types besides unions.
         code_.SetValue("TY", FollowType(field.value.type, "'_"));
         code_ +=
-            "\n     .visit_field::<{{TY}}>(&\"{{FIELD_NAME}}\", "
+            "\n     .visit_field::<{{TY}}>(\"{{FIELD_NAME}}\", "
             "Self::{{OFFSET_NAME}}, {{IS_REQ}})?\\";
         return;
       }
       // Unions.
-      EnumDef &union_def = *field.value.type.enum_def;
+      const EnumDef &union_def = *field.value.type.enum_def;
       code_.SetValue("UNION_TYPE", WrapInNameSpace(union_def));
+      // TODO: Use the same function that generates the _type field for
+      // consistency. We do not call Name() because it inconsistently
+      // escapes keywords.
+      code_.SetValue("UNION_TYPE_OFFSET_NAME",
+                     "VT_" + MakeUpper(field.name + "_type"));
       code_ +=
           "\n     .visit_union::<{{UNION_TYPE}}, _>("
-          "&\"{{FIELD_NAME}}_type\", Self::{{OFFSET_NAME}}_TYPE, "
-          "&\"{{FIELD_NAME}}\", Self::{{OFFSET_NAME}}, {{IS_REQ}}, "
+          "\"{{FIELD_NAME}}_type\", Self::{{UNION_TYPE_OFFSET_NAME}}, "
+          "\"{{FIELD_NAME}}\", Self::{{OFFSET_NAME}}, {{IS_REQ}}, "
           "|key, v, pos| {";
-      code_ += "        match key {";
+      code_ += "      match key {";
       ForAllUnionVariantsBesidesNone(union_def, [&](const EnumVal &unused) {
         (void)unused;
         code_ +=
-            "          {{U_ELEMENT_ENUM_TYPE}} => v.verify_union_variant::"
+            "        {{U_ELEMENT_ENUM_TYPE}} => v.verify_union_variant::"
             "<flatbuffers::ForwardsUOffset<{{U_ELEMENT_TABLE_TYPE}}>>("
             "\"{{U_ELEMENT_ENUM_TYPE}}\", pos),";
       });
-      code_ += "          _ => Ok(()),";
-      code_ += "        }";
-      code_ += "     })?\\";
+      code_ += "        _ => Ok(()),";
+      code_ += "      }";
+      code_ += "   })?\\";
     });
     code_ += "\n     .finish();";
     code_ += "    Ok(())";
@@ -1885,22 +2020,90 @@
     code_ += "pub struct {{STRUCT_NAME}}Args{{MAYBE_LT}} {";
     ForAllTableFields(struct_def, [&](const FieldDef &field) {
       code_.SetValue("PARAM_TYPE", TableBuilderArgsDefnType(field, "'a"));
-      code_ += "    pub {{FIELD_NAME}}: {{PARAM_TYPE}},";
+      code_ += "  pub {{FIELD_NAME}}: {{PARAM_TYPE}},";
     });
     code_ += "}";
 
     // Generate an impl of Default for the *Args type:
     code_ += "impl<'a> Default for {{STRUCT_NAME}}Args{{MAYBE_LT}} {";
-    code_ += "    #[inline]";
-    code_ += "    fn default() -> Self {";
-    code_ += "        {{STRUCT_NAME}}Args {";
+    code_ += "  #[inline]";
+    code_ += "  fn default() -> Self {";
+    code_ += "    {{STRUCT_NAME}}Args {";
     ForAllTableFields(struct_def, [&](const FieldDef &field) {
-      code_ += "            {{FIELD_NAME}}: {{BLDR_DEF_VAL}},\\";
+      code_ += "    {{FIELD_NAME}}: {{BLDR_DEF_VAL}},\\";
       code_ += field.IsRequired() ? " // required field" : "";
     });
-    code_ += "        }";
     code_ += "    }";
+    code_ += "  }";
     code_ += "}";
+    code_ += "";
+
+    // Implement serde::Serialize
+    if (parser_.opts.rust_serialize) {
+      const auto numFields = struct_def.fields.vec.size();
+      code_.SetValue("NUM_FIELDS", NumToString(numFields));
+      code_ += "impl Serialize for {{STRUCT_NAME}}<'_> {";
+      code_ +=
+          "  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>";
+      code_ += "  where";
+      code_ += "    S: Serializer,";
+      code_ += "  {";
+      if (numFields == 0) {
+        code_ +=
+            "    let s = serializer.serialize_struct(\"{{STRUCT_NAME}}\", 0)?;";
+      } else {
+        code_ +=
+            "    let mut s = serializer.serialize_struct(\"{{STRUCT_NAME}}\", "
+            "{{NUM_FIELDS}})?;";
+      }
+      ForAllTableFields(struct_def, [&](const FieldDef &field) {
+        const Type &type = field.value.type;
+        if (IsUnion(type)) {
+          if (type.base_type == BASE_TYPE_UNION) {
+            const auto &enum_def = *type.enum_def;
+            code_.SetValue("ENUM_NAME", WrapInNameSpace(enum_def));
+            code_.SetValue("FIELD_TYPE_FIELD_NAME", field.name);
+
+            code_ += "    match self.{{FIELD_TYPE_FIELD_NAME}}_type() {";
+            code_ += "      {{ENUM_NAME}}::NONE => (),";
+            ForAllUnionObjectVariantsBesidesNone(enum_def, [&] {
+              code_.SetValue("FIELD_TYPE_FIELD_NAME", field.name);
+              code_ += "      {{ENUM_NAME}}::{{VARIANT_NAME}} => {";
+              code_ +=
+                  "        let f = "
+                  "self.{{FIELD_TYPE_FIELD_NAME}}_as_{{U_ELEMENT_NAME}}()";
+              code_ +=
+                  "          .expect(\"Invalid union table, expected "
+                  "`{{ENUM_NAME}}::{{VARIANT_NAME}}`.\");";
+              code_ += "        s.serialize_field(\"{{FIELD_NAME}}\", &f)?;";
+              code_ += "      }";
+            });
+            code_ += "      _ => unimplemented!(),";
+            code_ += "    }";
+          } else {
+            code_ +=
+                "    s.serialize_field(\"{{FIELD_NAME}}\", "
+                "&self.{{FIELD_NAME}}())?;";
+          }
+        } else {
+          if (field.IsOptional()) {
+            code_ += "    if let Some(f) = self.{{FIELD_NAME}}() {";
+            code_ += "      s.serialize_field(\"{{FIELD_NAME}}\", &f)?;";
+            code_ += "    } else {";
+            code_ += "      s.skip_field(\"{{FIELD_NAME}}\")?;";
+            code_ += "    }";
+          } else {
+            code_ +=
+                "    s.serialize_field(\"{{FIELD_NAME}}\", "
+                "&self.{{FIELD_NAME}}())?;";
+          }
+        }
+      });
+      code_ += "    s.end()";
+      code_ += "  }";
+      code_ += "}";
+      code_ += "";
+    }
 
     // Generate a builder struct:
     code_ += "pub struct {{STRUCT_NAME}}Builder<'a: 'b, 'b> {";
@@ -1929,18 +2132,18 @@
       code_.SetValue("FIELD_OFFSET", Name(struct_def) + "::" + offset);
       code_.SetValue("FIELD_TYPE", TableBuilderArgsAddFuncType(field, "'b "));
       code_.SetValue("FUNC_BODY", TableBuilderArgsAddFuncBody(field));
-      code_ += "  #[inline]";
+      code_ += "#[inline]";
       code_ +=
-          "  pub fn add_{{FIELD_NAME}}(&mut self, {{FIELD_NAME}}: "
+          "pub fn add_{{FIELD_NAME}}(&mut self, {{FIELD_NAME}}: "
           "{{FIELD_TYPE}}) {";
       if (is_scalar && !field.IsOptional()) {
         code_ +=
-            "    {{FUNC_BODY}}({{FIELD_OFFSET}}, {{FIELD_NAME}}, "
+            "  {{FUNC_BODY}}({{FIELD_OFFSET}}, {{FIELD_NAME}}, "
             "{{BLDR_DEF_VAL}});";
       } else {
-        code_ += "    {{FUNC_BODY}}({{FIELD_OFFSET}}, {{FIELD_NAME}});";
+        code_ += "  {{FUNC_BODY}}({{FIELD_OFFSET}}, {{FIELD_NAME}});";
       }
-      code_ += "  }";
+      code_ += "}";
     });
 
     // Struct initializer (all fields required);
@@ -1966,7 +2169,7 @@
     ForAllTableFields(struct_def, [&](const FieldDef &field) {
       if (!field.IsRequired()) return;
       code_ +=
-          "    self.fbb_.required(o, {{STRUCT_NAME}}::{{OFFSET_NAME}},"
+          "  self.fbb_.required(o, {{STRUCT_NAME}}::{{OFFSET_NAME}},"
           "\"{{FIELD_NAME}}\");";
     });
     code_ += "    flatbuffers::WIPOffset::new(o.value())";
@@ -1983,35 +2186,33 @@
       if (GetFullType(field.value.type) == ftUnionValue) {
         // Generate a match statement to handle unions properly.
         code_.SetValue("KEY_TYPE", GenTableAccessorFuncReturnType(field, ""));
-        code_.SetValue("FIELD_TYPE_FIELD_NAME", field.name);
         code_.SetValue("UNION_ERR",
                        "&\"InvalidFlatbuffer: Union discriminant"
                        " does not match value.\"");
 
-        code_ += "      match self.{{FIELD_NAME}}_type() {";
+        code_ += "    match self.{{DISCRIMINANT}}() {";
         ForAllUnionVariantsBesidesNone(
             *field.value.type.enum_def, [&](const EnumVal &unused) {
               (void)unused;
-              code_ += "        {{U_ELEMENT_ENUM_TYPE}} => {";
+              code_ += "      {{U_ELEMENT_ENUM_TYPE}} => {";
               code_ +=
-                  "          if let Some(x) = "
-                  "self.{{FIELD_TYPE_FIELD_NAME}}_as_"
+                  "        if let Some(x) = "
+                  "self.{{FIELD_NAME}}_as_"
                   "{{U_ELEMENT_NAME}}() {";
-              code_ += "            ds.field(\"{{FIELD_NAME}}\", &x)";
-              code_ += "          } else {";
-              code_ +=
-                  "            ds.field(\"{{FIELD_NAME}}\", {{UNION_ERR}})";
-              code_ += "          }";
-              code_ += "        },";
+              code_ += "          ds.field(\"{{FIELD_NAME}}\", &x)";
+              code_ += "        } else {";
+              code_ += "          ds.field(\"{{FIELD_NAME}}\", {{UNION_ERR}})";
+              code_ += "        }";
+              code_ += "      },";
             });
-        code_ += "        _ => {";
-        code_ += "          let x: Option<()> = None;";
-        code_ += "          ds.field(\"{{FIELD_NAME}}\", &x)";
-        code_ += "        },";
-        code_ += "      };";
+        code_ += "      _ => {";
+        code_ += "        let x: Option<()> = None;";
+        code_ += "        ds.field(\"{{FIELD_NAME}}\", &x)";
+        code_ += "      },";
+        code_ += "    };";
       } else {
         // Most fields.
-        code_ += "      ds.field(\"{{FIELD_NAME}}\", &self.{{FIELD_NAME}}());";
+        code_ += "    ds.field(\"{{FIELD_NAME}}\", &self.{{FIELD_NAME}}());";
       }
     });
     code_ += "      ds.finish()";
@@ -2031,7 +2232,7 @@
       // Union objects combine both the union discriminant and value, so we
       // skip making a field for the discriminant.
       if (field.value.type.base_type == BASE_TYPE_UTYPE) return;
-      code_ += "  pub {{FIELD_NAME}}: {{FIELD_OBJECT_TYPE}},";
+      code_ += "pub {{FIELD_NAME}}: {{FIELD_OBJECT_TYPE}},";
     });
     code_ += "}";
 
@@ -2041,7 +2242,7 @@
     ForAllObjectTableFields(table, [&](const FieldDef &field) {
       if (field.value.type.base_type == BASE_TYPE_UTYPE) return;
       std::string default_value = GetDefaultValue(field, kObject);
-      code_ += "      {{FIELD_NAME}}: " + default_value + ",";
+      code_ += "    {{FIELD_NAME}}: " + default_value + ",";
     });
     code_ += "    }";
     code_ += "  }";
@@ -2065,7 +2266,7 @@
         case ftBool:
         case ftFloat:
         case ftEnumKey: {
-          code_ += "    let {{FIELD_NAME}} = self.{{FIELD_NAME}};";
+          code_ += "  let {{FIELD_NAME}} = self.{{FIELD_NAME}};";
           return;
         }
         case ftUnionKey: return;  // Generate union type with union value.
@@ -2073,9 +2274,9 @@
           code_.SetValue("SNAKE_CASE_ENUM_NAME",
                          MakeSnakeCase(Name(*field.value.type.enum_def)));
           code_ +=
-              "    let {{FIELD_NAME}}_type = "
+              "  let {{FIELD_NAME}}_type = "
               "self.{{FIELD_NAME}}.{{SNAKE_CASE_ENUM_NAME}}_type();";
-          code_ += "    let {{FIELD_NAME}} = self.{{FIELD_NAME}}.pack(_fbb);";
+          code_ += "  let {{FIELD_NAME}} = self.{{FIELD_NAME}}.pack(_fbb);";
           return;
         }
         // The rest of the types require special casing around optionalness
@@ -2088,14 +2289,13 @@
           // Hold the struct in a variable so we can reference it.
           if (field.IsRequired()) {
             code_ +=
-                "    let {{FIELD_NAME}}_tmp = "
-                "Some(self.{{FIELD_NAME}}.pack());";
+                "  let {{FIELD_NAME}}_tmp = Some(self.{{FIELD_NAME}}.pack());";
           } else {
             code_ +=
-                "    let {{FIELD_NAME}}_tmp = self.{{FIELD_NAME}}"
+                "  let {{FIELD_NAME}}_tmp = self.{{FIELD_NAME}}"
                 ".as_ref().map(|x| x.pack());";
           }
-          code_ += "    let {{FIELD_NAME}} = {{FIELD_NAME}}_tmp.as_ref();";
+          code_ += "  let {{FIELD_NAME}} = {{FIELD_NAME}}_tmp.as_ref();";
 
           return;
         }
@@ -2149,7 +2349,7 @@
     code_ += "    {{STRUCT_NAME}}::create(_fbb, &{{STRUCT_NAME}}Args{";
     ForAllObjectTableFields(table, [&](const FieldDef &field) {
       (void)field;  // Unused.
-      code_ += "      {{FIELD_NAME}},";
+      code_ += "    {{FIELD_NAME}},";
     });
     code_ += "    })";
     code_ += "  }";
@@ -2163,21 +2363,23 @@
       if (field.deprecated) continue;
       code_.SetValue("FIELD_NAME", Name(field));
       code_.SetValue("FIELD_OBJECT_TYPE", ObjectFieldType(field, true));
+      code_.IncrementIdentLevel();
       cb(field);
+      code_.DecrementIdentLevel();
     }
   }
   void MapNativeTableField(const FieldDef &field, const std::string &expr) {
     if (field.IsOptional()) {
-      code_ += "    let {{FIELD_NAME}} = self.{{FIELD_NAME}}.as_ref().map(|x|{";
-      code_ += "      " + expr;
-      code_ += "    });";
+      code_ += "  let {{FIELD_NAME}} = self.{{FIELD_NAME}}.as_ref().map(|x|{";
+      code_ += "    " + expr;
+      code_ += "  });";
     } else {
       // For some reason Args has optional types for required fields.
       // TODO(cneo): Fix this... but its a breaking change?
-      code_ += "    let {{FIELD_NAME}} = Some({";
-      code_ += "      let x = &self.{{FIELD_NAME}};";
-      code_ += "      " + expr;
-      code_ += "    });";
+      code_ += "  let {{FIELD_NAME}} = Some({";
+      code_ += "    let x = &self.{{FIELD_NAME}};";
+      code_ += "    " + expr;
+      code_ += "  });";
     }
   }
 
@@ -2187,21 +2389,22 @@
     FLATBUFFERS_ASSERT(field.key);
 
     code_.SetValue("KEY_TYPE", GenTableAccessorFuncReturnType(field, ""));
+    code_.SetValue("REF", IsString(field.value.type) ? "" : "&");
 
-    code_ += "  #[inline]";
+    code_ += "#[inline]";
     code_ +=
-        "  pub fn key_compare_less_than(&self, o: &{{STRUCT_NAME}}) -> "
-        " bool {";
-    code_ += "    self.{{FIELD_NAME}}() < o.{{FIELD_NAME}}()";
-    code_ += "  }";
+        "pub fn key_compare_less_than(&self, o: &{{STRUCT_NAME}}) -> "
+        "bool {";
+    code_ += "  self.{{FIELD_NAME}}() < o.{{FIELD_NAME}}()";
+    code_ += "}";
     code_ += "";
-    code_ += "  #[inline]";
+    code_ += "#[inline]";
     code_ +=
-        "  pub fn key_compare_with_value(&self, val: {{KEY_TYPE}}) -> "
-        " ::std::cmp::Ordering {";
-    code_ += "    let key = self.{{FIELD_NAME}}();";
-    code_ += "    key.cmp(&val)";
-    code_ += "  }";
+        "pub fn key_compare_with_value(&self, val: {{KEY_TYPE}}) -> "
+        "::std::cmp::Ordering {";
+    code_ += "  let key = self.{{FIELD_NAME}}();";
+    code_ += "  key.cmp({{REF}}val)";
+    code_ += "}";
   }
 
   // Generate functions for accessing the root table object. This function
@@ -2427,7 +2630,9 @@
       code_.SetValue(
           "REF",
           IsStruct(field.value.type) || IsArray(field.value.type) ? "&" : "");
+      code_.IncrementIdentLevel();
       cb(field);
+      code_.DecrementIdentLevel();
       const size_t size = InlineSize(field.value.type);
       offset_to_field += size + field.padding;
     }
@@ -2466,7 +2671,7 @@
     code_ += "    f.debug_struct(\"{{STRUCT_NAME}}\")";
     ForAllStructFields(struct_def, [&](const FieldDef &unused) {
       (void)unused;
-      code_ += "      .field(\"{{FIELD_NAME}}\", &self.{{FIELD_NAME}}())";
+      code_ += "    .field(\"{{FIELD_NAME}}\", &self.{{FIELD_NAME}}())";
     });
     code_ += "      .finish()";
     code_ += "  }";
@@ -2530,6 +2735,37 @@
     code_ += "    v.in_buffer::<Self>(pos)";
     code_ += "  }";
     code_ += "}";
+    code_ += "";
+
+    // Implement serde::Serialize
+    if (parser_.opts.rust_serialize) {
+      const auto numFields = struct_def.fields.vec.size();
+      code_.SetValue("NUM_FIELDS", NumToString(numFields));
+      code_ += "impl Serialize for {{STRUCT_NAME}} {";
+      code_ +=
+          "  fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>";
+      code_ += "  where";
+      code_ += "    S: Serializer,";
+      code_ += "  {";
+      if (numFields == 0) {
+        code_ +=
+            "    let s = serializer.serialize_struct(\"{{STRUCT_NAME}}\", 0)?;";
+      } else {
+        code_ +=
+            "    let mut s = serializer.serialize_struct(\"{{STRUCT_NAME}}\", "
+            "{{NUM_FIELDS}})?;";
+      }
+      ForAllStructFields(struct_def, [&](const FieldDef &unused) {
+        (void)unused;
+        code_ +=
+            "    s.serialize_field(\"{{FIELD_NAME}}\", "
+            "&self.{{FIELD_NAME}}())?;";
+      });
+      code_ += "    s.end()";
+      code_ += "  }";
+      code_ += "}";
+      code_ += "";
+    }
 
     // Generate a constructor that takes all fields as arguments.
     code_ += "impl<'a> {{STRUCT_NAME}} {";
@@ -2537,13 +2773,13 @@
     code_ += "  pub fn new(";
     ForAllStructFields(struct_def, [&](const FieldDef &unused) {
       (void)unused;
-      code_ += "    {{FIELD_NAME}}: {{REF}}{{FIELD_TYPE}},";
+      code_ += "  {{FIELD_NAME}}: {{REF}}{{FIELD_TYPE}},";
     });
     code_ += "  ) -> Self {";
     code_ += "    let mut s = Self([0; {{STRUCT_SIZE}}]);";
     ForAllStructFields(struct_def, [&](const FieldDef &unused) {
       (void)unused;
-      code_ += "    s.set_{{FIELD_NAME}}({{REF}}{{FIELD_NAME}});";
+      code_ += "  s.set_{{FIELD_NAME}}({{FIELD_NAME}});";
     });
     code_ += "    s";
     code_ += "  }";
@@ -2555,12 +2791,12 @@
 
     // Generate accessor methods for the struct.
     ForAllStructFields(struct_def, [&](const FieldDef &field) {
-      this->GenComment(field.doc_comment, "  ");
+      this->GenComment(field.doc_comment);
       // Getter.
       if (IsStruct(field.value.type)) {
-        code_ += "  pub fn {{FIELD_NAME}}(&self) -> &{{FIELD_TYPE}} {";
+        code_ += "pub fn {{FIELD_NAME}}(&self) -> &{{FIELD_TYPE}} {";
         code_ +=
-            "    unsafe {"
+            "  unsafe {"
             " &*(self.0[{{FIELD_OFFSET}}..].as_ptr() as *const"
             " {{FIELD_TYPE}}) }";
       } else if (IsArray(field.value.type)) {
@@ -2568,30 +2804,31 @@
                        NumToString(field.value.type.fixed_length));
         code_.SetValue("ARRAY_ITEM", GetTypeGet(field.value.type.VectorType()));
         code_ +=
-            "  pub fn {{FIELD_NAME}}(&'a self) -> "
+            "pub fn {{FIELD_NAME}}(&'a self) -> "
             "flatbuffers::Array<'a, {{ARRAY_ITEM}}, {{ARRAY_SIZE}}> {";
-        code_ += "    flatbuffers::Array::follow(&self.0, {{FIELD_OFFSET}})";
+        code_ += "  flatbuffers::Array::follow(&self.0, {{FIELD_OFFSET}})";
       } else {
-        code_ += "  pub fn {{FIELD_NAME}}(&self) -> {{FIELD_TYPE}} {";
+        code_ += "pub fn {{FIELD_NAME}}(&self) -> {{FIELD_TYPE}} {";
         code_ +=
-            "    let mut mem = core::mem::MaybeUninit::"
+            "  let mut mem = core::mem::MaybeUninit::"
             "<{{FIELD_TYPE}}>::uninit();";
-        code_ += "    unsafe {";
-        code_ += "      core::ptr::copy_nonoverlapping(";
-        code_ += "        self.0[{{FIELD_OFFSET}}..].as_ptr(),";
-        code_ += "        mem.as_mut_ptr() as *mut u8,";
-        code_ += "        core::mem::size_of::<{{FIELD_TYPE}}>(),";
-        code_ += "      );";
-        code_ += "      mem.assume_init()";
-        code_ += "    }.from_little_endian()";
+        code_ += "  unsafe {";
+        code_ += "    core::ptr::copy_nonoverlapping(";
+        code_ += "      self.0[{{FIELD_OFFSET}}..].as_ptr(),";
+        code_ += "      mem.as_mut_ptr() as *mut u8,";
+        code_ += "      core::mem::size_of::<{{FIELD_TYPE}}>(),";
+        code_ += "    );";
+        code_ += "    mem.assume_init()";
+        code_ += "  }.from_little_endian()";
       }
-      code_ += "  }\n";
+      code_ += "}\n";
       // Setter.
       if (IsStruct(field.value.type)) {
         code_.SetValue("FIELD_SIZE", NumToString(InlineSize(field.value.type)));
-        code_ += "  pub fn set_{{FIELD_NAME}}(&mut self, x: &{{FIELD_TYPE}}) {";
+        code_ += "#[allow(clippy::identity_op)]";  // If FIELD_OFFSET=0.
+        code_ += "pub fn set_{{FIELD_NAME}}(&mut self, x: &{{FIELD_TYPE}}) {";
         code_ +=
-            "    self.0[{{FIELD_OFFSET}}..{{FIELD_OFFSET}}+{{FIELD_SIZE}}]"
+            "  self.0[{{FIELD_OFFSET}}..{{FIELD_OFFSET}} + {{FIELD_SIZE}}]"
             ".copy_from_slice(&x.0)";
       } else if (IsArray(field.value.type)) {
         if (GetFullType(field.value.type) == ftArrayOfBuiltin) {
@@ -2601,36 +2838,35 @@
               "ARRAY_ITEM_SIZE",
               NumToString(InlineSize(field.value.type.VectorType())));
           code_ +=
-              "  pub fn set_{{FIELD_NAME}}(&mut self, items: &{{FIELD_TYPE}}) "
+              "pub fn set_{{FIELD_NAME}}(&mut self, items: &{{FIELD_TYPE}}) "
               "{";
           code_ +=
-              "    flatbuffers::emplace_scalar_array(&mut self.0, "
+              "  flatbuffers::emplace_scalar_array(&mut self.0, "
               "{{FIELD_OFFSET}}, items);";
         } else {
           code_.SetValue("FIELD_SIZE",
                          NumToString(InlineSize(field.value.type)));
-          code_ +=
-              "  pub fn set_{{FIELD_NAME}}(&mut self, x: &{{FIELD_TYPE}}) {";
-          code_ += "    unsafe {";
-          code_ += "      std::ptr::copy(";
-          code_ += "        x.as_ptr() as *const u8,";
-          code_ += "        self.0.as_mut_ptr().add({{FIELD_OFFSET}}),";
-          code_ += "        {{FIELD_SIZE}},";
-          code_ += "      );";
-          code_ += "    }";
+          code_ += "pub fn set_{{FIELD_NAME}}(&mut self, x: &{{FIELD_TYPE}}) {";
+          code_ += "  unsafe {";
+          code_ += "    std::ptr::copy(";
+          code_ += "      x.as_ptr() as *const u8,";
+          code_ += "      self.0.as_mut_ptr().add({{FIELD_OFFSET}}),";
+          code_ += "      {{FIELD_SIZE}},";
+          code_ += "    );";
+          code_ += "  }";
         }
       } else {
-        code_ += "  pub fn set_{{FIELD_NAME}}(&mut self, x: {{FIELD_TYPE}}) {";
-        code_ += "    let x_le = x.to_little_endian();";
-        code_ += "    unsafe {";
-        code_ += "      core::ptr::copy_nonoverlapping(";
-        code_ += "        &x_le as *const {{FIELD_TYPE}} as *const u8,";
-        code_ += "        self.0[{{FIELD_OFFSET}}..].as_mut_ptr(),";
-        code_ += "        core::mem::size_of::<{{FIELD_TYPE}}>(),";
-        code_ += "      );";
-        code_ += "    }";
+        code_ += "pub fn set_{{FIELD_NAME}}(&mut self, x: {{FIELD_TYPE}}) {";
+        code_ += "  let x_le = x.to_little_endian();";
+        code_ += "  unsafe {";
+        code_ += "    core::ptr::copy_nonoverlapping(";
+        code_ += "      &x_le as *const {{FIELD_TYPE}} as *const u8,";
+        code_ += "      self.0[{{FIELD_OFFSET}}..].as_mut_ptr(),";
+        code_ += "      core::mem::size_of::<{{FIELD_TYPE}}>(),";
+        code_ += "    );";
+        code_ += "  }";
       }
-      code_ += "  }\n";
+      code_ += "}\n";
 
       // Generate a comparison function for this field if it is a key.
       if (field.key) { GenKeyFieldMethods(field); }
@@ -2645,15 +2881,15 @@
         if (IsArray(field.value.type)) {
           if (GetFullType(field.value.type) == ftArrayOfStruct) {
             code_ +=
-                "      {{FIELD_NAME}}: { let {{FIELD_NAME}} = "
+                "    {{FIELD_NAME}}: { let {{FIELD_NAME}} = "
                 "self.{{FIELD_NAME}}(); flatbuffers::array_init(|i| "
                 "{{FIELD_NAME}}.get(i).unpack()) },";
           } else {
-            code_ += "      {{FIELD_NAME}}: self.{{FIELD_NAME}}().into(),";
+            code_ += "    {{FIELD_NAME}}: self.{{FIELD_NAME}}().into(),";
           }
         } else {
           std::string unpack = IsStruct(field.value.type) ? ".unpack()" : "";
-          code_ += "      {{FIELD_NAME}}: self.{{FIELD_NAME}}()" + unpack + ",";
+          code_ += "    {{FIELD_NAME}}: self.{{FIELD_NAME}}()" + unpack + ",";
         }
       });
       code_ += "    }";
@@ -2670,7 +2906,7 @@
       code_ += "pub struct {{NATIVE_STRUCT_NAME}} {";
       ForAllStructFields(struct_def, [&](const FieldDef &field) {
         (void)field;  // unused.
-        code_ += "  pub {{FIELD_NAME}}: {{FIELD_OBJECT_TYPE}},";
+        code_ += "pub {{FIELD_NAME}}: {{FIELD_OBJECT_TYPE}},";
       });
       code_ += "}";
       // The `pack` method that turns the native struct into its Flatbuffers
@@ -2680,17 +2916,17 @@
       code_ += "    {{STRUCT_NAME}}::new(";
       ForAllStructFields(struct_def, [&](const FieldDef &field) {
         if (IsStruct(field.value.type)) {
-          code_ += "      &self.{{FIELD_NAME}}.pack(),";
+          code_ += "    &self.{{FIELD_NAME}}.pack(),";
         } else if (IsArray(field.value.type)) {
           if (GetFullType(field.value.type) == ftArrayOfStruct) {
             code_ +=
-                "      &flatbuffers::array_init(|i| "
+                "    &flatbuffers::array_init(|i| "
                 "self.{{FIELD_NAME}}[i].pack()),";
           } else {
-            code_ += "      &self.{{FIELD_NAME}},";
+            code_ += "    &self.{{FIELD_NAME}},";
           }
         } else {
-          code_ += "      self.{{FIELD_NAME}},";
+          code_ += "    self.{{FIELD_NAME}},";
         }
       });
       code_ += "    )";
@@ -2728,6 +2964,13 @@
     code_ += indent + "use std::mem;";
     code_ += indent + "use std::cmp::Ordering;";
     code_ += "";
+    if (parser_.opts.rust_serialize) {
+      code_ += indent + "extern crate serde;";
+      code_ +=
+          indent +
+          "use self::serde::ser::{Serialize, Serializer, SerializeStruct};";
+      code_ += "";
+    }
     code_ += indent + "extern crate flatbuffers;";
     code_ += indent + "use self::flatbuffers::{EndianScalar, Follow};";
   }
diff -urN a/src/idl_gen_swift.cpp b/src/idl_gen_swift.cpp
--- a/src/idl_gen_swift.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_swift.cpp	2023-01-13 07:47:08.990253081 +0000
@@ -187,7 +187,9 @@
     code_.SetValue("ACCESS_TYPE", is_private_access ? "internal" : "public");
     GenComment(struct_def.doc_comment);
     code_.SetValue("STRUCTNAME", NameWrappedInNameSpace(struct_def));
-    code_ += "{{ACCESS_TYPE}} struct {{STRUCTNAME}}: NativeStruct\\";
+    code_ +=
+        "{{ACCESS_TYPE}} struct {{STRUCTNAME}}: NativeStruct, Verifiable, "
+        "FlatbuffersInitializable\\";
     if (parser_.opts.generate_object_based_api) code_ += ", NativeObject\\";
     code_ += " {";
     code_ += "";
@@ -218,8 +220,10 @@
           IsEnum(field.value.type) ? "{{BASEVALUE}}" : "{{VALUETYPE}}";
       code_ += "private var _{{VALUENAME}}: " + valueType;
       auto accessing_value = IsEnum(field.value.type) ? ".value" : "";
-      auto base_value =
-          IsStruct(field.value.type) ? (type + "()") : field.value.constant;
+      auto is_bool = IsBool(field.value.type.base_type);
+      auto base_value = IsStruct(field.value.type) ? (type + "()")
+        : is_bool ? ("0" == field.value.constant ? "false" : "true")
+        : field.value.constant;
 
       main_constructor.push_back("_" + name + " = " + name + accessing_value);
       base_constructor.push_back("_" + name + " = " + base_value);
@@ -228,6 +232,7 @@
       constructor += name + ": " + type;
     }
     code_ += "";
+    BuildStructConstructor(struct_def);
     BuildObjectConstructor(main_constructor, constructor);
     BuildObjectConstructor(base_constructor, "");
 
@@ -250,6 +255,45 @@
             GenReaderMainBody() + "{{VALUETYPE}}(rawValue: _{{VALUENAME}})! }";
       }
     }
+    code_ += "";
+    code_ +=
+        "public static func verify<T>(_ verifier: inout Verifier, at position: "
+        "Int, of type: T.Type) throws where T: Verifiable {";
+    Indent();
+    code_ +=
+        "try verifier.inBuffer(position: position, of: {{STRUCTNAME}}.self)";
+    Outdent();
+    code_ += "}";
+    Outdent();
+    code_ += "}\n";
+    if (parser_.opts.gen_json_coders) GenerateJSONEncodingAPIs(struct_def);
+  }
+
+  void BuildStructConstructor(const StructDef &struct_def) {
+    code_ += "{{ACCESS_TYPE}} init(_ bb: ByteBuffer, o: Int32) {";
+    Indent();
+    code_ += "let {{ACCESS}} = Struct(bb: bb, position: o)";
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      auto name = Name(field);
+      auto type = field.value.type;
+      code_.SetValue("VALUENAME", name);
+      code_.SetValue("VALUETYPE", GenType(type));
+      code_.SetValue("OFFSET", NumToString(field.value.offset));
+      if (IsScalar(type.base_type)) {
+        if (IsEnum(type))
+          code_.SetValue("VALUETYPE", GenTypeBasic(field.value.type, false));
+        code_ +=
+            "_{{VALUENAME}} = {{ACCESS}}.readBuffer(of: {{VALUETYPE}}.self, "
+            "at: {{OFFSET}})";
+      } else {
+        code_ +=
+            "_{{VALUENAME}} = {{VALUETYPE}}({{ACCESS}}.bb, o: "
+            "{{ACCESS}}.postion + {{OFFSET}})";
+      }
+    }
     Outdent();
     code_ += "}\n";
   }
@@ -368,15 +412,17 @@
   void GenTable(const StructDef &struct_def) {
     auto is_private_access = struct_def.attributes.Lookup("private");
     code_.SetValue("ACCESS_TYPE", is_private_access ? "internal" : "public");
-
     GenObjectHeader(struct_def);
     GenTableAccessors(struct_def);
     GenTableReader(struct_def);
     GenTableWriter(struct_def);
     if (parser_.opts.generate_object_based_api)
       GenerateObjectAPITableExtension(struct_def);
+    code_ += "";
+    GenerateVerifier(struct_def);
     Outdent();
     code_ += "}\n";
+    if (parser_.opts.gen_json_coders) GenerateJSONEncodingAPIs(struct_def);
   }
 
   // Generates the reader for swift
@@ -410,6 +456,7 @@
     code_.SetValue("MUTABLE", struct_def.fixed ? Mutable() : "");
     code_ +=
         "{{ACCESS_TYPE}} struct {{STRUCTNAME}}{{MUTABLE}}: FlatBufferObject\\";
+    if (!struct_def.fixed) code_ += ", Verifiable\\";
     if (!struct_def.fixed && parser_.opts.generate_object_based_api)
       code_ += ", ObjectAPIPacker\\";
     code_ += " {\n";
@@ -651,8 +698,10 @@
     code_.SetValue("VALUETYPE", type);
     code_.SetValue("OFFSET", name);
     code_.SetValue("CONSTANT", field.value.constant);
-    std::string def_Val = field.IsDefault() ? "{{CONSTANT}}" : "nil";
-    std::string optional = field.IsOptional() ? "?" : "";
+    bool opt_scalar =
+        field.IsOptional() && IsScalar(field.value.type.base_type);
+    std::string def_Val = opt_scalar ? "nil" : "{{CONSTANT}}";
+    std::string optional = opt_scalar ? "?" : "";
     auto const_string = "return o == 0 ? " + def_Val + " : ";
     GenComment(field.doc_comment);
     if (IsScalar(field.value.type.base_type) && !IsEnum(field.value.type) &&
@@ -665,7 +714,8 @@
 
     if (IsBool(field.value.type.base_type)) {
       std::string default_value =
-          "0" == field.value.constant ? "false" : "true";
+          field.IsOptional() ? "nil"
+                             : ("0" == field.value.constant ? "false" : "true");
       code_.SetValue("CONSTANT", default_value);
       code_.SetValue("VALUETYPE", "Bool");
       code_ += GenReaderMainBody(optional) + "\\";
@@ -831,6 +881,272 @@
     }
   }
 
+  void GenerateCodingKeys(const StructDef &struct_def) {
+    code_ += "enum CodingKeys: String, CodingKey {";
+    Indent();
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      auto name = Name(field);
+
+      code_.SetValue("RAWVALUENAME", field.name);
+      code_.SetValue("VALUENAME", name);
+      code_ += "case {{VALUENAME}} = \"{{RAWVALUENAME}}\"";
+    }
+    Outdent();
+    code_ += "}";
+  }
+
+  void GenerateEncoderUnionBody(const FieldDef &field) {
+    EnumDef &union_def = *field.value.type.enum_def;
+    auto is_vector = field.value.type.base_type == BASE_TYPE_VECTOR ||
+                     field.value.type.base_type == BASE_TYPE_ARRAY;
+    if (field.value.type.base_type == BASE_TYPE_UTYPE ||
+        (is_vector &&
+         field.value.type.VectorType().base_type == BASE_TYPE_UTYPE))
+      return;
+    if (is_vector) {
+      code_ +=
+          "var enumsEncoder = container.nestedUnkeyedContainer(forKey: "
+          ".{{VALUENAME}}Type)";
+      code_ +=
+          "var contentEncoder = container.nestedUnkeyedContainer(forKey: "
+          ".{{VALUENAME}})";
+      code_ += "for index in 0..<{{VALUENAME}}Count {";
+      Indent();
+      code_ +=
+          "guard let type = {{VALUENAME}}Type(at: index) else { continue }";
+      code_ += "try enumsEncoder.encode(type)";
+      code_ += "switch type {";
+      for (auto it = union_def.Vals().begin(); it != union_def.Vals().end();
+           ++it) {
+        const auto &ev = **it;
+
+        auto name = Name(ev);
+        auto type = GenType(ev.union_type);
+        code_.SetValue("KEY", name);
+        code_.SetValue("VALUETYPE", type);
+        if (ev.union_type.base_type == BASE_TYPE_NONE) { continue; }
+        code_ += "case .{{KEY}}:";
+        Indent();
+        code_ += "let _v = {{VALUENAME}}(at: index, type: {{VALUETYPE}}.self)";
+        code_ += "try contentEncoder.encode(_v)";
+        Outdent();
+      }
+      code_ += "default: break;";
+      code_ += "}";
+      Outdent();
+      code_ += "}";
+      return;
+    }
+
+    code_ += "switch {{VALUENAME}}Type {";
+    for (auto it = union_def.Vals().begin(); it != union_def.Vals().end();
+         ++it) {
+      const auto &ev = **it;
+
+      auto name = Name(ev);
+      auto type = GenType(ev.union_type);
+      code_.SetValue("KEY", name);
+      code_.SetValue("VALUETYPE", type);
+      if (ev.union_type.base_type == BASE_TYPE_NONE) { continue; }
+      code_ += "case .{{KEY}}:";
+      Indent();
+      code_ += "let _v = {{VALUENAME}}(type: {{VALUETYPE}}.self)";
+      code_ += "try container.encodeIfPresent(_v, forKey: .{{VALUENAME}})";
+      Outdent();
+    }
+    code_ += "default: break;";
+    code_ += "}";
+  }
+
+  void GenerateEncoderBody(const StructDef &struct_def) {
+    code_ += "var container = encoder.container(keyedBy: CodingKeys.self)";
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      auto name = Name(field);
+      auto type = field.value.type;
+
+      auto is_non_union_vector =
+          (field.value.type.base_type == BASE_TYPE_ARRAY ||
+           field.value.type.base_type == BASE_TYPE_VECTOR) &&
+          field.value.type.VectorType().base_type != BASE_TYPE_UTYPE;
+
+      code_.SetValue("RAWVALUENAME", field.name);
+      code_.SetValue("VALUENAME", name);
+      code_.SetValue("CONSTANT", field.value.constant);
+      bool should_indent = true;
+      if (is_non_union_vector) {
+        code_ += "if {{VALUENAME}}Count > 0 {";
+      } else if (IsEnum(type) && !field.IsOptional()) {
+        code_.SetValue("CONSTANT", GenEnumDefaultValue(field));
+        code_ += "if {{VALUENAME}} != {{CONSTANT}} {";
+      } else if (IsScalar(type.base_type) && !IsEnum(type) &&
+                 !IsBool(type.base_type) && !field.IsOptional()) {
+        code_ += "if {{VALUENAME}} != {{CONSTANT}} {";
+      } else if (IsBool(type.base_type) && !field.IsOptional()) {
+        std::string default_value =
+            "0" == field.value.constant ? "false" : "true";
+        code_.SetValue("CONSTANT", default_value);
+        code_ += "if {{VALUENAME}} != {{CONSTANT}} {";
+      } else {
+        should_indent = false;
+      }
+      if (should_indent) Indent();
+
+      if (IsUnion(type) && !IsEnum(type)) {
+        GenerateEncoderUnionBody(field);
+      } else if (is_non_union_vector &&
+                 (!IsScalar(type.VectorType().base_type) ||
+                  IsEnum(type.VectorType()))) {
+        code_ +=
+            "var contentEncoder = container.nestedUnkeyedContainer(forKey: "
+            ".{{VALUENAME}})";
+        code_ += "for index in 0..<{{VALUENAME}}Count {";
+        Indent();
+        code_ += "guard let type = {{VALUENAME}}(at: index) else { continue }";
+        code_ += "try contentEncoder.encode(type)";
+        Outdent();
+        code_ += "}";
+      } else {
+        code_ +=
+            "try container.encodeIfPresent({{VALUENAME}}, forKey: "
+            ".{{VALUENAME}})";
+      }
+      if (should_indent) Outdent();
+
+      if (is_non_union_vector ||
+          (IsScalar(type.base_type) && !field.IsOptional())) {
+        code_ += "}";
+      }
+    }
+  }
+
+  void GenerateJSONEncodingAPIs(const StructDef &struct_def) {
+    code_ += "extension {{STRUCTNAME}}: Encodable {";
+    Indent();
+    code_ += "";
+    if (struct_def.fields.vec.empty() == false) GenerateCodingKeys(struct_def);
+
+    code_ += "public func encode(to encoder: Encoder) throws {";
+    Indent();
+    if (struct_def.fields.vec.empty() == false) GenerateEncoderBody(struct_def);
+    Outdent();
+    code_ += "}";
+    Outdent();
+    code_ += "}";
+    code_ += "";
+  }
+
+  void GenerateVerifier(const StructDef &struct_def) {
+    code_ +=
+        "public static func verify<T>(_ verifier: inout Verifier, at position: "
+        "Int, of type: T.Type) throws where T: Verifiable {";
+    Indent();
+    code_ += "var _v = try verifier.visitTable(at: position)";
+    for (auto it = struct_def.fields.vec.begin();
+         it != struct_def.fields.vec.end(); ++it) {
+      auto &field = **it;
+      if (field.deprecated) continue;
+      auto offset = NumToString(field.value.offset);
+      auto name = Name(field);
+
+      code_.SetValue("VALUENAME", name);
+      code_.SetValue("VALUETYPE", GenerateVerifierType(field));
+      code_.SetValue("OFFSET", name);
+      code_.SetValue("ISREQUIRED", field.IsRequired() ? "true" : "false");
+
+      if (IsUnion(field.value.type)) {
+        GenerateUnionTypeVerifier(field);
+        continue;
+      }
+
+      code_ +=
+          "try _v.visit(field: {{TABLEOFFSET}}.{{OFFSET}}.p, fieldName: "
+          "\"{{VALUENAME}}\", required: {{ISREQUIRED}}, type: "
+          "{{VALUETYPE}}.self)";
+    }
+    code_ += "_v.finish()";
+    Outdent();
+    code_ += "}";
+  }
+
+  void GenerateUnionTypeVerifier(const FieldDef &field) {
+    auto is_vector = IsVector(field.value.type) || IsArray(field.value.type);
+    if (field.value.type.base_type == BASE_TYPE_UTYPE ||
+        (is_vector &&
+         field.value.type.VectorType().base_type == BASE_TYPE_UTYPE))
+      return;
+    EnumDef &union_def = *field.value.type.enum_def;
+    code_.SetValue("VALUETYPE", NameWrappedInNameSpace(union_def));
+    code_.SetValue("FUNCTION_NAME", is_vector ? "visitUnionVector" : "visit");
+    code_ +=
+        "try _v.{{FUNCTION_NAME}}(unionKey: {{TABLEOFFSET}}.{{OFFSET}}Type.p, "
+        "unionField: {{TABLEOFFSET}}.{{OFFSET}}.p, unionKeyName: "
+        "\"{{VALUENAME}}Type\", fieldName: \"{{VALUENAME}}\", required: "
+        "{{ISREQUIRED}}, completion: { (verifier, key: {{VALUETYPE}}, pos) in";
+    Indent();
+    code_ += "switch key {";
+    for (auto it = union_def.Vals().begin(); it != union_def.Vals().end();
+         ++it) {
+      const auto &ev = **it;
+
+      auto name = Name(ev);
+      auto type = GenType(ev.union_type);
+      code_.SetValue("KEY", name);
+      code_.SetValue("VALUETYPE", type);
+      code_ += "case .{{KEY}}:";
+      Indent();
+      if (ev.union_type.base_type == BASE_TYPE_NONE) {
+        code_ += "break // NOTE - SWIFT doesnt support none";
+      } else if (ev.union_type.base_type == BASE_TYPE_STRING) {
+        code_ +=
+            "try ForwardOffset<String>.verify(&verifier, at: pos, of: "
+            "String.self)";
+      } else {
+        code_.SetValue("MAINTYPE", ev.union_type.struct_def->fixed
+                                       ? type
+                                       : "ForwardOffset<" + type + ">");
+        code_ +=
+            "try {{MAINTYPE}}.verify(&verifier, at: pos, of: "
+            "{{VALUETYPE}}.self)";
+      }
+      Outdent();
+    }
+    code_ += "}";
+    Outdent();
+    code_ += "})";
+  }
+
+  std::string GenerateVerifierType(const FieldDef &field) {
+    auto type = field.value.type;
+    auto is_vector = IsVector(type) || IsArray(type);
+
+    if (is_vector) {
+      auto vector_type = field.value.type.VectorType();
+      return "ForwardOffset<Vector<" +
+             GenerateNestedVerifierTypes(vector_type) + ", " +
+             GenType(vector_type) + ">>";
+    }
+
+    return GenerateNestedVerifierTypes(field.value.type);
+  }
+
+  std::string GenerateNestedVerifierTypes(const Type &type) {
+    auto string_type = GenType(type);
+
+    if (IsScalar(type.base_type)) { return string_type; }
+
+    if (IsString(type)) { return "ForwardOffset<" + string_type + ">"; }
+
+    if (type.struct_def && type.struct_def->fixed) { return string_type; }
+
+    return "ForwardOffset<" + string_type + ">";
+  }
+
   void GenByKeyFunctions(const FieldDef &key_field) {
     code_.SetValue("TYPE", GenType(key_field.value.type));
     code_ +=
@@ -844,13 +1160,24 @@
   void GenEnum(const EnumDef &enum_def) {
     if (enum_def.generated) return;
     auto is_private_access = enum_def.attributes.Lookup("private");
+    code_.SetValue("ENUM_TYPE",
+                   enum_def.is_union ? "UnionEnum" : "Enum, Verifiable");
     code_.SetValue("ACCESS_TYPE", is_private_access ? "internal" : "public");
     code_.SetValue("ENUM_NAME", NameWrappedInNameSpace(enum_def));
     code_.SetValue("BASE_TYPE", GenTypeBasic(enum_def.underlying_type, false));
     GenComment(enum_def.doc_comment);
-    code_ += "{{ACCESS_TYPE}} enum {{ENUM_NAME}}: {{BASE_TYPE}}, Enum {";
+    code_ +=
+        "{{ACCESS_TYPE}} enum {{ENUM_NAME}}: {{BASE_TYPE}}, {{ENUM_TYPE}} {";
     Indent();
     code_ += "{{ACCESS_TYPE}} typealias T = {{BASE_TYPE}}";
+    if (enum_def.is_union) {
+      code_ += "";
+      code_ += "{{ACCESS_TYPE}} init?(value: T) {";
+      Indent();
+      code_ += "self.init(rawValue: value)";
+      Outdent();
+      code_ += "}\n";
+    }
     code_ +=
         "{{ACCESS_TYPE}} static var byteSize: Int { return "
         "MemoryLayout<{{BASE_TYPE}}>.size "
@@ -865,11 +1192,13 @@
       GenComment(ev.doc_comment);
       code_ += "case {{KEY}} = {{VALUE}}";
     }
-    code_ += "\n";
+    code_ += "";
     AddMinOrMaxEnumValue(Name(*enum_def.MaxValue()), "max");
     AddMinOrMaxEnumValue(Name(*enum_def.MinValue()), "min");
     Outdent();
     code_ += "}\n";
+    if (parser_.opts.gen_json_coders) EnumEncoder(enum_def);
+    code_ += "";
     if (parser_.opts.generate_object_based_api && enum_def.is_union) {
       code_ += "{{ACCESS_TYPE}} struct {{ENUM_NAME}}Union {";
       Indent();
@@ -894,6 +1223,27 @@
     }
   }
 
+  void EnumEncoder(const EnumDef &enum_def) {
+    code_ += "extension {{ENUM_NAME}}: Encodable {";
+    Indent();
+    code_ += "{{ACCESS_TYPE}} func encode(to encoder: Encoder) throws {";
+    Indent();
+    code_ += "var container = encoder.singleValueContainer()";
+    code_ += "switch self {";
+    for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
+      const auto &ev = **it;
+      auto name = Name(ev);
+      code_.SetValue("KEY", name);
+      code_.SetValue("RAWKEY", ev.name);
+      code_ += "case .{{KEY}}: try container.encode(\"{{RAWKEY}}\")";
+    }
+    code_ += "}";
+    Outdent();
+    code_ += "}";
+    Outdent();
+    code_ += "}";
+  }
+
   // MARK: - Object API
 
   void GenerateObjectAPIExtensionHeader(std::string name) {
diff -urN a/src/idl_gen_text.cpp b/src/idl_gen_text.cpp
--- a/src/idl_gen_text.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_text.cpp	2023-01-13 07:47:08.991253090 +0000
@@ -264,12 +264,18 @@
       FLATBUFFERS_ASSERT(IsStruct(fd.value.type) || IsArray(fd.value.type));
       val = reinterpret_cast<const Struct *>(table)->GetStruct<const void *>(
           fd.value.offset);
-    } else if (fd.flexbuffer) {
+    } else if (fd.flexbuffer && opts.json_nested_flexbuffers) {
+      // We could verify this FlexBuffer before access, but since this sits
+      // inside a FlatBuffer that we don't know wether it has been verified or
+      // not, there is little point making this part safer than the parent..
+      // The caller should really be verifying the whole.
+      // If the whole buffer is corrupt, we likely crash before we even get
+      // here.
       auto vec = table->GetPointer<const Vector<uint8_t> *>(fd.value.offset);
       auto root = flexbuffers::GetRoot(vec->data(), vec->size());
       root.ToString(true, opts.strict_json, text);
       return true;
-    } else if (fd.nested_flatbuffer) {
+    } else if (fd.nested_flatbuffer && opts.json_nested_flatbuffers) {
       auto vec = table->GetPointer<const Vector<uint8_t> *>(fd.value.offset);
       auto root = GetRoot<Table>(vec->data());
       return GenStruct(*fd.nested_flatbuffer, root, indent);
diff -urN a/src/idl_gen_ts.cpp b/src/idl_gen_ts.cpp
--- a/src/idl_gen_ts.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_gen_ts.cpp	2023-01-13 07:47:09.269255658 +0000
@@ -29,7 +29,10 @@
 
 struct ImportDefinition {
   std::string name;
-  std::string statement;
+  std::string import_statement;
+  std::string export_statement;
+  std::string bare_file_path;
+  std::string rel_file_path;
   const Definition *dependent;
   const Definition *dependency;
 };
@@ -45,10 +48,69 @@
 
   TsGenerator(const Parser &parser, const std::string &path,
               const std::string &file_name)
-      : BaseGenerator(parser, path, file_name, "", ".", "ts") {}
+      : BaseGenerator(parser, path, file_name, "", ".", "ts") {
+    // clang-format off
+
+    // List of keywords retrieved from here:
+    // https://github.com/microsoft/TypeScript/issues/2536
+    // One per line to ease comparisons to that list are easier
+    static const char *const keywords[] = {
+      "break",
+      "case",
+      "catch",
+      "class",
+      "const",
+      "continue",
+      "debugger",
+      "default",
+      "delete",
+      "do",
+      "else",
+      "enum",
+      "export",
+      "extends",
+      "false",
+      "finally",
+      "for",
+      "function",
+      "if",
+      "import",
+      "in",
+      "instanceof",
+      "new",
+      "null",
+      "return",
+      "super",
+      "switch",
+      "this",
+      "throw",
+      "true",
+      "try",
+      "typeof",
+      "var",
+      "void",
+      "while",
+      "with",
+      "as",
+      "implements",
+      "interface",
+      "let",
+      "package",
+      "private",
+      "protected",
+      "public",
+      "static",
+      "yield",
+      nullptr,
+      // clang-format on
+    };
+
+    for (auto kw = keywords; *kw; kw++) keywords_.insert(*kw);
+  }
   bool generate() {
     generateEnums();
     generateStructs();
+    generateEntry();
     return true;
   }
 
@@ -62,12 +124,12 @@
         "// " + std::string(FlatBuffersGeneratedWarning()) + "\n\n";
 
     for (auto it = bare_imports.begin(); it != bare_imports.end(); it++)
-      code += it->second.statement + "\n";
+      code += it->second.import_statement + "\n";
     if (!bare_imports.empty()) code += "\n";
 
     for (auto it = imports.begin(); it != imports.end(); it++)
       if (it->second.dependency != &definition)  // do not import itself
-        code += it->second.statement + "\n";
+        code += it->second.import_statement + "\n";
     if (!imports.empty()) code += "\n\n";
 
     code += classcode;
@@ -77,6 +139,14 @@
   }
 
  private:
+  std::unordered_set<std::string> keywords_;
+
+  std::string EscapeKeyword(const std::string &name) const {
+    return keywords_.find(name) == keywords_.end() ? name : name + "_";
+  }
+
+  import_set imports_all_;
+
   // Generate code for all enums.
   void generateEnums() {
     for (auto it = parser_.enums_.vec.begin(); it != parser_.enums_.vec.end();
@@ -88,6 +158,7 @@
       GenEnum(enum_def, &enumcode, imports, false);
       GenEnum(enum_def, &enumcode, imports, true);
       SaveType(enum_def, enumcode, imports, bare_imports);
+      imports_all_.insert(imports.begin(), imports.end());
     }
   }
 
@@ -102,9 +173,19 @@
       std::string declcode;
       GenStruct(parser_, struct_def, &declcode, imports);
       SaveType(struct_def, declcode, imports, bare_imports);
+      imports_all_.insert(imports.begin(), imports.end());
     }
   }
 
+  // Generate code for a single entry point module.
+  void generateEntry() {
+    std::string code;
+    for (auto it = imports_all_.begin(); it != imports_all_.end(); it++)
+      code += it->second.export_statement + "\n";
+    std::string path = "./" + path_ + file_name_ + ".ts";
+    SaveFile(path.c_str(), code, false);
+  }
+
   // Generate a documentation comment, if available.
   static void GenDocComment(const std::vector<std::string> &dc,
                             std::string *code_ptr,
@@ -210,8 +291,7 @@
 
   std::string GenBBAccess() const { return "this.bb!"; }
 
-  std::string GenDefaultValue(const FieldDef &field, const std::string &context,
-                              import_set &imports) {
+  std::string GenDefaultValue(const FieldDef &field, import_set &imports) {
     if (field.IsScalarOptional()) { return "null"; }
 
     const auto &value = field.value;
@@ -238,10 +318,7 @@
 
       case BASE_TYPE_LONG:
       case BASE_TYPE_ULONG: {
-        int64_t constant = StringToInt(value.constant.c_str());
-        std::string createLong = context + ".createLong";
-        return createLong + "(" + NumToString(static_cast<int32_t>(constant)) +
-               ", " + NumToString(static_cast<int32_t>(constant >> 32)) + ")";
+        return "BigInt('" + value.constant + "')";
       }
 
       default: return value.constant;
@@ -266,8 +343,7 @@
     switch (type.base_type) {
       case BASE_TYPE_BOOL: return allowNull ? "boolean|null" : "boolean";
       case BASE_TYPE_LONG:
-      case BASE_TYPE_ULONG:
-        return allowNull ? "flatbuffers.Long|null" : "flatbuffers.Long";
+      case BASE_TYPE_ULONG: return allowNull ? "bigint|null" : "bigint";
       default:
         if (IsScalar(type.base_type)) {
           if (type.enum_def) {
@@ -316,9 +392,9 @@
         GenStructArgs(imports, *field.value.type.struct_def, arguments,
                       nameprefix + field.name + "_");
       } else {
-        *arguments +=
-            ", " + nameprefix + field.name + ": " +
-            GenTypeName(imports, field, field.value.type, true, field.IsOptional());
+        *arguments += ", " + nameprefix + field.name + ": " +
+                      GenTypeName(imports, field, field.value.type, true,
+                                  field.IsOptional());
       }
     }
   }
@@ -465,30 +541,40 @@
       }
     }
     std::string import_statement;
+    std::string export_statement;
     import_statement += "import { ";
+    export_statement += "export { ";
+    std::string symbols_expression;
     if (long_import_name.empty()) {
-      import_statement += import_name;
+      symbols_expression += import_name;
       if (parser_.opts.generate_object_based_api)
-        import_statement += ", " + import_name + "T";
+        symbols_expression += ", " + import_name + "T";
     } else {
-      import_statement += dependency.name + " as " + long_import_name;
+      symbols_expression += dependency.name + " as " + long_import_name;
       if (parser_.opts.generate_object_based_api)
-        import_statement +=
+        symbols_expression +=
             ", " + dependency.name + "T as " + long_import_name + "T";
     }
-    import_statement += " } from '";
-    std::string file_name;
+    import_statement += symbols_expression + " } from '";
+    export_statement += symbols_expression + " } from '";
+    std::string bare_file_path;
+    std::string rel_file_path;
     const auto &dep_comps = dependent.defined_namespace->components;
     for (size_t i = 0; i < dep_comps.size(); i++)
-      file_name += i == 0 ? ".." : (kPathSeparator + std::string(".."));
-    if (dep_comps.size() == 0) file_name += ".";
+      rel_file_path += i == 0 ? ".." : (kPathSeparator + std::string(".."));
+    if (dep_comps.size() == 0) rel_file_path += ".";
     for (auto it = depc_comps.begin(); it != depc_comps.end(); it++)
-      file_name += kPathSeparator + ToDasherizedCase(*it);
-    file_name += kPathSeparator + ToDasherizedCase(dependency.name);
-    import_statement += file_name + "';";
+      bare_file_path += kPathSeparator + ToDasherizedCase(*it);
+    bare_file_path += kPathSeparator + ToDasherizedCase(dependency.name);
+    rel_file_path += bare_file_path;
+    import_statement += rel_file_path + "';";
+    export_statement += "." + bare_file_path + "';";
     ImportDefinition import;
     import.name = long_import_name.empty() ? import_name : long_import_name;
-    import.statement = import_statement;
+    import.bare_file_path = bare_file_path;
+    import.rel_file_path = rel_file_path;
+    import.import_statement = import_statement;
+    import.export_statement = export_statement;
     import.dependency = &dependency;
     import.dependent = &dependent;
     imports.insert(std::make_pair(unique_name, import));
@@ -514,28 +600,38 @@
       }
     }
     std::string import_statement;
+    std::string export_statement;
     import_statement += "import { ";
+    export_statement += "export { ";
+    std::string symbols_expression;
     if (long_import_name.empty())
-      import_statement += import_name;
+      symbols_expression += import_name;
     else
-      import_statement += dependency.name + " as " + long_import_name;
+      symbols_expression += dependency.name + " as " + long_import_name;
     if (dependency.is_union) {
-      import_statement += ", unionTo" + import_name;
-      import_statement += ", unionListTo" + import_name;
+      symbols_expression += ", unionTo" + import_name;
+      symbols_expression += ", unionListTo" + import_name;
     }
-    import_statement += " } from '";
-    std::string file_name;
+    import_statement += symbols_expression + " } from '";
+    export_statement += symbols_expression + " } from '";
+    std::string bare_file_path;
+    std::string rel_file_path;
     const auto &dep_comps = dependent.defined_namespace->components;
     for (size_t i = 0; i < dep_comps.size(); i++)
-      file_name += i == 0 ? ".." : (kPathSeparator + std::string(".."));
-    if (dep_comps.size() == 0) file_name += ".";
+      rel_file_path += i == 0 ? ".." : (kPathSeparator + std::string(".."));
+    if (dep_comps.size() == 0) rel_file_path += ".";
     for (auto it = depc_comps.begin(); it != depc_comps.end(); it++)
-      file_name += kPathSeparator + ToDasherizedCase(*it);
-    file_name += kPathSeparator + ToDasherizedCase(dependency.name);
-    import_statement += file_name + "';";
+      bare_file_path += kPathSeparator + ToDasherizedCase(*it);
+    bare_file_path += kPathSeparator + ToDasherizedCase(dependency.name);
+    rel_file_path += bare_file_path;
+    import_statement += rel_file_path + "';";
+    export_statement += "." + bare_file_path + "';";
     ImportDefinition import;
     import.name = long_import_name.empty() ? import_name : long_import_name;
-    import.statement = import_statement;
+    import.bare_file_path = bare_file_path;
+    import.rel_file_path = rel_file_path;
+    import.import_statement = import_statement;
+    import.export_statement = export_statement;
     import.dependency = &dependency;
     import.dependent = &dependent;
     imports.insert(std::make_pair(unique_name, import));
@@ -546,7 +642,8 @@
                  std::string fileName) {
     ImportDefinition import;
     import.name = import_name;
-    import.statement = "import " + import_name + " from '" + fileName + "';";
+    import.import_statement =
+        "import " + import_name + " from '" + fileName + "';";
     imports.insert(std::make_pair(import_name, import));
   }
 
@@ -809,8 +906,7 @@
       // a string that contains values for things that can be created inline or
       // the variable name from field_offset_decl
       std::string field_offset_val;
-      const auto field_default_val =
-          GenDefaultValue(field, "flatbuffers", imports);
+      const auto field_default_val = GenDefaultValue(field, imports);
 
       // Emit a scalar field
       const auto is_string = IsString(field.value.type);
@@ -1130,7 +1226,7 @@
           if (is_string) { index += ", optionalEncoding"; }
           code += offset_prefix +
                   GenGetter(field.value.type, "(" + index + ")") + " : " +
-                  GenDefaultValue(field, GenBBAccess(), imports);
+                  GenDefaultValue(field, imports);
           code += ";\n";
         }
       }
@@ -1226,7 +1322,7 @@
               code += "false";
             } else if (field.value.type.element == BASE_TYPE_LONG ||
                        field.value.type.element == BASE_TYPE_ULONG) {
-              code += GenBBAccess() + ".createLong(0, 0)";
+              code += "BigInt(0)";
             } else if (IsScalar(field.value.type.element)) {
               if (field.value.type.enum_def) {
                 code += field.value.constant;
@@ -1380,13 +1476,13 @@
           code += "0";
         } else if (HasNullDefault(field)) {
           if (IsLong(field.value.type.base_type)) {
-            code += "builder.createLong(0, 0)";
+            code += "BigInt(0)";
           } else {
             code += "0";
           }
         } else {
           if (field.value.type.base_type == BASE_TYPE_BOOL) { code += "+"; }
-          code += GenDefaultValue(field, "builder", imports);
+          code += GenDefaultValue(field, imports);
         }
         code += ");\n}\n\n";
 
@@ -1543,10 +1639,13 @@
                        allowNull && field.IsOptional());
   }
 
-  static std::string GetArgName(const FieldDef &field) {
+  std::string GetArgName(const FieldDef &field) {
     auto argname = MakeCamel(field.name, false);
-    if (!IsScalar(field.value.type.base_type)) { argname += "Offset"; }
-
+    if (!IsScalar(field.value.type.base_type)) {
+      argname += "Offset";
+    } else {
+      argname = EscapeKeyword(argname);
+    }
     return argname;
   }
 
@@ -1565,8 +1664,6 @@
 
 std::string TSMakeRule(const Parser &parser, const std::string &path,
                        const std::string &file_name) {
-  FLATBUFFERS_ASSERT(parser.opts.lang <= IDLOptions::kMAX);
-
   std::string filebase =
       flatbuffers::StripPath(flatbuffers::StripExtension(file_name));
   ts::TsGenerator generator(parser, path, file_name);
diff -urN a/src/idl_parser.cpp b/src/idl_parser.cpp
--- a/src/idl_parser.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/idl_parser.cpp	2023-01-13 07:47:09.704259675 +0000
@@ -20,6 +20,7 @@
 #include <string>
 #include <utility>
 
+#include "flatbuffers/base.h"
 #include "flatbuffers/idl.h"
 #include "flatbuffers/util.h"
 
@@ -143,7 +144,10 @@
 }
 
 void Parser::Warning(const std::string &msg) {
-  if (!opts.no_warnings) Message("warning: " + msg);
+  if (!opts.no_warnings) {
+    Message("warning: " + msg);
+    has_warning_ = true;  // for opts.warnings_as_errors
+  }
 }
 
 CheckedError Parser::Error(const std::string &msg) {
@@ -158,6 +162,10 @@
                " reached");
 }
 
+const std::string &Parser::GetPooledString(const std::string &s) const {
+  return *(string_cache_.insert(s).first);
+}
+
 class Parser::ParseDepthGuard {
  public:
   explicit ParseDepthGuard(Parser *parser_not_null)
@@ -808,8 +816,7 @@
           "or in structs.");
     if (IsString(type) || IsVector(type)) {
       advanced_features_ |= reflection::DefaultVectorsAndStrings;
-      if (field->value.constant != "0" && field->value.constant != "null" &&
-          !SupportsDefaultVectorsAndStrings()) {
+      if (field->value.constant != "0" && !SupportsDefaultVectorsAndStrings()) {
         return Error(
             "Default values for strings and vectors are not supported in one "
             "of the specified programming languages");
@@ -914,7 +921,7 @@
     }
     if (!SupportsOptionalScalars()) {
       return Error(
-          "Optional scalars are not yet supported in at least one the of "
+          "Optional scalars are not yet supported in at least one of "
           "the specified programming languages.");
     }
   }
@@ -1121,6 +1128,9 @@
       }
       uint8_t enum_idx;
       if (vector_of_union_types) {
+        if (vector_of_union_types->size() <= count)
+          return Error("union types vector smaller than union values vector"
+                       " for: " + field->name);
         enum_idx = vector_of_union_types->Get(count);
       } else {
         ECHECK(atot(constant.c_str(), *this, &enum_idx));
@@ -1623,7 +1633,7 @@
   auto length = array.type.fixed_length;
   uoffset_t count = 0;
   auto err = ParseVectorDelimiters(count, [&](uoffset_t &) -> CheckedError {
-    vector_emplace_back(&stack, Value());
+    stack.emplace_back(Value());
     auto &val = stack.back();
     val.type = type;
     if (IsStruct(type)) {
@@ -1667,7 +1677,13 @@
                                            size_t fieldn,
                                            const StructDef *parent_struct_def) {
   if (token_ == '[') {  // backwards compat for 'legacy' ubyte buffers
-    ECHECK(ParseAnyValue(val, field, fieldn, parent_struct_def, 0));
+    if (opts.json_nested_legacy_flatbuffers) {
+      ECHECK(ParseAnyValue(val, field, fieldn, parent_struct_def, 0));
+    } else {
+      return Error(
+          "cannot parse nested_flatbuffer as bytes unless"
+          " --json-nested-bytes is set");
+    }
   } else {
     auto cursor_at_value_begin = cursor_;
     ECHECK(SkipAnyJsonValue());
@@ -2148,10 +2164,14 @@
   auto &v = vals.vec;
   if (IsUInt64())
     std::sort(v.begin(), v.end(), [](const EnumVal *e1, const EnumVal *e2) {
+      if (e1->GetAsUInt64() == e2->GetAsUInt64()) {
+        return e1->name < e2->name;
+      }
       return e1->GetAsUInt64() < e2->GetAsUInt64();
     });
   else
     std::sort(v.begin(), v.end(), [](const EnumVal *e1, const EnumVal *e2) {
+      if (e1->GetAsInt64() == e2->GetAsInt64()) { return e1->name < e2->name; }
       return e1->GetAsInt64() < e2->GetAsInt64();
     });
 }
@@ -2281,13 +2301,18 @@
   bool user_value;
 };
 
-CheckedError Parser::ParseEnum(const bool is_union, EnumDef **dest) {
+CheckedError Parser::ParseEnum(const bool is_union, EnumDef **dest,
+                               const char *filename) {
   std::vector<std::string> enum_comment = doc_comment_;
   NEXT();
   std::string enum_name = attribute_;
   EXPECT(kTokenIdentifier);
   EnumDef *enum_def;
   ECHECK(StartEnum(enum_name, is_union, &enum_def));
+  if (filename != nullptr && !opts.project_root.empty()) {
+    enum_def->declaration_file =
+        &GetPooledString(RelativeToRootPath(opts.project_root, filename));
+  }
   enum_def->doc_comment = enum_comment;
   if (!is_union && !opts.proto_mode) {
     // Give specialized error message, since this type spec used to
@@ -2407,14 +2432,18 @@
   }
 
   if (dest) *dest = enum_def;
-  types_.Add(current_namespace_->GetFullyQualifiedName(enum_def->name),
-             new Type(BASE_TYPE_UNION, nullptr, enum_def));
+  const auto qualified_name =
+      current_namespace_->GetFullyQualifiedName(enum_def->name);
+  if (types_.Add(qualified_name, new Type(BASE_TYPE_UNION, nullptr, enum_def)))
+    return Error("datatype already exists: " + qualified_name);
   return NoError();
 }
 
 CheckedError Parser::StartStruct(const std::string &name, StructDef **dest) {
   auto &struct_def = *LookupCreateStruct(name, true, true);
-  if (!struct_def.predecl) return Error("datatype already exists: " + name);
+  if (!struct_def.predecl)
+    return Error("datatype already exists: " +
+                 current_namespace_->GetFullyQualifiedName(name));
   struct_def.predecl = false;
   struct_def.name = name;
   struct_def.file = file_being_parsed_;
@@ -2466,8 +2495,7 @@
 }
 
 bool Parser::SupportsAdvancedUnionFeatures() const {
-  return opts.lang_to_generate != 0 &&
-         (opts.lang_to_generate &
+  return (opts.lang_to_generate &
           ~(IDLOptions::kCpp | IDLOptions::kTs | IDLOptions::kPhp |
             IDLOptions::kJava | IDLOptions::kCSharp | IDLOptions::kKotlin |
             IDLOptions::kBinary | IDLOptions::kSwift)) == 0;
@@ -2512,7 +2540,7 @@
   return a_id < b_id;
 }
 
-CheckedError Parser::ParseDecl() {
+CheckedError Parser::ParseDecl(const char *filename) {
   std::vector<std::string> dc = doc_comment_;
   bool fixed = IsIdent("struct");
   if (!fixed && !IsIdent("table")) return Error("declaration expected");
@@ -2523,6 +2551,10 @@
   ECHECK(StartStruct(name, &struct_def));
   struct_def->doc_comment = dc;
   struct_def->fixed = fixed;
+  if (filename && !opts.project_root.empty()) {
+    struct_def->declaration_file =
+        &GetPooledString(RelativeToRootPath(opts.project_root, filename));
+  }
   ECHECK(ParseMetaData(&struct_def->attributes));
   struct_def->sortbysize =
       struct_def->attributes.Lookup("original_order") == nullptr && !fixed;
@@ -2594,12 +2626,15 @@
   ECHECK(CheckClash(fields, struct_def, "_byte_vector", BASE_TYPE_STRING));
   ECHECK(CheckClash(fields, struct_def, "ByteVector", BASE_TYPE_STRING));
   EXPECT('}');
-  types_.Add(current_namespace_->GetFullyQualifiedName(struct_def->name),
-             new Type(BASE_TYPE_STRUCT, struct_def, nullptr));
+  const auto qualified_name =
+      current_namespace_->GetFullyQualifiedName(struct_def->name);
+  if (types_.Add(qualified_name,
+                 new Type(BASE_TYPE_STRUCT, struct_def, nullptr)))
+    return Error("datatype already exists: " + qualified_name);
   return NoError();
 }
 
-CheckedError Parser::ParseService() {
+CheckedError Parser::ParseService(const char *filename) {
   std::vector<std::string> service_comment = doc_comment_;
   NEXT();
   auto service_name = attribute_;
@@ -2609,6 +2644,10 @@
   service_def.file = file_being_parsed_;
   service_def.doc_comment = service_comment;
   service_def.defined_namespace = current_namespace_;
+  if (filename != nullptr && !opts.project_root.empty()) {
+    service_def.declaration_file =
+        &GetPooledString(RelativeToRootPath(opts.project_root, filename));
+  }
   if (services_.Add(current_namespace_->GetFullyQualifiedName(service_name),
                     &service_def))
     return Error("service already exists: " + service_name);
@@ -2724,7 +2763,7 @@
   } else if (IsIdent("enum")) {
     // These are almost the same, just with different terminator:
     EnumDef *enum_def;
-    ECHECK(ParseEnum(false, &enum_def));
+    ECHECK(ParseEnum(false, &enum_def, nullptr));
     if (Is(';')) NEXT();
     // Temp: remove any duplicates, as .fbs files can't handle them.
     enum_def->RemoveDuplicates();
@@ -2747,17 +2786,17 @@
   return NoError();
 }
 
-CheckedError Parser::StartEnum(const std::string &enum_name, bool is_union,
+CheckedError Parser::StartEnum(const std::string &name, bool is_union,
                                EnumDef **dest) {
   auto &enum_def = *new EnumDef();
-  enum_def.name = enum_name;
+  enum_def.name = name;
   enum_def.file = file_being_parsed_;
   enum_def.doc_comment = doc_comment_;
   enum_def.is_union = is_union;
   enum_def.defined_namespace = current_namespace_;
-  if (enums_.Add(current_namespace_->GetFullyQualifiedName(enum_name),
-                 &enum_def))
-    return Error("enum already exists: " + enum_name);
+  const auto qualified_name = current_namespace_->GetFullyQualifiedName(name);
+  if (enums_.Add(qualified_name, &enum_def))
+    return Error("enum already exists: " + qualified_name);
   enum_def.underlying_type.base_type =
       is_union ? BASE_TYPE_UTYPE : BASE_TYPE_INT;
   enum_def.underlying_type.enum_def = &enum_def;
@@ -3232,7 +3271,7 @@
       for (auto val_it = enum_def.Vals().begin();
            val_it != enum_def.Vals().end(); ++val_it) {
         auto &val = **val_it;
-        if (!SupportsAdvancedUnionFeatures() &&
+        if (!(opts.lang_to_generate != 0 && SupportsAdvancedUnionFeatures()) &&
             (IsStruct(val.union_type) || IsString(val.union_type)))
           return Error(
               "only tables can be union elements in the generated language: " +
@@ -3296,7 +3335,7 @@
       ECHECK(ParseProtoDecl());
     } else if (IsIdent("native_include")) {
       NEXT();
-      vector_emplace_back(&native_included_files_, attribute_);
+      native_included_files_.emplace_back(attribute_);
       EXPECT(kTokenStringConstant);
       EXPECT(';');
     } else if (IsIdent("include") || (opts.proto_mode && IsIdent("import"))) {
@@ -3364,9 +3403,9 @@
     } else if (token_ == '{') {
       return NoError();
     } else if (IsIdent("enum")) {
-      ECHECK(ParseEnum(false, nullptr));
+      ECHECK(ParseEnum(false, nullptr, source_filename));
     } else if (IsIdent("union")) {
-      ECHECK(ParseEnum(true, nullptr));
+      ECHECK(ParseEnum(true, nullptr, source_filename));
     } else if (IsIdent("root_type")) {
       NEXT();
       auto root_type = attribute_;
@@ -3382,9 +3421,9 @@
       NEXT();
       file_identifier_ = attribute_;
       EXPECT(kTokenStringConstant);
-      if (file_identifier_.length() != FlatBufferBuilder::kFileIdentifierLength)
+      if (file_identifier_.length() != flatbuffers::kFileIdentifierLength)
         return Error("file_identifier must be exactly " +
-                     NumToString(FlatBufferBuilder::kFileIdentifierLength) +
+                     NumToString(flatbuffers::kFileIdentifierLength) +
                      " characters");
       EXPECT(';');
     } else if (IsIdent("file_extension")) {
@@ -3405,11 +3444,14 @@
       EXPECT(';');
       known_attributes_[name] = false;
     } else if (IsIdent("rpc_service")) {
-      ECHECK(ParseService());
+      ECHECK(ParseService(source_filename));
     } else {
-      ECHECK(ParseDecl());
+      ECHECK(ParseDecl(source_filename));
     }
   }
+  if (opts.warnings_as_errors && has_warning_) {
+    return Error("treating warnings as errors, failed due to above warnings");
+  }
   return NoError();
 }
 
@@ -3484,32 +3526,63 @@
   AssignIndices(structs_.vec);
   AssignIndices(enums_.vec);
   std::vector<Offset<reflection::Object>> object_offsets;
+  std::set<std::string> files;
   for (auto it = structs_.vec.begin(); it != structs_.vec.end(); ++it) {
     auto offset = (*it)->Serialize(&builder_, *this);
     object_offsets.push_back(offset);
     (*it)->serialized_location = offset.o;
+    const std::string *file = (*it)->declaration_file;
+    if (file) files.insert(*file);
   }
   std::vector<Offset<reflection::Enum>> enum_offsets;
   for (auto it = enums_.vec.begin(); it != enums_.vec.end(); ++it) {
     auto offset = (*it)->Serialize(&builder_, *this);
     enum_offsets.push_back(offset);
-    (*it)->serialized_location = offset.o;
+    const std::string *file = (*it)->declaration_file;
+    if (file) files.insert(*file);
   }
   std::vector<Offset<reflection::Service>> service_offsets;
   for (auto it = services_.vec.begin(); it != services_.vec.end(); ++it) {
     auto offset = (*it)->Serialize(&builder_, *this);
     service_offsets.push_back(offset);
-    (*it)->serialized_location = offset.o;
+    const std::string *file = (*it)->declaration_file;
+    if (file) files.insert(*file);
   }
-  auto objs__ = builder_.CreateVectorOfSortedTables(&object_offsets);
-  auto enum__ = builder_.CreateVectorOfSortedTables(&enum_offsets);
-  auto fiid__ = builder_.CreateString(file_identifier_);
-  auto fext__ = builder_.CreateString(file_extension_);
-  auto serv__ = builder_.CreateVectorOfSortedTables(&service_offsets);
-  auto schema_offset = reflection::CreateSchema(
+
+  // Create Schemafiles vector of tables.
+  flatbuffers::Offset<
+      flatbuffers::Vector<flatbuffers::Offset<reflection::SchemaFile>>>
+      schema_files__;
+  if (!opts.project_root.empty()) {
+    std::vector<Offset<reflection::SchemaFile>> schema_files;
+    std::vector<Offset<flatbuffers::String>> included_files;
+    for (auto f = files_included_per_file_.begin();
+         f != files_included_per_file_.end(); f++) {
+      const auto filename__ = builder_.CreateSharedString(
+          RelativeToRootPath(opts.project_root, f->first));
+      for (auto i = f->second.begin(); i != f->second.end(); i++) {
+        included_files.push_back(builder_.CreateSharedString(
+            RelativeToRootPath(opts.project_root, *i)));
+      }
+      const auto included_files__ = builder_.CreateVector(included_files);
+      included_files.clear();
+
+      schema_files.push_back(
+          reflection::CreateSchemaFile(builder_, filename__, included_files__));
+    }
+    schema_files__ = builder_.CreateVectorOfSortedTables(&schema_files);
+  }
+
+  const auto objs__ = builder_.CreateVectorOfSortedTables(&object_offsets);
+  const auto enum__ = builder_.CreateVectorOfSortedTables(&enum_offsets);
+  const auto fiid__ = builder_.CreateString(file_identifier_);
+  const auto fext__ = builder_.CreateString(file_extension_);
+  const auto serv__ = builder_.CreateVectorOfSortedTables(&service_offsets);
+  const auto schema_offset = reflection::CreateSchema(
       builder_, objs__, enum__, fiid__, fext__,
       (root_struct_def_ ? root_struct_def_->serialized_location : 0), serv__,
-      static_cast<reflection::AdvancedFeatures>(advanced_features_));
+      static_cast<reflection::AdvancedFeatures>(advanced_features_),
+      schema_files__);
   if (opts.size_prefixed) {
     builder_.FinishSizePrefixed(schema_offset, reflection::SchemaIdentifier());
   } else {
@@ -3550,16 +3623,18 @@
     field_offsets.push_back((*it)->Serialize(
         builder, static_cast<uint16_t>(it - fields.vec.begin()), parser));
   }
-  auto qualified_name = defined_namespace->GetFullyQualifiedName(name);
-  auto name__ = builder->CreateString(qualified_name);
-  auto flds__ = builder->CreateVectorOfSortedTables(&field_offsets);
-  auto attr__ = SerializeAttributes(builder, parser);
-  auto docs__ = parser.opts.binary_schema_comments
-                    ? builder->CreateVectorOfStrings(doc_comment)
-                    : 0;
-  return reflection::CreateObject(*builder, name__, flds__, fixed,
-                                  static_cast<int>(minalign),
-                                  static_cast<int>(bytesize), attr__, docs__);
+  const auto qualified_name = defined_namespace->GetFullyQualifiedName(name);
+  const auto name__ = builder->CreateString(qualified_name);
+  const auto flds__ = builder->CreateVectorOfSortedTables(&field_offsets);
+  const auto attr__ = SerializeAttributes(builder, parser);
+  const auto docs__ = parser.opts.binary_schema_comments
+                          ? builder->CreateVectorOfStrings(doc_comment)
+                          : 0;
+  std::string decl_file_in_project = declaration_file ? *declaration_file : "";
+  const auto file__ = builder->CreateSharedString(decl_file_in_project);
+  return reflection::CreateObject(
+      *builder, name__, flds__, fixed, static_cast<int>(minalign),
+      static_cast<int>(bytesize), attr__, docs__, file__);
 }
 
 bool StructDef::Deserialize(Parser &parser, const reflection::Object *object) {
@@ -3613,7 +3688,7 @@
       IsInteger(value.type.base_type) ? StringToInt(value.constant.c_str()) : 0,
       // result may be platform-dependent if underlying is float (not double)
       IsFloat(value.type.base_type) ? d : 0.0, deprecated, IsRequired(), key,
-      attr__, docs__, IsOptional());
+      attr__, docs__, IsOptional(), static_cast<uint16_t>(padding));
   // TODO: value.constant is almost always "0", we could save quite a bit of
   // space by sharing it. Same for common values of value.type.
 }
@@ -3629,6 +3704,7 @@
     value.constant = FloatToString(field->default_real(), 16);
   }
   presence = FieldDef::MakeFieldPresence(field->optional(), field->required());
+  padding = field->padding();
   key = field->key();
   if (!DeserializeAttributes(parser, field->attributes())) return false;
   // TODO: this should probably be handled by a separate attribute
@@ -3678,14 +3754,17 @@
   for (auto it = calls.vec.begin(); it != calls.vec.end(); ++it) {
     servicecall_offsets.push_back((*it)->Serialize(builder, parser));
   }
-  auto qualified_name = defined_namespace->GetFullyQualifiedName(name);
-  auto name__ = builder->CreateString(qualified_name);
-  auto call__ = builder->CreateVector(servicecall_offsets);
-  auto attr__ = SerializeAttributes(builder, parser);
-  auto docs__ = parser.opts.binary_schema_comments
-                    ? builder->CreateVectorOfStrings(doc_comment)
-                    : 0;
-  return reflection::CreateService(*builder, name__, call__, attr__, docs__);
+  const auto qualified_name = defined_namespace->GetFullyQualifiedName(name);
+  const auto name__ = builder->CreateString(qualified_name);
+  const auto call__ = builder->CreateVector(servicecall_offsets);
+  const auto attr__ = SerializeAttributes(builder, parser);
+  const auto docs__ = parser.opts.binary_schema_comments
+                          ? builder->CreateVectorOfStrings(doc_comment)
+                          : 0;
+  std::string decl_file_in_project = declaration_file ? *declaration_file : "";
+  const auto file__ = builder->CreateSharedString(decl_file_in_project);
+  return reflection::CreateService(*builder, name__, call__, attr__, docs__,
+                                   file__);
 }
 
 bool ServiceDef::Deserialize(Parser &parser,
@@ -3712,16 +3791,18 @@
   for (auto it = vals.vec.begin(); it != vals.vec.end(); ++it) {
     enumval_offsets.push_back((*it)->Serialize(builder, parser));
   }
-  auto qualified_name = defined_namespace->GetFullyQualifiedName(name);
-  auto name__ = builder->CreateString(qualified_name);
-  auto vals__ = builder->CreateVector(enumval_offsets);
-  auto type__ = underlying_type.Serialize(builder);
-  auto attr__ = SerializeAttributes(builder, parser);
-  auto docs__ = parser.opts.binary_schema_comments
-                    ? builder->CreateVectorOfStrings(doc_comment)
-                    : 0;
+  const auto qualified_name = defined_namespace->GetFullyQualifiedName(name);
+  const auto name__ = builder->CreateString(qualified_name);
+  const auto vals__ = builder->CreateVector(enumval_offsets);
+  const auto type__ = underlying_type.Serialize(builder);
+  const auto attr__ = SerializeAttributes(builder, parser);
+  const auto docs__ = parser.opts.binary_schema_comments
+                          ? builder->CreateVectorOfStrings(doc_comment)
+                          : 0;
+  std::string decl_file_in_project = declaration_file ? *declaration_file : "";
+  const auto file__ = builder->CreateSharedString(decl_file_in_project);
   return reflection::CreateEnum(*builder, name__, vals__, is_union, type__,
-                                attr__, docs__);
+                                attr__, docs__, file__);
 }
 
 bool EnumDef::Deserialize(Parser &parser, const reflection::Enum *_enum) {
@@ -3750,10 +3831,7 @@
   auto docs__ = parser.opts.binary_schema_comments
                     ? builder->CreateVectorOfStrings(doc_comment)
                     : 0;
-  return reflection::CreateEnumVal(
-      *builder, name__, value,
-      union_type.struct_def ? union_type.struct_def->serialized_location : 0,
-      type__, docs__);
+  return reflection::CreateEnumVal(*builder, name__, value, type__, docs__);
 }
 
 bool EnumVal::Deserialize(const Parser &parser,
@@ -3770,7 +3848,8 @@
       *builder, static_cast<reflection::BaseType>(base_type),
       static_cast<reflection::BaseType>(element),
       struct_def ? struct_def->index : (enum_def ? enum_def->index : -1),
-      fixed_length);
+      fixed_length, static_cast<uint32_t>(SizeOf(base_type)),
+      static_cast<uint32_t>(SizeOf(element)));
 }
 
 bool Type::Deserialize(const Parser &parser, const reflection::Type *type) {
@@ -3927,6 +4006,16 @@
     }
   }
   advanced_features_ = schema->advanced_features();
+
+  if (schema->fbs_files())
+    for (auto s = schema->fbs_files()->begin(); s != schema->fbs_files()->end();
+         ++s) {
+      for (auto f = s->included_filenames()->begin();
+           f != s->included_filenames()->end(); ++f) {
+        files_included_per_file_[s->filename()->str()].insert(f->str());
+      }
+    }
+
   return true;
 }
 
diff -urN a/src/reflection.cpp b/src/reflection.cpp
--- a/src/reflection.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/reflection.cpp	2023-01-13 07:47:09.831260848 +0000
@@ -23,7 +23,7 @@
 namespace flatbuffers {
 
 int64_t GetAnyValueI(reflection::BaseType type, const uint8_t *data) {
-// clang-format off
+  // clang-format off
   #define FLATBUFFERS_GET(T) static_cast<int64_t>(ReadScalar<T>(data))
   switch (type) {
     case reflection::UType:
@@ -121,7 +121,7 @@
 }
 
 void SetAnyValueI(reflection::BaseType type, uint8_t *data, int64_t val) {
-// clang-format off
+  // clang-format off
   #define FLATBUFFERS_SET(T) WriteScalar(data, static_cast<T>(val))
   switch (type) {
     case reflection::UType:
@@ -180,7 +180,7 @@
                 std::vector<uint8_t> *flatbuf,
                 const reflection::Object *root_table = nullptr)
       : schema_(schema),
-        startptr_(vector_data(*flatbuf) + start),
+        startptr_(flatbuf->data() + start),
         delta_(delta),
         buf_(*flatbuf),
         dag_check_(flatbuf->size() / sizeof(uoffset_t), false) {
@@ -188,8 +188,8 @@
     delta_ = (delta_ + mask) & ~mask;
     if (!delta_) return;  // We can't shrink by less than largest_scalar_t.
     // Now change all the offsets by delta_.
-    auto root = GetAnyRoot(vector_data(buf_));
-    Straddle<uoffset_t, 1>(vector_data(buf_), root, vector_data(buf_));
+    auto root = GetAnyRoot(buf_.data());
+    Straddle<uoffset_t, 1>(buf_.data(), root, buf_.data());
     ResizeTable(root_table ? *root_table : *schema.root_table(), root);
     // We can now add or remove bytes at start.
     if (delta_ > 0)
@@ -217,7 +217,7 @@
   // will straddle and which won't.
   uint8_t &DagCheck(const void *offsetloc) {
     auto dag_idx = reinterpret_cast<const uoffset_t *>(offsetloc) -
-                   reinterpret_cast<const uoffset_t *>(vector_data(buf_));
+                   reinterpret_cast<const uoffset_t *>(buf_.data());
     return dag_check_[dag_idx];
   }
 
@@ -309,19 +309,19 @@
                const reflection::Object *root_table) {
   auto delta = static_cast<int>(val.size()) - static_cast<int>(str->size());
   auto str_start = static_cast<uoffset_t>(
-      reinterpret_cast<const uint8_t *>(str) - vector_data(*flatbuf));
+      reinterpret_cast<const uint8_t *>(str) - flatbuf->data());
   auto start = str_start + static_cast<uoffset_t>(sizeof(uoffset_t));
   if (delta) {
     // Clear the old string, since we don't want parts of it remaining.
-    memset(vector_data(*flatbuf) + start, 0, str->size());
+    memset(flatbuf->data() + start, 0, str->size());
     // Different size, we must expand (or contract).
     ResizeContext(schema, start, delta, flatbuf, root_table);
     // Set the new length.
-    WriteScalar(vector_data(*flatbuf) + str_start,
+    WriteScalar(flatbuf->data() + str_start,
                 static_cast<uoffset_t>(val.size()));
   }
   // Copy new data. Safe because we created the right amount of space.
-  memcpy(vector_data(*flatbuf) + start, val.c_str(), val.size() + 1);
+  memcpy(flatbuf->data() + start, val.c_str(), val.size() + 1);
 }
 
 uint8_t *ResizeAnyVector(const reflection::Schema &schema, uoffset_t newsize,
@@ -330,25 +330,26 @@
                          const reflection::Object *root_table) {
   auto delta_elem = static_cast<int>(newsize) - static_cast<int>(num_elems);
   auto delta_bytes = delta_elem * static_cast<int>(elem_size);
-  auto vec_start =
-      reinterpret_cast<const uint8_t *>(vec) - vector_data(*flatbuf);
-  auto start = static_cast<uoffset_t>(vec_start + sizeof(uoffset_t) +
-                                      elem_size * num_elems);
+  auto vec_start = reinterpret_cast<const uint8_t *>(vec) - flatbuf->data();
+  auto start = static_cast<uoffset_t>(vec_start) +
+               static_cast<uoffset_t>(sizeof(uoffset_t)) +
+               elem_size * num_elems;
   if (delta_bytes) {
     if (delta_elem < 0) {
       // Clear elements we're throwing away, since some might remain in the
       // buffer.
       auto size_clear = -delta_elem * elem_size;
-      memset(vector_data(*flatbuf) + start - size_clear, 0, size_clear);
+      memset(flatbuf->data() + start - size_clear, 0, size_clear);
     }
     ResizeContext(schema, start, delta_bytes, flatbuf, root_table);
-    WriteScalar(vector_data(*flatbuf) + vec_start, newsize);  // Length field.
+    WriteScalar(flatbuf->data() + vec_start, newsize);  // Length field.
     // Set new elements to 0.. this can be overwritten by the caller.
     if (delta_elem > 0) {
-      memset(vector_data(*flatbuf) + start, 0, delta_elem * elem_size);
+      memset(flatbuf->data() + start, 0,
+             static_cast<size_t>(delta_elem) * elem_size);
     }
   }
-  return vector_data(*flatbuf) + start;
+  return flatbuf->data() + start;
 }
 
 const uint8_t *AddFlatBuffer(std::vector<uint8_t> &flatbuf,
@@ -363,7 +364,7 @@
   // Insert the entire FlatBuffer minus the root pointer.
   flatbuf.insert(flatbuf.end(), newbuf + sizeof(uoffset_t), newbuf + newlen);
   auto root_offset = ReadScalar<uoffset_t>(newbuf) - sizeof(uoffset_t);
-  return vector_data(flatbuf) + insertion_point + root_offset;
+  return flatbuf.data() + insertion_point + root_offset;
 }
 
 void CopyInline(FlatBufferBuilder &fbb, const reflection::Field &fielddef,
@@ -504,8 +505,9 @@
   auto offset = parent_table.GetOptionalFieldOffset(field_offset);
   if (required && !offset) { return false; }
 
-  return !offset || v.Verify(reinterpret_cast<const uint8_t *>(&parent_table),
-                             offset, obj.bytesize());
+  return !offset ||
+         v.VerifyFieldStruct(reinterpret_cast<const uint8_t *>(&parent_table),
+                             offset, obj.bytesize(), obj.minalign());
 }
 
 bool VerifyVectorOfStructs(flatbuffers::Verifier &v,
@@ -552,7 +554,8 @@
                   const flatbuffers::Table &table,
                   const reflection::Field &vec_field) {
   FLATBUFFERS_ASSERT(vec_field.type()->base_type() == reflection::Vector);
-  if (!table.VerifyField<uoffset_t>(v, vec_field.offset())) return false;
+  if (!table.VerifyField<uoffset_t>(v, vec_field.offset(), sizeof(uoffset_t)))
+    return false;
 
   switch (vec_field.type()->element()) {
     case reflection::UType:
@@ -635,33 +638,45 @@
     switch (field_def->type()->base_type()) {
       case reflection::None: FLATBUFFERS_ASSERT(false); break;
       case reflection::UType:
-        if (!table->VerifyField<uint8_t>(v, field_def->offset())) return false;
+        if (!table->VerifyField<uint8_t>(v, field_def->offset(),
+                                         sizeof(uint8_t)))
+          return false;
         break;
       case reflection::Bool:
       case reflection::Byte:
       case reflection::UByte:
-        if (!table->VerifyField<int8_t>(v, field_def->offset())) return false;
+        if (!table->VerifyField<int8_t>(v, field_def->offset(), sizeof(int8_t)))
+          return false;
         break;
       case reflection::Short:
       case reflection::UShort:
-        if (!table->VerifyField<int16_t>(v, field_def->offset())) return false;
+        if (!table->VerifyField<int16_t>(v, field_def->offset(),
+                                         sizeof(int16_t)))
+          return false;
         break;
       case reflection::Int:
       case reflection::UInt:
-        if (!table->VerifyField<int32_t>(v, field_def->offset())) return false;
+        if (!table->VerifyField<int32_t>(v, field_def->offset(),
+                                         sizeof(int32_t)))
+          return false;
         break;
       case reflection::Long:
       case reflection::ULong:
-        if (!table->VerifyField<int64_t>(v, field_def->offset())) return false;
+        if (!table->VerifyField<int64_t>(v, field_def->offset(),
+                                         sizeof(int64_t)))
+          return false;
         break;
       case reflection::Float:
-        if (!table->VerifyField<float>(v, field_def->offset())) return false;
+        if (!table->VerifyField<float>(v, field_def->offset(), sizeof(float)))
+          return false;
         break;
       case reflection::Double:
-        if (!table->VerifyField<double>(v, field_def->offset())) return false;
+        if (!table->VerifyField<double>(v, field_def->offset(), sizeof(double)))
+          return false;
         break;
       case reflection::String:
-        if (!table->VerifyField<uoffset_t>(v, field_def->offset()) ||
+        if (!table->VerifyField<uoffset_t>(v, field_def->offset(),
+                                           sizeof(uoffset_t)) ||
             !v.VerifyString(flatbuffers::GetFieldS(*table, *field_def))) {
           return false;
         }
diff -urN a/src/util.cpp b/src/util.cpp
--- a/src/util.cpp	2021-05-10 18:45:16.000000000 +0000
+++ b/src/util.cpp	2023-01-13 07:47:09.939261845 +0000
@@ -40,14 +40,16 @@
 #endif
 // clang-format on
 
-#include "flatbuffers/base.h"
 #include "flatbuffers/util.h"
 
 #include <sys/stat.h>
+
 #include <clocale>
 #include <cstdlib>
 #include <fstream>
 
+#include "flatbuffers/base.h"
+
 namespace flatbuffers {
 
 bool FileExistsRaw(const char *name) {
@@ -156,7 +158,7 @@
                                const std::string &filename) {
   std::string filepath = path;
   if (filepath.length()) {
-    char &filepath_last_character = string_back(filepath);
+    char &filepath_last_character = filepath.back();
     if (filepath_last_character == kPathSeparatorWindows) {
       filepath_last_character = kPathSeparator;
     } else if (filepath_last_character != kPathSeparator) {
@@ -176,6 +178,9 @@
   std::replace(p.begin(), p.end(), '\\', '/');
   return p;
 }
+std::string PosixPath(const std::string &path) {
+  return PosixPath(path.c_str());
+}
 
 void EnsureDirExists(const std::string &filepath) {
   auto parent = StripFileName(filepath);
@@ -215,6 +220,36 @@
   // clang-format on
 }
 
+std::string RelativeToRootPath(const std::string &project,
+                               const std::string &filepath) {
+  std::string absolute_project = PosixPath(AbsolutePath(project));
+  if (absolute_project.back() != '/') absolute_project += "/";
+  std::string absolute_filepath = PosixPath(AbsolutePath(filepath));
+
+  // Find the first character where they disagree.
+  // The previous directory is the lowest common ancestor;
+  const char *a = absolute_project.c_str();
+  const char *b = absolute_filepath.c_str();
+  size_t common_prefix_len = 0;
+  while (*a != '\0' && *b != '\0' && *a == *b) {
+    if (*a == '/') common_prefix_len = a - absolute_project.c_str();
+    a++;
+    b++;
+  }
+  // the number of ../ to prepend to b depends on the number of remaining
+  // directories in A.
+  const char *suffix = absolute_project.c_str() + common_prefix_len;
+  size_t num_up = 0;
+  while (*suffix != '\0')
+    if (*suffix++ == '/') num_up++;
+  num_up--;  // last one is known to be '/'.
+  std::string result = "//";
+  for (size_t i = 0; i < num_up; i++) result += "../";
+  result += absolute_filepath.substr(common_prefix_len + 1);
+
+  return result;
+}
+
 // Locale-independent code.
 #if defined(FLATBUFFERS_LOCALE_INDEPENDENT) && \
     (FLATBUFFERS_LOCALE_INDEPENDENT > 0)
@@ -238,8 +273,7 @@
 
 std::string RemoveStringQuotes(const std::string &s) {
   auto ch = *s.c_str();
-  return ((s.size() >= 2) && (ch == '\"' || ch == '\'') &&
-          (ch == string_back(s)))
+  return ((s.size() >= 2) && (ch == '\"' || ch == '\'') && (ch == s.back()))
              ? s.substr(1, s.length() - 2)
              : s;
 }
diff -urN a/swift/FlatBuffers.podspec b/swift/FlatBuffers.podspec
--- a/swift/FlatBuffers.podspec	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/FlatBuffers.podspec	2023-01-13 07:47:12.800288267 +0000
@@ -1,6 +1,6 @@
 Pod::Spec.new do |s|
   s.name             = 'FlatBuffers'
-  s.version          = '1.0.0'
+  s.version          = '2.0.0'
   s.summary          = 'FlatBuffers: Memory Efficient Serialization Library'
 
   s.description      = "FlatBuffers is a cross platform serialization library architected for
diff -urN a/swift/Package.swift b/swift/Package.swift
--- a/swift/Package.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Package.swift	2023-01-13 07:47:12.847288701 +0000
@@ -31,5 +31,6 @@
   targets: [
     .target(
       name: "FlatBuffers",
-      dependencies: []),
+      dependencies: [],
+      exclude: ["Documentation.docc/Resources/code/swift"]),
   ])
diff -urN a/swift/Package@swift-5.5.swift b/swift/Package@swift-5.5.swift
--- a/swift/Package@swift-5.5.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Package@swift-5.5.swift	2023-01-13 07:47:12.848288710 +0000
@@ -0,0 +1,36 @@
+// swift-tools-version:5.5
+/*
+ * Copyright 2020 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import PackageDescription
+
+let package = Package(
+  name: "FlatBuffers",
+  platforms: [
+    .iOS(.v11),
+    .macOS(.v10_14),
+  ],
+  products: [
+    .library(
+      name: "FlatBuffers",
+      targets: ["FlatBuffers"]),
+  ],
+  targets: [
+    .target(
+      name: "FlatBuffers",
+      dependencies: []),
+  ])
+
diff -urN a/swift/README.md b/swift/README.md
--- a/swift/README.md	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/README.md	2023-01-13 07:47:12.848288710 +0000
@@ -10,8 +10,6 @@
 
 1- To report any error please use the main repository.
 
-2- `1.0.0` deprecates `MyGame_Example_Vec3.createVec3(builder: &fbb, x: 10, test2: .blue)` for `MyGame_Example_Vec3(x: 10, test2: .blue)`. This uses Swift native structs instead of workarounds that which leads to a huge performance increase when serializing structs. You can download the [binary here](https://github.com/google/flatbuffers/actions) and select the latest push to master
-
 ### Contribute
 
 1- Always run `swift test --generate-linuxmain` whenever new test functions are added or removed
\ No newline at end of file
diff -urN a/swift/Sources/FlatBuffers/ByteBuffer.swift b/swift/Sources/FlatBuffers/ByteBuffer.swift
--- a/swift/Sources/FlatBuffers/ByteBuffer.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/ByteBuffer.swift	2023-01-13 07:47:12.848288710 +0000
@@ -16,6 +16,9 @@
 
 import Foundation
 
+/// `ByteBuffer` is the interface that stores the data for a `Flatbuffers` object
+/// it allows users to write and read data directly from memory thus the use of its
+/// functions should be used
 @frozen
 public struct ByteBuffer {
 
@@ -32,7 +35,9 @@
 
     @usableFromInline
     init(count: Int, alignment: Int) {
-      memory = UnsafeMutableRawPointer.allocate(byteCount: count, alignment: alignment)
+      memory = UnsafeMutableRawPointer.allocate(
+        byteCount: count,
+        alignment: alignment)
       capacity = count
       unowned = false
     }
@@ -69,7 +74,7 @@
     /// Reallocates the buffer incase the object to be written doesnt fit in the current buffer
     /// - Parameter size: Size of the current object
     @usableFromInline
-    internal func reallocate(_ size: Int, writerSize: Int, alignment: Int) {
+    func reallocate(_ size: Int, writerSize: Int, alignment: Int) {
       let currentWritingIndex = capacity &- writerSize
       while capacity <= writerSize &+ size {
         capacity = capacity << 1
@@ -78,7 +83,9 @@
       /// solution take from Apple-NIO
       capacity = capacity.convertToPowerofTwo
 
-      let newData = UnsafeMutableRawPointer.allocate(byteCount: capacity, alignment: alignment)
+      let newData = UnsafeMutableRawPointer.allocate(
+        byteCount: capacity,
+        alignment: alignment)
       memset(newData, 0, capacity &- writerSize)
       memcpy(
         newData.advanced(by: capacity &- writerSize),
@@ -94,9 +101,9 @@
   /// The size of the elements written to the buffer + their paddings
   private var _writerSize: Int = 0
   /// Aliginment of the current  memory being written to the buffer
-  internal var alignment = 1
+  var alignment = 1
   /// Current Index which is being used to write to the buffer, it is written from the end to the start of the buffer
-  internal var writerIndex: Int { _storage.capacity &- _writerSize }
+  var writerIndex: Int { _storage.capacity &- _writerSize }
 
   /// Reader is the position of the current Writer Index (capacity - size)
   public var reader: Int { writerIndex }
@@ -157,7 +164,10 @@
   /// Constructor that creates a Flatbuffer from unsafe memory region without copying
   /// - Parameter assumingMemoryBound: The unsafe memory region
   /// - Parameter capacity: The size of the given memory region
-  public init(assumingMemoryBound memory: UnsafeMutableRawPointer, capacity: Int) {
+  public init(
+    assumingMemoryBound memory: UnsafeMutableRawPointer,
+    capacity: Int)
+  {
     _storage = Storage(memory: memory, capacity: capacity, unowned: true)
     _writerSize = capacity
   }
@@ -166,7 +176,7 @@
   /// - Parameters:
   ///   - memory: Current memory of the buffer
   ///   - count: count of bytes
-  internal init(memory: UnsafeMutableRawPointer, count: Int) {
+  init(memory: UnsafeMutableRawPointer, count: Int) {
     _storage = Storage(count: count, alignment: alignment)
     _storage.copy(from: memory, count: count)
     _writerSize = _storage.capacity
@@ -177,7 +187,11 @@
   ///   - memory: Current memory of the buffer
   ///   - count: count of bytes
   ///   - removeBytes: Removes a number of bytes from the current size
-  internal init(memory: UnsafeMutableRawPointer, count: Int, removing removeBytes: Int) {
+  init(
+    memory: UnsafeMutableRawPointer,
+    count: Int,
+    removing removeBytes: Int)
+  {
     _storage = Storage(count: count, alignment: alignment)
     _storage.copy(from: memory, count: count)
     _writerSize = removeBytes
@@ -233,7 +247,10 @@
   @usableFromInline
   mutating func push(string str: String, len: Int) {
     ensureSpace(size: len)
-    if str.utf8.withContiguousStorageIfAvailable({ self.push(bytes: $0, len: len) }) != nil {
+    if str.utf8
+      .withContiguousStorageIfAvailable({ self.push(bytes: $0, len: len) }) !=
+      nil
+    {
     } else {
       let utf8View = str.utf8
       for c in utf8View.reversed() {
@@ -247,7 +264,7 @@
   ///   - bytes: Pointer to the view
   ///   - len: Size of string
   @inline(__always)
-  mutating internal func push(
+  mutating func push(
     bytes: UnsafeBufferPointer<String.UTF8View.Element>,
     len: Int) -> Bool
   {
@@ -292,20 +309,20 @@
   /// pops the written VTable if it's already written into the buffer
   /// - Parameter size: size of the `VTable`
   @inline(__always)
-  mutating internal func pop(_ size: Int) {
-    assert((_writerSize &- size) > 0, "New size should NOT be a negative number")
+  mutating func pop(_ size: Int) {
+    assert(
+      (_writerSize &- size) > 0,
+      "New size should NOT be a negative number")
     memset(_storage.memory.advanced(by: writerIndex), 0, _writerSize &- size)
     _writerSize = size
   }
 
   /// Clears the current size of the buffer
-  @inline(__always)
   mutating public func clearSize() {
     _writerSize = 0
   }
 
   /// Clears the current instance of the buffer, replacing it with new memory
-  @inline(__always)
   mutating public func clear() {
     _writerSize = 0
     alignment = 1
@@ -317,10 +334,7 @@
   ///   - def: Type of the object
   ///   - position: the index of the object in the buffer
   public func read<T>(def: T.Type, position: Int) -> T {
-    assert(
-      position + MemoryLayout<T>.size <= _storage.capacity,
-      "Reading out of bounds is illegal")
-    return _storage.memory.advanced(by: position).load(as: T.self)
+    _storage.memory.advanced(by: position).load(as: T.self)
   }
 
   /// Reads a slice from the memory assuming a type of T
@@ -329,14 +343,15 @@
   ///   - count: count of bytes in memory
   @inline(__always)
   public func readSlice<T>(
-    index: Int32,
-    count: Int32) -> [T]
+    index: Int,
+    count: Int) -> [T]
   {
-    let _index = Int(index)
-    let _count = Int(count)
-    assert(_index + _count <= _storage.capacity, "Reading out of bounds is illegal")
-    let start = _storage.memory.advanced(by: _index).assumingMemoryBound(to: T.self)
-    let array = UnsafeBufferPointer(start: start, count: _count)
+    assert(
+      index + count <= _storage.capacity,
+      "Reading out of bounds is illegal")
+    let start = _storage.memory.advanced(by: index)
+      .assumingMemoryBound(to: T.self)
+    let array = UnsafeBufferPointer(start: start, count: count)
     return Array(array)
   }
 
@@ -345,17 +360,17 @@
   ///   - index: index of the string in the buffer
   ///   - count: length of the string
   ///   - type: Encoding of the string
-  @inline(__always)
   public func readString(
-    at index: Int32,
-    count: Int32,
+    at index: Int,
+    count: Int,
     type: String.Encoding = .utf8) -> String?
   {
-    let _index = Int(index)
-    let _count = Int(count)
-    assert(_index + _count <= _storage.capacity, "Reading out of bounds is illegal")
-    let start = _storage.memory.advanced(by: _index).assumingMemoryBound(to: UInt8.self)
-    let bufprt = UnsafeBufferPointer(start: start, count: _count)
+    assert(
+      index + count <= _storage.capacity,
+      "Reading out of bounds is illegal")
+    let start = _storage.memory.advanced(by: index)
+      .assumingMemoryBound(to: UInt8.self)
+    let bufprt = UnsafeBufferPointer(start: start, count: count)
     return String(bytes: Array(bufprt), encoding: type)
   }
 
@@ -363,12 +378,32 @@
   /// - Parameter removeBytes: the amount of bytes to remove from the current Size
   public func duplicate(removing removeBytes: Int = 0) -> ByteBuffer {
     assert(removeBytes > 0, "Can NOT remove negative bytes")
-    assert(removeBytes < _storage.capacity, "Can NOT remove more bytes than the ones allocated")
+    assert(
+      removeBytes < _storage.capacity,
+      "Can NOT remove more bytes than the ones allocated")
     return ByteBuffer(
       memory: _storage.memory,
       count: _storage.capacity,
       removing: _writerSize &- removeBytes)
   }
+
+  /// Returns the written bytes into the ``ByteBuffer``
+    public var underlyingBytes: [UInt8] {
+      let cp = capacity &- writerIndex
+      let start = memory.advanced(by: writerIndex)
+                                .bindMemory(to: UInt8.self, capacity: cp)
+
+      let ptr = UnsafeBufferPointer<UInt8>(start: start, count: cp)
+      return Array(ptr)
+  }
+
+  /// SkipPrefix Skips the first 4 bytes in case one of the following
+  /// functions are called `getPrefixedSizeCheckedRoot` & `getPrefixedSizeRoot`
+  /// which allows us to skip the first 4 bytes instead of recreating the buffer
+  @usableFromInline
+  mutating func skipPrefix() {
+    _writerSize = _writerSize &- MemoryLayout<Int32>.size
+  }
 }
 
 extension ByteBuffer: CustomDebugStringConvertible {
diff -urN a/swift/Sources/FlatBuffers/Constants.swift b/swift/Sources/FlatBuffers/Constants.swift
--- a/swift/Sources/FlatBuffers/Constants.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Constants.swift	2023-01-13 07:47:12.848288710 +0000
@@ -21,7 +21,8 @@
 #endif
 
 /// A boolean to see if the system is littleEndian
-let isLitteEndian = CFByteOrderGetCurrent() == Int(CFByteOrderLittleEndian.rawValue)
+let isLitteEndian = CFByteOrderGetCurrent() ==
+  Int(CFByteOrderLittleEndian.rawValue)
 /// Constant for the file id length
 let FileIdLength = 4
 /// Type aliases
@@ -30,16 +31,19 @@
 public typealias SOffset = Int32
 public typealias VOffset = UInt16
 /// Maximum size for a buffer
-public let FlatBufferMaxSize = UInt32.max << ((MemoryLayout<SOffset>.size * 8 - 1) - 1)
+public let FlatBufferMaxSize = UInt32
+  .max << ((MemoryLayout<SOffset>.size * 8 - 1) - 1)
 
-/// Protocol that confirms all the numbers
+/// Protocol that All Scalars should conform to
 ///
-/// Scalar is used to confirm all the numbers that can be represented in a FlatBuffer. It's used to write/read from the buffer.
+/// Scalar is used to conform all the numbers that can be represented in a FlatBuffer. It's used to write/read from the buffer.
 public protocol Scalar: Equatable {
   associatedtype NumericValue
   var convertedEndian: NumericValue { get }
 }
 
+extension Scalar where Self: Verifiable {}
+
 extension Scalar where Self: FixedWidthInteger {
   /// Converts the value from BigEndian to LittleEndian
   ///
@@ -49,7 +53,7 @@
   }
 }
 
-extension Double: Scalar {
+extension Double: Scalar, Verifiable {
   public typealias NumericValue = UInt64
 
   public var convertedEndian: UInt64 {
@@ -57,7 +61,7 @@
   }
 }
 
-extension Float32: Scalar {
+extension Float32: Scalar, Verifiable {
   public typealias NumericValue = UInt32
 
   public var convertedEndian: UInt32 {
@@ -65,7 +69,7 @@
   }
 }
 
-extension Bool: Scalar {
+extension Bool: Scalar, Verifiable {
   public var convertedEndian: UInt8 {
     self == true ? 1 : 0
   }
@@ -73,39 +77,39 @@
   public typealias NumericValue = UInt8
 }
 
-extension Int: Scalar {
+extension Int: Scalar, Verifiable {
   public typealias NumericValue = Int
 }
 
-extension Int8: Scalar {
+extension Int8: Scalar, Verifiable {
   public typealias NumericValue = Int8
 }
 
-extension Int16: Scalar {
+extension Int16: Scalar, Verifiable {
   public typealias NumericValue = Int16
 }
 
-extension Int32: Scalar {
+extension Int32: Scalar, Verifiable {
   public typealias NumericValue = Int32
 }
 
-extension Int64: Scalar {
+extension Int64: Scalar, Verifiable {
   public typealias NumericValue = Int64
 }
 
-extension UInt8: Scalar {
+extension UInt8: Scalar, Verifiable {
   public typealias NumericValue = UInt8
 }
 
-extension UInt16: Scalar {
+extension UInt16: Scalar, Verifiable {
   public typealias NumericValue = UInt16
 }
 
-extension UInt32: Scalar {
+extension UInt32: Scalar, Verifiable {
   public typealias NumericValue = UInt32
 }
 
-extension UInt64: Scalar {
+extension UInt64: Scalar, Verifiable {
   public typealias NumericValue = UInt64
 }
 
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Documentation.md b/swift/Sources/FlatBuffers/Documentation.docc/Documentation.md
--- a/swift/Sources/FlatBuffers/Documentation.docc/Documentation.md	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Documentation.md	2023-01-13 07:47:12.857288794 +0000
@@ -0,0 +1,22 @@
+# ``FlatBuffers``
+
+FlatBuffers: Memory Efficient Serialization Library
+
+## Overview
+
+- Access to serialized data without parsing/unpacking - What sets FlatBuffers apart is that it represents hierarchical data in a flat binary buffer in such a way that it can still be accessed directly without parsing/unpacking, while also still supporting data structure evolution (forwards/backwards compatibility).
+- Memory efficiency and speed - The only memory needed to access your data is that of the buffer. It requires 0 additional allocations (in C++, other languages may vary). FlatBuffers is also very suitable for use with mmap (or streaming), requiring only part of the buffer to be in memory. Access is close to the speed of raw struct access with only one extra indirection (a kind of vtable) to allow for format evolution and optional fields. It is aimed at projects where spending time and space (many memory allocations) to be able to access or construct serialized data is undesirable, such as in games or any other performance sensitive applications. See the benchmarks for details.
+- Flexible - Optional fields means not only do you get great forwards and backwards compatibility (increasingly important for long-lived games: don't have to update all data with each new version!). It also means you have a lot of choice in what data you write and what data you don't, and how you design data structures.
+- Tiny code footprint - Small amounts of generated code, and just a single small header as the minimum dependency, which is very easy to integrate. Again, see the benchmark section for details.
+- Strongly typed - Errors happen at compile time rather than manually having to write repetitive and error prone run-time checks. Useful code can be generated for you.
+
+## Topics
+
+### Read this first
+
+- <doc:Tutorial_Table_of_Contents>
+
+### Where to start
+
+- ``FlatBufferBuilder``
+- ``ByteBuffer``
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_1.fbs b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_1.fbs
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_1.fbs	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_1.fbs	2023-01-13 07:47:12.872288932 +0000
@@ -0,0 +1 @@
+
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_2.fbs b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_2.fbs
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_2.fbs	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_2.fbs	2023-01-13 07:47:12.872288932 +0000
@@ -0,0 +1 @@
+enum Color:byte { red, green, blue }
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_3.fbs b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_3.fbs
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_3.fbs	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_3.fbs	2023-01-13 07:47:12.872288932 +0000
@@ -0,0 +1,6 @@
+enum Color:byte { red, green, blue }
+
+struct Vec3 {
+  x:float;
+  y:float;
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_4.fbs b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_4.fbs
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_4.fbs	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_4.fbs	2023-01-13 07:47:12.872288932 +0000
@@ -0,0 +1,12 @@
+enum Color:byte { red, green, blue }
+
+struct Vec3 {
+  x:float;
+  y:float;
+}
+
+table Monster {
+  pos:Vec3;
+  color:Color = Blue;
+}
+
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_5.fbs b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_5.fbs
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_5.fbs	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_5.fbs	2023-01-13 07:47:12.872288932 +0000
@@ -0,0 +1,18 @@
+enum Color:byte { red, green, blue }
+
+struct Vec3 {
+  x:float;
+  y:float;
+}
+
+table Monster {
+  pos:Vec3;
+  color:Color = Blue;
+
+  mana:short = 150;
+  hp:short = 100;
+  name:string;
+  equipped:Equipment;
+  weapons:[Weapon];
+  path:[Vec3];
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_6.fbs b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_6.fbs
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_6.fbs	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_6.fbs	2023-01-13 07:47:12.872288932 +0000
@@ -0,0 +1,25 @@
+enum Color:byte { red, green, blue }
+
+union Equipment { Weapon } // Optionally add more tables.
+
+struct Vec3 {
+  x:float;
+  y:float;
+}
+
+table Monster {
+  pos:Vec3;
+  color:Color = Blue;
+
+  mana:short = 150;
+  hp:short = 100;
+  name:string;
+  equipped:Equipment;
+  weapons:[Weapon];
+  path:[Vec3];
+}
+
+table Weapon {
+  name:string;
+  damage:short;
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_7.fbs b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_7.fbs
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_7.fbs	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/fbs/monster_step_7.fbs	2023-01-13 07:47:12.873288942 +0000
@@ -0,0 +1,27 @@
+enum Color:byte { red, green, blue }
+
+union Equipment { Weapon } // Optionally add more tables.
+
+struct Vec3 {
+  x:float;
+  y:float;
+}
+
+table Monster {
+  pos:Vec3;
+  color:Color = Blue;
+
+  mana:short = 150;
+  hp:short = 100;
+  name:string;
+  equipped:Equipment;
+  weapons:[Weapon];
+  path:[Vec3];
+}
+
+table Weapon {
+  name:string;
+  damage:short;
+}
+
+root_type Monster; // flatc --swift monster.fbs
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_1.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_1.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_1.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_1.swift	2023-01-13 07:47:12.873288942 +0000
@@ -0,0 +1 @@
+import Foundation
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_10.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_10.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_10.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_10.swift	2023-01-13 07:47:12.874288951 +0000
@@ -0,0 +1,71 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a `FlatBufferBuilder`, which will be used to serialize objects
+  let builder = FlatBufferBuilder(initialSize: 1024)
+
+  let weapon1Name = builder.create(string: "Sword")
+  let weapon2Name = builder.create(string: "Axe")
+
+  // start creating the weapon by calling startWeapon
+  let weapon1Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon1Name, &builder)
+  Weapon.add(damage: 3, &builder)
+  // end the object by passing the start point for the weapon 1
+  let sword = Weapon.endWeapon(&builder, start: weapon1Start)
+
+  let weapon2Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon2Name, &builder)
+  Weapon.add(damage: 5, &builder)
+  let axe = Weapon.endWeapon(&builder, start: weapon2Start)
+
+  // Create a FlatBuffer `vector` that contains offsets to the sword and axe
+  // we created above.
+  let weaponsOffset = builder.createVector(ofOffsets: [sword, axe])
+
+  // Name of the Monster.
+  let name = builder.create(string: "Orc")
+
+  let pathOffset = fbb.createVector(ofStructs: [
+    Vec3(x: 0, y: 0),
+    Vec3(x: 5, y: 5),
+  ])
+
+  // startVector(len, elementSize: MemoryLayout<Offset>.size)
+  // for o in offsets.reversed() {
+  //   push(element: o)
+  // }
+  // endVector(len: len)
+
+  let orc = Monster.createMonster(
+    &builder,
+    pos: Vec3(x: 1, y: 2),
+    hp: 300,
+    nameOffset: name,
+    color: .red,
+    weaponsVectorOffset: weaponsOffset,
+    equippedType: .weapon,
+    equippedOffset: axe,
+    pathOffset: pathOffset)
+
+  // let start = Monster.startMonster(&builder)
+  // Monster.add(pos: Vec3(x: 1, y: 2), &builder)
+  // Monster.add(hp: 300, &builder)
+  // Monster.add(name: name, &builder)
+  // Monster.add(color: .red, &builder)
+  // Monster.addVectorOf(weapons: weaponsOffset, &builder)
+  // Monster.add(equippedType: .weapon, &builder)
+  // Monster.addVectorOf(paths: weaponsOffset, &builder)
+  // Monster.add(equipped: axe, &builder)
+  // var orc = Monster.endMonster(&builder, start: start)
+
+  // Call `finish(offset:)` to instruct the builder that this monster is complete.
+  builder.finish(offset: orc)
+  // This must be called after `finish()`.
+  // `sizedByteArray` returns the finished buf of type [UInt8].
+  let buf = builder.sizedByteArray
+
+  // or you can use to get an object of type Data
+  let bufData = ByteBuffer(data: builder.sizedBuffer)
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_11.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_11.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_11.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_11.swift	2023-01-13 07:47:12.874288951 +0000
@@ -0,0 +1,11 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a ByteBuffer(:) from an [UInt8] or Data()
+  let buf = [] // Get your data
+
+  // Get an accessor to the root object inside the buffer.
+  let monster: Monster = try! getCheckedRoot(byteBuffer: ByteBuffer(bytes: buf))
+  // let monster: Monster = getRoot(byteBuffer: ByteBuffer(bytes: buf))
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_12.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_12.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_12.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_12.swift	2023-01-13 07:47:12.875288960 +0000
@@ -0,0 +1,19 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a ByteBuffer(:) from an [UInt8] or Data()
+  let buf = [] // Get your data
+
+  // Get an accessor to the root object inside the buffer.
+  let monster: Monster = try! getCheckedRoot(byteBuffer: ByteBuffer(bytes: buf))
+  // let monster: Monster = getRoot(byteBuffer: ByteBuffer(bytes: buf))
+
+  let hp = monster.hp
+  let mana = monster.mana
+  let name = monster.name // returns an optional string
+
+  let pos = monster.pos
+  let x = pos.x
+  let y = pos.y
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_13.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_13.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_13.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_13.swift	2023-01-13 07:47:12.875288960 +0000
@@ -0,0 +1,26 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a ByteBuffer(:) from an [UInt8] or Data()
+  let buf = [] // Get your data
+
+  // Get an accessor to the root object inside the buffer.
+  let monster: Monster = try! getCheckedRoot(byteBuffer: ByteBuffer(bytes: buf))
+  // let monster: Monster = getRoot(byteBuffer: ByteBuffer(bytes: buf))
+
+  let hp = monster.hp
+  let mana = monster.mana
+  let name = monster.name // returns an optional string
+
+  let pos = monster.pos
+  let x = pos.x
+  let y = pos.y
+
+  // Get and check if the monster has an equipped item
+  if monster.equippedType == .weapon {
+    let _weapon = monster.equipped(type: Weapon.self)
+    let name = _weapon.name // should return "Axe"
+    let dmg = _weapon.damage // should return 5
+  }
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_2.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_2.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_2.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_2.swift	2023-01-13 07:47:12.876288969 +0000
@@ -0,0 +1,2 @@
+import FlatBuffers
+import Foundation
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_3.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_3.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_3.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_3.swift	2023-01-13 07:47:12.888289080 +0000
@@ -0,0 +1,7 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a `FlatBufferBuilder`, which will be used to serialize objects
+  let builder = FlatBufferBuilder(initialSize: 1024)
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_4.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_4.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_4.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_4.swift	2023-01-13 07:47:12.888289080 +0000
@@ -0,0 +1,10 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a `FlatBufferBuilder`, which will be used to serialize objects
+  let builder = FlatBufferBuilder(initialSize: 1024)
+
+  let weapon1Name = builder.create(string: "Sword")
+  let weapon2Name = builder.create(string: "Axe")
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_5.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_5.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_5.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_5.swift	2023-01-13 07:47:12.888289080 +0000
@@ -0,0 +1,22 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a `FlatBufferBuilder`, which will be used to serialize objects
+  let builder = FlatBufferBuilder(initialSize: 1024)
+
+  let weapon1Name = builder.create(string: "Sword")
+  let weapon2Name = builder.create(string: "Axe")
+
+  // start creating the weapon by calling startWeapon
+  let weapon1Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon1Name, &builder)
+  Weapon.add(damage: 3, &builder)
+  // end the object by passing the start point for the weapon 1
+  let sword = Weapon.endWeapon(&builder, start: weapon1Start)
+
+  let weapon2Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon2Name, &builder)
+  Weapon.add(damage: 5, &builder)
+  let axe = Weapon.endWeapon(&builder, start: weapon2Start)
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_6.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_6.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_6.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_6.swift	2023-01-13 07:47:12.888289080 +0000
@@ -0,0 +1,26 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a `FlatBufferBuilder`, which will be used to serialize objects
+  let builder = FlatBufferBuilder(initialSize: 1024)
+
+  let weapon1Name = builder.create(string: "Sword")
+  let weapon2Name = builder.create(string: "Axe")
+
+  // start creating the weapon by calling startWeapon
+  let weapon1Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon1Name, &builder)
+  Weapon.add(damage: 3, &builder)
+  // end the object by passing the start point for the weapon 1
+  let sword = Weapon.endWeapon(&builder, start: weapon1Start)
+
+  let weapon2Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon2Name, &builder)
+  Weapon.add(damage: 5, &builder)
+  let axe = Weapon.endWeapon(&builder, start: weapon2Start)
+
+  // Create a FlatBuffer `vector` that contains offsets to the sword and axe
+  // we created above.
+  let weaponsOffset = builder.createVector(ofOffsets: [sword, axe])
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_7.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_7.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_7.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_7.swift	2023-01-13 07:47:12.888289080 +0000
@@ -0,0 +1,29 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a `FlatBufferBuilder`, which will be used to serialize objects
+  let builder = FlatBufferBuilder(initialSize: 1024)
+
+  let weapon1Name = builder.create(string: "Sword")
+  let weapon2Name = builder.create(string: "Axe")
+
+  // start creating the weapon by calling startWeapon
+  let weapon1Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon1Name, &builder)
+  Weapon.add(damage: 3, &builder)
+  // end the object by passing the start point for the weapon 1
+  let sword = Weapon.endWeapon(&builder, start: weapon1Start)
+
+  let weapon2Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon2Name, &builder)
+  Weapon.add(damage: 5, &builder)
+  let axe = Weapon.endWeapon(&builder, start: weapon2Start)
+
+  // Create a FlatBuffer `vector` that contains offsets to the sword and axe
+  // we created above.
+  let weaponsOffset = builder.createVector(ofOffsets: [sword, axe])
+
+  // Name of the Monster.
+  let name = builder.create(string: "Orc")
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_8.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_8.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_8.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_8.swift	2023-01-13 07:47:12.888289080 +0000
@@ -0,0 +1,40 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a `FlatBufferBuilder`, which will be used to serialize objects
+  let builder = FlatBufferBuilder(initialSize: 1024)
+
+  let weapon1Name = builder.create(string: "Sword")
+  let weapon2Name = builder.create(string: "Axe")
+
+  // start creating the weapon by calling startWeapon
+  let weapon1Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon1Name, &builder)
+  Weapon.add(damage: 3, &builder)
+  // end the object by passing the start point for the weapon 1
+  let sword = Weapon.endWeapon(&builder, start: weapon1Start)
+
+  let weapon2Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon2Name, &builder)
+  Weapon.add(damage: 5, &builder)
+  let axe = Weapon.endWeapon(&builder, start: weapon2Start)
+
+  // Create a FlatBuffer `vector` that contains offsets to the sword and axe
+  // we created above.
+  let weaponsOffset = builder.createVector(ofOffsets: [sword, axe])
+
+  // Name of the Monster.
+  let name = builder.create(string: "Orc")
+
+  let pathOffset = fbb.createVector(ofStructs: [
+    Vec3(x: 0, y: 0),
+    Vec3(x: 5, y: 5),
+  ])
+
+  // startVector(len, elementSize: MemoryLayout<Offset>.size)
+  // for o in offsets.reversed() {
+  //   push(element: o)
+  // }
+  // endVector(len: len)
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_9.swift b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_9.swift
--- a/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_9.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Resources/code/swift/swift_code_9.swift	2023-01-13 07:47:12.920289376 +0000
@@ -0,0 +1,62 @@
+import FlatBuffers
+import Foundation
+
+func run() {
+  // create a `FlatBufferBuilder`, which will be used to serialize objects
+  let builder = FlatBufferBuilder(initialSize: 1024)
+
+  let weapon1Name = builder.create(string: "Sword")
+  let weapon2Name = builder.create(string: "Axe")
+
+  // start creating the weapon by calling startWeapon
+  let weapon1Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon1Name, &builder)
+  Weapon.add(damage: 3, &builder)
+  // end the object by passing the start point for the weapon 1
+  let sword = Weapon.endWeapon(&builder, start: weapon1Start)
+
+  let weapon2Start = Weapon.startWeapon(&builder)
+  Weapon.add(name: weapon2Name, &builder)
+  Weapon.add(damage: 5, &builder)
+  let axe = Weapon.endWeapon(&builder, start: weapon2Start)
+
+  // Create a FlatBuffer `vector` that contains offsets to the sword and axe
+  // we created above.
+  let weaponsOffset = builder.createVector(ofOffsets: [sword, axe])
+
+  // Name of the Monster.
+  let name = builder.create(string: "Orc")
+
+  let pathOffset = fbb.createVector(ofStructs: [
+    Vec3(x: 0, y: 0),
+    Vec3(x: 5, y: 5),
+  ])
+
+  // startVector(len, elementSize: MemoryLayout<Offset>.size)
+  // for o in offsets.reversed() {
+  //   push(element: o)
+  // }
+  // endVector(len: len)
+
+  let orc = Monster.createMonster(
+    &builder,
+    pos: Vec3(x: 1, y: 2),
+    hp: 300,
+    nameOffset: name,
+    color: .red,
+    weaponsVectorOffset: weaponsOffset,
+    equippedType: .weapon,
+    equippedOffset: axe,
+    pathOffset: pathOffset)
+
+  // let start = Monster.startMonster(&builder)
+  // Monster.add(pos: Vec3(x: 1, y: 2), &builder)
+  // Monster.add(hp: 300, &builder)
+  // Monster.add(name: name, &builder)
+  // Monster.add(color: .red, &builder)
+  // Monster.addVectorOf(weapons: weaponsOffset, &builder)
+  // Monster.add(equippedType: .weapon, &builder)
+  // Monster.addVectorOf(paths: weaponsOffset, &builder)
+  // Monster.add(equipped: axe, &builder)
+  // var orc = Monster.endMonster(&builder, start: start)
+}
Binary files a/swift/Sources/FlatBuffers/Documentation.docc/Resources/images/tutorial_cover_image_1.png and b/swift/Sources/FlatBuffers/Documentation.docc/Resources/images/tutorial_cover_image_1.png differ
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/Tutorial_Table_of_Contents.tutorial b/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/Tutorial_Table_of_Contents.tutorial
--- a/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/Tutorial_Table_of_Contents.tutorial	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/Tutorial_Table_of_Contents.tutorial	2023-01-13 07:47:12.953289681 +0000
@@ -0,0 +1,14 @@
+@Tutorials(name: "Starting with FlatBuffers") {
+    @Intro(title: "Starting with FlatBuffers") {
+      FlatBuffers is an efficient cross platform serialization library for C++,
+      C#, C, Go, Java, Kotlin, JavaScript, Lobster, Lua, TypeScript, PHP, Python, Rust and Swift.
+      It was originally created at Google for game development and other performance-critical applications.
+    }
+    @Chapter(name: "Generating your code") {
+        Start by generating your first FlatBuffers objects.
+        @Image(source: tutorial_cover_image_1.png, alt: "A code structure for a base struct in flatbuffers")
+        @TutorialReference(tutorial: "doc:creating_flatbuffer_schema")
+        @TutorialReference(tutorial: "doc:create_your_first_buffer")
+        @TutorialReference(tutorial: "doc:reading_bytebuffer")
+    }
+}
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/create_your_first_buffer.tutorial b/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/create_your_first_buffer.tutorial
--- a/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/create_your_first_buffer.tutorial	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/create_your_first_buffer.tutorial	2023-01-13 07:47:12.953289681 +0000
@@ -0,0 +1,72 @@
+@Tutorial(time: 5) {
+  @Intro(title: "After having our code generated") {
+    After generating the code from the previous section, we will know start creating our monster object.
+    We will create a monster object called orc.
+    }
+    
+    @Section(title: "Building your first buffer") {
+      @ContentAndMedia {}
+      @Steps {
+        @Step {
+          Starting with a new file, we will create our very first Flatbuffer.
+          @Code(name: "ViewController.swift", file: "swift_code_1.swift")
+        }
+        @Step {
+          First, we need to import ``FlatBuffers``
+          @Code(name: "ViewController.swift", file: "swift_code_2.swift")
+        }
+        @Step {
+          We need to create an instance of the `FlatBufferBuilder`, which will contain the buffer as it grows. 
+          You can pass an initial size of the buffer (here 1024 bytes), which will grow automatically if needed.
+          @Code(name: "ViewController.swift", file: "swift_code_3.swift")
+        }
+        @Step {
+          After creating the builder, we can start serializing our data. Before we make our orc Monster, 
+          let's create some Weapons: a Sword and an Axe. However we will start by naming our weapons as `Sword` and `Axe`
+          @Code(name: "ViewController.swift", file: "swift_code_4.swift")
+        }
+        @Step {
+          After naming the weapons, we will create two weapon objects with the damage that the weapon is going to deal. 
+          That's done by calling the `start` Method on each table you will be creating, in this case its called `startWeapon` 
+          and finished by calling `end`.
+          @Code(name: "ViewController.swift", file: "swift_code_5.swift")
+        }
+        @Step {
+          We will take our (Sword and Axe) serialized data and serialize their offsets as a vector of tables into our `ByteBuffer`. 
+          So we can reference them later on from our Monster Object
+          @Code(name: "ViewController.swift", file: "swift_code_6.swift")
+        }
+        @Step {
+          We will add our Monster name as a string value just like we did with the weapons.
+          @Code(name: "ViewController.swift", file: "swift_code_7.swift")
+        }
+        
+        @Step {
+          We will create a path that our monster should be using while roaming in its den. To create a vector of paths we would us
+          `createVector(ofStructs: [])` which will take a Native `Swift` struct that has been padded to fit the `FlatBuffers` standards.
+          
+          There are usually two ways of creating vectors in `FlatBuffers` which you can see in commented out code. 
+          And thus there are multiple convenience methods that will cover all the bases 
+          when trying to create a vector so that you dont have to create it with `start` and `end`
+          @Code(name: "ViewController.swift", file: "swift_code_8.swift")
+        }
+        
+        @Step {
+          Now to serialize our data into our `Monster` object. Which again there are two ways of doing, by calling the `create` method or
+          by serializing the objects yourself. What we added to our Monster were the `Equipped Type` and the `Equipped` union itself, which
+          allows the Monster to have the `Axe` as his equipped weapon.
+          
+          Important: Unlike structs, you should not nest tables or other objects, 
+          which is why we created all the `strings/vectors/tables` that this monster refers to before start.
+          If you try to create any of them between start and end, you will get an `assert`.
+          @Code(name: "ViewController.swift", file: "swift_code_9.swift")
+        }
+        
+        @Step {
+          Finally you can just finalize the buffer by calling `builder.finish` and get the Byte array from the buffer.
+          @Code(name: "ViewController.swift", file: "swift_code_10.swift")
+        }
+
+      }
+    }
+  }
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/creating_flatbuffer_schema.tutorial b/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/creating_flatbuffer_schema.tutorial
--- a/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/creating_flatbuffer_schema.tutorial	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/creating_flatbuffer_schema.tutorial	2023-01-13 07:47:12.953289681 +0000
@@ -0,0 +1,47 @@
+@Tutorial(time: 2) {
+  @Intro(title: "Creating a schema") {
+    You will need to have the FlatBuffer compiler to be installed on your device
+    }
+    
+    @Section(title: "Creating a schema") {
+      @ContentAndMedia {}
+      @Steps {
+        @Step {
+          Start by creating a new empty folder called `monster.fbs`. We want to create a Monster table, that contains
+          position, color, and basic information about the monster.
+          @Code(name: "monster.fbs", file: "monster_step_1.fbs")
+        }
+        @Step {
+          We will start by adding our Color object. We will be using an enumerate, to represent this object
+          @Code(name: "monster.fbs", file: "monster_step_2.fbs")
+        }
+        @Step {
+          We will add a position object and will use a struct to represent that type of data. Where we will need the monsters
+          x and y positions.
+          @Code(name: "monster.fbs", file: "monster_step_3.fbs")
+        }
+        @Step {
+          Then we will be creating our Monster object of type table. This will contain the current position of our
+          monster and its color
+          @Code(name: "monster.fbs", file: "monster_step_4.fbs")
+        }
+        @Step {
+          Our Monster is missing a name, mana, hp, name, equipped Weapon, weapons, and path. We will be adding these 
+          fields to our table with a proper data type for each. Example; weapons, and path would be a vector of data.
+          @Code(name: "monster.fbs", file: "monster_step_5.fbs")
+        }
+        @Step {
+          Now we are missing two data types here, `Weapon` and `Equipment`. And since Equipment can be a weapon, we will be using
+          a `Union` enumerate that can contain all the equipment that you would want your monster to have. And the weapon can simply
+          have a name and amount of damage
+          @Code(name: "monster.fbs", file: "monster_step_6.fbs")
+        }
+        @Step {
+          And to finalize our monster table, we can add a root type of type Monster. 
+          Then run the command `flatc --swift monster.fbs`
+          Note: Make sure to import the file to your xcode project.
+          @Code(name: "monster.fbs", file: "monster_step_7.fbs")
+        }
+      }
+    }
+  }
diff -urN a/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/reading_bytebuffer.tutorial b/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/reading_bytebuffer.tutorial
--- a/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/reading_bytebuffer.tutorial	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Documentation.docc/Tutorials/reading_bytebuffer.tutorial	2023-01-13 07:47:12.984289967 +0000
@@ -0,0 +1,27 @@
+@Tutorial(time: 2) {
+  @Intro(title: "Reading ByteBuffers") {
+    After getting our ByteBuffer created, we can now read it.
+    }
+    
+    @Section(title: "Reading your first buffer") {
+      @ContentAndMedia {}
+      @Steps {
+        @Step {
+          After fetching the data from disk or network you need to access that data, and that can be done.
+          By simply calling `getCheckedRoot`, which checks if the data is valid before enabling you to read from a corrupt buffer.
+          however, if you are sure that the data is 100% correct you can simply call `getRoot`
+          @Code(name: "ViewController.swift", file: "swift_code_11.swift")
+        }
+        @Step {
+          Now since we have a Monster object, all the fields can be accessed by simply fetching the data. Note, Deprecated fields will not
+          show up
+          @Code(name: "ViewController.swift", file: "swift_code_12.swift")
+        }
+        @Step {
+          And you can access union types as easy as this
+          @Code(name: "ViewController.swift", file: "swift_code_13.swift")
+        }
+      }
+    }
+  }
+
diff -urN a/swift/Sources/FlatBuffers/Enum.swift b/swift/Sources/FlatBuffers/Enum.swift
--- a/swift/Sources/FlatBuffers/Enum.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Enum.swift	2023-01-13 07:47:12.849288720 +0000
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import Foundation
+
+/// Enum is a protocol that all flatbuffers enums should conform to
+/// Since it allows us to get the actual `ByteSize` and `Value` from
+/// a swift enum.
+public protocol Enum {
+  /// associatedtype that the type of the enum should conform to
+  associatedtype T: Scalar & Verifiable
+  /// Size of the current associatedtype in the enum
+  static var byteSize: Int { get }
+  /// The current value the enum hosts
+  var value: T { get }
+}
+
+extension Enum where Self: Verifiable {
+
+  /// Verifies that the current value is which the bounds of the buffer, and if
+  /// the current `Value` is aligned properly
+  /// - Parameters:
+  ///   - verifier: Verifier that hosts the buffer
+  ///   - position: Current position within the buffer
+  ///   - type: The type of the object to be verified
+  /// - Throws: Errors coming from `inBuffer` function
+  public static func verify<T>(
+    _ verifier: inout Verifier,
+    at position: Int,
+    of type: T.Type) throws where T: Verifiable
+  {
+    try verifier.inBuffer(position: position, of: type.self)
+  }
+
+}
+
+/// UnionEnum is a Protocol that allows us to create Union type of enums
+/// and their value initializers. Since an `init` was required by
+/// the verifier
+public protocol UnionEnum: Enum {
+  init?(value: T) throws
+}
diff -urN a/swift/Sources/FlatBuffers/FlatBufferBuilder.swift b/swift/Sources/FlatBuffers/FlatBufferBuilder.swift
--- a/swift/Sources/FlatBuffers/FlatBufferBuilder.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/FlatBufferBuilder.swift	2023-01-13 07:47:12.849288720 +0000
@@ -16,6 +16,16 @@
 
 import Foundation
 
+/// ``FlatBufferBuilder`` builds a `FlatBuffer` through manipulating its internal state.
+///
+/// This is done by creating a ``ByteBuffer`` that hosts the incoming data and
+/// has a hardcoded growth limit of `2GiB` which is set by the Flatbuffers standards.
+///
+/// ```swift
+/// var builder = FlatBufferBuilder()
+/// ```
+/// The builder should be always created as a variable, since it would be passed into the writers
+///
 @frozen
 public struct FlatBufferBuilder {
 
@@ -44,55 +54,76 @@
 
   /// Gives a read access to the buffer's size
   public var size: UOffset { _bb.size }
+
   /// Data representation of the buffer
+  ///
+  /// Should only be used after ``finish(offset:addPrefix:)`` is called
   public var data: Data {
     assert(finished, "Data shouldn't be called before finish()")
     return Data(
       bytes: _bb.memory.advanced(by: _bb.writerIndex),
       count: _bb.capacity &- _bb.writerIndex)
   }
-  /// Get's the fully sized buffer stored in memory
+
+  /// Returns the underlying bytes in the ``ByteBuffer``
+  ///
+  /// Note: This should be used with caution.
   public var fullSizedByteArray: [UInt8] {
     let ptr = UnsafeBufferPointer(
       start: _bb.memory.assumingMemoryBound(to: UInt8.self),
       count: _bb.capacity)
     return Array(ptr)
   }
-  /// Returns the written size of the buffer
+
+  /// Returns the written bytes into the ``ByteBuffer``
+  ///
+  /// Should only be used after ``finish(offset:addPrefix:)`` is called
   public var sizedByteArray: [UInt8] {
     assert(finished, "Data shouldn't be called before finish()")
-    let cp = _bb.capacity &- _bb.writerIndex
-    let start = _bb.memory.advanced(by: _bb.writerIndex)
-      .bindMemory(to: UInt8.self, capacity: cp)
-
-    let ptr = UnsafeBufferPointer(start: start, count: cp)
-    return Array(ptr)
+    return _bb.underlyingBytes
   }
-  /// Returns the buffer
+
+  /// Returns the original ``ByteBuffer``
+  ///
+  /// Returns the current buffer that was just created
+  /// with the offsets, and data written to it.
   public var buffer: ByteBuffer { _bb }
 
-  /// Returns A sized Buffer from the readable bytes
+  /// Returns a newly created sized ``ByteBuffer``
+  ///
+  /// returns a new buffer that is sized to the data written
+  /// to the main buffer
   public var sizedBuffer: ByteBuffer {
     assert(finished, "Data shouldn't be called before finish()")
-    return ByteBuffer(memory: _bb.memory.advanced(by: _bb.reader), count: Int(_bb.size))
+    return ByteBuffer(
+      memory: _bb.memory.advanced(by: _bb.reader),
+      count: Int(_bb.size))
   }
 
   // MARK: - Init
 
-  /// initialize the buffer with a size
+  /// Initialize the buffer with a size
   /// - Parameters:
   ///   - initialSize: Initial size for the buffer
   ///   - force: Allows default to be serialized into the buffer
-  public init(initialSize: Int32 = 1024, serializeDefaults force: Bool = false) {
+  ///
+  /// This initializes a new builder with an initialSize that would initialize
+  /// a new ``ByteBuffer``. ``FlatBufferBuilder`` by default doesnt serialize defaults
+  /// however the builder can be force by passing true for `serializeDefaults`
+  public init(
+    initialSize: Int32 = 1024,
+    serializeDefaults force: Bool = false)
+  {
     assert(initialSize > 0, "Size should be greater than zero!")
     guard isLitteEndian else {
-      fatalError("Reading/Writing a buffer in big endian machine is not supported on swift")
+      fatalError(
+        "Reading/Writing a buffer in big endian machine is not supported on swift")
     }
     serializeDefaults = force
     _bb = ByteBuffer(initialSize: Int(initialSize))
   }
 
-  /// Clears the buffer and the builder from it's data
+  /// Clears the builder and the buffer from the written data.
   mutating public func clear() {
     _minAlignment = 0
     isNested = false
@@ -108,11 +139,16 @@
   /// - Parameters:
   ///   - table: offset for the table
   ///   - fields: Array of all the important fields to be serialized
+  ///
+  /// *NOTE: Never call this function, this is only supposed to be called
+  /// by the generated code*
   mutating public func require(table: Offset, fields: [Int32]) {
     for field in fields {
       let start = _bb.capacity &- Int(table.o)
       let startTable = start &- Int(_bb.read(def: Int32.self, position: start))
-      let isOkay = _bb.read(def: VOffset.self, position: startTable &+ Int(field)) != 0
+      let isOkay = _bb.read(
+        def: VOffset.self,
+        position: startTable &+ Int(field)) != 0
       assert(isOkay, "Flatbuffers requires the following field")
     }
   }
@@ -122,9 +158,32 @@
   ///   - offset: Offset of the table
   ///   - fileId: Takes the fileId
   ///   - prefix: if false it wont add the size of the buffer
-  mutating public func finish(offset: Offset, fileId: String, addPrefix prefix: Bool = false) {
+  ///
+  /// ``finish(offset:fileId:addPrefix:)`` should be called at the end of creating
+  /// a table
+  /// ```swift
+  /// var root = SomeObject
+  ///   .createObject(&builder,
+  ///   name: nameOffset)
+  /// builder.finish(
+  ///   offset: root,
+  ///   fileId: "ax1a",
+  ///   addPrefix: true)
+  /// ```
+  /// File id would append a file id name at the end of the written bytes before,
+  /// finishing the buffer.
+  ///
+  /// Whereas, if `addPrefix` is true, the written bytes would
+  /// include the size of the current buffer.
+  mutating public func finish(
+    offset: Offset,
+    fileId: String,
+    addPrefix prefix: Bool = false)
+  {
     let size = MemoryLayout<UOffset>.size
-    preAlign(len: size &+ (prefix ? size : 0) &+ FileIdLength, alignment: _minAlignment)
+    preAlign(
+      len: size &+ (prefix ? size : 0) &+ FileIdLength,
+      alignment: _minAlignment)
     assert(fileId.count == FileIdLength, "Flatbuffers requires file id to be 4")
     _bb.push(string: fileId, len: 4)
     finish(offset: offset, addPrefix: prefix)
@@ -134,7 +193,23 @@
   /// - Parameters:
   ///   - offset: Offset of the table
   ///   - prefix: if false it wont add the size of the buffer
-  mutating public func finish(offset: Offset, addPrefix prefix: Bool = false) {
+  ///
+  /// ``finish(offset:addPrefix:)`` should be called at the end of creating
+  /// a table
+  /// ```swift
+  /// var root = SomeObject
+  ///   .createObject(&builder,
+  ///   name: nameOffset)
+  /// builder.finish(
+  ///   offset: root,
+  ///   addPrefix: true)
+  /// ```
+  /// If `addPrefix` is true, the written bytes would
+  /// include the size of the current buffer.
+  mutating public func finish(
+    offset: Offset,
+    addPrefix prefix: Bool = false)
+  {
     notNested()
     let size = MemoryLayout<UOffset>.size
     preAlign(len: size &+ (prefix ? size : 0), alignment: _minAlignment)
@@ -144,10 +219,15 @@
     finished = true
   }
 
-  /// starttable will let the builder know, that a new object is being serialized.
+  /// ``startTable(with:)`` will let the builder know, that a new object is being serialized.
   ///
-  /// The function will fatalerror if called while there is another object being serialized
+  /// The function will fatalerror if called while there is another object being serialized.
+  /// ```swift
+  /// let start = Monster
+  ///   .startMonster(&fbb)
+  /// ```
   /// - Parameter numOfFields: Number of elements to be written to the buffer
+  /// - Returns: Offset of the newly started table
   mutating public func startTable(with numOfFields: Int) -> UOffset {
     notNested()
     isNested = true
@@ -155,11 +235,14 @@
     return _bb.size
   }
 
-  /// Endtable will let the builder know that the object that's written to it is completed
+  /// ``endTable(at:)`` will let the ``FlatBufferBuilder`` know that the
+  /// object that's written to it is completed
+  ///
+  /// This would be called after all the elements are serialized,
+  /// it will add the current vtable into the ``ByteBuffer``.
+  /// The functions will `fatalError` in case the object is called
+  /// without ``startTable(with:)``, or the object has exceeded  the limit of 2GB.
   ///
-  /// This would be called after all the elements are serialized, it will add the vtable into the buffer.
-  /// it will fatalError in case the object is called without starttable, or the object has exceeded  the limit of
-  ///  2GB,
   /// - Parameter startOffset:Start point of the object written
   /// - returns: The root of the table
   mutating public func endTable(at startOffset: UOffset)  -> UOffset {
@@ -184,7 +267,10 @@
       itr = itr &+ _vtableStorage.size
       guard loaded.offset != 0 else { continue }
       let _index = (_bb.writerIndex &+ Int(loaded.position))
-      _bb.write(value: VOffset(vTableOffset &- loaded.offset), index: _index, direct: true)
+      _bb.write(
+        value: VOffset(vTableOffset &- loaded.offset),
+        index: _index,
+        direct: true)
     }
 
     _vtableStorage.clear()
@@ -220,7 +306,7 @@
 
   // MARK: - Builds Buffer
 
-  /// asserts to see if the object is not nested
+  /// Asserts to see if the object is not nested
   @usableFromInline
   mutating internal func notNested()  {
     assert(!isNested, "Object serialization must not be nested")
@@ -240,7 +326,10 @@
   ///   - bufSize: Current size of the buffer + the offset of the object to be written
   ///   - elementSize: Element size
   @inline(__always)
-  mutating internal func padding(bufSize: UInt32, elementSize: UInt32) -> UInt32 {
+  mutating internal func padding(
+    bufSize: UInt32,
+    elementSize: UInt32) -> UInt32
+  {
     ((~bufSize) &+ 1) & (elementSize - 1)
   }
 
@@ -285,7 +374,18 @@
 
   // MARK: - Inserting Vectors
 
-  /// Starts a vector of length and Element size
+  /// ``startVector(_:elementSize:)`` creates a new vector within buffer
+  ///
+  /// The function checks if there is a current object being written, if
+  /// the check passes it creates a buffer alignment of `length * elementSize`
+  /// ```swift
+  /// builder.startVector(
+  ///   int32Values.count, elementSize: 4)
+  /// ```
+  ///
+  /// - Parameters:
+  ///   - len: Length of vector to be created
+  ///   - elementSize: Size of object type to be written
   mutating public func startVector(_ len: Int, elementSize: Int) {
     notNested()
     isNested = true
@@ -293,46 +393,102 @@
     preAlign(len: len &* elementSize, alignment: elementSize)
   }
 
-  /// Ends the vector of at length
+  /// ``endVector(len:)`` ends the currently created vector
+  ///
+  /// Calling ``endVector(len:)`` requires the length, of the current
+  /// vector. The length would be pushed to indicate the count of numbers
+  /// within the vector. If ``endVector(len:)`` is called without
+  /// ``startVector(_:elementSize:)`` it asserts.
+  ///
+  /// ```swift
+  /// let vectorOffset = builder.
+  ///   endVector(len: int32Values.count)
+  /// ```
   ///
-  /// The current function will fatalError if startVector is called before serializing the vector
   /// - Parameter len: Length of the buffer
+  /// - Returns: Returns the current ``Offset`` in the ``ByteBuffer``
   mutating public func endVector(len: Int) -> Offset {
     assert(isNested, "Calling endVector without calling startVector")
     isNested = false
     return Offset(offset: push(element: Int32(len)))
   }
 
-  /// Creates a vector of type Scalar in the buffer
+  /// Creates a vector of type ``Scalar`` into the ``ByteBuffer``
+  ///
+  /// ``createVector(_:)-4swl0`` writes a vector of type Scalars into
+  /// ``ByteBuffer``. This is a convenient method instead of calling,
+  /// ``startVector(_:elementSize:)`` and then ``endVector(len:)``
+  /// ```swift
+  /// let vectorOffset = builder.
+  ///   createVector([1, 2, 3, 4])
+  /// ```
+  ///
+  /// The underlying implementation simply calls ``createVector(_:size:)-4lhrv``
+  ///
   /// - Parameter elements: elements to be written into the buffer
-  /// - returns: Offset of the vector
+  /// - returns: ``Offset`` of the vector
   mutating public func createVector<T: Scalar>(_ elements: [T]) -> Offset {
     createVector(elements, size: elements.count)
   }
 
   ///  Creates a vector of type Scalar in the buffer
+  ///
+  /// ``createVector(_:)-4swl0`` writes a vector of type Scalars into
+  /// ``ByteBuffer``. This is a convenient method instead of calling,
+  /// ``startVector(_:elementSize:)`` and then ``endVector(len:)``
+  /// ```swift
+  /// let vectorOffset = builder.
+  ///   createVector([1, 2, 3, 4], size: 4)
+  /// ```
+  ///
   /// - Parameter elements: Elements to be written into the buffer
   /// - Parameter size: Count of elements
-  /// - returns: Offset of the vector
-  mutating public func createVector<T: Scalar>(_ elements: [T], size: Int) -> Offset {
+  /// - returns: ``Offset`` of the vector
+  mutating public func createVector<T: Scalar>(
+    _ elements: [T],
+    size: Int) -> Offset
+  {
     let size = size
     startVector(size, elementSize: MemoryLayout<T>.size)
     _bb.push(elements: elements)
     return endVector(len: size)
   }
 
-  /// Creates a vector of type Enums in the buffer
+  /// Creates a vector of type ``Enum`` into the ``ByteBuffer``
+  ///
+  /// ``createVector(_:)-9h189`` writes a vector of type ``Enum`` into
+  /// ``ByteBuffer``. This is a convenient method instead of calling,
+  /// ``startVector(_:elementSize:)`` and then ``endVector(len:)``
+  /// ```swift
+  /// let vectorOffset = builder.
+  ///   createVector([.swift, .cpp])
+  /// ```
+  ///
+  /// The underlying implementation simply calls ``createVector(_:size:)-7cx6z``
+  ///
   /// - Parameter elements: elements to be written into the buffer
-  /// - returns: Offset of the vector
+  /// - returns: ``Offset`` of the vector
   mutating public func createVector<T: Enum>(_ elements: [T]) -> Offset {
     createVector(elements, size: elements.count)
   }
 
-  ///  Creates a vector of type Enums in the buffer
+  /// Creates a vector of type ``Enum`` into the ``ByteBuffer``
+  ///
+  /// ``createVector(_:)-9h189`` writes a vector of type ``Enum`` into
+  /// ``ByteBuffer``. This is a convenient method instead of calling,
+  /// ``startVector(_:elementSize:)`` and then ``endVector(len:)``
+  /// ```swift
+  /// let vectorOffset = builder.
+  ///   createVector([.swift, .cpp])
+  /// ```
+  ///
   /// - Parameter elements: Elements to be written into the buffer
   /// - Parameter size: Count of elements
-  /// - returns: Offset of the vector
-  mutating public func createVector<T: Enum>(_ elements: [T], size: Int) -> Offset {
+  /// - returns: ``Offset`` of the vector
+  mutating public func createVector<T: Enum>(
+    _ elements: [T],
+    size: Int) -> Offset
+  {
     let size = size
     startVector(size, elementSize: T.byteSize)
     for e in elements.reversed() {
@@ -341,18 +497,42 @@
     return endVector(len: size)
   }
 
-  /// Creates a vector of type Offsets  in the buffer
-  /// - Parameter offsets:Array of offsets of type T
-  /// - returns: Offset of the vector
+  /// Creates a vector of already written offsets
+  ///
+  /// ``createVector(ofOffsets:)`` creates a vector of ``Offset`` into
+  /// ``ByteBuffer``. This is a convenient method instead of calling,
+  /// ``startVector(_:elementSize:)`` and then ``endVector(len:)``.
+  ///
+  /// The underlying implementation simply calls ``createVector(ofOffsets:len:)``
+  ///
+  /// ```swift
+  /// let namesOffsets = builder.
+  ///   createVector(ofOffsets: [name1, name2])
+  /// ```
+  /// - Parameter offsets: Array of offsets of type ``Offset``
+  /// - returns: ``Offset`` of the vector
   mutating public func createVector(ofOffsets offsets: [Offset]) -> Offset {
     createVector(ofOffsets: offsets, len: offsets.count)
   }
 
-  ///  Creates a vector of type Offsets  in the buffer
-  /// - Parameter elements: Array of offsets of type T
+  /// Creates a vector of already written offsets
+  ///
+  /// ``createVector(ofOffsets:)`` creates a vector of ``Offset`` into
+  /// ``ByteBuffer``. This is a convenient method instead of calling,
+  /// ``startVector(_:elementSize:)`` and then ``endVector(len:)``
+  ///
+  /// ```swift
+  /// let namesOffsets = builder.
+  ///   createVector(ofOffsets: [name1, name2])
+  /// ```
+  ///
+  /// - Parameter offsets: Array of offsets of type ``Offset``
   /// - Parameter size: Count of elements
-  /// - returns: Offset of the vector
-  mutating public func createVector(ofOffsets offsets: [Offset], len: Int) -> Offset {
+  /// - returns: ``Offset`` of the vector
+  mutating public func createVector(
+    ofOffsets offsets: [Offset],
+    len: Int) -> Offset
+  {
     startVector(len, elementSize: MemoryLayout<Offset>.size)
     for o in offsets.reversed() {
       push(element: o)
@@ -360,9 +540,21 @@
     return endVector(len: len)
   }
 
-  /// Creates a vector of Strings
-  /// - Parameter str: a vector of strings that will be written into the buffer
-  /// - returns: Offset of the vector
+  /// Creates a vector of strings
+  ///
+  /// ``createVector(ofStrings:)`` creates a vector of `String` into
+  /// ``ByteBuffer``. This is a convenient method instead of manually
+  /// creating the string offsets, you simply pass it to this function
+  /// and it would write the strings into the ``ByteBuffer``.
+  /// After that it calls ``createVector(ofOffsets:)``
+  ///
+  /// ```swift
+  /// let namesOffsets = builder.
+  ///   createVector(ofStrings: ["Name", "surname"])
+  /// ```
+  ///
+  /// - Parameter str: Array of string
+  /// - returns: ``Offset`` of the vector
   mutating public func createVector(ofStrings str: [String]) -> Offset {
     var offsets: [Offset] = []
     for s in str {
@@ -371,11 +563,25 @@
     return createVector(ofOffsets: offsets)
   }
 
-  /// Creates a vector of `Native swift structs` which were padded to flatbuffers standards
-  /// - Parameter structs: A vector of structs
-  /// - Returns: offset of the vector
-  mutating public func createVector<T: NativeStruct>(ofStructs structs: [T]) -> Offset {
-    startVector(structs.count * MemoryLayout<T>.size, elementSize: MemoryLayout<T>.alignment)
+  /// Creates a vector of type ``NativeStruct``.
+  ///
+  /// Any swift struct in the generated code, should confirm to
+  /// ``NativeStruct``. Since the generated swift structs are padded
+  /// to the `FlatBuffers` standards.
+  ///
+  /// ```swift
+  /// let offsets = builder.
+  ///   createVector(ofStructs: [NativeStr(num: 1), NativeStr(num: 2)])
+  /// ```
+  ///
+  /// - Parameter structs: A vector of ``NativeStruct``
+  /// - Returns: ``Offset`` of the vector
+  mutating public func createVector<T: NativeStruct>(ofStructs structs: [T])
+    -> Offset
+  {
+    startVector(
+      structs.count * MemoryLayout<T>.size,
+      elementSize: MemoryLayout<T>.alignment)
     for i in structs.reversed() {
       _ = create(struct: i)
     }
@@ -384,24 +590,46 @@
 
   // MARK: - Inserting Structs
 
-  /// Fills the buffer with a native struct that's build and padded according to flatbuffers standards
+  /// Writes a ``NativeStruct`` into the ``ByteBuffer``
+  ///
+  /// Adds a native struct that's build and padded according
+  /// to `FlatBuffers` standards. with a predefined position.
+  ///
+  /// ```swift
+  /// let offset = builder.create(
+  ///   struct: NativeStr(num: 1),
+  ///   position: 10)
+  /// ```
+  ///
   /// - Parameters:
-  ///   - s: `Native swift` struct to insert
+  ///   - s: ``NativeStruct`` to be inserted into the ``ByteBuffer``
   ///   - position: The  predefined position of the object
-  /// - Returns: offset of written struct
+  /// - Returns: ``Offset`` of written struct
   @discardableResult
   mutating public func create<T: NativeStruct>(
     struct s: T, position: VOffset) -> Offset
   {
     let offset = create(struct: s)
-    _vtableStorage.add(loc: FieldLoc(offset: _bb.size, position: VOffset(position)))
+    _vtableStorage.add(loc: FieldLoc(
+      offset: _bb.size,
+      position: VOffset(position)))
     return offset
   }
 
-  /// Fills the buffer with a native struct that's build and padded according to flatbuffers standards
+  /// Writes a ``NativeStruct`` into the ``ByteBuffer``
+  ///
+  /// Adds a native struct that's build and padded according
+  /// to `FlatBuffers` standards, directly into the buffer without
+  /// a predefined position.
+  ///
+  /// ```swift
+  /// let offset = builder.create(
+  ///   struct: NativeStr(num: 1))
+  /// ```
+  ///
   /// - Parameters:
-  ///   - s: `Native swift` struct to insert
-  /// - Returns: offset of written struct
+  ///   - s: ``NativeStruct`` to be inserted into the ``ByteBuffer``
+  /// - Returns: ``Offset`` of written struct
   @discardableResult
   mutating public func create<T: NativeStruct>(
     struct s: T) -> Offset
@@ -414,9 +642,18 @@
 
   // MARK: - Inserting Strings
 
-  /// Insets a string into the buffer using UTF8
+  /// Insets a string into the buffer of type `UTF8`
+  ///
+  /// Adds a swift string into ``ByteBuffer`` by encoding it
+  /// using `UTF8`
+  ///
+  /// ```swift
+  /// let nameOffset = builder
+  ///   .create(string: "welcome")
+  /// ```
+  ///
   /// - Parameter str: String to be serialized
-  /// - returns: The strings offset in the buffer
+  /// - returns: ``Offset`` of inserted string
   mutating public func create(string str: String?) -> Offset {
     guard let str = str else { return Offset() }
     let len = str.utf8.count
@@ -428,11 +665,25 @@
     return Offset(offset: _bb.size)
   }
 
-  /// Inserts a shared string to the buffer
+  /// Insets a shared string into the buffer of type `UTF8`
+  ///
+  /// Adds a swift string into ``ByteBuffer`` by encoding it
+  /// using `UTF8`. The function will check if the string,
+  /// is already written to the ``ByteBuffer``
+  ///
+  /// ```swift
+  /// let nameOffset = builder
+  ///   .createShared(string: "welcome")
+  ///
+  ///
+  /// let secondOffset = builder
+  ///   .createShared(string: "welcome")
+  ///
+  /// assert(nameOffset.o == secondOffset.o)
+  /// ```
   ///
-  /// The function checks the stringOffsetmap if it's seen a similar string before
   /// - Parameter str: String to be serialized
-  /// - returns: The strings offset in the buffer
+  /// - returns: ``Offset`` of inserted string
   mutating public func createShared(string str: String?) -> Offset {
     guard let str = str else { return Offset() }
     if let offset = stringOffsetMap[str] {
@@ -445,18 +696,22 @@
 
   // MARK: - Inseting offsets
 
-  /// Adds the offset of an object into the buffer
+  /// Writes the ``Offset`` of an already written table
+  ///
+  /// Writes the ``Offset`` of a table if not empty into the
+  /// ``ByteBuffer``
+  ///
   /// - Parameters:
-  ///   - offset: Offset of another object to be written
-  ///   - position: The  predefined position of the object
+  ///   - offset: ``Offset`` of another object to be written
+  ///   - position: The predefined position of the object
   mutating public func add(offset: Offset, at position: VOffset) {
     if offset.isEmpty { return }
     add(element: refer(to: offset.o), def: 0, at: position)
   }
 
-  /// Pushes a value of type offset into the buffer
-  /// - Parameter o: Offset
-  /// - returns: Position of the offset
+  /// Pushes a value of type ``Offset`` into the ``ByteBuffer``
+  /// - Parameter o: ``Offset``
+  /// - returns: Current position of the ``Offset``
   @discardableResult
   mutating public func push(element o: Offset) -> UOffset {
     push(element: refer(to: o.o))
@@ -464,18 +719,42 @@
 
   // MARK: - Inserting Scalars to Buffer
 
-  /// Adds a value into the buffer of type Scalar
+  /// Writes a ``Scalar`` value into ``ByteBuffer``
+  ///
+  /// ``add(element:def:at:)`` takes in a default value, and current value
+  /// and the position within the `VTable`. The default value would not
+  /// be serialized if the value is the same as the current value or
+  /// `serializeDefaults` is equal to false.
+  ///
+  /// If serializing defaults is important ``init(initialSize:serializeDefaults:)``,
+  /// passing true for `serializeDefaults` would do the job.
+  ///
+  /// ```swift
+  /// // Adds 10 to the buffer
+  /// builder.add(element: Int(10), def: 1, position 12)
+  /// ```
+  ///
+  /// *NOTE: Never call this manually*
   ///
   /// - Parameters:
   ///   - element: Element to insert
   ///   - def: Default value for that element
   ///   - position: The predefined position of the element
-  mutating public func add<T: Scalar>(element: T, def: T, at position: VOffset) {
+  mutating public func add<T: Scalar>(
+    element: T,
+    def: T,
+    at position: VOffset)
+  {
     if element == def && !serializeDefaults { return }
     track(offset: push(element: element), at: position)
   }
 
-  /// Adds a value into the buffer of type optional Scalar
+  /// Writes a optional ``Scalar`` value into ``ByteBuffer``
+  ///
+  /// Takes an optional value to be written into the ``ByteBuffer``
+  ///
+  /// *NOTE: Never call this manually*
+  ///
   /// - Parameters:
   ///   - element: Optional element of type scalar
   ///   - position: The predefined position of the element
@@ -484,7 +763,10 @@
     track(offset: push(element: element), at: position)
   }
 
-  /// Pushes the values into the buffer
+  /// Pushes a values of type ``Scalar`` into the ``ByteBuffer``
+  ///
+  /// *NOTE: Never call this manually*
+  ///
   /// - Parameter element: Element to insert
   /// - returns: Postion of the Element
   @discardableResult
@@ -529,13 +811,13 @@
     var numOfFields: Int = 0
     /// Last written Index
     var writtenIndex: Int = 0
-    /// the amount of added elements into the buffer
-    var addedElements: Int { capacity - (numOfFields &* size) }
 
     /// Creates the memory to store the buffer in
     @usableFromInline
     init() {
-      memory = UnsafeMutableRawBufferPointer.allocate(byteCount: 0, alignment: 0)
+      memory = UnsafeMutableRawBufferPointer.allocate(
+        byteCount: 0,
+        alignment: 0)
     }
 
     deinit {
@@ -555,7 +837,9 @@
     /// and max offset
     /// - Parameter loc: Location of encoded element
     func add(loc: FieldLoc) {
-      memory.baseAddress?.advanced(by: writtenIndex).storeBytes(of: loc, as: FieldLoc.self)
+      memory.baseAddress?.advanced(by: writtenIndex).storeBytes(
+        of: loc,
+        as: FieldLoc.self)
       writtenIndex = writtenIndex &+ size
       numOfFields = numOfFields &+ 1
       maxOffset = max(loc.position, maxOffset)
@@ -574,7 +858,9 @@
     func ensure(space: Int) {
       guard space &+ writtenIndex > capacity else { return }
       memory.deallocate()
-      memory = UnsafeMutableRawBufferPointer.allocate(byteCount: space, alignment: size)
+      memory = UnsafeMutableRawBufferPointer.allocate(
+        byteCount: space,
+        alignment: size)
       capacity = space
     }
 
diff -urN a/swift/Sources/FlatBuffers/FlatBufferObject.swift b/swift/Sources/FlatBuffers/FlatBufferObject.swift
--- a/swift/Sources/FlatBuffers/FlatBufferObject.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/FlatBufferObject.swift	2023-01-13 07:47:12.849288720 +0000
@@ -23,6 +23,8 @@
 /// FlatbuffersInitializable is a protocol that allows any object to be
 /// Initialized from a ByteBuffer
 public protocol FlatbuffersInitializable {
+  /// Any flatbuffers object that confirms to this protocol is going to be
+  /// initializable through this initializer
   init(_ bb: ByteBuffer, o: Int32)
 }
 
@@ -31,15 +33,32 @@
   var __buffer: ByteBuffer! { get }
 }
 
+/// ``ObjectAPIPacker`` is a protocol that allows object to pack and unpack from a
+/// ``NativeObject`` to a flatbuffers Object and vice versa.
 public protocol ObjectAPIPacker {
+  /// associatedtype to the object that should be unpacked.
   associatedtype T
+
+  /// ``pack(_:obj:)-3ptws`` tries to pacs the variables of a native Object into the `ByteBuffer` by using
+  /// a FlatBufferBuilder
+  /// - Parameters:
+  ///   - builder: FlatBufferBuilder that will host incoming data
+  ///   - obj: Object of associatedtype to the current implementer
+  ///
+  /// ``pack(_:obj:)-3ptws`` can be called by passing through an already initialized ``FlatBufferBuilder``
+  /// or it can be called by using the public API that will create a new ``FlatBufferBuilder``
   static func pack(_ builder: inout FlatBufferBuilder, obj: inout T?) -> Offset
+
+  /// ``pack(_:obj:)-20ipk`` packs the variables of a native Object into the `ByteBuffer` by using
+  /// the FlatBufferBuilder
+  /// - Parameters:
+  ///   - builder: FlatBufferBuilder that will host incoming data
+  ///   - obj: Object of associatedtype to the current implementer
+  ///
+  /// ``pack(_:obj:)-20ipk`` can be called by passing through an already initialized ``FlatBufferBuilder``
+  /// or it can be called by using the public API that will create a new ``FlatBufferBuilder``
   static func pack(_ builder: inout FlatBufferBuilder, obj: inout T) -> Offset
-  mutating func unpack() -> T
-}
 
-public protocol Enum {
-  associatedtype T: Scalar
-  static var byteSize: Int { get }
-  var value: T { get }
+  /// ``unpack()`` unpacks a ``FlatBuffers`` object into a Native swift object.
+  mutating func unpack() -> T
 }
diff -urN a/swift/Sources/FlatBuffers/FlatBuffersUtils.swift b/swift/Sources/FlatBuffers/FlatBuffersUtils.swift
--- a/swift/Sources/FlatBuffers/FlatBuffersUtils.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/FlatBuffersUtils.swift	2023-01-13 07:47:12.849288720 +0000
@@ -16,7 +16,8 @@
 
 import Foundation
 
-public final class FlatBuffersUtils {
+/// FlatBuffersUtils hosts some utility functions that might be useful
+public enum FlatBuffersUtils {
 
   /// Gets the size of the prefix
   /// - Parameter bb: Flatbuffer object
@@ -24,8 +25,12 @@
     bb.read(def: Int32.self, position: bb.reader)
   }
 
-  /// Removes the prefix by duplicating the Flatbuffer
+  /// Removes the prefix by duplicating the Flatbuffer this call is expensive since its
+  /// creates a new buffer use `readPrefixedSizeCheckedRoot` instead
+  /// unless a completely new buffer is required
   /// - Parameter bb: Flatbuffer object
+  ///
+  ///
   public static func removeSizePrefix(bb: ByteBuffer) -> ByteBuffer {
     bb.duplicate(removing: MemoryLayout<Int32>.size)
   }
diff -urN a/swift/Sources/FlatBuffers/FlatbuffersErrors.swift b/swift/Sources/FlatBuffers/FlatbuffersErrors.swift
--- a/swift/Sources/FlatBuffers/FlatbuffersErrors.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/FlatbuffersErrors.swift	2023-01-13 07:47:12.849288720 +0000
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import Foundation
+
+/// Collection of thrown from the Flatbuffer verifier
+public enum FlatbuffersErrors: Error, Equatable {
+
+  /// Thrown when buffer is bigger than the allowed 2GiB
+  case exceedsMaxSizeAllowed
+  /// Thrown when there is an missaligned pointer at position
+  /// of type
+  case missAlignedPointer(position: Int, type: String)
+  /// Thrown when trying to read a value that goes out of the
+  /// current buffer bounds
+  case outOfBounds(position: UInt, end: Int)
+  /// Thrown when the signed offset is out of the bounds of the
+  /// current buffer
+  case signedOffsetOutOfBounds(offset: Int, position: Int)
+  /// Thrown when a required field doesnt exist within the buffer
+  case requiredFieldDoesntExist(position: VOffset, name: String)
+  /// Thrown when a string is missing its NULL Terminator `\0`,
+  /// this can be disabled in the `VerifierOptions`
+  case missingNullTerminator(position: Int, str: String?)
+  /// Thrown when the verifier has reached the maximum tables allowed,
+  /// this can be disabled in the `VerifierOptions`
+  case maximumTables
+  /// Thrown when the verifier has reached the maximum depth allowed,
+  /// this can be disabled in the `VerifierOptions`
+  case maximumDepth
+  /// Thrown when the verifier is presented with an unknown union case
+  case unknownUnionCase
+  /// thrown when a value for a union is not found within the buffer
+  case valueNotFound(key: Int?, keyName: String, field: Int?, fieldName: String)
+  /// thrown when the size of the keys vector doesnt match fields vector
+  case unionVectorSize(
+    keyVectorSize: Int,
+    fieldVectorSize: Int,
+    unionKeyName: String,
+    fieldName: String)
+  case apparentSizeTooLarge
+
+  public static func == (
+    lhs: FlatbuffersErrors,
+    rhs: FlatbuffersErrors) -> Bool
+  {
+    lhs.localizedDescription == rhs.localizedDescription
+  }
+}
diff -urN a/swift/Sources/FlatBuffers/Message.swift b/swift/Sources/FlatBuffers/Message.swift
--- a/swift/Sources/FlatBuffers/Message.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Message.swift	2023-01-13 07:47:12.849288720 +0000
@@ -14,6 +14,10 @@
  * limitations under the License.
  */
 
+import Foundation
+
+/// FlatBufferGRPCMessage protocol that should allow us to invoke
+/// initializers directly from the GRPC generated code
 public protocol FlatBufferGRPCMessage {
 
   /// Raw pointer which would be pointing to the beginning of the readable bytes
@@ -34,10 +38,12 @@
   public var object: T {
     T.init(
       buffer,
-      o: Int32(buffer.read(def: UOffset.self, position: buffer.reader)) + Int32(buffer.reader))
+      o: Int32(buffer.read(def: UOffset.self, position: buffer.reader)) +
+        Int32(buffer.reader))
   }
 
-  public var rawPointer: UnsafeMutableRawPointer { buffer.memory.advanced(by: buffer.reader) }
+  public var rawPointer: UnsafeMutableRawPointer {
+    buffer.memory.advanced(by: buffer.reader) }
 
   public var size: Int { Int(buffer.size) }
 
diff -urN a/swift/Sources/FlatBuffers/Mutable.swift b/swift/Sources/FlatBuffers/Mutable.swift
--- a/swift/Sources/FlatBuffers/Mutable.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Mutable.swift	2023-01-13 07:47:12.849288720 +0000
@@ -16,17 +16,17 @@
 
 import Foundation
 
-/// Mutable is a protocol that allows us to mutate Scalar values within the buffer
+/// Mutable is a protocol that allows us to mutate Scalar values within a ``ByteBuffer``
 public protocol Mutable {
   /// makes Flatbuffer accessed within the Protocol
   var bb: ByteBuffer { get }
-  /// makes position of the table/struct  accessed within the Protocol
+  /// makes position of the ``Table``/``struct`` accessed within the Protocol
   var postion: Int32 { get }
 }
 
 extension Mutable {
 
-  /// Mutates the memory in the buffer, this is only called from the access function of table and structs
+  /// Mutates the memory in the buffer, this is only called from the access function of ``Table`` and ``struct``
   /// - Parameters:
   ///   - value: New value to be inserted to the buffer
   ///   - index: index of the Element
@@ -39,7 +39,7 @@
 
 extension Mutable where Self == Table {
 
-  /// Mutates a value by calling mutate with respect to the position in the table
+  /// Mutates a value by calling mutate with respect to the position in a ``Table``
   /// - Parameters:
   ///   - value: New value to be inserted to the buffer
   ///   - index: index of the Element
diff -urN a/swift/Sources/FlatBuffers/NativeObject.swift b/swift/Sources/FlatBuffers/NativeObject.swift
--- a/swift/Sources/FlatBuffers/NativeObject.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/NativeObject.swift	2023-01-13 07:47:12.849288720 +0000
@@ -16,6 +16,9 @@
 
 import Foundation
 
+/// NativeObject is a protocol that all of the `Object-API` generated code should be
+/// conforming to since it allows developers the ease of use to pack and unpack their
+/// Flatbuffers objects
 public protocol NativeObject {}
 
 extension NativeObject {
@@ -23,7 +26,9 @@
   /// Serialize is a helper function that serailizes the data from the Object API to a bytebuffer directly th
   /// - Parameter type: Type of the Flatbuffer object
   /// - Returns: returns the encoded sized ByteBuffer
-  public func serialize<T: ObjectAPIPacker>(type: T.Type) -> ByteBuffer where T.T == Self {
+  public func serialize<T: ObjectAPIPacker>(type: T.Type) -> ByteBuffer
+    where T.T == Self
+  {
     var builder = FlatBufferBuilder(initialSize: 1024)
     return serialize(builder: &builder, type: type.self)
   }
@@ -36,7 +41,10 @@
   /// - Returns: returns the encoded sized ByteBuffer
   /// - Note: The `serialize(builder:type)` can be considered as a function that allows you to create smaller builder instead of the default `1024`.
   ///  It can be considered less expensive in terms of memory allocation
-  public func serialize<T: ObjectAPIPacker>(builder: inout FlatBufferBuilder, type: T.Type) -> ByteBuffer where T.T == Self {
+  public func serialize<T: ObjectAPIPacker>(
+    builder: inout FlatBufferBuilder,
+    type: T.Type) -> ByteBuffer where T.T == Self
+  {
     var s = self
     let root = type.pack(&builder, obj: &s)
     builder.finish(offset: root)
diff -urN a/swift/Sources/FlatBuffers/Root.swift b/swift/Sources/FlatBuffers/Root.swift
--- a/swift/Sources/FlatBuffers/Root.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Root.swift	2023-01-13 07:47:12.850288729 +0000
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import Foundation
+
+/// Takes in a prefixed sized buffer, where the prefixed size would be skipped.
+/// And would verify that the buffer passed is a valid `Flatbuffers` Object.
+/// - Parameters:
+///   - byteBuffer: Buffer that needs to be checked and read
+///   - options: Verifier options
+/// - Throws: FlatbuffersErrors
+/// - Returns: Returns a valid, checked Flatbuffers object
+///
+/// ``getPrefixedSizeCheckedRoot(byteBuffer:options:)`` would skip the first Bytes in
+/// the ``ByteBuffer`` and verifies the buffer by calling ``getCheckedRoot(byteBuffer:options:)``
+public func getPrefixedSizeCheckedRoot<T: FlatBufferObject & Verifiable>(
+  byteBuffer: inout ByteBuffer,
+  options: VerifierOptions = .init()) throws -> T
+{
+  byteBuffer.skipPrefix()
+  return try getCheckedRoot(byteBuffer: &byteBuffer, options: options)
+}
+
+/// Takes in a prefixed sized buffer, where the prefixed size would be skipped.
+/// Returns a `NON-Checked` flatbuffers object
+/// - Parameter byteBuffer: Buffer that contains data
+/// - Returns: Returns a Flatbuffers object
+///
+/// ``getPrefixedSizeCheckedRoot(byteBuffer:options:)`` would skip the first Bytes in
+/// the ``ByteBuffer`` and then calls ``getRoot(byteBuffer:)``
+public func getPrefixedSizeRoot<T: FlatBufferObject>(byteBuffer: inout ByteBuffer)
+  -> T
+{
+  byteBuffer.skipPrefix()
+  return getRoot(byteBuffer: &byteBuffer)
+
+}
+
+/// Verifies that the buffer passed is a valid `Flatbuffers` Object.
+/// - Parameters:
+///   - byteBuffer: Buffer that needs to be checked and read
+///   - options: Verifier options
+/// - Throws: FlatbuffersErrors
+/// - Returns: Returns a valid, checked Flatbuffers object
+///
+/// ``getCheckedRoot(byteBuffer:options:)`` Takes in a ``ByteBuffer`` and verifies
+/// that by creating a ``Verifier`` and checkes if all the `Bytes` and correctly aligned
+/// and within the ``ByteBuffer`` range.
+public func getCheckedRoot<T: FlatBufferObject & Verifiable>(
+  byteBuffer: inout ByteBuffer,
+  options: VerifierOptions = .init()) throws -> T
+{
+  var verifier = try Verifier(buffer: &byteBuffer, options: options)
+  try ForwardOffset<T>.verify(&verifier, at: 0, of: T.self)
+  return T.init(
+    byteBuffer,
+    o: Int32(byteBuffer.read(def: UOffset.self, position: byteBuffer.reader)) +
+      Int32(byteBuffer.reader))
+}
+
+/// Returns a `NON-Checked` flatbuffers object
+/// - Parameter byteBuffer: Buffer that contains data
+/// - Returns: Returns a Flatbuffers object
+public func getRoot<T: FlatBufferObject>(byteBuffer: inout ByteBuffer) -> T {
+  T.init(
+    byteBuffer,
+    o: Int32(byteBuffer.read(def: UOffset.self, position: byteBuffer.reader)) +
+      Int32(byteBuffer.reader))
+}
diff -urN a/swift/Sources/FlatBuffers/String+extension.swift b/swift/Sources/FlatBuffers/String+extension.swift
--- a/swift/Sources/FlatBuffers/String+extension.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/String+extension.swift	2023-01-13 07:47:12.850288729 +0000
@@ -16,6 +16,44 @@
 
 import Foundation
 
+extension String: Verifiable {
+
+  /// Verifies that the current value is which the bounds of the buffer, and if
+  /// the current `Value` is aligned properly
+  /// - Parameters:
+  ///   - verifier: Verifier that hosts the buffer
+  ///   - position: Current position within the buffer
+  ///   - type: The type of the object to be verified
+  /// - Throws: Errors coming from `inBuffer`, `missingNullTerminator` and `outOfBounds`
+  public static func verify<T>(
+    _ verifier: inout Verifier,
+    at position: Int,
+    of type: T.Type) throws where T: Verifiable
+  {
+
+    let range = try String.verifyRange(&verifier, at: position, of: UInt8.self)
+    /// Safe &+ since we already check for overflow in verify range
+    let stringLen = range.start &+ range.count
+
+    if stringLen >= verifier.capacity {
+      throw FlatbuffersErrors.outOfBounds(
+        position: UInt(clamping: stringLen.magnitude),
+        end: verifier.capacity)
+    }
+
+    let isNullTerminated = verifier._buffer.read(
+      def: UInt8.self,
+      position: stringLen) == 0
+
+    if !verifier._options._ignoreMissingNullTerminators && !isNullTerminated {
+      let str = verifier._buffer.readString(at: range.start, count: range.count)
+      throw FlatbuffersErrors.missingNullTerminator(
+        position: position,
+        str: str)
+    }
+  }
+}
+
 extension String: FlatbuffersInitializable {
 
   /// Initailizes a string from a Flatbuffers ByteBuffer
@@ -23,21 +61,28 @@
   ///   - bb: ByteBuffer containing the readable string
   ///   - o: Current position
   public init(_ bb: ByteBuffer, o: Int32) {
-    let count = bb.read(def: Int32.self, position: Int(o))
+    let v = Int(o)
+    let count = bb.read(def: Int32.self, position: v)
     self = bb.readString(
-      at: Int32(MemoryLayout<Int32>.size) + o,
-      count: count) ?? ""
+      at: MemoryLayout<Int32>.size + v,
+      count: Int(count)) ?? ""
   }
 }
 
 extension String: ObjectAPIPacker {
 
-  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout String?) -> Offset {
+  public static func pack(
+    _ builder: inout FlatBufferBuilder,
+    obj: inout String?) -> Offset
+  {
     guard var obj = obj else { return Offset() }
     return pack(&builder, obj: &obj)
   }
 
-  public static func pack(_ builder: inout FlatBufferBuilder, obj: inout String) -> Offset {
+  public static func pack(
+    _ builder: inout FlatBufferBuilder,
+    obj: inout String) -> Offset
+  {
     builder.create(string: obj)
   }
 
@@ -49,11 +94,16 @@
 
 extension String: NativeObject {
 
-  public func serialize<T: ObjectAPIPacker>(type: T.Type) -> ByteBuffer where T.T == Self {
+  public func serialize<T: ObjectAPIPacker>(type: T.Type) -> ByteBuffer
+    where T.T == Self
+  {
     fatalError("serialize should never be called from string directly")
   }
 
-  public func serialize<T: ObjectAPIPacker>(builder: inout FlatBufferBuilder, type: T.Type) -> ByteBuffer where T.T == Self {
+  public func serialize<T: ObjectAPIPacker>(
+    builder: inout FlatBufferBuilder,
+    type: T.Type) -> ByteBuffer where T.T == Self
+  {
     fatalError("serialize should never be called from string directly")
   }
 }
diff -urN a/swift/Sources/FlatBuffers/Struct.swift b/swift/Sources/FlatBuffers/Struct.swift
--- a/swift/Sources/FlatBuffers/Struct.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Struct.swift	2023-01-13 07:47:12.850288729 +0000
@@ -16,16 +16,30 @@
 
 import Foundation
 
+/// Struct is a representation of a mutable `Flatbuffers` struct
+/// since native structs are value types and cant be mutated
 @frozen
 public struct Struct {
+
+  /// Hosting Bytebuffer
   public private(set) var bb: ByteBuffer
+  /// Current position of the struct
   public private(set) var postion: Int32
 
+  /// Initializer for a mutable flatbuffers struct
+  /// - Parameters:
+  ///   - bb: Current hosting Bytebuffer
+  ///   - position: Current position for the struct in the ByteBuffer
   public init(bb: ByteBuffer, position: Int32 = 0) {
     self.bb = bb
     postion = position
   }
 
+  /// Reads data from the buffer directly at offset O
+  /// - Parameters:
+  ///   - type: Type of data to be read
+  ///   - o: Current offset of the data
+  /// - Returns: Data of Type T that conforms to type Scalar
   public func readBuffer<T: Scalar>(of type: T.Type, at o: Int32) -> T {
     let r = bb.read(def: T.self, position: Int(o + postion))
     return r
diff -urN a/swift/Sources/FlatBuffers/Table.swift b/swift/Sources/FlatBuffers/Table.swift
--- a/swift/Sources/FlatBuffers/Table.swift	2021-05-10 18:45:16.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Table.swift	2023-01-13 07:47:12.850288729 +0000
@@ -16,27 +16,50 @@
 
 import Foundation
 
+/// `Table` is a Flatbuffers object that can read,
+/// mutate scalar fields within a valid flatbuffers buffer
 @frozen
 public struct Table {
+
+  /// Hosting Bytebuffer
   public private(set) var bb: ByteBuffer
+  /// Current position of the table within the buffer
   public private(set) var postion: Int32
 
+  /// Initializer for the table interface to allow generated code to read
+  /// data from memory
+  /// - Parameters:
+  ///   - bb: ByteBuffer that stores data
+  ///   - position: Current table position
+  /// - Note: This will `CRASH` if read on a big endian machine
   public init(bb: ByteBuffer, position: Int32 = 0) {
     guard isLitteEndian else {
-      fatalError("Reading/Writing a buffer in big endian machine is not supported on swift")
+      fatalError(
+        "Reading/Writing a buffer in big endian machine is not supported on swift")
     }
     self.bb = bb
     postion = position
   }
 
+  /// Gets the offset of the current field within the buffer by reading
+  /// the vtable
+  /// - Parameter o: current offset
+  /// - Returns: offset of field within buffer
   public func offset(_ o: Int32) -> Int32 {
     let vtable = postion - bb.read(def: Int32.self, position: Int(postion))
-    return o < bb.read(def: VOffset.self, position: Int(vtable)) ? Int32(bb.read(
-      def: Int16.self,
-      position: Int(vtable + o))) : 0
+    return o < bb
+      .read(def: VOffset.self, position: Int(vtable)) ? Int32(bb.read(
+        def: Int16.self,
+        position: Int(vtable + o))) : 0
   }
 
-  public func indirect(_ o: Int32) -> Int32 { o + bb.read(def: Int32.self, position: Int(o)) }
+  /// Gets the indirect offset of the current stored object
+  /// (applicable only for object arrays)
+  /// - Parameter o: current offset
+  /// - Returns: offset of field within buffer
+  public func indirect(_ o: Int32) -> Int32 {
+    o + bb.read(def: Int32.self, position: Int(o))
+  }
 
   /// String reads from the buffer with respect to position of the current table.
   /// - Parameter offset: Offset of the string
@@ -45,14 +68,15 @@
   }
 
   /// Direct string reads from the buffer disregarding the position of the table.
-  /// It would be preferable to use string unless the current position of the table is not needed
+  /// It would be preferable to use string unless the current position of the table
+  /// is not needed
   /// - Parameter offset: Offset of the string
   public func directString(at offset: Int32) -> String? {
     var offset = offset
     offset += bb.read(def: Int32.self, position: Int(offset))
     let count = bb.read(def: Int32.self, position: Int(offset))
-    let position = offset + Int32(MemoryLayout<Int32>.size)
-    return bb.readString(at: position, count: count)
+    let position = Int(offset) + MemoryLayout<Int32>.size
+    return bb.readString(at: position, count: Int(count))
   }
 
   /// Reads from the buffer with respect to the position in the table.
@@ -81,19 +105,30 @@
     return r
   }
 
+  /// Returns that current `Union` object at a specific offset
+  /// by adding offset to the current position of table
+  /// - Parameter o: offset
+  /// - Returns: A flatbuffers object
   public func union<T: FlatbuffersInitializable>(_ o: Int32) -> T {
     let o = o + postion
     return directUnion(o)
   }
 
+  /// Returns a direct `Union` object at a specific offset
+  /// - Parameter o: offset
+  /// - Returns: A flatbuffers object
   public func directUnion<T: FlatbuffersInitializable>(_ o: Int32) -> T {
     T.init(bb, o: o + bb.read(def: Int32.self, position: Int(o)))
   }
 
+  /// Returns a vector of type T at a specific offset
+  /// This should only be used by `Scalars`
+  /// - Parameter off: Readable offset
+  /// - Returns: Returns a vector of type [T]
   public func getVector<T>(at off: Int32) -> [T]? {
     let o = offset(off)
     guard o != 0 else { return nil }
-    return bb.readSlice(index: vector(at: o), count: vector(count: o))
+    return bb.readSlice(index: Int(vector(at: o)), count: Int(vector(count: o)))
   }
 
   /// Vector count gets the count of Elements within the array
@@ -115,18 +150,45 @@
     return o + bb.read(def: Int32.self, position: Int(o)) + 4
   }
 
-  static public func indirect(_ o: Int32, _ fbb: ByteBuffer) -> Int32 { o + fbb.read(
-    def: Int32.self,
-    position: Int(o)) }
+  /// Reading an indirect offset of a table.
+  /// - Parameters:
+  ///   - o: position within the buffer
+  ///   - fbb: ByteBuffer
+  /// - Returns: table offset
+  static public func indirect(_ o: Int32, _ fbb: ByteBuffer) -> Int32 {
+    o + fbb.read(def: Int32.self, position: Int(o))
+  }
 
-  static public func offset(_ o: Int32, vOffset: Int32, fbb: ByteBuffer) -> Int32 {
+  /// Gets a vtable value according to an table Offset and a field offset
+  /// - Parameters:
+  ///   - o: offset relative to entire buffer
+  ///   - vOffset: Field offset within a vtable
+  ///   - fbb: ByteBuffer
+  /// - Returns: an position of a field
+  static public func offset(
+    _ o: Int32,
+    vOffset: Int32,
+    fbb: ByteBuffer) -> Int32
+  {
     let vTable = Int32(fbb.capacity) - o
     return vTable + Int32(fbb.read(
       def: Int16.self,
-      position: Int(vTable + vOffset - fbb.read(def: Int32.self, position: Int(vTable)))))
+      position: Int(vTable + vOffset - fbb.read(
+        def: Int32.self,
+        position: Int(vTable)))))
   }
 
-  static public func compare(_ off1: Int32, _ off2: Int32, fbb: ByteBuffer) -> Int32 {
+  /// Compares two objects at offset A and offset B within a ByteBuffer
+  /// - Parameters:
+  ///   - off1: first offset to compare
+  ///   - off2: second offset to compare
+  ///   - fbb: Bytebuffer
+  /// - Returns: returns the difference between
+  static public func compare(
+    _ off1: Int32,
+    _ off2: Int32,
+    fbb: ByteBuffer) -> Int32
+  {
     let memorySize = Int32(MemoryLayout<Int32>.size)
     let _off1 = off1 + fbb.read(def: Int32.self, position: Int(off1))
     let _off2 = off2 + fbb.read(def: Int32.self, position: Int(off2))
@@ -145,7 +207,17 @@
     return len1 - len2
   }
 
-  static public func compare(_ off1: Int32, _ key: [Byte], fbb: ByteBuffer) -> Int32 {
+  /// Compares two objects at offset A and array of `Bytes` within a ByteBuffer
+  /// - Parameters:
+  ///   - off1: Offset to compare to
+  ///   - key: bytes array to compare to
+  ///   - fbb: Bytebuffer
+  /// - Returns: returns the difference between
+  static public func compare(
+    _ off1: Int32,
+    _ key: [Byte],
+    fbb: ByteBuffer) -> Int32
+  {
     let memorySize = Int32(MemoryLayout<Int32>.size)
     let _off1 = off1 + fbb.read(def: Int32.self, position: Int(off1))
     let len1 = fbb.read(def: Int32.self, position: Int(_off1))
diff -urN a/swift/Sources/FlatBuffers/TableVerifier.swift b/swift/Sources/FlatBuffers/TableVerifier.swift
--- a/swift/Sources/FlatBuffers/TableVerifier.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/TableVerifier.swift	2023-01-13 07:47:12.850288729 +0000
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import Foundation
+
+/// `TableVerifier` verifies a table object is within a provided memory.
+/// It checks if all the objects for a specific generated table, are within
+/// the bounds of the buffer, aligned.
+public struct TableVerifier {
+
+  /// position of current table in `ByteBuffer`
+  fileprivate var _position: Int
+
+  /// Current VTable position
+  fileprivate var _vtable: Int
+
+  /// Length of current VTable
+  fileprivate var _vtableLength: Int
+
+  /// `Verifier` object created in the base verifable call.
+  fileprivate var _verifier: Verifier
+
+  /// Creates a `TableVerifier` verifier that allows the Flatbuffer object
+  /// to verify the buffer before accessing any of the data.
+  ///
+  /// - Parameters:
+  ///   - position: Current table Position
+  ///   - vtable: Current `VTable` position
+  ///   - vtableLength: Current `VTable` length
+  ///   - verifier: `Verifier` Object  that caches the data of the verifiable object
+  internal init(
+    position: Int,
+    vtable: Int,
+    vtableLength: Int,
+    verifier: inout Verifier)
+  {
+    _position = position
+    _vtable = vtable
+    _vtableLength = vtableLength
+    _verifier = verifier
+  }
+
+  /// Dereference the current object position from the `VTable`
+  /// - Parameter field: Current VTable refrence to  position.
+  /// - Throws: A `FlatbuffersErrors` incase the voffset is not aligned/outOfBounds/apparentSizeTooLarge
+  /// - Returns: An optional position for current field
+  internal mutating func dereference(_ field: VOffset) throws -> Int? {
+    if field >= _vtableLength {
+      return nil
+    }
+
+    /// Reading the offset for the field needs to be read.
+    let offset: VOffset = try _verifier.getValue(
+      at: Int(clamping: _vtable &+ Int(field)))
+
+    if offset > 0 {
+      return Int(clamping: _position &+ Int(offset))
+    }
+    return nil
+  }
+
+  /// Visits all the fields within the table to validate the integrity
+  /// of the data
+  /// - Parameters:
+  ///   - field: voffset of the current field to be read
+  ///   - fieldName: fieldname to report data Errors.
+  ///   - required: If the field has to be available in the buffer
+  ///   - type: Type of field to be read
+  /// - Throws: A `FlatbuffersErrors` where the field is corrupt
+  public mutating func visit<T>(
+    field: VOffset,
+    fieldName: String,
+    required: Bool,
+    type: T.Type) throws where T: Verifiable
+  {
+    let derefValue = try dereference(field)
+
+    if let value = derefValue {
+      try T.verify(&_verifier, at: value, of: T.self)
+      return
+    }
+    if required {
+      throw FlatbuffersErrors.requiredFieldDoesntExist(
+        position: field,
+        name: fieldName)
+    }
+  }
+
+  /// Visits all the fields for a union object within the table to
+  /// validate the integrity of the data
+  /// - Parameters:
+  ///   - key: Current Key Voffset
+  ///   - field: Current field Voffset
+  ///   - unionKeyName: Union key name
+  ///   - fieldName: Field key name
+  ///   - required: indicates if an object is required to be present
+  ///   - completion: Completion is a handler that WILL be called in the generated
+  /// - Throws: A `FlatbuffersErrors` where the field is corrupt
+  public mutating func visit<T>(
+    unionKey key: VOffset,
+    unionField field: VOffset,
+    unionKeyName: String,
+    fieldName: String,
+    required: Bool,
+    completion: @escaping (inout Verifier, T, Int) throws -> Void) throws
+    where T: UnionEnum
+  {
+    let keyPos = try dereference(key)
+    let valPos = try dereference(field)
+
+    if keyPos == nil && valPos == nil {
+      if required {
+        throw FlatbuffersErrors.requiredFieldDoesntExist(
+          position: key,
+          name: unionKeyName)
+      }
+      return
+    }
+
+    if let _key = keyPos,
+       let _val = valPos
+    {
+      /// verifiying that the key is within the buffer
+      try T.T.verify(&_verifier, at: _key, of: T.T.self)
+      guard let _enum = try T.init(value: _verifier._buffer.read(
+        def: T.T.self,
+        position: _key)) else
+      {
+        throw FlatbuffersErrors.unknownUnionCase
+      }
+      /// we are assuming that Unions will always be of type Uint8
+      try completion(
+        &_verifier,
+        _enum,
+        _val)
+      return
+    }
+    throw FlatbuffersErrors.valueNotFound(
+      key: keyPos,
+      keyName: unionKeyName,
+      field: valPos,
+      fieldName: fieldName)
+  }
+
+  /// Visits and validates all the objects within a union vector
+  /// - Parameters:
+  ///   - key: Current Key Voffset
+  ///   - field: Current field Voffset
+  ///   - unionKeyName: Union key name
+  ///   - fieldName: Field key name
+  ///   - required: indicates if an object is required to be present
+  ///   - completion: Completion is a handler that WILL be called in the generated
+  /// - Throws: A `FlatbuffersErrors` where the field is corrupt
+  public mutating func visitUnionVector<T>(
+    unionKey key: VOffset,
+    unionField field: VOffset,
+    unionKeyName: String,
+    fieldName: String,
+    required: Bool,
+    completion: @escaping (inout Verifier, T, Int) throws -> Void) throws
+    where T: UnionEnum
+  {
+    let keyVectorPosition = try dereference(key)
+    let offsetVectorPosition = try dereference(field)
+
+    if let keyPos = keyVectorPosition,
+       let valPos = offsetVectorPosition
+    {
+      try UnionVector<T>.verify(
+        &_verifier,
+        keyPosition: keyPos,
+        fieldPosition: valPos,
+        unionKeyName: unionKeyName,
+        fieldName: fieldName,
+        completion: completion)
+      return
+    }
+    if required {
+      throw FlatbuffersErrors.requiredFieldDoesntExist(
+        position: field,
+        name: fieldName)
+    }
+  }
+
+  /// Finishs the current Table verifier, and subtracts the current
+  /// table from the incremented depth.
+  public mutating func finish() {
+    _verifier.finish()
+  }
+}
diff -urN a/swift/Sources/FlatBuffers/VeriferOptions.swift b/swift/Sources/FlatBuffers/VeriferOptions.swift
--- a/swift/Sources/FlatBuffers/VeriferOptions.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/VeriferOptions.swift	2023-01-13 07:47:12.850288729 +0000
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import Foundation
+
+/// `VerifierOptions` is a set of options to verify a flatbuffer
+public struct VerifierOptions {
+
+  /// Maximum `Apparent` size if the buffer can be expanded into a DAG tree
+  internal var _maxApparentSize: UOffset
+
+  /// Maximum table count allowed in a buffer
+  internal var _maxTableCount: UOffset
+
+  /// Maximum depth allowed in a buffer
+  internal var _maxDepth: UOffset
+
+  /// Ignoring missing null terminals in strings
+  internal var _ignoreMissingNullTerminators: Bool
+
+  /// initializes the set of options for the verifier
+  /// - Parameters:
+  ///   - maxDepth: Maximum depth allowed in a buffer
+  ///   - maxTableCount: Maximum table count allowed in a buffer
+  ///   - maxApparentSize: Maximum `Apparent` size if the buffer can be expanded into a DAG tree
+  ///   - ignoreMissingNullTerminators: Ignoring missing null terminals in strings *Currently not supported in swift*
+  public init(
+    maxDepth: UOffset = 64,
+    maxTableCount: UOffset = 1000000,
+    maxApparentSize: UOffset = 1 << 31,
+    ignoreMissingNullTerminators: Bool = false)
+  {
+    _maxDepth = maxDepth
+    _maxTableCount = maxTableCount
+    _maxApparentSize = maxApparentSize
+    _ignoreMissingNullTerminators = ignoreMissingNullTerminators
+  }
+
+}
diff -urN a/swift/Sources/FlatBuffers/Verifiable.swift b/swift/Sources/FlatBuffers/Verifiable.swift
--- a/swift/Sources/FlatBuffers/Verifiable.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Verifiable.swift	2023-01-13 07:47:12.850288729 +0000
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import Foundation
+
+/// Verifiable is a protocol all swift flatbuffers object should conform to,
+/// since swift is similar to `cpp` and `rust` where the data is read directly
+/// from `unsafeMemory` thus the need to verify if the buffer received is a valid one
+public protocol Verifiable {
+
+  /// Verifies that the current value is which the bounds of the buffer, and if
+  /// the current `Value` is aligned properly
+  /// - Parameters:
+  ///   - verifier: Verifier that hosts the buffer
+  ///   - position: Current position within the buffer
+  ///   - type: The type of the object to be verified
+  /// - Throws: Errors coming from `inBuffer` function
+  static func verify<T>(
+    _ verifier: inout Verifier,
+    at position: Int,
+    of type: T.Type) throws where T: Verifiable
+}
+
+extension Verifiable {
+
+  /// Verifies if the current range to be read is within the bounds of the buffer,
+  /// and if the range is properly aligned
+  /// - Parameters:
+  ///   - verifier: Verifier that hosts the buffer
+  ///   - position: Current position within the buffer
+  ///   - type: The type of the object to be verified
+  /// - Throws: Erros thrown from `isAligned` & `rangeInBuffer`
+  /// - Returns: a tuple of the start position and the count of objects within the range
+  @discardableResult
+  public static func verifyRange<T>(
+    _ verifier: inout Verifier,
+    at position: Int, of type: T.Type) throws -> (start: Int, count: Int)
+  {
+    let len: UOffset = try verifier.getValue(at: position)
+    let intLen = Int(len)
+    let start = Int(clamping: (position &+ MemoryLayout<Int32>.size).magnitude)
+    try verifier.isAligned(position: start, type: type.self)
+    try verifier.rangeInBuffer(position: start, size: intLen)
+    return (start, intLen)
+  }
+}
+
+extension Verifiable where Self: Scalar {
+
+  /// Verifies that the current value is which the bounds of the buffer, and if
+  /// the current `Value` is aligned properly
+  /// - Parameters:
+  ///   - verifier: Verifier that hosts the buffer
+  ///   - position: Current position within the buffer
+  ///   - type: The type of the object to be verified
+  /// - Throws: Errors coming from `inBuffer` function
+  public static func verify<T>(
+    _ verifier: inout Verifier,
+    at position: Int,
+    of type: T.Type) throws where T: Verifiable
+  {
+    try verifier.inBuffer(position: position, of: type.self)
+  }
+}
+
+// MARK: - ForwardOffset
+
+/// ForwardOffset is a container to wrap around the Generic type to be verified
+/// from the flatbuffers object.
+public enum ForwardOffset<U>: Verifiable where U: Verifiable {
+
+  /// Verifies that the current value is which the bounds of the buffer, and if
+  /// the current `Value` is aligned properly
+  /// - Parameters:
+  ///   - verifier: Verifier that hosts the buffer
+  ///   - position: Current position within the buffer
+  ///   - type: The type of the object to be verified
+  /// - Throws: Errors coming from `inBuffer` function
+  public static func verify<T>(
+    _ verifier: inout Verifier,
+    at position: Int,
+    of type: T.Type) throws where T: Verifiable
+  {
+    let offset: UOffset = try verifier.getValue(at: position)
+    let nextOffset = Int(clamping: (Int(offset) &+ position).magnitude)
+    try U.verify(&verifier, at: nextOffset, of: U.self)
+  }
+}
+
+// MARK: - Vector
+
+/// Vector is a container to wrap around the Generic type to be verified
+/// from the flatbuffers object.
+public enum Vector<U, S>: Verifiable where U: Verifiable, S: Verifiable {
+
+  /// Verifies that the current value is which the bounds of the buffer, and if
+  /// the current `Value` is aligned properly
+  /// - Parameters:
+  ///   - verifier: Verifier that hosts the buffer
+  ///   - position: Current position within the buffer
+  ///   - type: The type of the object to be verified
+  /// - Throws: Errors coming from `inBuffer` function
+  public static func verify<T>(
+    _ verifier: inout Verifier,
+    at position: Int,
+    of type: T.Type) throws where T: Verifiable
+  {
+    /// checks if the next verification type S is equal to U of type forwardOffset
+    /// This had to be done since I couldnt find a solution for duplicate call functions
+    /// A fix will be appreciated
+    if U.self is ForwardOffset<S>.Type {
+      let range = try verifyRange(&verifier, at: position, of: UOffset.self)
+      for index in stride(
+        from: range.start,
+        to: Int(clamping: range.start &+ range.count),
+        by: MemoryLayout<UOffset>.size)
+      {
+        try U.verify(&verifier, at: index, of: U.self)
+      }
+    } else {
+      try S.verifyRange(&verifier, at: position, of: S.self)
+    }
+  }
+}
+
+// MARK: - UnionVector
+
+/// UnionVector is a container to wrap around the Generic type to be verified
+/// from the flatbuffers object.
+public enum UnionVector<S> where S: UnionEnum {
+
+  /// Completion handler for the function Verify, that passes the verifier
+  /// enum type and position of union field
+  public typealias Completion = (inout Verifier, S, Int) throws -> Void
+
+  /// Verifies if the current range to be read is within the bounds of the buffer,
+  /// and if the range is properly aligned. It also verifies if the union type is a
+  /// *valid/supported* union type.
+  /// - Parameters:
+  ///   - verifier: Verifier that hosts the buffer
+  ///   - keyPosition: Current union key position within the buffer
+  ///   - fieldPosition: Current union field position within the buffer
+  ///   - unionKeyName: Name of key to written if error is presented
+  ///   - fieldName: Name of field to written if error is presented
+  ///   - completion: Completion is a handler that WILL be called in the generated
+  ///   code to verify the actual objects
+  /// - Throws: FlatbuffersErrors
+  public static func verify(
+    _ verifier: inout Verifier,
+    keyPosition: Int,
+    fieldPosition: Int,
+    unionKeyName: String,
+    fieldName: String,
+    completion: @escaping Completion) throws
+  {
+    /// Get offset for union key vectors and offset vectors
+    let keyOffset: UOffset = try verifier.getValue(at: keyPosition)
+    let fieldOffset: UOffset = try verifier.getValue(at: fieldPosition)
+
+    /// Check if values are within the buffer, returns the start position of vectors, and vector counts
+    /// Using &+ is safe since we already verified that the value is within the buffer, where the max is
+    /// going to be 2Gib and swift supports Int64 by default
+    let keysRange = try S.T.verifyRange(
+      &verifier,
+      at: Int(keyOffset) &+ keyPosition,
+      of: S.T.self)
+    let offsetsRange = try UOffset.verifyRange(
+      &verifier,
+      at: Int(fieldOffset) &+ fieldPosition,
+      of: UOffset.self)
+
+    guard keysRange.count == offsetsRange.count else {
+      throw FlatbuffersErrors.unionVectorSize(
+        keyVectorSize: keysRange.count,
+        fieldVectorSize: offsetsRange.count,
+        unionKeyName: unionKeyName,
+        fieldName: fieldName)
+    }
+
+    var count = 0
+    /// Iterate over the vector of keys and offsets.
+    while count < keysRange.count {
+
+      /// index of readable enum value in array
+      let keysIndex = MemoryLayout<S.T>.size * count
+      guard let _enum = try S.init(value: verifier._buffer.read(
+        def: S.T.self,
+        position: keysRange.start + keysIndex)) else
+      {
+        throw FlatbuffersErrors.unknownUnionCase
+      }
+      /// index of readable offset value in array
+      let fieldIndex = MemoryLayout<UOffset>.size * count
+      try completion(&verifier, _enum, offsetsRange.start + fieldIndex)
+      count += 1
+    }
+  }
+}
diff -urN a/swift/Sources/FlatBuffers/Verifier.swift b/swift/Sources/FlatBuffers/Verifier.swift
--- a/swift/Sources/FlatBuffers/Verifier.swift	1970-01-01 00:00:00.000000000 +0000
+++ b/swift/Sources/FlatBuffers/Verifier.swift	2023-01-13 07:47:12.850288729 +0000
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2021 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import Foundation
+
+/// Verifier that check if the buffer passed into it is a valid,
+/// safe, aligned Flatbuffers object since swift read from `unsafeMemory`
+public struct Verifier {
+
+  /// Flag to check for alignment if true
+  fileprivate let _checkAlignment: Bool
+  /// Capacity of the current buffer
+  fileprivate var _capacity: Int
+  /// Current ApparentSize
+  fileprivate var _apparentSize: UOffset = 0
+  /// Amount of tables present within a buffer
+  fileprivate var _tableCount = 0
+
+  /// Capacity of the buffer
+  internal var capacity: Int { _capacity }
+  /// Current reached depth within the buffer
+  internal var _depth = 0
+  /// Current verifiable ByteBuffer
+  internal var _buffer: ByteBuffer
+  /// Options for verification
+  internal let _options: VerifierOptions
+
+  /// Initializer for the verifier
+  /// - Parameters:
+  ///   - buffer: Bytebuffer that is required to be verified
+  ///   - options: `VerifierOptions` that set the rule for some of the verification done
+  ///   - checkAlignment: If alignment check is required to be preformed
+  /// - Throws: `exceedsMaxSizeAllowed` if capacity of the buffer is more than 2GiB
+  public init(
+    buffer: inout ByteBuffer,
+    options: VerifierOptions = .init(),
+    checkAlignment: Bool = true) throws
+  {
+    guard buffer.capacity < FlatBufferMaxSize else {
+      throw FlatbuffersErrors.exceedsMaxSizeAllowed
+    }
+
+    _buffer = buffer
+    _capacity = buffer.capacity
+    _checkAlignment = checkAlignment
+    _options = options
+  }
+
+  /// Resets the verifier to initial state
+  public mutating func reset() {
+    _depth = 0
+    _tableCount = 0
+  }
+
+  /// Checks if the value of type `T` is aligned properly in the buffer
+  /// - Parameters:
+  ///   - position: Current position
+  ///   - type: Type of value to check
+  /// - Throws: `missAlignedPointer` if the pointer is not aligned properly
+  public mutating func isAligned<T>(position: Int, type: T.Type) throws {
+
+    /// If check alignment is false this mutating function doesnt continue
+    if !_checkAlignment { return }
+
+    /// advance pointer to position X
+    let ptr = _buffer._storage.memory.advanced(by: position)
+    /// Check if the pointer is aligned
+    if Int(bitPattern: ptr) & (MemoryLayout<T>.alignment &- 1) == 0 {
+      return
+    }
+
+    throw FlatbuffersErrors.missAlignedPointer(
+      position: position,
+      type: String(describing: T.self))
+  }
+
+  /// Checks if the value of Size "X" is within the range of the buffer
+  /// - Parameters:
+  ///   - position: Current postion to be read
+  ///   - size: `Byte` Size of readable object within the buffer
+  /// - Throws: `outOfBounds` if the value is out of the bounds of the buffer
+  /// and `apparentSizeTooLarge` if the apparent size is bigger than the one specified
+  /// in `VerifierOptions`
+  public mutating func rangeInBuffer(position: Int, size: Int) throws {
+    let end = UInt(clamping: (position &+ size).magnitude)
+    if end > _buffer.capacity {
+      throw FlatbuffersErrors.outOfBounds(position: end, end: capacity)
+    }
+    _apparentSize = _apparentSize &+ UInt32(size)
+    if _apparentSize > _options._maxApparentSize {
+      throw FlatbuffersErrors.apparentSizeTooLarge
+    }
+  }
+
+  /// Validates if a value of type `T` is aligned and within the bounds of
+  /// the buffer
+  /// - Parameters:
+  ///   - position: Current readable position
+  ///   - type: Type of value to check
+  /// - Throws: FlatbuffersErrors
+  public mutating func inBuffer<T>(position: Int, of type: T.Type) throws {
+    try isAligned(position: position, type: type)
+    try rangeInBuffer(position: position, size: MemoryLayout<T>.size)
+  }
+
+  /// Visits a table at the current position and validates if the table meets
+  /// the rules specified in the `VerifierOptions`
+  /// - Parameter position: Current position to be read
+  /// - Throws: FlatbuffersErrors
+  /// - Returns: A `TableVerifier` at the current readable table
+  public mutating func visitTable(at position: Int) throws -> TableVerifier {
+    let vtablePosition = try derefOffset(position: position)
+    let vtableLength: VOffset = try getValue(at: vtablePosition)
+
+    let length = Int(vtableLength)
+    try isAligned(
+      position: Int(clamping: (vtablePosition + length).magnitude),
+      type: VOffset.self)
+    try rangeInBuffer(position: vtablePosition, size: length)
+
+    _tableCount += 1
+
+    if _tableCount > _options._maxTableCount {
+      throw FlatbuffersErrors.maximumTables
+    }
+
+    _depth += 1
+
+    if _depth > _options._maxDepth {
+      throw FlatbuffersErrors.maximumDepth
+    }
+
+    return TableVerifier(
+      position: position,
+      vtable: vtablePosition,
+      vtableLength: length,
+      verifier: &self)
+  }
+
+  /// Validates if a value of type `T` is within the buffer and returns it
+  /// - Parameter position: Current position to be read
+  /// - Throws: `inBuffer` errors
+  /// - Returns: a value of type `T` usually a `VTable` or a table offset
+  internal mutating func getValue<T>(at position: Int) throws -> T {
+    try inBuffer(position: position, of: T.self)
+    return _buffer.read(def: T.self, position: position)
+  }
+
+  /// derefrences an offset within a vtable to get the position of the field
+  /// in the bytebuffer
+  /// - Parameter position: Current readable position
+  /// - Throws: `inBuffer` errors & `signedOffsetOutOfBounds`
+  /// - Returns: Current readable position for a field
+  @inline(__always)
+  internal mutating func derefOffset(position: Int) throws -> Int {
+    try inBuffer(position: position, of: Int32.self)
+
+    let offset = _buffer.read(def: Int32.self, position: position)
+    // switching to int32 since swift's default Int is int64
+    // this should be safe since we already checked if its within
+    // the buffer
+    let _int32Position = UInt32(position)
+
+    let reportedOverflow: (partialValue: UInt32, overflow: Bool)
+    if offset > 0 {
+      reportedOverflow = _int32Position
+        .subtractingReportingOverflow(offset.magnitude)
+    } else {
+      reportedOverflow = _int32Position
+        .addingReportingOverflow(offset.magnitude)
+    }
+
+    /// since `subtractingReportingOverflow` & `addingReportingOverflow` returns true,
+    /// if there is overflow we return failure
+    if reportedOverflow.overflow || reportedOverflow.partialValue > _buffer
+      .capacity
+    {
+      throw FlatbuffersErrors.signedOffsetOutOfBounds(
+        offset: Int(offset),
+        position: position)
+    }
+
+    return Int(reportedOverflow.partialValue)
+  }
+
+  /// finishes the current iteration of verification on an object
+  internal mutating func finish() {
+    _depth -= 1
+  }
+}
diff -urN a/swift.swiftformat b/swift.swiftformat
--- a/swift.swiftformat	2021-05-10 18:45:16.000000000 +0000
+++ b/swift.swiftformat	2023-01-13 07:47:09.939261845 +0000
@@ -2,6 +2,7 @@
 
 # format
 --indent 2
+--maxwidth 80
 
 # options
 --self remove # redundantSelf
@@ -16,10 +17,11 @@
 --typeattributes prev-line # wrapAttributes
 
 # rules
---rules todos,anyObjectProtocol,redundantParens,redundantReturn,redundantSelf,sortedImports,strongifiedSelf,trailingCommas,trailingSpace,wrapArguments,wrapMultilineStatementBraces,indent,wrapAttributes,void,fileHeader
+--rules wrap,todos,anyObjectProtocol,redundantParens,redundantReturn,redundantSelf,sortedImports,strongifiedSelf,trailingCommas,trailingSpace,wrapArguments,wrapMultilineStatementBraces,indent,wrapAttributes,void,fileHeader
 --disable trailingclosures
 
 --exclude **/*_generated.swift
+--exclude **/swift_code_*.swift
 --exclude **/*.grpc.swift
 
 --header "/*\n * Copyright {year} Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */"
\ No newline at end of file
