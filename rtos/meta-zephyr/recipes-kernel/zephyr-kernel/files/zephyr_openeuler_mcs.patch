diff --git a/boards/qemu/cortex_a53/Kconfig.defconfig b/boards/qemu/cortex_a53/Kconfig.defconfig
index 70fe11c6d73..c0b78c1f0b8 100644
--- a/boards/qemu/cortex_a53/Kconfig.defconfig
+++ b/boards/qemu/cortex_a53/Kconfig.defconfig
@@ -42,5 +42,11 @@ config QEMU_ICOUNT_SLEEP
 	default y
 
 endif # QEMU_ICOUNT
+if IPM
+
+config IPM_GIC_SGI
+	default y
+
+endif # IPM
 
 endif # BOARD_QEMU_CORTEX_A53
diff --git a/boards/qemu/cortex_a53/board.yml b/boards/qemu/cortex_a53/board.yml
index ab04f6ac8f1..89303f59086 100644
--- a/boards/qemu/cortex_a53/board.yml
+++ b/boards/qemu/cortex_a53/board.yml
@@ -6,3 +6,5 @@ board:
     variants:
     - name: smp
     - name: xip
+    - name: remote
+    - name: ivshmem
diff --git a/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_ivshmem.dts b/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_ivshmem.dts
new file mode 100644
index 00000000000..fbbd693f495
--- /dev/null
+++ b/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_ivshmem.dts
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2019 Carlo Caione <ccaione@baylibre.com>
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ */
+
+/dts-v1/;
+#include <arm64/qemu/qemu-virt-a53.dtsi>
+#include <zephyr/dt-bindings/pcie/pcie.h>
+
+/ {
+	model = "QEMU Cortex-A53";
+	compatible = "qemu,arm-cortex-a53";
+
+	psci {
+		compatible = "arm,psci-0.2";
+		method = "hvc";
+		label = "PSCI";
+	};
+
+	chosen {
+		zephyr,sram = &sram1;
+		/* uart0 is used for debug, which also may be used by Linux */
+		zephyr,console = &uart0;
+		zephyr,shell-uart = &uart_rpmsg0;
+		zephyr,flash = &flash0;
+		zephyr,pcie-controller = &pcie_jailhouse;
+	};
+
+	uart_rpmsg0: ep0 {
+		status = "okay";
+		compatible = "zephyr,rpmsg-uart";
+		/* the rpmsg-tty driver requires ep-name should be rpmsg-tty* */
+		ep-name = "rpmsg-tty";
+	};
+
+	uart_rpmsg1: ep1 {
+		status = "okay";
+		compatible = "zephyr,rpmsg-uart";
+		ep-name = "rpmsg-tty1";
+	};
+
+	soc {
+
+		sram1: memory@7a000000 {
+			compatible = "mmio-sram";
+			reg = <0x0 0x7a000000 0x0 DT_SIZE_M(10)>;
+		};
+
+		pcie_jailhouse: pcie@8e00000 {
+			compatible = "pci-host-ecam-generic";
+			device_type = "pci";
+			reg = <0x00 0x08e00000 0x00 0x100000>;
+			#size-cells = <0x02>;
+			#address-cells = <0x03>;
+			ranges = <0x02000000 0x00 0x10000000 0x0 0x10000000 0x00 0x10000>;
+			#interrupt-cells = <0x01>;
+			interrupt-map-mask = <0x00 0x00 0x00 0x07>;
+			interrupt-map = <
+				0x00 0x00 0x00 1 &gic 0 0 GIC_SPI 108 IRQ_TYPE_EDGE IRQ_DEFAULT_PRIORITY
+				0x00 0x00 0x00 2 &gic 0 0 GIC_SPI 109 IRQ_TYPE_EDGE IRQ_DEFAULT_PRIORITY
+				0x00 0x00 0x00 3 &gic 0 0 GIC_SPI 110 IRQ_TYPE_EDGE IRQ_DEFAULT_PRIORITY
+				0x00 0x00 0x00 4 &gic 0 0 GIC_SPI 111 IRQ_TYPE_EDGE IRQ_DEFAULT_PRIORITY>;
+			bus-range = <0x00 0x00>;
+		};
+
+	};
+};
+
+&uart0 {
+	status = "okay";
+	current-speed = <115200>;
+};
+
+&pcie {
+	status = "disabled";
+};
+
+&pcie_jailhouse {
+	ivshmem0: ivshmem@0 {
+		compatible = "qemu,ivshmem";
+		ivshmem-v2;
+		vendor-id = <0x110A>;           /* Siemens */
+		device-id = <0x4106>;           /* IVSHMEM */
+		class-rev = <0xFF400100>;       /* PCI_CLASS_OTHERS | IVSHMEM_PROTO_RPMSG */
+		class-rev-mask = <0xFFFFFF00>;  /* PCI_CLASS_MASK | IVSHMEM_PROTO_MASK */
+		interrupt-parent = <&pcie_jailhouse>;
+		interrupts = <1 2 3 4>;
+		reg = <0x00 0x00 0x00 0x00 0x01>;
+		status = "okay";
+	};
+};
diff --git a/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_ivshmem_defconfig b/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_ivshmem_defconfig
new file mode 100644
index 00000000000..646bc473caa
--- /dev/null
+++ b/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_ivshmem_defconfig
@@ -0,0 +1,68 @@
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_QEMU_ICOUNT=n
+
+# Cache management
+CONFIG_CACHE_MANAGEMENT=y
+
+# Enable UART driver
+CONFIG_SERIAL=y
+
+# Enable console
+CONFIG_CONSOLE=y
+# no early console, because uart_rpmsg is used
+CONFIG_EARLY_CONSOLE=y
+CONFIG_UART_CONSOLE=y
+CONFIG_PRINTK=y
+
+# to use remote, must be in Non-Secure world
+CONFIG_ARMV8_A_NS=y
+
+# Enable RPMSG based serial port
+CONFIG_UART_RPMSG=y
+CONFIG_UART_INTERRUPT_DRIVEN=y
+
+CONFIG_OPENAMP=y
+CONFIG_RPMSG_SERVICE_MODE_REMOTE=y
+CONFIG_OPENAMP_MASTER=n
+CONFIG_OPENAMP_RSC_TABLE_NUM_RPMSG_BUFF=8
+CONFIG_OPENAMP_RSC_TABLE=y
+CONFIG_HEAP_MEM_POOL_SIZE=4096
+# shell must be initialized after uart_rpmsg
+CONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY=60
+# the tx ring buffer size is the same of bufffer of rpmsg_virtio buffer
+CONFIG_SHELL_BACKEND_SERIAL_TX_RING_BUFFER_SIZE=512
+
+# no IPM as we use virtualization
+CONFIG_IPM=n
+
+CONFIG_PCIE=y
+CONFIG_POLL=y
+CONFIG_PCIE_CONTROLLER=y
+CONFIG_PCIE_ECAM=y
+CONFIG_KERNEL_VM_SIZE=0x80000000
+
+# Hungry PCI requires phys addresses with more than 32 bits
+CONFIG_ARM64_VA_BITS_40=y
+CONFIG_ARM64_PA_BITS_40=y
+
+CONFIG_VIRTUALIZATION=y
+CONFIG_IVSHMEM=y
+CONFIG_IVSHMEM_V2=y
+CONFIG_IVSHMEM_DOORBELL=y
+CONFIG_DYNAMIC_INTERRUPTS=y
+# the correct init order:
+# serial->pci controler->
+# ->pci scan->pci device(ivshmem_init)
+# ->virtio->rpmsg endpoint
+CONFIG_SERIAL_INIT_PRIORITY=41
+CONFIG_CONSOLE_INIT_PRIORITY=42
+CONFIG_PCIE_INIT_PRIORITY=43
+CONFIG_KERNEL_INIT_PRIORITY_DEVICE=41
+
+CONFIG_KERNEL_DIRECT_MAP=y
+CONFIG_LOG=y
+CONFIG_LOG_BACKEND_UART=y
+# comment out the following for debug
+#CONFIG_LOG_MODE_IMMEDIATE=y
+#CONFIG_LOG_DEFAULT_LEVEL=4
+#CONFIG_LOG_PRINTK=n
diff --git a/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_remote.dts b/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_remote.dts
new file mode 100644
index 00000000000..dd5b3acc2c9
--- /dev/null
+++ b/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_remote.dts
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2019 Carlo Caione <ccaione@baylibre.com>
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ */
+
+/dts-v1/;
+#include <arm64/qemu/qemu-virt-a53.dtsi>
+
+/ {
+	model = "QEMU Cortex-A53";
+	compatible = "qemu,arm-cortex-a53";
+
+	psci {
+		compatible = "arm,psci-0.2";
+		method = "hvc";
+		label = "PSCI";
+	};
+
+	chosen {
+		zephyr,sram = &sram1;
+		/* uart0 is used for debug, which also may be used by Linux */
+		zephyr,console = &uart0;
+		zephyr,shell-uart = &uart_rpmsg0;
+		zephyr,flash = &flash0;
+		/*
+		 * shared memory reserved for the inter-processor communication
+		 */
+		 zephyr,ipc_shm = &ipc_shm0;
+		 zephyr,ipc = &ipm_gic_sgi0;
+	};
+
+	ipm_gic_sgi0: ipm{
+		compatible = "arm,gic-sgi";
+		label = "gic_sgi0";
+	};
+
+	uart_rpmsg0: ep0 {
+		status = "okay";
+		compatible = "zephyr,rpmsg-uart";
+		/* the rpmsg-tty driver requires ep-name should be rpmsg-tty* */
+		ep-name = "rpmsg-tty";
+	};
+
+	uart_rpmsg1: ep1 {
+		status = "okay";
+		compatible = "zephyr,rpmsg-uart";
+		ep-name = "rpmsg-tty1";
+	};
+
+	soc {
+		ipc_shm0: memory@70000000 {
+			compatible = "mmio-sram";
+			reg = <0 0x70000000 0 0x100000>;
+		};
+
+		sram1: memory@7a000000 {
+			compatible = "mmio-sram";
+			reg = <0x0 0x7a000000 0x0 DT_SIZE_M(10)>;
+		};
+
+	};
+};
+
+&uart0 {
+	status = "okay";
+	current-speed = <115200>;
+};
diff --git a/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_remote_defconfig b/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_remote_defconfig
new file mode 100644
index 00000000000..91cd83af6e1
--- /dev/null
+++ b/boards/qemu/cortex_a53/qemu_cortex_a53_qemu_cortex_a53_remote_defconfig
@@ -0,0 +1,37 @@
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_QEMU_ICOUNT=n
+
+# Cache management
+CONFIG_CACHE_MANAGEMENT=y
+
+# Enable UART driver
+CONFIG_SERIAL=y
+
+# Enable console
+CONFIG_CONSOLE=y
+# no early console, because uart_rpmsg is used
+CONFIG_BOOT_BANNER=n
+CONFIG_EARLY_CONSOLE=n
+CONFIG_UART_CONSOLE=y
+CONFIG_PRINTK=n
+
+# to use remote, must be in Non-Secure world
+CONFIG_ARMV8_A_NS=y
+
+# Enable RPMSG based serial port
+CONFIG_UART_RPMSG=y
+CONFIG_UART_INTERRUPT_DRIVEN=y
+
+# support psci ops
+CONFIG_PM_CPU_OPS=y
+CONFIG_OPENAMP=y
+CONFIG_IPM=y
+CONFIG_RPMSG_SERVICE_MODE_REMOTE=y
+CONFIG_OPENAMP_MASTER=n
+CONFIG_OPENAMP_RSC_TABLE_NUM_RPMSG_BUFF=8
+CONFIG_OPENAMP_RSC_TABLE=y
+CONFIG_HEAP_MEM_POOL_SIZE=4096
+# shell must be initialized after uart_rpmsg
+CONFIG_SHELL_BACKEND_SERIAL_INIT_PRIORITY=60
+# the tx ring buffer size is the same of bufffer of rpmsg_virtio buffer
+CONFIG_SHELL_BACKEND_SERIAL_TX_RING_BUFFER_SIZE=512
diff --git a/drivers/interrupt_controller/intc_gic.c b/drivers/interrupt_controller/intc_gic.c
index 862d389f816..72160937a8e 100644
--- a/drivers/interrupt_controller/intc_gic.c
+++ b/drivers/interrupt_controller/intc_gic.c
@@ -275,7 +275,10 @@ static void gic_cpu_init(void)
 int arm_gic_init(const struct device *dev)
 {
 	/* Init of Distributor interface registers */
-	gic_dist_init();
+	/* openamp client does not init the global part of GIC */
+	if (!IS_ENABLED(CONFIG_OPENAMP_SLAVE)) {
+		gic_dist_init();
+	}
 
 	/* Init CPU interface registers */
 	gic_cpu_init();
diff --git a/drivers/interrupt_controller/intc_gicv3.c b/drivers/interrupt_controller/intc_gicv3.c
index e3c25c4d8b8..64cf4e952f2 100644
--- a/drivers/interrupt_controller/intc_gicv3.c
+++ b/drivers/interrupt_controller/intc_gicv3.c
@@ -600,7 +600,11 @@ static void __arm_gic_init(void)
 
 int arm_gic_init(const struct device *dev)
 {
-	gicv3_dist_init();
+
+/* openamp client does not init the global part of GIC */
+	if (!IS_ENABLED(CONFIG_OPENAMP_SLAVE)) {
+		gicv3_dist_init();
+	}
 
 	__arm_gic_init();
 
diff --git a/drivers/ipm/CMakeLists.txt b/drivers/ipm/CMakeLists.txt
index cc79cce4f83..e15aeed5013 100644
--- a/drivers/ipm/CMakeLists.txt
+++ b/drivers/ipm/CMakeLists.txt
@@ -15,5 +15,6 @@ zephyr_library_sources_ifdef(CONFIG_IPM_SEDI ipm_sedi.c)
 zephyr_library_sources_ifdef(CONFIG_IPM_IVSHMEM ipm_ivshmem.c)
 zephyr_library_sources_ifdef(CONFIG_ESP32_SOFT_IPM ipm_esp32.c)
 zephyr_library_sources_ifdef(CONFIG_XLNX_IPI ipm_xlnx_ipi.c)
+zephyr_library_sources_ifdef(CONFIG_IPM_GIC_SGI ipm_gic_sgi.c)
 
 zephyr_library_sources_ifdef(CONFIG_USERSPACE   ipm_handlers.c)
diff --git a/drivers/ipm/Kconfig b/drivers/ipm/Kconfig
index 81c64202427..dd881e461f8 100644
--- a/drivers/ipm/Kconfig
+++ b/drivers/ipm/Kconfig
@@ -63,6 +63,24 @@ source "drivers/ipm/Kconfig.ivshmem"
 source "drivers/ipm/Kconfig.sedi"
 
 
+config IPM_GIC_SGI
+	bool "ARM GIC SGI driver"
+	depends on GIC
+	help
+	  use ARM GIC SGI interrupt as IPM
+
+if IPM_GIC_SGI
+
+config IPM_GIC_SGI_INTNO
+	int "Intno of SGI used for IPM"
+	range 6 7
+	default 7
+	help
+	  The intno of SGI used for IPM. For arm64, SGI can be used to
+	  work as IPM
+
+endif # IPM_GIC_SGI
+
 module = IPM
 module-str = ipm
 source "subsys/logging/Kconfig.template.log_config"
diff --git a/drivers/ipm/ipm_gic_sgi.c b/drivers/ipm/ipm_gic_sgi.c
new file mode 100644
index 00000000000..bb7b5d6662d
--- /dev/null
+++ b/drivers/ipm/ipm_gic_sgi.c
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2022 openEuler
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT arm_gic_sgi
+
+#include <errno.h>
+#include <zephyr/device.h>
+#include <zephyr/kernel.h>
+#include <zephyr/drivers/ipm.h>
+#include <zephyr/drivers/interrupt_controller/gic.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(ipm_gic_sgi, CONFIG_IPM_LOG_LEVEL);
+
+
+/* Device config structure */
+struct ipm_gic_sgi_device_config {
+	void (*irq_config_func)(const struct device *d);
+	int intno;
+};
+
+/* Device data structure */
+struct ipm_gic_sgi_data {
+	ipm_callback_t callback;
+	void *user_data;
+};
+
+
+static int gic_sgi_send(const struct device *d, int wait, uint32_t id,
+			  const void *data, int size)
+{
+	/* use SGI x to send ipi */
+	const uint64_t mpidr = GET_MPIDR();
+	const struct ipm_gic_sgi_device_config *config = d->config;
+
+	LOG_DBG("gic_sig_send:id:%x, data:%p, size:%d", id, data, size);
+
+	if (!IS_ENABLED(CONFIG_OPENAMP_SLAVE)) {
+		/*
+		 * Send SGI to all cores except itself, this is for test as host does not know
+		 * which core the client side is in
+		 * Note: Assume only one Cluster now.
+		 */
+		gic_raise_sgi(config->intno, mpidr, SGIR_TGT_MASK & ~(1 << MPIDR_TO_CORE(mpidr)));
+	} else {
+		/* Send SGI only to core 0 (master core) for client side to
+		 * avoid unnecessary ipi interrupts
+		 */
+		gic_raise_sgi(config->intno, mpidr, 0x1);
+	}
+
+	return 0;
+}
+
+static uint32_t gic_sgi_max_id_val_get(const struct device *d)
+{
+	ARG_UNUSED(d);
+
+	return 0;
+}
+
+static int gic_sgi_init(const struct device *d)
+{
+	const struct ipm_gic_sgi_device_config *config = d->config;
+
+	/* just register sgi into, no special init */
+	config->irq_config_func(d);
+
+	return 0;
+}
+
+static void gic_sgi_isr(const struct device *d)
+{
+	struct ipm_gic_sgi_data *driver_data = d->data;
+
+	if (driver_data->callback) {
+		driver_data->callback(d, driver_data->user_data, 0, 0);
+	}
+}
+
+static int gic_sgi_set_enabled(const struct device *d, int enable)
+{
+	ARG_UNUSED(d);
+	ARG_UNUSED(enable);
+
+	/* already enabled in gic_sgi_config_func */
+	return 0;
+}
+
+static int gic_sgi_max_data_size_get(const struct device *d)
+{
+	ARG_UNUSED(d);
+
+	/* sgi is just IPI, no data can be sent */
+	return 0;
+}
+
+static void gic_sgi_register_cb(const struct device *d,
+				ipm_callback_t cb,
+				void *user_data)
+{
+	struct ipm_gic_sgi_data *driver_data = d->data;
+
+	driver_data->callback = cb;
+	driver_data->user_data = user_data;
+}
+
+static const struct ipm_driver_api gic_sgi_driver_api = {
+	.send = gic_sgi_send,
+	.register_callback = gic_sgi_register_cb,
+	.max_data_size_get = gic_sgi_max_data_size_get,
+	.max_id_val_get = gic_sgi_max_id_val_get,
+	.set_enabled = gic_sgi_set_enabled,
+};
+
+static void gic_sgi_irq_config_func_0(const struct device *d);
+
+static const struct ipm_gic_sgi_device_config gic_sgi_cfg_0 = {
+	.irq_config_func = gic_sgi_irq_config_func_0,
+	.intno = CONFIG_IPM_GIC_SGI_INTNO,
+};
+
+static struct ipm_gic_sgi_data gic_sgi_data_0 = {
+	.callback = NULL,
+	.user_data = NULL,
+};
+
+DEVICE_DT_INST_DEFINE(0,
+			&gic_sgi_init,
+			NULL,
+			&gic_sgi_data_0,
+			&gic_sgi_cfg_0, PRE_KERNEL_1,
+			CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
+			&gic_sgi_driver_api);
+
+static void gic_sgi_irq_config_func_0(const struct device *d)
+{
+	ARG_UNUSED(d);
+	IRQ_CONNECT(CONFIG_IPM_GIC_SGI_INTNO,
+			IRQ_DEFAULT_PRIORITY,
+			gic_sgi_isr,
+			DEVICE_DT_INST_GET(0),
+			0);
+	irq_enable(CONFIG_IPM_GIC_SGI_INTNO);
+	LOG_INF("gic sgi int config");
+}
diff --git a/drivers/serial/CMakeLists.txt b/drivers/serial/CMakeLists.txt
index 9ac2f22920d..b7444d8a716 100644
--- a/drivers/serial/CMakeLists.txt
+++ b/drivers/serial/CMakeLists.txt
@@ -68,6 +68,7 @@ zephyr_library_sources_ifdef(CONFIG_UART_HOSTLINK uart_hostlink.c)
 zephyr_library_sources_ifdef(CONFIG_UART_EMUL uart_emul.c)
 zephyr_library_sources_ifdef(CONFIG_UART_NUMAKER uart_numaker.c)
 zephyr_library_sources_ifdef(CONFIG_UART_EFINIX_SAPPIHIRE uart_efinix_sapphire.c)
+zephyr_library_sources_ifdef(CONFIG_UART_RPMSG uart_rpmsg.c)
 zephyr_library_sources_ifdef(CONFIG_UART_SEDI uart_sedi.c)
 zephyr_library_sources_ifdef(CONFIG_UART_MAX32 uart_max32.c)
 zephyr_library_sources_ifdef(CONFIG_UART_BCM2711_MU uart_bcm2711.c)
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index faa150237c5..38bd3026cfc 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -244,6 +244,8 @@ rsource "Kconfig.xen"
 
 rsource "Kconfig.ifx_cat1"
 
+rsource "Kconfig.rpmsg_uart"
+
 rsource "Kconfig.smartbond"
 
 rsource "Kconfig.nxp_s32"
diff --git a/drivers/serial/Kconfig.rpmsg_uart b/drivers/serial/Kconfig.rpmsg_uart
new file mode 100644
index 00000000000..a1e45351462
--- /dev/null
+++ b/drivers/serial/Kconfig.rpmsg_uart
@@ -0,0 +1,30 @@
+# Rpmsg service based UART
+#
+# Copyright (c) 2022 openEuler Embedded
+# SPDX-License-Identifier: Apache-2.0
+
+config UART_RPMSG
+	bool "RPMSG service based UART driver"
+	select SERIAL_HAS_DRIVER
+	select SERIAL_SUPPORT_INTERRUPT
+	select RPMSG_SERVICE
+	select RING_BUFFER
+	help
+		Enable RPMSG service based uart driver. Zephyr runs as
+		a remote OS
+
+if UART_RPMSG
+
+config UART_RPMSG_RING_BUF_SIZE
+	int "RPMSG UART receive ring buf size"
+	default 512
+	help
+	  Set the size of ring buffer used for rpmsg uart receive
+
+config UART_RPMSG_LINE_BUF_SIZE
+	int "RPMSG UART poll line buf size"
+	default 32
+	help
+	  Set the size of line buffer used for rpmsg uart poll out
+
+endif # UART_RPMSG
diff --git a/drivers/serial/uart_rpmsg.c b/drivers/serial/uart_rpmsg.c
new file mode 100644
index 00000000000..e38c101ae20
--- /dev/null
+++ b/drivers/serial/uart_rpmsg.c
@@ -0,0 +1,310 @@
+/*
+ * Copyright (c) 2022 openEuler Embedded
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#define DT_DRV_COMPAT zephyr_rpmsg_uart
+
+#include <zephyr/device.h>
+#include <zephyr/init.h>
+#include <zephyr/kernel.h>
+#include <zephyr/sys/ring_buffer.h>
+#include <zephyr/drivers/uart.h>
+#include <zephyr/ipc/rpmsg_service.h>
+
+#include <zephyr/logging/log.h>
+LOG_MODULE_REGISTER(uart_rpmsg, CONFIG_UART_LOG_LEVEL);
+
+
+struct uart_rpmsg_data {
+	const struct device *dev;
+	char *name;
+
+	int ep_id; /* endpoint id */
+
+	/** Ring buffer for received bytes from rpmsg */
+	struct ring_buf rb;
+	uint8_t ring_buf_data[CONFIG_UART_RPMSG_RING_BUF_SIZE];
+	uint8_t line_buf_data[CONFIG_UART_RPMSG_LINE_BUF_SIZE];
+	size_t line_len;
+
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN)
+	uart_irq_callback_user_data_t irq_cb;
+	void *irq_cb_data;
+	int tx_busy;
+#endif /* CONFIG_UART_INTERRUPT_DRIVEN */
+};
+
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN)
+static void uart_rpmsg_cb(struct uart_rpmsg_data *data)
+{
+	if (data->irq_cb) {
+		/* use data->tx_busy to simulate the tx empty interrupt
+		 * uart_tx_enable will call uart_rpmsg_cb, and set tx_busy to 1
+		 * uart_tx_disable will set tx_buys to 0, so uart_tx_disable
+		 * must be called if nothing to send and the loop will end
+		 */
+		do {
+			data->irq_cb(data->dev, data->irq_cb_data);
+		} while (data->tx_busy);
+	}
+}
+#endif
+
+/* called in thread context */
+static int uart_rpmsg_endpoint_cb(struct rpmsg_endpoint *ept, void *data,
+		size_t len, uint32_t src, void *priv)
+{
+	struct uart_rpmsg_data *uart_data = (struct uart_rpmsg_data *)priv;
+	int wrote;
+
+	if (rpmsg_service_endpoint_is_bound(uart_data->ep_id) == false) {
+		rpmsg_service_endpoint_bound(uart_data->ep_id);
+	}
+
+	/* direct return for empty msg which is used for sync up between
+	 * two sides.
+	 */
+	if (len == 0) {
+		return RPMSG_SUCCESS;
+	}
+
+	/* put the received data into ring buf */
+	wrote = ring_buf_put(&uart_data->rb, data, len);
+
+	if (wrote < len) {
+		LOG_INF("ring buf is full, data overrun");
+		/* ring buf is full, disable rx? */
+	}
+
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN)
+	uart_rpmsg_cb(priv);
+#endif
+
+	return RPMSG_SUCCESS;
+}
+
+static int uart_rpmsg_poll_in(const struct device *dev,
+			unsigned char *c)
+{
+	struct uart_rpmsg_data *data = (struct uart_rpmsg_data *)dev->data;
+	int ret = 0;
+	char temp;
+
+	/* wait until ring buffer is not empty */
+	while (ring_buf_is_empty(&data->rb)) {
+		k_msleep(1);
+	}
+
+	ret = ring_buf_get(&data->rb, &temp, sizeof(temp));
+
+	if (ret != 1) {
+		/* char was not received correctly */
+		return -1;
+	}
+
+	*c = temp;
+
+	return 0;
+}
+
+static void uart_rpmsg_poll_out(const struct device *dev, unsigned char c)
+{
+	struct uart_rpmsg_data *uart_data = (struct uart_rpmsg_data *)dev->data;
+	int ret;
+
+	/* should wait until uart_rpmsg's endpoint is bound ?
+	 * if not bound, rpmsg_service_send will fail
+	 * in thread context, we can sleep to wait
+	 * in no-thread context, we should fail and lose msg
+	 */
+
+	while (rpmsg_service_endpoint_is_bound(uart_data->ep_id) == false) {
+		k_msleep(10);
+	}
+
+	if (uart_data->line_len < CONFIG_UART_RPMSG_LINE_BUF_SIZE) {
+		uart_data->line_buf_data[uart_data->line_len++] = c;
+		if (c != '\n') {
+			return;
+		}
+	}
+
+	ret = rpmsg_service_send(uart_data->ep_id, uart_data->line_buf_data,
+							uart_data->line_len);
+
+	if (ret < 0) {
+		LOG_ERR("Error uart_rpmsg poll out over rpmsg_service ret:%d", ret);
+	}
+
+	uart_data->line_len = 0;
+
+	uart_data->line_buf_data[uart_data->line_len++] = c;
+}
+
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN)
+
+static int uart_rpmsg_fifo_fill(const struct device *dev, const uint8_t *tx_data,
+			 int len)
+{
+	struct uart_rpmsg_data *data = (struct uart_rpmsg_data *)dev->data;
+	int ret = 0, sent = 0;
+
+	data->tx_busy = 1;
+	while (len) {
+		sent = rpmsg_service_send(data->ep_id, tx_data, len);
+		/* < 0, send error */
+		if (sent < 0) {
+			ret = sent;
+			break;
+		}
+		ret += sent;
+		tx_data += sent;
+		len -= sent;
+	}
+
+	return ret;
+}
+
+static int uart_rpmsg_fifo_read(const struct device *dev, uint8_t *rx_data,
+			 const int size)
+{
+	struct uart_rpmsg_data *data = (struct uart_rpmsg_data *)dev->data;
+
+	return ring_buf_get(&data->rb, rx_data, size);
+}
+
+static void uart_rpmsg_irq_tx_enable(const struct device *dev)
+{
+/* explicitly call UART callback to simulate Tx interrupt */
+	struct uart_rpmsg_data *data = (struct uart_rpmsg_data *)dev->data;
+
+	/* should wait until uart_rpmsg's endpoint is bound ?
+	 * if not bound, rpmsg_service_send will fail
+	 * in thread context, we can sleep to wait
+	 * in no-thread context, we should fail and lose msg
+	 */
+
+	if (rpmsg_service_endpoint_is_bound(data->ep_id)) {
+		uart_rpmsg_cb(data);
+	}
+}
+
+static void uart_rpmsg_irq_tx_disable(const struct device *dev)
+{
+	struct uart_rpmsg_data *data = (struct uart_rpmsg_data *)dev->data;
+
+	data->tx_busy = 0;
+}
+
+
+static int uart_rpmsg_irq_tx_ready(const struct device *dev)
+{
+	/* always ready to tx */
+	return 1;
+}
+
+static void uart_rpmsg_irq_rx_enable(const struct device *dev)
+{
+	/* always rx enable */
+}
+
+static int uart_rpmsg_irq_tx_complete(const struct device *dev)
+{
+	/*
+	 * after send, it's always complete
+	 */
+	return 1;
+}
+
+static int uart_rpmsg_irq_rx_ready(const struct device *dev)
+{
+	/* if ring buf is not empty, then ready to rx */
+	struct uart_rpmsg_data *data = (struct uart_rpmsg_data *)dev->data;
+
+	return  !ring_buf_is_empty(&data->rb);
+}
+
+static int uart_rpmsg_irq_is_pending(const struct device *dev)
+{
+	return uart_rpmsg_irq_rx_ready(dev);
+}
+
+static int uart_rpmsg_irq_update(const struct device *dev)
+{
+	/* Nothing needs to be updated */
+	return 1;
+}
+
+static void uart_rpmsg_irq_callback_set(const struct device *dev,
+		 uart_irq_callback_user_data_t cb, void *user_data)
+{
+	struct uart_rpmsg_data *data = (struct uart_rpmsg_data *)dev->data;
+
+	data->irq_cb = cb;
+	data->irq_cb_data = user_data;
+}
+#endif /* CONFIG_UART_INTERRUPT_DRIVEN */
+
+static const struct uart_driver_api uart_rpmsg_api = {
+	.poll_in = uart_rpmsg_poll_in,
+	.poll_out = uart_rpmsg_poll_out,
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN)
+	.fifo_fill = uart_rpmsg_fifo_fill,
+	.fifo_read = uart_rpmsg_fifo_read,
+	.irq_tx_enable = uart_rpmsg_irq_tx_enable,
+	.irq_tx_disable = uart_rpmsg_irq_tx_disable,
+	.irq_tx_ready = uart_rpmsg_irq_tx_ready,
+	.irq_rx_enable = uart_rpmsg_irq_rx_enable,
+	.irq_tx_complete = uart_rpmsg_irq_tx_complete,
+	.irq_rx_ready = uart_rpmsg_irq_rx_ready,
+	.irq_is_pending = uart_rpmsg_irq_is_pending,
+	.irq_update = uart_rpmsg_irq_update,
+	.irq_callback_set = uart_rpmsg_irq_callback_set,
+#endif /* CONFIG_UART_INTERRUPT_DRIVEN */
+};
+
+int uart_rpmsg_init(const struct device *dev)
+{
+	struct uart_rpmsg_data *data = dev->data;
+	int status;
+
+	status = rpmsg_service_register_endpoint(data->name, uart_rpmsg_endpoint_cb,
+									NULL, data);
+
+	if (status < 0) {
+		LOG_INF("RPMSG UART initialized error");
+		return status;
+	}
+
+	data->dev = dev;
+	data->ep_id = status;
+	ring_buf_init(&data->rb, CONFIG_UART_RPMSG_RING_BUF_SIZE, data->ring_buf_data);
+
+	data->line_len = 0;
+#if defined(CONFIG_UART_INTERRUPT_DRIVEN)
+
+	data->tx_busy = 0;
+
+#endif
+
+	LOG_INF("IPC UART initialized successfully");
+
+	return 0;
+}
+
+#define RPMSG_DEV(idx) DT_NODELABEL(uart_rpmsg ## idx)
+
+#define UART_RPMSG_INIT(n)		\
+	static struct uart_rpmsg_data uart_data_##n = {	\
+		.name = DT_PROP(RPMSG_DEV(n), ep_name),	\
+	};											\
+												\
+	DEVICE_DT_DEFINE(RPMSG_DEV(n), uart_rpmsg_init, NULL, \
+		&uart_data_##n,	\
+		NULL, POST_KERNEL, \
+		CONFIG_RPMSG_SERVICE_EP_REG_PRIORITY, \
+		&uart_rpmsg_api);
+
+DT_INST_FOREACH_STATUS_OKAY(UART_RPMSG_INIT)
diff --git a/drivers/virtualization/virt_ivshmem.c b/drivers/virtualization/virt_ivshmem.c
index bce1dd4c428..da188e0f8f6 100644
--- a/drivers/virtualization/virt_ivshmem.c
+++ b/drivers/virtualization/virt_ivshmem.c
@@ -214,26 +214,27 @@ static bool ivshmem_configure(const struct device *dev)
 		/* State table R/O */
 		cap_pos = vendor_cap + IVSHMEM_CFG_STATE_TAB_SZ / 4;
 		size_t state_table_size = pcie_conf_read(data->pcie->bdf, cap_pos);
-		LOG_INF("State table size 0x%zX", state_table_size);
 		if (state_table_size < sizeof(uint32_t) * data->max_peers) {
 			LOG_ERR("Invalid state table size %zu", state_table_size);
 			return false;
 		}
 		k_mem_map_phys_bare((uint8_t **)&data->state_table_shmem,
 				    shmem_phys_addr, state_table_size,
-				    K_MEM_CACHE_WB | K_MEM_PERM_USER);
-
+				    K_MEM_CACHE_WB | K_MEM_PERM_USER | K_MEM_DIRECT_MAP);
+		LOG_INF("State table size 0x%zX at 0x%lX (mapped to 0x%lX)",
+					state_table_size, shmem_phys_addr, data->state_table_shmem);
 		/* R/W section (optional) */
 		cap_pos = vendor_cap + IVSHMEM_CFG_RW_SECTION_SZ / 4;
 		data->rw_section_size = pcie_conf_read_u64(data->pcie->bdf, cap_pos);
 		size_t rw_section_offset = state_table_size;
-		LOG_INF("RW section size 0x%zX", data->rw_section_size);
 		if (data->rw_section_size > 0) {
 			k_mem_map_phys_bare((uint8_t **)&data->rw_section_shmem,
 					    shmem_phys_addr + rw_section_offset,
 					    data->rw_section_size,
-					    K_MEM_CACHE_WB | K_MEM_PERM_RW | K_MEM_PERM_USER);
+					    K_MEM_CACHE_WB | K_MEM_PERM_RW | K_MEM_PERM_USER | K_MEM_DIRECT_MAP);
 		}
+		LOG_INF("RW section size 0x%zX at 0x%lX (mapped to 0x%lX)",
+			data->rw_section_size, shmem_phys_addr + rw_section_offset, data->rw_section_shmem);
 
 		/* Output sections */
 		cap_pos = vendor_cap + IVSHMEM_CFG_OUTPUT_SECTION_SZ / 4;
@@ -250,8 +251,12 @@ static bool ivshmem_configure(const struct device *dev)
 			if (i == regs->id) {
 				flags |= K_MEM_PERM_RW;
 			}
-			k_mem_map_phys_bare((uint8_t **)&data->output_section_shmem[i],
-					    phys_addr, data->output_section_size, flags);
+			if (data->output_section_size > 0) {
+				k_mem_map_phys_bare((uint8_t **)&data->output_section_shmem[i],
+						phys_addr, data->output_section_size, flags);
+				LOG_INF("Output section at 0x%lX (mapped to 0x%lX)",
+				phys_addr, data->output_section_shmem[i]);
+			}
 		}
 
 		data->size = output_section_offset +
@@ -276,7 +281,7 @@ static bool ivshmem_configure(const struct device *dev)
 
 		k_mem_map_phys_bare((uint8_t **)&data->shmem,
 				    shmem_phys_addr, data->size,
-				    K_MEM_CACHE_WB | K_MEM_PERM_RW | K_MEM_PERM_USER);
+				    K_MEM_CACHE_WB | K_MEM_PERM_RW | K_MEM_PERM_USER | K_MEM_DIRECT_MAP);
 	}
 
 	if (msi_x_bar_present) {
diff --git a/dts/arm64/qemu/qemu-virt-a53.dtsi b/dts/arm64/qemu/qemu-virt-a53.dtsi
index cb96eba2874..d1f86148eed 100644
--- a/dts/arm64/qemu/qemu-virt-a53.dtsi
+++ b/dts/arm64/qemu/qemu-virt-a53.dtsi
@@ -7,8 +7,8 @@
 /*
  * Derived from DTS extracted with:
  *
- *   qemu-system-aarch64 -machine virt -cpu cortex-a53 -nographic
- *         -machine dumpdtb=virt.dtb
+ *   qemu-system-aarch64 -machine virt,gic-version=host,accel=kvm
+ *         -cpu cortex-a53 -nographic -machine dumpdtb=virt.dtb
  *
  *   dtc -I dtb -O dts virt.dtb
  */
@@ -28,13 +28,13 @@
 
 		cpu@0 {
 			device_type = "cpu";
-			compatible = "arm,cortex-a53";
+			compatible = "arm,cortex-virt";
 			reg = <0>;
 		};
 
 		cpu@1 {
 			device_type = "cpu";
-			compatible = "arm,cortex-a53";
+			compatible = "arm,cortex-virt";
 			reg = <1>;
 		};
 	};
@@ -151,4 +151,4 @@
 			bus-range = <0x00 0xff>;
 		};
 	};
-};
+};
\ No newline at end of file
diff --git a/dts/bindings/ipm/arm,gic-sgi.yaml b/dts/bindings/ipm/arm,gic-sgi.yaml
new file mode 100644
index 00000000000..282a4207d47
--- /dev/null
+++ b/dts/bindings/ipm/arm,gic-sgi.yaml
@@ -0,0 +1,9 @@
+# Copyright (c) 2022 openEuler
+# SPDX-License-Identifier: Apache-2.0
+
+description: ARM SGI (IPM by software generated int)
+
+compatible: "arm,gic-sgi"
+
+include: base.yaml
+
diff --git a/dts/bindings/serial/zephy,rpmsg-uart.yaml b/dts/bindings/serial/zephy,rpmsg-uart.yaml
new file mode 100644
index 00000000000..a9616618872
--- /dev/null
+++ b/dts/bindings/serial/zephy,rpmsg-uart.yaml
@@ -0,0 +1,14 @@
+# Copyright (c) 2022, openEuler Embedded
+# SPDX-License-Identifier: Apache-2.0
+
+description: RPMSG service based UART
+
+compatible: "zephyr,rpmsg-uart"
+
+include: base.yaml
+
+properties:
+    ep-name:
+        type: string
+        required: true
+        description: the endpoint name of uart-rpmsg device
diff --git a/include/zephyr/arch/arm64/cache.h b/include/zephyr/arch/arm64/cache.h
index cddd901ba02..d8e2cb51b5a 100644
--- a/include/zephyr/arch/arm64/cache.h
+++ b/include/zephyr/arch/arm64/cache.h
@@ -190,7 +190,13 @@ static ALWAYS_INLINE size_t arch_icache_line_size_get(void)
 
 static ALWAYS_INLINE int arch_icache_flush_all(void)
 {
-	return -ENOTSUP;
+	/* invalidate all instruction cache */
+	__asm__ volatile ("ic iallu" ::: "memory");
+
+	z_barrier_dsync_fence_full();
+	z_barrier_isync_fence_full();
+
+	return 0;
 }
 
 static ALWAYS_INLINE int arch_icache_invd_all(void)
diff --git a/include/zephyr/ipc/rpmsg_service.h b/include/zephyr/ipc/rpmsg_service.h
index e599c8deac4..b1047d3cab5 100644
--- a/include/zephyr/ipc/rpmsg_service.h
+++ b/include/zephyr/ipc/rpmsg_service.h
@@ -32,13 +32,18 @@ extern "C" {
  *             for master and slave
  * @param cb Callback executed when data are available on given endpoint
  *
+ * @param unbind_cb Callback executed when given endpoint is unbound
+ *
+ * @param priv endpoint private data, transferred to cb when cb is called
+ *
  * @retval >=0 id of registered endpoint on success;
  * @retval -EINPROGRESS when requested to register an endpoint after endpoints
  *         creation procedure has started;
  * @retval -ENOMEM when there is not enough slots to register the endpoint;
  * @retval <0 an other negative errno code, reported by rpmsg.
  */
-int rpmsg_service_register_endpoint(const char *name, rpmsg_ept_cb cb);
+int rpmsg_service_register_endpoint(const char *name, rpmsg_ept_cb cb,
+				rpmsg_ns_unbind_cb unbind_cb, void *priv);
 
 /**
  * @brief Send data using given IPC endpoint
@@ -67,6 +72,8 @@ int rpmsg_service_send(int endpoint_id, const void *data, size_t len);
  */
 bool rpmsg_service_endpoint_is_bound(int endpoint_id);
 
+void rpmsg_service_endpoint_bound(int endpoint_id);
+
 /**
  * @}
  */
diff --git a/lib/open-amp/resource_table.c b/lib/open-amp/resource_table.c
index a857c3ca05f..fb10f664652 100644
--- a/lib/open-amp/resource_table.c
+++ b/lib/open-amp/resource_table.c
@@ -39,7 +39,7 @@ static struct fw_resource_table __resource resource_table = {
 		.num = RSC_TABLE_NUM_ENTRY,
 	},
 	.offset = {
-
+		offsetof(struct fw_resource_table, ept_table),
 #if (CONFIG_OPENAMP_RSC_TABLE_NUM_RPMSG_BUFF > 0)
 		offsetof(struct fw_resource_table, vdev),
 #endif
@@ -49,10 +49,15 @@ static struct fw_resource_table __resource resource_table = {
 #endif
 	},
 
+	.ept_table = {
+		.type = RSC_VENDOR_EPT_TABLE,
+		.num_of_epts = 0,
+	},
+
 #if (CONFIG_OPENAMP_RSC_TABLE_NUM_RPMSG_BUFF > 0)
 	/* Virtio device entry */
 	.vdev = {
-		RSC_VDEV, VIRTIO_ID_RPMSG, 0, RPMSG_IPU_C0_FEATURES, 0, 0, 0,
+		RSC_VDEV, VIRTIO_ID_RPMSG, 2, RPMSG_IPU_C0_FEATURES, 0, 0, 0,
 		VRING_COUNT, {0, 0},
 	},
 
diff --git a/lib/open-amp/resource_table.h b/lib/open-amp/resource_table.h
index dc577fafa7e..5bfedada2b0 100644
--- a/lib/open-amp/resource_table.h
+++ b/lib/open-amp/resource_table.h
@@ -7,6 +7,7 @@
 #ifndef RESOURCE_TABLE_H__
 #define RESOURCE_TABLE_H__
 
+#include <openamp/rpmsg.h>
 #include <openamp/remoteproc.h>
 #include <openamp/virtio.h>
 
@@ -28,9 +29,12 @@ extern "C" {
 #define VRING_BUFF_ADDRESS      -1  /* allocated by Master processor */
 #define VRING_ALIGNMENT         16  /* fixed to match with Linux constraint */
 
+#define RSC_VENDOR_EPT_TABLE    128 /* List of bound endpoints */
+
 #endif
 
 enum rsc_table_entries {
+	RSC_TABLE_EPT_TABLE_ENTRY,
 #if (CONFIG_OPENAMP_RSC_TABLE_NUM_RPMSG_BUFF > 0)
 	RSC_TABLE_VDEV_ENTRY,
 #endif
@@ -40,10 +44,27 @@ enum rsc_table_entries {
 	RSC_TABLE_NUM_ENTRY
 };
 
+METAL_PACKED_BEGIN
+struct ept_info {
+	char name[RPMSG_NAME_SIZE];
+	uint32_t addr;
+	uint32_t dest_addr;
+} METAL_PACKED_END;
+
+#define MAX_NUM_OF_EPTS 64
+
+METAL_PACKED_BEGIN
+struct fw_rsc_ept {
+	uint32_t type;
+	uint32_t num_of_epts;
+	struct ept_info endpoints[MAX_NUM_OF_EPTS];
+} METAL_PACKED_END;
+
 struct fw_resource_table {
 	struct resource_table hdr;
 	uint32_t offset[RSC_TABLE_NUM_ENTRY];
 
+	struct fw_rsc_ept ept_table;
 #if (CONFIG_OPENAMP_RSC_TABLE_NUM_RPMSG_BUFF > 0)
 	struct fw_rsc_vdev vdev;
 	struct fw_rsc_vdev_vring vring0;
diff --git a/soc/arm/qemu_cortex_a53/CMakeLists.txt b/soc/arm/qemu_cortex_a53/CMakeLists.txt
index 35d88056740..18a38dd2016 100644
--- a/soc/arm/qemu_cortex_a53/CMakeLists.txt
+++ b/soc/arm/qemu_cortex_a53/CMakeLists.txt
@@ -3,6 +3,7 @@
 
 zephyr_library_sources_ifdef(CONFIG_ARM_MMU mmu_regions.c)
 
-zephyr_include_directories(.)
-
 set(SOC_LINKER_SCRIPT ${ZEPHYR_BASE}/include/zephyr/arch/arm64/scripts/linker.ld CACHE INTERNAL "")
+if(CONFIG_OPENAMP_RSC_TABLE)
+zephyr_linker_sources(DATA_SECTIONS rsc_table_linker.ld)
+endif()
diff --git a/soc/arm/qemu_cortex_a53/mmu_regions.c b/soc/arm/qemu_cortex_a53/mmu_regions.c
index b5d1205775f..afd584c56a1 100644
--- a/soc/arm/qemu_cortex_a53/mmu_regions.c
+++ b/soc/arm/qemu_cortex_a53/mmu_regions.c
@@ -19,6 +19,12 @@ static const struct arm_mmu_region mmu_regions[] = {
 			      DT_REG_ADDR_BY_IDX(DT_INST(0, arm_gic), 1),
 			      DT_REG_SIZE_BY_IDX(DT_INST(0, arm_gic), 1),
 			      MT_DEVICE_nGnRnE | MT_P_RW_U_NA | MT_DEFAULT_SECURE_STATE),
+#if defined(CONFIG_OPENAMP) && !defined(CONFIG_IVSHMEM)
+	MMU_REGION_FLAT_ENTRY("IPC_SHM",
+			      DT_REG_ADDR(DT_NODELABEL(ipc_shm0)),
+			      DT_REG_SIZE(DT_NODELABEL(ipc_shm0)),
+			      MT_NORMAL | MT_P_RW_U_NA | MT_DEFAULT_SECURE_STATE),
+#endif
 };
 
 const struct arm_mmu_config mmu_config = {
diff --git a/soc/arm/qemu_cortex_a53/rsc_table_linker.ld b/soc/arm/qemu_cortex_a53/rsc_table_linker.ld
new file mode 100644
index 00000000000..665093337f9
--- /dev/null
+++ b/soc/arm/qemu_cortex_a53/rsc_table_linker.ld
@@ -0,0 +1,13 @@
+/*
+ * Copyright (c) 2023, openEuler Embedded
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+ SECTION_PROLOGUE(.resource_table,, SUBALIGN(4))
+        {
+          _resource_table_start = .;
+          KEEP(*(.resource_table*))
+          _resource_table_end = .;
+        } GROUP_LINK_IN(ROMABLE_REGION)
+        _resource_tables_size = _resource_table_end - _resource_table_start;
diff --git a/subsys/ipc/rpmsg_service/CMakeLists.txt b/subsys/ipc/rpmsg_service/CMakeLists.txt
index 357a2bc6c3f..b63b11be8f0 100644
--- a/subsys/ipc/rpmsg_service/CMakeLists.txt
+++ b/subsys/ipc/rpmsg_service/CMakeLists.txt
@@ -1,4 +1,19 @@
 # SPDX-License-Identifier: Apache-2.0
 
+if(CONFIG_OPENAMP_RSC_TABLE)
+# METAL_MAX_DEVICE_REGIONS is used to give the number of memory regions shared
+# between processors. By default only one region is defined for the vrings
+# and rpmsg buffers. The METAL_MAX_DEVICE_REGIONS has to be redefined to add a
+# second region for the resource table.
+zephyr_compile_definitions(METAL_MAX_DEVICE_REGIONS=2)
+if(CONFIG_IVSHMEM_DOORBELL)
+# if IVSHMEM is enabled, use IVSHMEM specific implementation
+zephyr_sources(rpmsg_backend_rsc_table_ivshmem.c)
+else()
+zephyr_sources(rpmsg_backend_rsc_table.c)
+endif()
+else()
 zephyr_sources(rpmsg_backend.c)
+endif()
 zephyr_sources(rpmsg_service.c)
+zephyr_sources(rpmsg_rpc_service.c)
diff --git a/subsys/ipc/rpmsg_service/Kconfig b/subsys/ipc/rpmsg_service/Kconfig
index 17d75b37452..7ea7d964d64 100644
--- a/subsys/ipc/rpmsg_service/Kconfig
+++ b/subsys/ipc/rpmsg_service/Kconfig
@@ -23,7 +23,6 @@ config RPMSG_SERVICE_DUAL_IPM_SUPPORT
 
 menuconfig RPMSG_SERVICE
 	bool "RPMsg service for multiple users"
-	select IPM
 	select OPENAMP
 	help
 	  Enables support for a service that can be shared by multiple
@@ -46,7 +45,7 @@ endchoice
 
 config RPMSG_SERVICE_NUM_ENDPOINTS
 	int "Max number of registered endpoints"
-	default 2
+	default 5
 	help
 	  Maximal number of endpoints that can be registered for given
 	  RPMsg service.
diff --git a/subsys/ipc/rpmsg_service/rpmsg_backend.c b/subsys/ipc/rpmsg_service/rpmsg_backend.c
index b3f428e011c..fe1212de906 100644
--- a/subsys/ipc/rpmsg_service/rpmsg_backend.c
+++ b/subsys/ipc/rpmsg_service/rpmsg_backend.c
@@ -60,6 +60,13 @@ static const struct device *const ipm_handle =
 	DEVICE_DT_GET(DT_CHOSEN(zephyr_ipc));
 #endif
 
+/*
+ * 32 bit: -1 == 0xffffffff
+ * 64 bit: -1 == 0xffffffffffffffff
+ */
+#define DEFAULT_PAGE_SHIFT (-1UL)
+#define DEFAULT_PAGE_MASK  (-1UL)
+
 static metal_phys_addr_t shm_physmap[] = { SHM_START_ADDR };
 static struct metal_device shm_device = {
 	.name = SHM_DEVICE_NAME,
@@ -70,8 +77,8 @@ static struct metal_device shm_device = {
 			.virt       = (void *) SHM_START_ADDR,
 			.physmap    = shm_physmap,
 			.size       = SHM_SIZE,
-			.page_shift = 0xffffffff,
-			.page_mask  = 0xffffffff,
+			.page_shift = DEFAULT_PAGE_SHIFT,
+			.page_mask  = DEFAULT_PAGE_MASK,
 			.mem_flags  = 0,
 			.ops        = { NULL },
 		},
diff --git a/subsys/ipc/rpmsg_service/rpmsg_backend.h b/subsys/ipc/rpmsg_service/rpmsg_backend.h
index a74e46b8520..a9f874a0392 100644
--- a/subsys/ipc/rpmsg_service/rpmsg_backend.h
+++ b/subsys/ipc/rpmsg_service/rpmsg_backend.h
@@ -13,15 +13,22 @@
 extern "C" {
 #endif
 
+#if defined(CONFIG_OPENAMP_RSC_TABLE)
+#define SHM_DEVICE_NAME	"shm"
+#define SHM_NODE		DT_CHOSEN(zephyr_ipc_shm)
+#define SHM_START_ADDR	DT_REG_ADDR(SHM_NODE)
+#define SHM_SIZE		DT_REG_SIZE(SHM_NODE)
+#else
 #define VDEV_START_ADDR		DT_REG_ADDR(DT_CHOSEN(zephyr_ipc_shm))
 #define VDEV_SIZE		DT_REG_SIZE(DT_CHOSEN(zephyr_ipc_shm))
 
 #define VDEV_STATUS_ADDR	VDEV_START_ADDR
-#define VDEV_STATUS_SIZE	0x400
+#define VDEV_STATUS_SIZE	0x4000
 
 #define SHM_START_ADDR		(VDEV_START_ADDR + VDEV_STATUS_SIZE)
 #define SHM_SIZE		    (VDEV_SIZE - VDEV_STATUS_SIZE)
 #define SHM_DEVICE_NAME		"sramx.shm"
+#endif
 
 /*
  * @brief Initialize RPMsg backend
@@ -35,7 +42,13 @@ extern "C" {
  * @retval 0 Initialization successful
  * @retval <0 Initialization error reported by OpenAMP
  */
+#if defined(CONFIG_OPENAMP_RSC_TABLE)
+int rpmsg_backend_init(struct metal_io_region **io, struct virtio_device **vdev);
+#else
 int rpmsg_backend_init(struct metal_io_region **io, struct virtio_device *vdev);
+#endif
+
+extern struct rpmsg_virtio_device rvdev;
 
 #ifdef __cplusplus
 }
diff --git a/subsys/ipc/rpmsg_service/rpmsg_backend_rsc_table.c b/subsys/ipc/rpmsg_service/rpmsg_backend_rsc_table.c
new file mode 100644
index 00000000000..e2d817e3185
--- /dev/null
+++ b/subsys/ipc/rpmsg_service/rpmsg_backend_rsc_table.c
@@ -0,0 +1,318 @@
+/*
+ * Copyright (c) 2023, openEuler Embedded
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include "rpmsg_backend.h"
+
+#include <zephyr/kernel.h>
+#include <zephyr/drivers/ipm.h>
+#include <zephyr/device.h>
+#include <zephyr/drivers/pm_cpu_ops.h>
+#include <zephyr/drivers/cache.h>
+#include <zephyr/logging/log.h>
+
+#include <openamp/open_amp.h>
+#include <metal/device.h>
+#include <metal/cache.h>
+#include <resource_table.h>
+
+#define LOG_MODULE_NAME rpmsg_backend
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_RPMSG_SERVICE_LOG_LEVEL);
+
+/* Configuration defines */
+#if !DT_HAS_CHOSEN(zephyr_ipc_shm)
+#error "Module requires definition of shared memory for rpmsg"
+#endif
+
+#define MASTER IS_ENABLED(CONFIG_RPMSG_SERVICE_MODE_MASTER)
+
+#if	IS_ENABLED(CONFIG_RPMSG_SERVICE_MODE_MASTER)
+#error "resource table implementation is only for device"
+#endif
+
+
+/* use resource tables's  reserved[0] to carry some extra information
+ *  the following IDs come from PSCI definition
+ */
+#define CPU_OFF_FUNCID		0x84000002
+#define CPU_SUSPEND_FUNCID 	0xc4000001
+#define CPU_ON_FUNCID		0xC4000003
+#define SYSTEM_RESET		0x84000009
+
+#define IPM_WORK_QUEUE_STACK_SIZE CONFIG_RPMSG_SERVICE_WORK_QUEUE_STACK_SIZE
+#define IPM_WORK_QUEUE_PRIORITY   K_HIGHEST_APPLICATION_THREAD_PRIO
+
+K_THREAD_STACK_DEFINE(ipm_stack_area, IPM_WORK_QUEUE_STACK_SIZE);
+
+struct k_work_q ipm_work_q;
+
+/* End of configuration defines */
+
+static const struct device *const ipm_handle =
+	DEVICE_DT_GET(DT_CHOSEN(zephyr_ipc));
+
+static metal_phys_addr_t shm_physmap = SHM_START_ADDR;
+static struct metal_device shm_device = {
+	.name = SHM_DEVICE_NAME,
+	.num_regions = 2,
+	.regions = {
+	/* shared memory io, only the addr in [share mem start + share mem size]
+	 * can be accessed and guaranteed by metal_io_read/write
+	 */
+		{.virt = NULL},
+	/* resource table io, only the addr in [resource table start + table size]
+	 * can be accessed and guaranteed by metal_io_read/write
+	 */
+		{.virt = NULL},
+	},
+	.node = { NULL },
+	.irq_num = 0,
+	.irq_info = NULL
+};
+
+static struct virtio_device *cur_vdev;
+static struct k_work ipm_work_vring_rx;
+static struct k_work ipm_work_cpu_off;
+
+static int virtio_notify(void *priv, uint32_t id)
+{
+	ARG_UNUSED(priv);
+	int status;
+
+	status = ipm_send(ipm_handle, 0, id, NULL, 0);
+
+	if (status != 0) {
+		LOG_ERR("ipm_send failed to notify: %d", status);
+		return status;
+	}
+
+	return status;
+}
+
+static void ipm_work_handle_vring_rx(struct k_work *work)
+{
+	/* as remote device, VRING1_ID is for RX (from host to devive)*/
+	rproc_virtio_notified(cur_vdev, VRING1_ID);
+}
+
+static void ipm_work_handle_cpu_off(struct k_work *work)
+{
+	LOG_DBG("zephyr: cpu off");
+		/* before cpu_off, some clean ops need to be done:
+		 * - turn off tasks, device, etc.
+		 * - clear cache, memory etc.
+		 */
+	cache_data_invd_all();
+	cache_instr_invd_all();
+
+	/* \todo: extra work to notify other tasks that cpu is going to
+		turn off
+	*/
+
+	/* from arm64 supporting psci, call pm_cpu_off to turn off */
+	pm_cpu_off();
+}
+
+static void reset_vq(void)
+{
+	if (rvdev.svq != NULL) {
+		/*
+		 * For svq:
+		 * vq_free_cnt: Set to vq_nentries, all descriptors in the svq are available.
+		 * vq_queued_cnt: Set to 0, no descriptors waiting to be processed in the svq.
+		 * vq_desc_head_idx: Set to 0, the next available descriptor is at the beginning
+		 *                   of the descriptor table.
+		 * vq_available_idx: Set to 0, No descriptors have been added to the available ring.
+		 * vq_used_cons_idx: No descriptors have been added to the used ring.
+		 * vq_ring.avail->idx and vq_ring.used->idx will be set at host.
+		 */
+		rvdev.svq->vq_free_cnt = rvdev.svq->vq_nentries;
+		rvdev.svq->vq_queued_cnt = 0;
+		rvdev.svq->vq_desc_head_idx = 0;
+		rvdev.svq->vq_available_idx = 0;
+		rvdev.svq->vq_used_cons_idx = 0;
+	}
+
+	if (rvdev.rvq != NULL) {
+		/*
+		 * For rvq:
+		 * Because host resets its tx vq, on the remote side,
+		 * it also needs to reset the rx rq.
+		 */
+		rvdev.rvq->vq_available_idx = 0;
+		rvdev.rvq->vq_used_cons_idx = 0;
+		rvdev.rvq->vq_ring.used->idx = 0;
+		rvdev.rvq->vq_ring.avail->idx = 0;
+		metal_cache_flush(&(rvdev.rvq->vq_ring.used->idx),
+				  sizeof(rvdev.rvq->vq_ring.used->idx));
+		metal_cache_flush(&(rvdev.rvq->vq_ring.avail->idx),
+				  sizeof(rvdev.rvq->vq_ring.avail->idx));
+	}
+}
+
+static void ipm_callback(const struct device *dev,
+			 void *context, uint32_t id,
+			 volatile void *data)
+{
+	struct fw_resource_table *rsc;
+	uint32_t status;
+
+	rsc = (struct fw_resource_table *)context;
+	metal_cache_invalidate(rsc->hdr.reserved, sizeof(rsc->hdr.reserved));
+	status = rsc->hdr.reserved[0];
+
+	(void)dev;
+
+	LOG_DBG("Got callback of id %u", id);
+
+	/* use resource table's reserved bits for extra work */
+	if (status == 0)
+		return;
+
+	LOG_DBG("rsc reserved[0]:%x", status);
+
+	if (status == CPU_OFF_FUNCID) {
+		/* cpu off work */
+		k_work_submit_to_queue(&ipm_work_q, &ipm_work_cpu_off);
+	} else if (status == CPU_ON_FUNCID || status == 0) {
+		/* normal work */
+		k_work_submit_to_queue(&ipm_work_q, &ipm_work_vring_rx);
+	} else if (status == SYSTEM_RESET) {
+		/* attach work: reset virtqueue */
+		reset_vq();
+		/* clear reserved[0] after the reset work is completed */
+		rsc->hdr.reserved[0] = 0;
+		metal_cache_flush(rsc->hdr.reserved, sizeof(rsc->hdr.reserved));
+	}
+}
+
+struct virtio_device *
+platform_create_vdev(void *rsc_table, struct metal_io_region *rsc_io)
+{
+	struct fw_rsc_vdev_vring *vring_rsc;
+	struct virtio_device *vdev;
+	int ret;
+
+	vdev = rproc_virtio_create_vdev(VIRTIO_DEV_DEVICE, VDEV_ID,
+					rsc_table_to_vdev(rsc_table),
+					rsc_io, NULL, virtio_notify, NULL);
+
+	if (!vdev) {
+		LOG_ERR("failed to create vdev");
+		return NULL;
+	}
+
+	/* wait master rpmsg init completion */
+	rproc_virtio_wait_remote_ready(vdev);
+
+
+	vring_rsc = rsc_table_get_vring0(rsc_table);
+	ret = rproc_virtio_init_vring(vdev, 0, vring_rsc->notifyid,
+				      (void *)(uintptr_t)vring_rsc->da, rsc_io,
+				      vring_rsc->num, vring_rsc->align);
+	if (ret) {
+		LOG_ERR("failed to init vring 0");
+		goto failed;
+	}
+
+	vring_rsc = rsc_table_get_vring1(rsc_table);
+	ret = rproc_virtio_init_vring(vdev, 1, vring_rsc->notifyid,
+				      (void *)(uintptr_t)vring_rsc->da, rsc_io,
+				      vring_rsc->num, vring_rsc->align);
+	if (ret) {
+		LOG_ERR("failed to init vring 1");
+		goto failed;
+	}
+
+	cur_vdev = vdev;
+	return vdev;
+
+failed:
+	rproc_virtio_remove_vdev(vdev);
+
+	return NULL;
+}
+
+int rpmsg_backend_init(struct metal_io_region **io, struct virtio_device **vdev)
+{
+	void *rsc_table;
+	struct metal_io_region *rsc_io;
+	int rsc_size;
+	int32_t                  err;
+	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
+	struct metal_device     *device;
+
+	/* Libmetal setup */
+	err = metal_init(&metal_params);
+	if (err) {
+		LOG_ERR("metal_init: failed - error code %d", err);
+		return err;
+	}
+
+	err = metal_register_generic_device(&shm_device);
+	if (err) {
+		LOG_ERR("Couldn't register shared memory device: %d", err);
+		return err;
+	}
+
+	err = metal_device_open("generic", SHM_DEVICE_NAME, &device);
+	if (err) {
+		LOG_ERR("metal_device_open failed: %d", err);
+		return err;
+	}
+
+	metal_io_init(&device->regions[0], (void *)SHM_START_ADDR, &shm_physmap,
+		      SHM_SIZE, -1, 0, NULL);
+
+	/* shared mem io should be return to the caller */
+	*io = metal_device_io_region(device, 0);
+	if (!*io) {
+		LOG_ERR("metal_device_io_region failed to get region");
+		return err;
+	}
+
+	rsc_table_get((struct fw_resource_table **)&rsc_table, &rsc_size);
+	metal_io_init(&device->regions[1], rsc_table,
+		      (metal_phys_addr_t *)rsc_table, rsc_size, -1, 0, NULL);
+	rsc_io = metal_device_io_region(device, 1);
+	if (!rsc_io) {
+		LOG_ERR("Failed to get rsc_io region");
+		return -1;
+	}
+
+	/* IPM setup */
+
+	/* Start IPM workqueue */
+	k_work_queue_start(&ipm_work_q, ipm_stack_area,
+			   K_THREAD_STACK_SIZEOF(ipm_stack_area),
+			   IPM_WORK_QUEUE_PRIORITY, NULL);
+	k_thread_name_set(&ipm_work_q.thread, "ipm_work_q");
+
+	/* Setup IPM workqueue item */
+	k_work_init(&ipm_work_vring_rx, ipm_work_handle_vring_rx);
+	k_work_init(&ipm_work_cpu_off, ipm_work_handle_cpu_off);
+
+	if (!device_is_ready(ipm_handle)) {
+		LOG_ERR("IPM device is not ready");
+		return -ENODEV;
+	}
+
+	ipm_register_callback(ipm_handle, ipm_callback, rsc_table);
+
+	err = ipm_set_enabled(ipm_handle, 1);
+	if (err != 0) {
+		LOG_ERR("Could not enable IPM interrupts and callbacks");
+		return err;
+	}
+
+	/* virtio device setup */
+	*vdev = platform_create_vdev(rsc_table, rsc_io);
+
+	if (*vdev == NULL) {
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/subsys/ipc/rpmsg_service/rpmsg_backend_rsc_table_ivshmem.c b/subsys/ipc/rpmsg_service/rpmsg_backend_rsc_table_ivshmem.c
new file mode 100644
index 00000000000..799e6502aba
--- /dev/null
+++ b/subsys/ipc/rpmsg_service/rpmsg_backend_rsc_table_ivshmem.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright (c) 2023, openEuler Embedded
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include "rpmsg_backend.h"
+
+#include <zephyr/kernel.h>
+#include <zephyr/drivers/virtualization/ivshmem.h>
+#include <zephyr/device.h>
+#include <zephyr/logging/log.h>
+#include <kernel_arch_interface.h>
+
+#include <openamp/open_amp.h>
+#include <metal/device.h>
+#include <resource_table.h>
+
+#define LOG_MODULE_NAME rpmsg_backend
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_RPMSG_SERVICE_LOG_LEVEL);
+
+/* Configuration defines */
+#define MASTER IS_ENABLED(CONFIG_RPMSG_SERVICE_MODE_MASTER)
+
+#if	IS_ENABLED(CONFIG_RPMSG_SERVICE_MODE_MASTER)
+#error "resource table implementation is only for device"
+#endif
+
+
+#define IVSHMEM_EVENT_POLL_STACK_SIZE	8192
+#define IVSHMEM_EVENT_POLL_PRIO		K_HIGHEST_APPLICATION_THREAD_PRIO
+
+/* End of configuration defines */
+
+K_THREAD_STACK_DEFINE(ivshmem_event_poll_stack, IVSHMEM_EVENT_POLL_STACK_SIZE);
+static struct k_thread ivshmem_event_poll_thread;
+
+static const struct device *ivshmem_dev =
+		DEVICE_DT_GET(DT_NODELABEL(ivshmem0));
+
+static struct metal_device shm_device = {
+	.name = SHM_DEVICE_NAME,
+	.num_regions = 2,
+	.regions = {
+	/* shared memory io, only the addr in [share mem start + share mem size]
+	 * can be accessed and guaranteed by metal_io_read/write
+	 */
+		{.virt = NULL},
+	/* resource table io, only the addr in [resource table start + table size]
+	 * can be accessed and guaranteed by metal_io_read/write
+	 */
+		{.virt = NULL},
+	},
+	.node = { NULL },
+	.irq_num = 0,
+	.irq_info = NULL
+};
+
+static struct virtio_device *cur_vdev;
+
+static int virtio_notify(void *priv, uint32_t id)
+{
+	ARG_UNUSED(priv);
+	int status;
+	uint16_t peer_dest_id = ivshmem_get_id(ivshmem_dev);
+
+	peer_dest_id -= 1;
+
+	status = ivshmem_int_peer(ivshmem_dev, peer_dest_id, 0);
+
+	if (status != 0) {
+		LOG_ERR("ivshmem_int_peer failed to notify: %d", status);
+		return status;
+	}
+
+	return status;
+}
+
+struct virtio_device *
+platform_create_vdev(void *rsc_table, struct metal_io_region *rsc_io)
+{
+	struct fw_rsc_vdev_vring *vring_rsc;
+	struct virtio_device *vdev;
+	int ret;
+
+	vdev = rproc_virtio_create_vdev(VIRTIO_DEV_DEVICE, VDEV_ID,
+					rsc_table_to_vdev(rsc_table),
+					rsc_io, NULL, virtio_notify, NULL);
+
+	if (!vdev) {
+		LOG_ERR("failed to create vdev");
+		return NULL;
+	}
+
+	/* wait master rpmsg init completion */
+	rproc_virtio_wait_remote_ready(vdev);
+
+	vring_rsc = rsc_table_get_vring0(rsc_table);
+	LOG_DBG("vring_rsc info: num:%d, da:0x%x", vring_rsc->num, vring_rsc->da);
+	ret = rproc_virtio_init_vring(vdev, 0, vring_rsc->notifyid,
+				      (void *)(uintptr_t)vring_rsc->da, rsc_io,
+				      vring_rsc->num, vring_rsc->align);
+	if (ret) {
+		LOG_ERR("failed to init vring 0");
+		goto failed;
+	}
+
+	vring_rsc = rsc_table_get_vring1(rsc_table);
+	ret = rproc_virtio_init_vring(vdev, 1, vring_rsc->notifyid,
+				      (void *)(uintptr_t)vring_rsc->da, rsc_io,
+				      vring_rsc->num, vring_rsc->align);
+	if (ret) {
+		LOG_ERR("failed to init vring 1");
+		goto failed;
+	}
+
+	cur_vdev = vdev;
+	return vdev;
+
+failed:
+	rproc_virtio_remove_vdev(vdev);
+
+	return NULL;
+}
+
+static void ivshmem_event_poll_thread_entry(void *arg1, void *arg2, void *arg3)
+{
+	ARG_UNUSED(arg1);
+	ARG_UNUSED(arg2);
+	ARG_UNUSED(arg3);
+
+	/* k_poll was signaled or not */
+	unsigned int poll_signaled;
+	/* vector received */
+	int ivshmem_vector_rx;
+	int ret;
+
+	struct k_poll_signal sig;
+
+	struct k_poll_event events[] = {
+		K_POLL_EVENT_INITIALIZER(K_POLL_TYPE_SIGNAL,
+					 K_POLL_MODE_NOTIFY_ONLY,
+					 &sig),
+	};
+
+	k_poll_signal_init(&sig);
+
+	ret = ivshmem_register_handler(ivshmem_dev, &sig, 0);
+
+	if (ret < 0) {
+		LOG_ERR("registering handlers must be supported: %d\n", ret);
+		k_panic();
+	}
+
+	while (1) {
+		LOG_DBG("%s: waiting interrupt from remote peers...\n", __func__);
+		ret = k_poll(events, ARRAY_SIZE(events), K_FOREVER);
+
+		k_poll_signal_check(&sig, &poll_signaled, &ivshmem_vector_rx);
+		/* get ready for next signal */
+		k_poll_signal_reset(&sig);
+
+		/* as remote device, VRING1_ID is for RX (from host to device)*/
+		rproc_virtio_notified(cur_vdev, VRING1_ID);
+	}
+}
+
+int rpmsg_backend_init(struct metal_io_region **io, struct virtio_device **vdev)
+{
+	uintptr_t	rsc_table;
+	struct metal_io_region *rsc_io;
+	int rsc_size;
+	int32_t                  err;
+	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
+	struct metal_device     *device;
+	size_t shmem_size;
+	uintptr_t shmem_phy_addr;
+	static metal_phys_addr_t shm_physmap;
+
+	k_thread_create(&ivshmem_event_poll_thread,
+			ivshmem_event_poll_stack,
+			IVSHMEM_EVENT_POLL_STACK_SIZE,
+			(k_thread_entry_t)ivshmem_event_poll_thread_entry,
+			NULL, NULL, NULL, IVSHMEM_EVENT_POLL_PRIO, 0, K_NO_WAIT);
+
+	/* get ivshmem info, shmem is already mapped in virt_ivshmem. c*/
+	shmem_size = ivshmem_get_rw_mem_section(ivshmem_dev, &shmem_phy_addr);
+
+	LOG_INF("ivshmem addr is 0x%lX, size is 0x%lX", shmem_phy_addr, shmem_size);
+
+	/* Libmetal setup */
+	err = metal_init(&metal_params);
+	if (err) {
+		LOG_ERR("metal_init: failed - error code %d", err);
+		return err;
+	}
+
+	err = metal_register_generic_device(&shm_device);
+	if (err) {
+		LOG_ERR("Couldn't register shared memory device: %d", err);
+		return err;
+	}
+
+	err = metal_device_open("generic", SHM_DEVICE_NAME, &device);
+	if (err) {
+		LOG_ERR("metal_device_open failed: %d", err);
+		return err;
+	}
+
+	/* part1 resource table 
+	 * here resource table will be parsed by the other side and
+	 * copied to the 1st page of ivshmem read&write section. 
+	 * we call rst_table_get to get the correct size and init meta
+	 * io region 
+	 *
+	 */
+	rsc_table_get((struct fw_resource_table **)&rsc_table, &rsc_size);
+	rsc_table = shmem_phy_addr;
+
+	LOG_DBG("rsc_table phys addr is %lx", (uintptr_t)rsc_table);
+
+	metal_io_init(&device->regions[1], (void *)rsc_table,
+		      (metal_phys_addr_t *)rsc_table, rsc_size, -1, 0, NULL);
+	rsc_io = metal_device_io_region(device, 1);
+	if (!rsc_io) {
+		LOG_ERR("Failed to get rsc_io region");
+		return -1;
+	}
+
+	/* part 2: shared mem used for virtio, skip rsc table */
+	shm_physmap = rsc_table + CONFIG_MMU_PAGE_SIZE;
+	metal_io_init(&device->regions[0], (void *)(shm_physmap), &shm_physmap,
+		      shmem_size - CONFIG_MMU_PAGE_SIZE , -1, 0, NULL);
+
+	/* shared mem io should be return to the caller */
+	*io = metal_device_io_region(device, 0);
+	if (!*io) {
+		LOG_ERR("metal_device_io_region failed to get region");
+		return err;
+	}
+	
+	/* virtio device setup */
+	*vdev = platform_create_vdev((void *)rsc_table, rsc_io);
+
+	if (*vdev == NULL) {
+		return -1;
+	}
+
+	/* enable ivshmem device interrupt */
+	ivshmem_enable_interrupts(ivshmem_dev, true);
+
+	return 0;
+}
diff --git a/subsys/ipc/rpmsg_service/rpmsg_rpc_service.c b/subsys/ipc/rpmsg_service/rpmsg_rpc_service.c
new file mode 100644
index 00000000000..635921f0e35
--- /dev/null
+++ b/subsys/ipc/rpmsg_service/rpmsg_rpc_service.c
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2022, openEuler Embedded
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#include "rpmsg_rpc_service.h"
+
+#include <zephyr/types.h>
+#include <zephyr/kernel.h>
+#include <zephyr/device.h>
+#include <zephyr/ipc/rpmsg_service.h>
+#include <zephyr/drivers/pm_cpu_ops.h>
+#include <zephyr/cache.h>
+#include <zephyr/logging/log.h>
+
+#define LOG_MODULE_NAME rpmsg_rpc_service
+LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_RPMSG_SERVICE_LOG_LEVEL);
+
+static const struct rpmsg_rpc_service *find_rpc_service(struct rpmsg_rpc_instance *inst,
+					unsigned int id)
+{
+	const struct rpmsg_rpc_service *service;
+
+	for (unsigned int i = 0; i < inst->n_services; i++) {
+		service = &inst->services[i];
+
+		if (service->id == id) {
+			return service;
+		}
+	}
+
+	return NULL;
+}
+
+static int endpoint_cb_rpmsg_rpc(struct rpmsg_endpoint *ept, void *data,
+					size_t len, uint32_t src, void *priv)
+{
+	uint32_t id;
+
+	struct rpmsg_rpc_instance *inst;
+	const struct rpmsg_rpc_service *service;
+
+	if (len < RPC_ID_LEN) {
+		return 0;
+	}
+
+	inst = (struct rpmsg_rpc_instance *)priv;
+
+	/* skip rpc id */
+	id = *(uint32_t *)data;
+	data = (char *)data + RPC_ID_LEN;
+	len -= RPC_ID_LEN;
+
+	service = find_rpc_service(inst, id);
+
+	if (service) {
+		if (service->cb_function(data, len) < 0) {
+			LOG_ERR("call back %d error", id);
+		}
+	} else {
+		LOG_ERR("no service found");
+	}
+
+	return 0;
+}
+
+int rpmsg_rpc_service_init(struct rpmsg_rpc_instance *inst,
+					const struct rpmsg_rpc_service *services,
+					unsigned int n_services)
+{
+	int ret;
+
+	/* parameter check */
+	if (inst == NULL || services == NULL || n_services == 0) {
+		return -1;
+	}
+
+	inst->services = services;
+	inst->n_services = n_services;
+
+	ret = rpmsg_service_register_endpoint(RPMSG_RPC_SERVICE_NAME,
+							endpoint_cb_rpmsg_rpc, NULL, inst);
+
+	if (ret >= 0) {
+		inst->ep_id = ret;
+		return 0;
+	} else {
+		return ret;
+	}
+}
+
+int rpmsg_rpc_send(struct rpmsg_rpc_instance *inst, uint32_t rpc_id, void *params, size_t len)
+{
+	int ret;
+	struct rpmsg_rpc_data data;
+
+	if (inst == NULL || params == NULL || len == 0) {
+		return -1;
+	}
+
+	data.id = rpc_id;
+	memcpy(data.params, params, len);
+
+	ret = rpmsg_service_send(inst->ep_id, &data, RPC_ID_LEN + len);
+
+	if (ret > 0) {
+		ret -= RPC_ID_LEN;
+	}
+
+	return ret;
+}
+
+/* this call back is called when the response of
+ * sys_service_power_off arrives (in fact maybe never arrives)
+ */
+static int sys_service_power_off_cb(void *params, size_t len)
+{
+	/* before cpu_off, some clean ops need to be done:
+	 * - turn off tasks, device, etc.
+	 * - clear cache, memory etc.
+	 */
+	sys_cache_data_flush_all();
+	sys_cache_instr_flush_all();
+
+	/* from arm64 supporting psci, call pm_cpu_off to turn off */
+	//pm_cpu_off();
+
+	return 0;
+}
+
+static struct rpmsg_rpc_instance sys_service_inst;
+static struct rpmsg_rpc_service sys_service_table[] = {
+	{RPMSG_SYS_SERVICE_POWER_OFF, sys_service_power_off_cb}
+};
+
+static int rpmsg_sys_service_init(void)
+{
+	unsigned int n_services = sizeof(sys_service_table) / sizeof(struct rpmsg_rpc_service);
+
+	LOG_INF("number of services: %d", n_services);
+
+	rpmsg_rpc_service_init(&sys_service_inst, sys_service_table, n_services);
+
+	return 0;
+}
+
+SYS_INIT(rpmsg_sys_service_init, POST_KERNEL,  CONFIG_RPMSG_SERVICE_EP_REG_PRIORITY);
diff --git a/subsys/ipc/rpmsg_service/rpmsg_rpc_service.h b/subsys/ipc/rpmsg_service/rpmsg_rpc_service.h
new file mode 100644
index 00000000000..e6c4b0a1050
--- /dev/null
+++ b/subsys/ipc/rpmsg_service/rpmsg_rpc_service.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2022, openEuler Embedded
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ */
+
+#ifndef ZEPHYR_SUBSYS_IPC_RPMSG_RPC_SERVICE_H
+#define ZEPHYR_SUBSYS_IPC_RPMSG_RPC_SERVICE_H
+
+#include <zephyr/toolchain.h>
+#include <zephyr/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define RPMSG_SYS_SERVICE_POWER_OFF 1
+
+#define RPMSG_RPC_SERVICE_NAME "rpmsg-rpc"
+
+/* RPMSG_BUFFER_SIZE = 512
+ * sizeof(struct rpmsg_hdr) = 16
+ * RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr) - 4 = 492
+ * Aligning to 64 bits -> 488UL
+ */
+#define MAX_BUF_LEN	488UL
+#define RPC_ID_LEN sizeof(uint32_t)
+/*
+ * rpc service call back
+ */
+typedef int (*rpmsg_rpc_cb_t)(void *params, size_t len);
+
+struct rpmsg_rpc_service {
+	uint32_t id;
+	rpmsg_rpc_cb_t cb_function;
+};
+
+struct rpmsg_rpc_data {
+	uint32_t id;    /* rpc id */
+	unsigned char params[MAX_BUF_LEN];
+} __packed;
+
+struct rpmsg_rpc_instance {
+	unsigned int ep_id; /* endpoint id */
+	const struct rpmsg_rpc_service *services; /* service table */
+	unsigned int n_services; /* number of services */
+};
+
+int rpmsg_rpc_service_init(struct rpmsg_rpc_instance *inst,
+					const struct rpmsg_rpc_service *services,
+					unsigned int n_services);
+
+int rpmsg_rpc_send(struct rpmsg_rpc_instance *inst, uint32_t rpc_id, void *params, size_t len);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZEPHYR_SUBSYS_IPC_RPMSG_RPC_SERVICE_H */
diff --git a/subsys/ipc/rpmsg_service/rpmsg_service.c b/subsys/ipc/rpmsg_service/rpmsg_service.c
index 616bfb86ebd..470f9e644ec 100644
--- a/subsys/ipc/rpmsg_service/rpmsg_service.c
+++ b/subsys/ipc/rpmsg_service/rpmsg_service.c
@@ -20,8 +20,12 @@ LOG_MODULE_REGISTER(LOG_MODULE_NAME, CONFIG_RPMSG_SERVICE_LOG_LEVEL);
 
 #define MASTER IS_ENABLED(CONFIG_RPMSG_SERVICE_MODE_MASTER)
 
+#if defined(CONFIG_OPENAMP_RSC_TABLE)
+static struct virtio_device *vdev;
+#else
 static struct virtio_device vdev;
-static struct rpmsg_virtio_device rvdev;
+#endif
+struct rpmsg_virtio_device rvdev;
 static struct metal_io_region *io;
 static bool ep_crt_started;
 
@@ -29,16 +33,30 @@ static bool ep_crt_started;
 static struct rpmsg_virtio_shm_pool shpool;
 #endif
 
-static struct {
+struct service_endpoint {
 	const char *name;
 	rpmsg_ept_cb cb;
+	rpmsg_ns_unbind_cb unbind_cb;
 	struct rpmsg_endpoint ep;
 	volatile bool bound;
-} endpoints[CONFIG_RPMSG_SERVICE_NUM_ENDPOINTS];
+};
+
+static struct service_endpoint endpoints[CONFIG_RPMSG_SERVICE_NUM_ENDPOINTS];
 
 static void rpmsg_service_unbind(struct rpmsg_endpoint *ep)
 {
+	struct service_endpoint *endpoint =
+			CONTAINER_OF(ep, struct service_endpoint, ep);
+
+	if (endpoint->unbind_cb) {
+		endpoint->unbind_cb(ep);
+	}
+
+	/* get unbind reg from host, adjust name to avoid sending ns msg back */
+	ep->name[0] = 0;
 	rpmsg_destroy_ept(ep);
+
+	memset(endpoint, 0, sizeof(struct service_endpoint));
 }
 
 #if MASTER
@@ -86,12 +104,15 @@ static int rpmsg_service_init(void)
 		LOG_ERR("RPMsg backend init failed with error %d", err);
 		return err;
 	}
-
+#if defined(CONFIG_OPENAMP_RSC_TABLE)
+	err = rpmsg_init_vdev(&rvdev, vdev, NULL, io, NULL);
+#else
 #if MASTER
 	rpmsg_virtio_init_shm_pool(&shpool, (void *)SHM_START_ADDR, SHM_SIZE);
 	err = rpmsg_init_vdev(&rvdev, &vdev, ns_bind_cb, io, &shpool);
 #else
 	err = rpmsg_init_vdev(&rvdev, &vdev, NULL, io, NULL);
+#endif
 #endif
 
 	if (err) {
@@ -129,7 +150,8 @@ static int rpmsg_service_init(void)
 	return 0;
 }
 
-int rpmsg_service_register_endpoint(const char *name, rpmsg_ept_cb cb)
+int rpmsg_service_register_endpoint(const char *name, rpmsg_ept_cb cb,
+							rpmsg_ns_unbind_cb unbind_cb, void *priv)
 {
 	if (ep_crt_started) {
 		return -EINPROGRESS;
@@ -139,7 +161,8 @@ int rpmsg_service_register_endpoint(const char *name, rpmsg_ept_cb cb)
 		if (!endpoints[i].name) {
 			endpoints[i].name = name;
 			endpoints[i].cb = cb;
-
+			endpoints[i].unbind_cb = unbind_cb;
+			endpoints[i].ep.priv = priv;
 			return i;
 		}
 	}
@@ -154,6 +177,11 @@ bool rpmsg_service_endpoint_is_bound(int endpoint_id)
 	return endpoints[endpoint_id].bound;
 }
 
+void rpmsg_service_endpoint_bound(int endpoint_id)
+{
+	endpoints[endpoint_id].bound = true;
+}
+
 int rpmsg_service_send(int endpoint_id, const void *data, size_t len)
 {
 	return rpmsg_send(&endpoints[endpoint_id].ep, data, len);
