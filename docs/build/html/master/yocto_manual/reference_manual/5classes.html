<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>5 类文件 &mdash; openEuler Embedded在线文档 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="简介" href="../../oebuild/intro.html" />
    <link rel="prev" title="参考手册" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> openEuler Embedded在线文档
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">介绍与概述</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/index.html">总体介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started/index.html">快速上手</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../releases/index.html">版本说明</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq/index.html">常见问题</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">指导手册</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../features/index.html">关键特性</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bsp/index.html">南向支持</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../yocto/index.html">构建系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../develop_help/index.html">开发帮助</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../linux/index.html">使用与配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../infrastructure/index.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references/index.html">参考文献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bitbake/index.html">BitBake 手册</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">yocto 手册</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">参考手册</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">5 类文件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#allarch">5.1 allarch 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#archiver">5.2 archiver 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#autotools">5.3 autotools 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#base">5.4 base 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bash-completion">5.5 bash-completion</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bin-package">5.6 bin_package 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#binconfig">5.7 binconfig 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#binconfig-disabled">5.8 binconfig-disabled 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buildhistory">5.9 buildhistory 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buildstats">5.10 buildstats 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#buildstats-summary">5.11 buildstats-summary 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cargo">5.12 cargo 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cargo-c">5.13 cargo_c 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cargo-common">5.14 cargo_common 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cargo-update-recipe-crates">5.15 cargo-update-recipe-crates 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ccache">5.16 ccache 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chrpath">5.17 chrpath 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cmake">5.18 cmake 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cml1">5.19 cml1 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compress-doc">5.20 compress_doc 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#copyleft-compliance">5.21 copyleft_compliance 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#copyleft-filter">5.22 copyleft_filter 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#core-image">5.23 core-image 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpan">5.24 cpan* 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#create-spdx">5.25 create-spdx 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cross">5.26 cross 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cross-canadian">5.27 cross-canadian 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crosssdk">5.28 crosssdk 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cve-check">5.29 cve-check</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debian">5.30 debian类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deploy">5.31 deploy类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#devidetree">5.32 devidetree类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#devshell">5.33 devshell类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#devupstream">5.34 devupstream 类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#externalsrc">5.35 externalsrc类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#extausers">5.36 extausers类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#features-check">5.37 features_check类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fontcache">5.38 fontcache类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fs-uuid">5.39 fs-uuid类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gconf">5.40 gconf类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gettext">5.41 gettext类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#github-releases">5.42 github-releases类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gnomebase">5.43 gnomebase类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#go">5.44 go类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#go-mod">5.45 go-mod类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gobject-introspection">5.46 gobject-introspection类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#grub-efi">5.47 grub-efi类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gsettings">5.48 gsettings类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gtk-doc">5.49 gtk-doc类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gtk-icon-cache">5.50 gtk-icon-cache类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gtk-immodules-cache">5.51 gtk-immodules-cache类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gzipnative">5.52 gzipnative类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#icecc">5.53 icecc类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#image">5.54 image类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#image-buildinfo">5.55 image-buildinfo类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#image-types">5.56 image_types类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#image-live">5.57 image-live类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#insane">5.58 insane类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel">5.59 kernel类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-arch">5.60 kernel-arch类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-devicetree">5.61 kernel-devicetree类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-fitimage">5.62 kernel-fitimage类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-grub">5.63 kernel-grub类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-module-split">5.64 kernel-module-split类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-uboot">5.65 kernel-uboot类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-uimage">5.66 kernel-uimage类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-yocto">5.67 kernel-yocto类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernelsrc">5.68 kernelsrc类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lib-package">5.69 lib_package类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#libc">5.70 libc*类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#license">5.71 license类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-kernel-base">5.72 linux-kernel-base类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linuxloader">5.73 linuxloader类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logging">5.74 logging类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#meson">5.75 meson类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#metadata-scm">5.76 metadata_scm类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#migrate-localcount">5.77 migrate_localcount类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mime">5.78 mime类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mime-xdg">5.79 mime-xdg类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mirrors">5.80 mirrors类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module">5.81 module类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-base">5.82 module-base类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multilib">5.83 multilib*类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#native">5.84 native类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nativesdk">5.85 nativesdk类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nopackages">5.86 nopackages类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#npm">5.87 npm类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#oelint">5.88 oelint类</a></li>
<li class="toctree-l4"><a class="reference internal" href="#overlayfs">5.89 overlayfs类</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">oebuild 指导</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../oebuild/intro.html">简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oebuild/userguide/index.html">用户指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oebuild/develop/index.html">开发者指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../oebuild/release/index.html">版本变更日志</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">openEuler Embedded在线文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">yocto 手册</a> &raquo;</li>
          <li><a href="index.html">参考手册</a> &raquo;</li>
      <li>5 类文件</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="classes">
<span id="id1"></span><h1>5 类文件<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<p>类文件用于抽象通用功能并在多个配方（.bb）文件中共享。要使用类文件，只需确保配方继承了该类。在大多数情况下，当配方继承一个类时，启用其功能就足够了。然而，在某些情况下，您可能需要在配方中设置变量或覆盖某些默认行为。</p>
<p>通常在配方中找到的任何元数据也可以放在类文件中。类文件通过扩展名
.bbclass 进行标识，通常放置在 Source Directory 下的 meta*/
目录的一组子目录之一：</p>
<ul class="simple">
<li><p>classes-recipe/ - 旨在单独由配方继承的类</p></li>
<li><p>classes-global/ - 旨在全局继承的类</p></li>
<li><p>classes/ - 使用上下文未明确定义的类</p></li>
</ul>
<p>类文件也可以通过 BUILDDIR（例如 build/）指向，与 conf 目录中的 .conf
文件相同。类文件通过与搜索 .conf 文件相同的方法在 BBPATH 中进行搜索。</p>
<p>本章仅讨论最有用和重要的类。Source Directory 中的 meta/classes*
目录中确实存在其他类。您可以直接引用 .bbclass 文件以获取更多信息。</p>
<section id="allarch">
<h2>5.1 allarch 类<a class="headerlink" href="#allarch" title="Permalink to this headline">¶</a></h2>
<p>allarch
类被继承给不产生特定于架构的输出的配方。该类禁用了通常需要用于生成可执行二进制文件的配方的功能（例如，在构建交叉编译器和
C 库作为先决条件，并在打包过程中拆分调试符号）。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>与某些发行版配方（例如 Debian）不同，通过使用 RDEPENDS 和
TUNE_PKGARCH 变量来依赖调整的 OpenEmbedded
配方，不应配置为所有架构使用
allarch。即使配方不产生特定于架构的输出，这也是正确的。</p>
<p>将此类配方配置为所有架构会导致具有不同调整的机器的 <cite>do_package_write_*</cite>
任务具有不同的签名。此外，即使配方从未更改，每次构建不同 MACHINE
的映像时都会发生不必要的重建。</p>
</div>
<p>默认情况下，所有配方都继承 base 和 package
类，这些类启用了生成可执行输出所需的功能。如果您的配方仅生成包含配置文件、媒体文件或脚本（例如
Python 和 Perl）的包，则应继承 allarch 类。</p>
</section>
<section id="archiver">
<h2>5.2 archiver 类<a class="headerlink" href="#archiver" title="Permalink to this headline">¶</a></h2>
<p>archiver 类支持在二进制文件发布时同时发布源代码和其他材料。</p>
<p>有关 source archiver 的更多详细信息，请参阅 Yocto Project Development
Tasks Manual
中的“<a class="reference external" href="https://docs.yoctoproject.org/dev-manual/licenses.html#maintaining-open-source-license-compliance-during-your-product-s-lifecycle">在产品生命周期中维护开源许可合规性</a>”部分。您还可以查看
ARCHIVER_MODE
变量以获取有关帮助控制存档创建的变量标志（varflags）的信息。</p>
</section>
<section id="autotools">
<h2>5.3 autotools 类<a class="headerlink" href="#autotools" title="Permalink to this headline">¶</a></h2>
<p>autotools* 类支持使用 GNU Autotools 构建的软件包。</p>
<p>autoconf、automake 和 libtool
软件包带来了标准化。这个类定义了一组任务（例如 configure、compile
等），适用于所有使用 Autotools
的软件包。通常只需定义一些标准变量，然后简单地继承 autotools
类就足够了。这些类也可以与模拟 Autotools
的软件一起使用。有关更多信息，请参阅 Yocto Project Development Tasks
Manual 中的“构建一个 Autotooled Package”部分。</p>
<p>默认情况下，autotools* 类使用 out-of-tree 构建（即 autotools.bbclass 在
B != S 的情况下构建）。</p>
<p>如果配方构建的软件不支持使用 out-of-tree 构建，您应该让配方继承
autotools-brokensep 类。autotools-brokensep 类的行为与 autotools*
类相同，但在 B == S 的情况下构建。当 out-of-tree
构建支持不存在或损坏时，这种方法很有用。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果可能的话，建议修复并使用 out-of-tree 支持。</p>
</div>
<p>了解由 autotools* 类定义的任务如何工作以及它们在幕后做了什么是有用的。</p>
<ul class="simple">
<li><dl class="simple">
<dt>do_configure — 重新生成 configure 脚本（使用</dt><dd><p>autoreconf），然后使用交叉编译期间使用的标准参数集启动它。您可以通过
EXTRA_OECONF 或 PACKAGECONFIG_CONFARGS 变量向 configure
传递额外参数。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>do_compile — 运行 make 命令，并指定编译器和链接器的参数。您可以通过</dt><dd><p>EXTRA_OEMAKE 变量传递额外的参数。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>do_install — 运行 make install 命令，并将 ${D} 作为 DESTDIR</dt><dd><p>传递进去。</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="base">
<h2>5.4 base 类<a class="headerlink" href="#base" title="Permalink to this headline">¶</a></h2>
<p>base 类是特殊的，因为每个 .bb
文件都会隐式地继承该类。这个类包含了一些标准基本任务的定义，例如获取、解压缩、配置（默认为空）、编译（运行任何存在的
Makefile）、安装（默认为空）和打包（默认为空）。这些任务通常被其他类（如
autotools* 类或 package 类）覆盖或扩展。</p>
<p>该类还包含一些常用的函数，例如 oe_runmake，它使用在 EXTRA_OEMAKE
变量中指定的参数以及直接传递给 oe_runmake 的参数来运行 make。</p>
</section>
<section id="bash-completion">
<h2>5.5 bash-completion<a class="headerlink" href="#bash-completion" title="Permalink to this headline">¶</a></h2>
<p>为构建包含 bash-completion 数据的配方设置适当的打包和依赖项。</p>
</section>
<section id="bin-package">
<h2>5.6 bin_package 类<a class="headerlink" href="#bin-package" title="Permalink to this headline">¶</a></h2>
<p>bin_package 类是帮助配方提取二进制包（例如
RPM）的内容并安装这些内容，而不是从源代码构建二进制文件的辅助类。二进制包被提取，然后创建配置输出包格式的新包。提取和安装专有二进制文件是一个很好的使用此类的例子。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<blockquote>
<div><p>对于不包含子目录的 RPM 和其他软件包，您应该指定适当的 fetcher
参数以指向子目录。例如，如果 BitBake 使用的是 Git
fetcher（git://），则“subpath”参数将检出限制为树的特定子路径。以下是一个示例，其中
${BP} 用于使文件提取到预期的默认值 S 的子目录中：</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SRC_URI</span> <span class="o">=</span> <span class="s2">&quot;git://example.com/downloads/somepackage.rpm;branch=main;subpath=$</span><span class="si">{BP}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>有关支持的 BitBake Fetchers 的更多信息，请参阅 BitBake User Manual
中的“Fetchers”部分。</p>
</div>
</section>
<section id="binconfig">
<h2>5.7 binconfig 类<a class="headerlink" href="#binconfig" title="Permalink to this headline">¶</a></h2>
<p>binconfig 类有助于纠正 shell 脚本中的路径。</p>
<p>在 pkg-config 成为主流之前，库会提供 shell
脚本来提供有关构建软件所需的库和包含路径的信息（通常命名为
LIBNAME-config）。此类可帮助任何使用此类脚本的配方。</p>
<p>在暂存期间，OpenEmbedded 构建系统将此类脚本安装到 sysroots/
目录中。继承此类会导致这些脚本中的所有路径更改为指向 sysroots/
目录，以便所有使用该脚本的构建都使用交叉编译布局的正确目录。有关更多信息，请参阅
BINCONFIG_GLOB 变量。</p>
</section>
<section id="binconfig-disabled">
<h2>5.8 binconfig-disabled 类<a class="headerlink" href="#binconfig-disabled" title="Permalink to this headline">¶</a></h2>
<p>binconfig 类的替代版本，通过使它们返回错误来禁用二进制配置脚本，从而使用
pkg-config 查询信息。要禁用的脚本应在继承该类的配方中使用 BINCONFIG
变量指定。</p>
</section>
<section id="buildhistory">
<h2>5.9 buildhistory 类<a class="headerlink" href="#buildhistory" title="Permalink to this headline">¶</a></h2>
<p>buildhistory类记录构建输出元数据的历史，该元数据可用于检测可能的回归，也可用于分析构建输出。有关使用构建历史的更多信息，请参阅Yocto项目开发任务手册中的“<a class="reference external" href="https://docs.yoctoproject.org/dev-manual/build-quality.html#maintaining-build-output-quality">维护构建输出质量</a>”部分。</p>
</section>
<section id="buildstats">
<h2>5.10 buildstats 类<a class="headerlink" href="#buildstats" title="Permalink to this headline">¶</a></h2>
<p>buildstats 类记录了构建期间执行的每个任务的性能统计信息（例如，耗时、CPU
使用率和 I/O 使用率）。</p>
<p>当您使用此类时，输出将进入 BUILDSTATS_BASE 目录，默认为
${TMPDIR}/buildstats/。您可以使用
scripts/pybootchartgui/pybootchartgui.py
分析耗时，该脚本生成整个构建过程的级联图表，可用于突出显示瓶颈。</p>
<p>通过本地.conf 文件中的 USER_CLASSES
变量启用收集构建统计信息的默认设置。因此，您无需执行任何操作即可启用该类。但是，如果您想禁用该类，只需从
USER_CLASSES 列表中删除“buildstats”。</p>
</section>
<section id="buildstats-summary">
<h2>5.11 buildstats-summary 类<a class="headerlink" href="#buildstats-summary" title="Permalink to this headline">¶</a></h2>
<p>当全局继承时，在构建结束时打印有关 sstate
重用的统计信息。为了使其正常工作，此类需要启用 buildstats 类。</p>
</section>
<section id="cargo">
<h2>5.12 cargo 类<a class="headerlink" href="#cargo" title="Permalink to this headline">¶</a></h2>
<p>cargo 类允许使用 Cargo 编译 Rust 语言程序。Cargo 是 Rust
的包管理器，允许获取包依赖项并构建您的程序。</p>
<p>使用此类可以非常方便地构建 Rust 程序。您只需要使用 SRC_URI
变量指向一个可以通过 Cargo 构建的源代码仓库，通常是由 cargo new
命令创建的，包含 Cargo.toml 文件、Cargo.lock 文件和 src 子目录。</p>
<p>如果您想构建和打包程序的测试，请继承 ptest-cargo 类而不是 cargo。</p>
<p>在 zvariant_3.12.0.bb 配方中，您将找到一个示例（还展示了如何处理可能的
git 源依赖项）。另一个只有 crate 依赖项的示例是 uutils-coreutils
配方，它是由 cargo-bitbake 工具生成的。</p>
<p>此类继承了 cargo_common 类。</p>
</section>
<section id="cargo-c">
<h2>5.13 cargo_c 类<a class="headerlink" href="#cargo-c" title="Permalink to this headline">¶</a></h2>
<p>cargo_c 类可以被配方继承，以生成一个可以由 C/C++ 代码调用的 Rust
库。继承此类的配方只需将 inherit cargo 替换为 inherit cargo_c。</p>
<p>请参阅 rust-c-lib-example_git.bb 示例配方。</p>
</section>
<section id="cargo-common">
<h2>5.14 cargo_common 类<a class="headerlink" href="#cargo-common" title="Permalink to this headline">¶</a></h2>
<p>cargo_common 类是一个内部类，不打算直接使用。</p>
<p>一个例外是“rust”配方，用于构建 Rust 编译器和运行时库，它由 Cargo 构建，但不能使用 cargo 类。这就是为什么引入了这个类。</p>
</section>
<section id="cargo-update-recipe-crates">
<h2>5.15 cargo-update-recipe-crates 类<a class="headerlink" href="#cargo-update-recipe-crates" title="Permalink to this headline">¶</a></h2>
<p>cargo-update-recipe-crates 类允许配方开发人员通过读取源代码树中的
Cargo.lock 文件来更新 SRC_URI 中的 Cargo crate 列表。</p>
<p>要做到这一点，为您的程序创建一个配方，例如使用 devtool，使其继承 cargo
和 cargo-update-recipe-crates，然后运行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bitbake</span> <span class="o">-</span><span class="n">c</span> <span class="n">update_crates</span> <span class="n">recipe</span>
</pre></div>
</div>
<p>这将创建一个 recipe-crates.inc 文件，您可以将其包含在您的配方中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>require ${BPN}-crates.inc
</pre></div>
</div>
<p>这也是您可以使用 cargo-bitbake 工具实现的目标。</p>
</section>
<section id="ccache">
<h2>5.16 ccache 类<a class="headerlink" href="#ccache" title="Permalink to this headline">¶</a></h2>
<p>ccache 类启用了构建过程中的 C/C++
编译器缓存。这个类用于在构建期间提供轻微的性能提升。</p>
<p>有关 C/C++ 编译器缓存的信息，请参阅
<a class="reference external" href="https://ccache.samba.org/">https://ccache.samba.org/</a>。有关如何在配置文件中启用此机制、如何为特定配方禁用它以及如何在构建之间共享
ccache 文件的详细信息，请参阅 ccache.bbclass 文件。</p>
<p>然而，使用该类可能会导致意外的副作用。因此，不建议使用此类。</p>
</section>
<section id="chrpath">
<h2>5.17 chrpath 类<a class="headerlink" href="#chrpath" title="Permalink to this headline">¶</a></h2>
<p>chrpath 类是“chrpath”实用程序的包装器，在构建过程中用于 nativesdk、cross
和 cross-canadian 配方中，以更改二进制文件中的 RPATH
记录，从而使它们可重定位。</p>
</section>
<section id="cmake">
<h2>5.18 cmake 类<a class="headerlink" href="#cmake" title="Permalink to this headline">¶</a></h2>
<p>cmake 类允许配方使用 CMake 构建系统来构建软件。您可以使用 EXTRA_OECMAKE
变量指定要传递给 cmake 命令行的附加配置选项。</p>
<p>默认情况下，cmake 类使用 Ninja 而不是 GNU make
进行构建，这提供了更好的构建性能。如果一个配方在使用 Ninja
时出现问题，那么该配方可以将 OECMAKE_GENERATOR 变量设置为 Unix Makefiles
以改用 GNU make。</p>
<p>如果您需要安装由正在构建的应用程序提供的自定义 CMake 工具链文件，则应在
do_install 期间将它们安装到首选的 CMake
模块目录：<code class="docutils literal notranslate"><span class="pre">${D}${datadir}/cmake/modules/</span></code>。</p>
</section>
<section id="cml1">
<h2>5.19 cml1 类<a class="headerlink" href="#cml1" title="Permalink to this headline">¶</a></h2>
<p>cml1 类提供了对 Linux
内核风格的构建配置系统的基本支持。“cml”代表“Configuration Menu
Language”，它起源于 Linux 内核，但也用于其他项目，如 U-Boot 和
BusyBox。它也可以被叫做“kconfig”。</p>
</section>
<section id="compress-doc">
<h2>5.20 compress_doc 类<a class="headerlink" href="#compress-doc" title="Permalink to this headline">¶</a></h2>
<p>启用对手册页和信息页的压缩。该类旨在全局继承。默认的压缩机制是
gz（gzip），但您可以通过设置 DOC_COMPRESS 变量来选择另一种机制。</p>
</section>
<section id="copyleft-compliance">
<h2>5.21 copyleft_compliance 类<a class="headerlink" href="#copyleft-compliance" title="Permalink to this headline">¶</a></h2>
<p>copyleft_compliance 类保留源代码以遵守许可证。该类是 archiver
类的替代方案，尽管它已被弃用，但仍被一些用户使用。</p>
</section>
<section id="copyleft-filter">
<h2>5.22 copyleft_filter 类<a class="headerlink" href="#copyleft-filter" title="Permalink to this headline">¶</a></h2>
<p>archiver 和 copyleft_compliance 类用于过滤许可证的类。copyleft_filter
类是内部类，不建议直接使用。</p>
</section>
<section id="core-image">
<h2>5.23 core-image 类<a class="headerlink" href="#core-image" title="Permalink to this headline">¶</a></h2>
<p>core-image 类为 core-image-* 图像配方提供通用定义，例如支持额外的
IMAGE_FEATURES。</p>
</section>
<section id="cpan">
<h2>5.24 cpan* 类<a class="headerlink" href="#cpan" title="Permalink to this headline">¶</a></h2>
<p>cpan* 类支持 Perl 模块。</p>
<p>Perl
模块的配方非常简单。这些配方通常只需要指向源文件的存档，然后继承适当的类文件。构建分为两种方法，具体取决于模块作者使用的方法。</p>
<ul class="simple">
<li><dl class="simple">
<dt>使用旧的基于 Makefile.PL 的构建系统的模块需要在它们的配方中使用</dt><dd><p>cpan.bbclass。</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>使用基于 Build.PL 的构建系统的模块需要在它们的配方中使用</dt><dd><p>cpan_build.bbclass。</p>
</dd>
</dl>
</li>
</ul>
<p>这两种构建方法都继承 cpan-base 类以提供基本的 Perl 支持。</p>
</section>
<section id="create-spdx">
<h2>5.25 create-spdx 类<a class="headerlink" href="#create-spdx" title="Permalink to this headline">¶</a></h2>
<p>create-spdx 类提供了基于图像和 SDK 内容自动创建 SPDX SBOM 文档的支持。</p>
<p>该类应从配置文件中全局继承：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INHERIT</span> <span class="o">+=</span> <span class="s2">&quot;create-spdx&quot;</span>
</pre></div>
</div>
<p>顶层 SPDX 输出文件以 JSON 格式生成为 IMAGE-MACHINE.spdx.json 文件，位于
Build Directory 中的 tmp/deploy/images/MACHINE/
目录下。同一目录中还有其他相关文件，以及在 tmp/deploy/spdx 中。</p>
<p>此类的确切行为以及输出量可以通过
SPDX_PRETTY、SPDX_ARCHIVE_PACKAGED、SPDX_ARCHIVE_SOURCES 和
SPDX_INCLUDE_SOURCES 变量进行控制。</p>
<p>有关这些变量的描述以及“创建软件材料清单”部分，请参阅 <a class="reference external" href="https://docs.yoctoproject.org/dev-manual/sbom.html#creating-a-software-bill-of-materials">Yocto Project
Development
Manual</a>。</p>
</section>
<section id="cross">
<h2>5.26 cross 类<a class="headerlink" href="#cross" title="Permalink to this headline">¶</a></h2>
<p>cross 类提供了构建交叉编译工具的配方的支持。</p>
</section>
<section id="cross-canadian">
<h2>5.27 cross-canadian 类<a class="headerlink" href="#cross-canadian" title="Permalink to this headline">¶</a></h2>
<p>cross-canadian 类为构建用于 SDK 的 Canadian Cross-compilation
工具的配方提供支持。有关这些交叉编译工具的更多讨论，请参阅《Yocto
项目概述和概念手册》中的“交叉开发工具链生成”部分。</p>
</section>
<section id="crosssdk">
<h2>5.28 crosssdk 类<a class="headerlink" href="#crosssdk" title="Permalink to this headline">¶</a></h2>
<p>crosssdk 类提供了构建用于构建 SDK
的交叉编译工具的配方的支持。有关这些交叉编译工具的更多讨论，请参阅 Yocto
项目概述和概念手册中的“交叉开发工具链生成”部分。</p>
</section>
<section id="cve-check">
<h2>5.29 cve-check<a class="headerlink" href="#cve-check" title="Permalink to this headline">¶</a></h2>
<p>cve-check类在构建时使用BitBake查找已知的CVE（常见漏洞和暴露）。这个类应该从配置文件中全局继承：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">INHERIT</span> <span class="o">+=</span> <span class="s2">&quot;cve-check&quot;</span>
</pre></div>
</div>
<p>要过滤掉已知不会影响Poky和OE-Core软件的过时CVE数据库条目，请在构建配置文件中添加以下行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">include</span> <span class="n">cve</span><span class="o">-</span><span class="n">extra</span><span class="o">-</span><span class="n">exclusions</span><span class="o">.</span><span class="n">inc</span>
</pre></div>
</div>
<p>您还可以通过向BitBake传递-c cve_check来查找特定包中的漏洞。</p>
<p>使用Bitbake构建软件后，CVE检查输出报告可在
<em>tmp/deploy/cve</em>中找到，图像特定的摘要在<em>tmp/deploy/images/.cve</em>或<em>tmp/deploy/images/.json</em>文件中。</p>
<p>在构建过程中，CVE检查器会对检测到的任何处于Unpatched状态的问题发出构建时间警告，这意味着CVE问题似乎会影响正在编译的软件组件和版本，并且没有应用解决该问题的补丁。检测到的CVE问题的其它状态是：Patched表示已经应用了解决该问题的补丁，以及Ignored表示可以忽略该问题。</p>
<p>CVE问题的Patched状态是通过具有格式CVE-ID.patch的补丁文件检测的，例如CVE-2019-20633.patch，在SRC_URI中使用CVE元数据，并在补丁文件的提交消息中使用格式CVE:
CVE-ID。</p>
<p>如果配方中添加了CVE-ID作为CVE_STATUS变量的标志，并且状态映射为Ignored，那么CVE状态将被报告为Ignored：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CVE_STATUS</span><span class="p">[</span><span class="n">CVE</span><span class="o">-</span><span class="mi">2020</span><span class="o">-</span><span class="mi">15523</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;not-applicable-platform: Issue only applies on Windows&quot;</span>
</pre></div>
</div>
<p>如果CVE检查报告配方包含误报或漏报，可以通过调整CVE产品名称来修复这些问题，使用CVE_PRODUCT和CVE_VERSION变量。CVE_PRODUCT默认为纯配方名称BPN，可以使用以下语法将其调整为一个或多个CVE数据库供应商和产品对：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CVE_PRODUCT</span> <span class="o">=</span> <span class="s2">&quot;flex_project:flex&quot;</span>
</pre></div>
</div>
<p>其中flex_project是CVE数据库供应商名称，flex是产品名称。同样，如果默认的配方版本PV与上游发布中的软件组件的版本号或CVE数据库不匹配，则可以使用CVE_VERSION变量设置与CVE数据库兼容的版本号，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CVE_VERSION</span> <span class="o">=</span> <span class="s2">&quot;2.39&quot;</span>
</pre></div>
</div>
<p>CVE数据库条目中的任何错误、缺失或不完整信息都应通过NVD反馈表在CVE数据库中进行修复。</p>
<p>用户应注意，安全是一个过程，而不是一个产品，因此CVE检查、分析结果、修补和更新软件也应作为一个常规过程来进行。CVE检查器可靠检测问题所需的数据和假设经常以各种方式被破坏。这些问题只能通过审查问题的详细信息、迭代生成的报告以及关注其他Linux发行版和更大的开源社区中发生的事情来检测。</p>
<p>您可以在“<a class="reference external" href="https://docs.yoctoproject.org/dev-manual/vulnerabilities.html#checking-for-vulnerabilities">《开发任务手册》</a>”的“检查漏洞”部分中找到更多详细信息。</p>
</section>
<section id="debian">
<h2>5.30 debian类<a class="headerlink" href="#debian" title="Permalink to this headline">¶</a></h2>
<p>Debian类将输出包重命名为遵循Debian命名策略的包名（例如，glibc变为libc6，glibc-devel变为libc6-dev）。重命名包括库名称和版本作为包名的一部分。</p>
<p>如果一个配方为多个库创建包（.so类型的共享对象文件），请在配方中使用LEAD_SONAME变量来指定应用命名方案的库。</p>
</section>
<section id="deploy">
<h2>5.31 deploy类<a class="headerlink" href="#deploy" title="Permalink to this headline">¶</a></h2>
<p>Deploy类处理将文件部署到DEPLOY_DIR_IMAGE目录。这个类的主要功能是通过共享状态加速部署步骤。继承此类的配方应定义自己的do_deploy函数，将要部署的文件复制到DEPLOYDIR，并使用addtask在适当的位置添加任务，通常在do_compile或do_install之后。然后，该类负责将文件从DEPLOYDIR阶段化到DEPLOY_DIR_IMAGE。</p>
</section>
<section id="devidetree">
<h2>5.32 devidetree类<a class="headerlink" href="#devidetree" title="Permalink to this headline">¶</a></h2>
<p>Devicetree类允许构建一个编译不在内核树中的设备树源文件的配方。</p>
<p>编译非树形设备树源的过程与内核树中设备树编译过程相同。这包括能够包含来自内核的源，例如SoC
dtsi文件以及C头文件，如gpio.h。</p>
<p>do_compile任务将编译两种类型的文件：</p>
<ul class="simple">
<li><p>带有.dts扩展名的常规设备树源文件。</p></li>
<li><p>检测到文件内容中存在/plugin/;字符串的设备树覆盖层。</p></li>
</ul>
<p>该类将生成的设备树二进制部署到<em>${DEPLOY_DIR_IMAGE}/devicetree/</em>中。这与kernel-devicetree类所做的类似，添加了devicetree子目录以避免名称冲突。此外，设备树被填充到sysroot中，以便通过sysroot从其他配方中访问。</p>
<p>默认情况下，位于DT_FILES_PATH目录中的所有设备树源文件都将被编译。要选择特定的源文件，请将DT_FILES设置为相对于DT_FILES_PATH的文件列表（以空格分隔）。为了方便起见，可以使用.dts和.dtb扩展名。</p>
<p>在非覆盖设备树二进制文件中附加额外的填充。这通常可以用作在启动时添加额外属性的额外空间。可以通过将DT_PADDING_SIZE设置为所需的大小（以字节为单位）来修改填充大小。</p>
<p>有关控制此类的其他变量，请参阅devicetree.bbclass源代码。</p>
<p>以下是继承此类的示例recipes-kernel/linux/devicetree-acme.bb配方的摘录：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inherit</span> <span class="n">devicetree</span>
<span class="n">COMPATIBLE_MACHINE</span> <span class="o">=</span> <span class="s2">&quot;^mymachine$&quot;</span>
<span class="n">SRC_URI</span><span class="p">:</span><span class="n">mymachine</span> <span class="o">=</span> <span class="s2">&quot;file://mymachine.dts&quot;</span>
</pre></div>
</div>
</section>
<section id="devshell">
<h2>5.33 devshell类<a class="headerlink" href="#devshell" title="Permalink to this headline">¶</a></h2>
<p>devshell类添加了do_devshell任务。是否包含此类由发行版策略决定。有关使用devshell的更多信息，请参阅Yocto项目开发任务手册中的“<a class="reference external" href="https://docs.yoctoproject.org/dev-manual/development-shell.html#using-a-development-shell">使用开发Shell</a>”部分。</p>
</section>
<section id="devupstream">
<h2>5.34 devupstream 类<a class="headerlink" href="#devupstream" title="Permalink to this headline">¶</a></h2>
<p>devupstream类使用BBCLASSEXTEND添加一个从替代URI（例如Git）获取而不是tarball的配方变体。以下是一个例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BBCLASSEXTEND</span> <span class="o">=</span> <span class="s2">&quot;devupstream:target&quot;</span>
<span class="n">SRC_URI</span><span class="p">:</span><span class="n">class</span><span class="o">-</span><span class="n">devupstream</span> <span class="o">=</span> <span class="s2">&quot;git://git.example.com/example;branch=main&quot;</span>
<span class="n">SRCREV</span><span class="p">:</span><span class="n">class</span><span class="o">-</span><span class="n">devupstream</span> <span class="o">=</span> <span class="s2">&quot;abcd1234&quot;</span>
</pre></div>
</div>
<p>将上述语句添加到您的配方中，会创建一个默认优先级设置为“-1”的变体。因此，您需要选择要使用的配方变体。任何开发特定的调整都可以通过使用class-devupstream覆盖来实现。以下是一个例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>DEPENDS:append:class-devupstream = &quot; gperf-native&quot;
do_configure:prepend:class-devupstream() {
    touch ${S}/README
}
</pre></div>
</div>
<p>该类目前仅支持创建目标配方的开发变体，不支持原生或原生sdk变体。</p>
<p>BBCLASSEXTEND语法（即devupstream:target）提供了对原生和原生sdk变体的支持。因此，此功能可以在将来的版本中添加。</p>
<p>由于BitBake的自动获取依赖项（例如subversion-native），对其他版本控制系统（如Subversion）的支持有限。</p>
</section>
<section id="externalsrc">
<h2>5.35 externalsrc类<a class="headerlink" href="#externalsrc" title="Permalink to this headline">¶</a></h2>
<p>externalsrc类支持从OpenEmbedded构建系统外部的源代码构建软件。从外部源代码树构建软件意味着不使用构建系统的正常获取、解压缩和修补过程。</p>
<p>默认情况下，OpenEmbedded构建系统使用S和B变量来定位解压缩的配方源代码并构建它。当您的配方继承externalsrc类时，您使用EXTERNALSRC和EXTERNALSRC_BUILD变量最终定义S和B。</p>
<p>默认情况下，此类期望源代码支持使用B变量指向OpenEmbedded构建系统放置从配方生成的对象的目录的配方构建。默认情况下，B目录设置为以下内容，与源目录（S）分开：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>${WORKDIR}/${BPN}-{PV}/
</pre></div>
</div>
<p>有关这些变量的更多信息，请参阅WORKDIR、BPN和PV变量。</p>
<p>有关externalsrc类的更多信息，请参阅Source
Directory中的<em>meta/classes/externalsrc.bbclass</em>中的注释。有关如何使用externalsrc类的信息，请参阅Yocto项目开发任务手册中的“从外部源代码构建软件”部分。</p>
</section>
<section id="extausers">
<h2>5.36 extausers类<a class="headerlink" href="#extausers" title="Permalink to this headline">¶</a></h2>
<p>extrausers类允许在镜像级别应用额外的用户和组配置。继承这个类可以在全局或从镜像配方中进行，允许使用EXTRA_USERS_PARAMS变量执行额外的用户和组操作。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>使用extrausers类添加的用户和组操作与特定配方之外的配方无关。因此，可以在整个镜像上执行操作。使用useradd*类将用户和组配置添加到特定的配方中。</p>
</div>
<p>以下是一个在镜像配方中使用此类的示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inherit</span> <span class="n">extrausers</span>
<span class="n">EXTRA_USERS_PARAMS</span> <span class="o">=</span> <span class="s2">&quot;</span>
    <span class="n">useradd</span> <span class="o">-</span><span class="n">p</span> <span class="s1">&#39;&#39;</span> <span class="n">tester</span><span class="p">;</span>
    <span class="n">groupadd</span> <span class="n">developers</span><span class="p">;</span>
    <span class="n">userdel</span> <span class="n">nobody</span><span class="p">;</span>
    <span class="n">groupdel</span> <span class="o">-</span><span class="n">g</span> <span class="n">video</span><span class="p">;</span>
    <span class="n">groupmod</span> <span class="o">-</span><span class="n">g</span> <span class="mi">1020</span> <span class="n">developers</span><span class="p">;</span>
    <span class="n">usermod</span> <span class="o">-</span><span class="n">s</span> <span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">sh</span> <span class="n">tester</span><span class="p">;</span>
    <span class="s2">&quot;</span>
</pre></div>
</div>
<p>以下是一个添加名为“tester-jim”和“tester-sue”的两个用户并分配密码的示例。首先在主机上创建（转义）密码哈希：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>printf &quot;%q&quot; $(mkpasswd -m sha256crypt tester01)
</pre></div>
</div>
<p>生成的哈希被设置为一个变量并在useradd命令参数中使用：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inherit</span> <span class="n">extrausers</span>
<span class="n">PASSWD</span> <span class="o">=</span> <span class="s2">&quot;\$X\$ABC123\$A-Long-Hash&quot;</span>
<span class="n">EXTRA_USERS_PARAMS</span> <span class="o">=</span> <span class="s2">&quot;</span>
    <span class="n">useradd</span> <span class="o">-</span><span class="n">p</span> <span class="s1">&#39;$</span><span class="si">{PASSWD}</span><span class="s1">&#39;</span> <span class="n">tester</span><span class="o">-</span><span class="n">jim</span><span class="p">;</span>
    <span class="n">useradd</span> <span class="o">-</span><span class="n">p</span> <span class="s1">&#39;$</span><span class="si">{PASSWD}</span><span class="s1">&#39;</span> <span class="n">tester</span><span class="o">-</span><span class="n">sue</span><span class="p">;</span>
    <span class="s2">&quot;</span>
</pre></div>
</div>
<p>最后，以下是一个设置root密码的示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inherit</span> <span class="n">extrausers</span>
<span class="n">EXTRA_USERS_PARAMS</span> <span class="o">=</span> <span class="s2">&quot;</span>
    <span class="n">usermod</span> <span class="o">-</span><span class="n">p</span> <span class="s1">&#39;$</span><span class="si">{PASSWD}</span><span class="s1">&#39;</span> <span class="n">root</span><span class="p">;</span>
    <span class="s2">&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>从安全的角度来看，硬编码默认密码通常不是一个好主意，甚至在某些司法管辖区是非法的。如果您正在构建生产镜像，建议不要这样做。</p>
</div>
</section>
<section id="features-check">
<h2>5.37 features_check类<a class="headerlink" href="#features-check" title="Permalink to this headline">¶</a></h2>
<p>features_check类允许各个配方检查所需的和冲突的DISTRO_FEATURES、MACHINE_FEATURES或COMBINED_FEATURES。</p>
<p>该类支持以下变量：</p>
<ul class="simple">
<li><p>REQUIRED_DISTRO_FEATURES</p></li>
<li><p>CONFLICT_DISTRO_FEATURES</p></li>
<li><p>ANY_OF_DISTRO_FEATURES</p></li>
<li><p>REQUIRED_MACHINE_FEATURES</p></li>
<li><p>CONFLICT_MACHINE_FEATURES</p></li>
<li><p>ANY_OF_MACHINE_FEATURES</p></li>
<li><p>REQUIRED_COMBINED_FEATURES</p></li>
<li><p>CONFLICT_COMBINED_FEATURES</p></li>
<li><p>ANY_OF_COMBINED_FEATURES</p></li>
</ul>
<p>如果配方中使用上述变量指定的任何条件不满足，则配方将被跳过，如果构建系统尝试构建配方，则会触发错误。</p>
</section>
<section id="fontcache">
<h2>5.38 fontcache类<a class="headerlink" href="#fontcache" title="Permalink to this headline">¶</a></h2>
<p>fontcache类为字体包生成适当的安装后和卸载后（postinst和postrm）脚本。这些脚本调用Fontconfig的fc-cache将字体添加到字体信息缓存中。由于缓存文件是特定于架构的，如果需要在图像创建期间在构建主机上运行postinst脚本，则使用QEMU运行fc-cache。</p>
<p>如果安装的字体不在主包中，而是在其他包中，请设置FONT_PACKAGES以指定包含字体的包。</p>
</section>
<section id="fs-uuid">
<h2>5.39 fs-uuid类<a class="headerlink" href="#fs-uuid" title="Permalink to this headline">¶</a></h2>
<p>fs-uuid类从<span class="math notranslate nohighlight">\({ROOTFS}中提取UUID，该函数被调用时必须已经构建了\)</span>{ROOTFS}。fs-uuid类仅适用于ext文件系统，并依赖于tune2fs。</p>
</section>
<section id="gconf">
<h2>5.40 gconf类<a class="headerlink" href="#gconf" title="Permalink to this headline">¶</a></h2>
<p>gconf类为需要安装GConf模式的配方提供通用功能。这些模式将被放入一个单独的包（${PN}-gconf）中，该包在继承此类时自动创建。此包使用适当的安装后和卸载后（postinst/postrm）脚本来在目标映像中注册和注销模式。</p>
</section>
<section id="gettext">
<h2>5.41 gettext类<a class="headerlink" href="#gettext" title="Permalink to this headline">¶</a></h2>
<p>gettext类提供对使用GNU
gettext国际化和本地化系统的软件的构建支持。所有使用gettext的软件配方都应该继承这个类。</p>
</section>
<section id="github-releases">
<h2>5.42 github-releases类<a class="headerlink" href="#github-releases" title="Permalink to this headline">¶</a></h2>
<p>对于从github获取发布tarball的配方，github-releases类为检查可用上游版本（以支持devtool升级和自动升级助手（AUH））提供了一种标准方法。</p>
<p>要使用它，请在配方的inherit行中添加“github-releases”，如果GITHUB_BASE_URI的默认值不合适，则在配方中设置自己的值。然后，您应该在配方中设置SRC_URI的值时使用${GITHUB_BASE_URI}。</p>
</section>
<section id="gnomebase">
<h2>5.43 gnomebase类<a class="headerlink" href="#gnomebase" title="Permalink to this headline">¶</a></h2>
<p>gnomebase类是用于从GNOME堆栈构建软件的配方的基本类。该类将SRC_URI设置为从GNOME镜像下载源代码，并使用典型的GNOME安装路径扩展FILES。</p>
</section>
<section id="go">
<h2>5.44 go类<a class="headerlink" href="#go" title="Permalink to this headline">¶</a></h2>
<p>go类支持构建Go程序。该类的行为由必需的GO_IMPORT变量控制，并由可选的GO_INSTALL和GO_INSTALL_FILTEROUT变量控制。</p>
<p>要使用Yocto
Project构建一个Go程序，您可以使用<a class="reference external" href="https://git.yoctoproject.org/poky/tree/meta/recipes-extended/go-examples/go-helloworld_0.1.bb">go-helloworld_0.1.bb</a>配方作为示例。</p>
</section>
<section id="go-mod">
<h2>5.45 go-mod类<a class="headerlink" href="#go-mod" title="Permalink to this headline">¶</a></h2>
<p>go-mod类允许使用Go模块，并继承go类。</p>
<p>请参阅相关的<a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-GO_WORKDIR">GO_WORKDIR</a>变量。</p>
</section>
<section id="gobject-introspection">
<h2>5.46 gobject-introspection类<a class="headerlink" href="#gobject-introspection" title="Permalink to this headline">¶</a></h2>
<p>提供支持构建支持GObject内省的软件的配方。只有在“gobject-introspection-data”功能也在DISTRO_FEATURES中，并且“qemu-usermode”也在MACHINE_FEATURES中时，此功能才启用。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>默认情况下，此功能通过backfill实现，如果不适用，则应分别通过DISTRO_FEATURES_BACKFILL_CONSIDERED或MACHINE_FEATURES_BACKFILL_CONSIDERED禁用。</p>
</div>
</section>
<section id="grub-efi">
<h2>5.47 grub-efi类<a class="headerlink" href="#grub-efi" title="Permalink to this headline">¶</a></h2>
<p>grub-efi类提供了用于构建可引导映像的特定于grub-efi的功能。</p>
<p>该类支持以下变量：</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-INITRD">INITRD</a>：指示要连接并用作初始RAM磁盘（initrd）的文件系统映像列表（可选）。</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-ROOTFS">ROOTFS</a>：指示要包含作为根文件系统的映像（可选）。</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-GRUB_GFXSERIAL">GRUB_GFXSERIAL</a>：将其设置为“1”以在启动菜单中具有图形和串行功能。</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-LABELS">LABELS</a>：自动配置的目标列表。</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-APPEND">APPEND</a>：每个LABEL的附加字符串覆盖列表。</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-GRUB_OPTS">GRUB_OPTS</a>：要添加到配置中的其他选项（可选）。选项使用分号字符（；）分隔。</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-GRUB_TIMEOUT">GRUB_TIMEOUT</a>：执行默认LABEL之前的超时时间（可选）。</p>
</section>
<section id="gsettings">
<h2>5.48 gsettings类<a class="headerlink" href="#gsettings" title="Permalink to this headline">¶</a></h2>
<p>gsettings类为需要安装GSettings（glib）模式的配方提供了通用功能。这些模式被认为是主包的一部分。在目标映像中注册和解注册模式时，会添加适当的后安装和后删除（postinst/postrm）脚本片段。</p>
</section>
<section id="gtk-doc">
<h2>5.49 gtk-doc类<a class="headerlink" href="#gtk-doc" title="Permalink to this headline">¶</a></h2>
<p>gtk-doc类是一个帮助类，用于拉入适当的gtk-doc依赖项并禁用gtk-doc。</p>
</section>
<section id="gtk-icon-cache">
<h2>5.50 gtk-icon-cache类<a class="headerlink" href="#gtk-icon-cache" title="Permalink to this headline">¶</a></h2>
<p>gtk-icon-cache类为使用GTK+并安装图标的包生成适当的后安装和后删除（postinst/postrm）脚本片段。这些脚本片段调用gtk-update-icon-cache将字体添加到GTK+的图标缓存中。由于缓存文件是特定于架构的，因此如果需要在映像创建期间在构建主机上运行postinst脚本片段，则使用QEMU运行gtk-update-icon-cache。</p>
</section>
<section id="gtk-immodules-cache">
<h2>5.51 gtk-immodules-cache类<a class="headerlink" href="#gtk-immodules-cache" title="Permalink to this headline">¶</a></h2>
<p>gtk-immodules-cache类为安装虚拟键盘的GTK+输入法模块的包生成适当的后安装和后删除（postinst/postrm）脚本片段。这些脚本片段调用gtk-update-icon-cache将输入法模块添加到缓存中。由于缓存文件是特定于架构的，因此如果需要在映像创建期间在构建主机上运行postinst脚本片段，则使用QEMU运行gtk-update-icon-cache。</p>
<p>如果正在安装的输入法模块位于主包之外的其他包中，请设置<a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-GTKIMMODULES_PACKAGES">GTKIMMODULES_PACKAGES</a>以指定包含模块的包。</p>
</section>
<section id="gzipnative">
<h2>5.52 gzipnative类<a class="headerlink" href="#gzipnative" title="Permalink to this headline">¶</a></h2>
<p>gzipnative类允许使用不同版本的本地gzip和pigz，而不是从构建主机中获取这些工具的版本。</p>
</section>
<section id="icecc">
<h2>5.53 icecc类<a class="headerlink" href="#icecc" title="Permalink to this headline">¶</a></h2>
<p>icecc类支持Icecream，它有助于将编译工作分配给远程机器。</p>
<p>该类为本地和交叉编译器创建带有指向icecc的符号链接的目录。根据每个配置或编译，OpenEmbedded构建系统将目录添加到PATH列表的开头，然后设置ICECC_CXX和ICECC_CC变量，这些变量分别是g++和gcc编译器的路径。</p>
<p>对于交叉编译器，该类创建一个包含Yocto
Project工具链的tar.gz文件，并相应地设置ICECC_VERSION，这是交叉开发工具链中使用的交叉编译器版本。</p>
<p>该类处理所有三个不同的编译阶段（即本地、交叉内核和目标）并创建必要的环境tar.gz文件以供远程机器使用。该类还支持SDK生成。</p>
<p>如果在您的local.conf文件中未设置ICECC_PATH，则该类尝试使用which定位icecc二进制文件。如果在您的local.conf文件中设置了ICECC_ENV_EXEC，则该变量应指向用户提供的icecc-create-env脚本。如果您不指向用户提供的脚本，则构建系统使用配方icecc-create-env_0.1.bb中提供的默认脚本。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>这是一个修改后的版本，而不是与icecream一起提供的脚本。</p>
</div>
<p>如果您不希望Icecream分布式编译支持应用于特定配方或类，则可以在local.conf文件中使用ICECC_RECIPE_DISABLE和ICECC_CLASS_DISABLE变量分别列出这些配方和类，以使OpenEmbedded构建系统在本地处理这些编译。</p>
<p>此外，您可以在local.conf文件中使用ICECC_RECIPE_ENABLE变量列出配方，以强制启用具有空PARALLEL_MAKE变量的配方的icecc。</p>
<p>继承icecc类会更改所有sstate签名。因此，如果开发团队拥有一个填充SSTATE_MIRRORS的专用构建系统，并且他们希望重用来自SSTATE_MIRRORS的sstate，那么所有开发人员和构建系统都需要要么继承icecc类，要么都不继承。</p>
<p>在发行级别上，您可以继承icecc类以确保所有构建者都从相同的sstate签名开始。在继承类之后，您可以通过以下方式禁用功能：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>INHERIT_DISTRO:append = &quot; icecc&quot;
ICECC_DISABLED ??= &quot;1&quot;
</pre></div>
</div>
<p>这种做法确保每个人都使用相同的签名，但还需要那些确实想使用Icecream的人单独启用该功能，如下所示在local.conf文件中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ICECC_DISABLED</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
</pre></div>
</div>
</section>
<section id="image">
<h2>5.54 image类<a class="headerlink" href="#image" title="Permalink to this headline">¶</a></h2>
<p>image类帮助支持创建不同格式的图像。首先，使用rootfs*.bbclass文件之一（取决于使用的包格式）从包中创建根文件系统，然后创建一个或多个图像文件。</p>
<ul class="simple">
<li><p>IMAGE_FSTYPES变量控制要生成的图像类型。</p></li>
<li><p>IMAGE_INSTALL变量控制要安装到图像中的软件包列表。</p></li>
</ul>
<p>有关自定义图像的信息，请参阅Yocto
Project开发任务手册中的“<a class="reference external" href="https://docs.yoctoproject.org/4.0.17/dev-manual/customizing-images.html#customizing-images">自定义图像</a>”部分。有关如何创建图像的信息，请参阅Yocto
Project概述和概念手册中的“图像”部分。</p>
</section>
<section id="image-buildinfo">
<h2>5.55 image-buildinfo类<a class="headerlink" href="#image-buildinfo" title="Permalink to this headline">¶</a></h2>
<p>image-buildinfo类默认将包含构建信息的纯文本文件写入目标文件系统的<em>${sysconfdir}/buildinfo</em>（由IMAGE_BUILDINFO_FILE指定）。这可以用于手动确定任何给定图像的来源。它输出两个部分：</p>
<ol class="arabic simple">
<li><p>Build Configuration:
变量及其值的列表（由IMAGE_BUILDINFO_VARS指定，默认为DISTRO和DISTRO_VERSION）</p></li>
<li><p>Layer Revisions: 构建中使用的所有层的修订版本。</p></li>
</ol>
<p>此外，在构建SDK时，它将默认将相同的内容写入/buildinfo（由SDK_BUILDINFO_FILE指定）。</p>
</section>
<section id="image-types">
<h2>5.56 image_types类<a class="headerlink" href="#image-types" title="Permalink to this headline">¶</a></h2>
<p>image_types类定义了您可以通过IMAGE_FSTYPES变量启用的所有标准图像输出类型。您可以使用此类作为如何添加对自定义图像输出类型的支持的参考。</p>
<p>默认情况下，image类会自动启用image_types类。image类使用IMGCLASSES变量如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>IMGCLASSES = &quot;rootfs_${IMAGE_PKGTYPE} image_types ${IMAGE_CLASSES}&quot;
IMGCLASSES += &quot;${@[&#39;populate_sdk_base&#39;, &#39;populate_sdk_ext&#39;][&#39;linux&#39; in d.getVar(&quot;SDK_OS&quot;)]}&quot;
IMGCLASSES += &quot;${@bb.utils.contains_any(&#39;IMAGE_FSTYPES&#39;, &#39;live iso hddimg&#39;, &#39;image-live&#39;, &#39;&#39;, d)}&quot;
IMGCLASSES += &quot;${@bb.utils.contains(&#39;IMAGE_FSTYPES&#39;, &#39;container&#39;, &#39;image-container&#39;, &#39;&#39;, d)}&quot;
IMGCLASSES += &quot;image_types_wic&quot;
IMGCLASSES += &quot;rootfs-postcommands&quot;
IMGCLASSES += &quot;image-postinst-intercepts&quot;
inherit ${IMGCLASSES}
</pre></div>
</div>
<p>image_types类还处理图像的转换和压缩。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>要构建VMware
VMDK图像，需要将“wic.vmdk”添加到IMAGE_FSTYPES中。对于Virtual Box
Virtual Disk Image（“vdi”）和QEMU Copy On Write Version
2（“qcow2”）图像也是如此。</p>
</div>
</section>
<section id="image-live">
<h2>5.57 image-live类<a class="headerlink" href="#image-live" title="Permalink to this headline">¶</a></h2>
<p>这个类控制构建“实时”（即HDDIMG和ISO）图像。实时图像包含用于传统引导的syslinux，以及如果MACHINE_FEATURES包含“efi”时由EFI_PROVIDER指定的引导程序。</p>
<p>通常，您不会直接使用此类。相反，您将“live”添加到IMAGE_FSTYPES中。</p>
</section>
<section id="insane">
<h2>5.58 insane类<a class="headerlink" href="#insane" title="Permalink to this headline">¶</a></h2>
<p>insane类在包生成过程中添加了一个步骤，以便OpenEmbedded构建系统生成输出质量保证检查。执行一系列检查，检查构建的输出中常见的运行时问题。分发策略通常决定是否包含此类。</p>
<p>您可以配置这些检查，使特定的测试失败引发警告或错误消息。通常，新测试的失败会生成警告。当元数据处于已知且良好状态时，随后对同一测试的失败将生成错误消息。请参阅“QA错误和警告消息”一章，了解使用默认配置时可能会遇到的警告和错误消息列表。</p>
<p>使用WARN_QA和ERROR_QA变量来控制这些检查的行为（即在您的自定义发行版配置中）。然而，要在配方中跳过一个或多个检查，您应该使用INSANE_SKIP。例如，要跳过配方主包中符号链接.so文件的检查，请在配方中添加以下内容。您需要意识到，在此示例中必须使用包名覆盖${PN}：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>INSANE_SKIP:${PN} += &quot;dev-so&quot;
</pre></div>
</div>
<p>请注意，QA检查的目的是检测包输出中的实际或潜在问题。因此，在禁用这些检查时要谨慎。</p>
<p>以下是您可以使用WARN_QA和ERROR_QA变量列出的测试：</p>
<ul>
<li><p>already-stripped：检查生成的二进制文件是否在构建系统提取调试符号之前已经被剥离。上游软件项目的常见做法是默认剥离输出二进制文件的调试符号。为了使用-dbg包在目标上进行调试，必须禁用此剥离。</p></li>
<li><p>arch：检查任何二进制文件的可执行和可链接格式（ELF）类型、位大小和字节顺序，以确保它们与目标架构匹配。如果有任何二进制文件不匹配该类型，则此测试将失败，因为存在不兼容。该测试可能表明使用了错误的编译器或编译器选项。有时，像引导加载程序这样的软件可能需要绕过此检查。</p></li>
<li><p>buildpaths：检查输出文件中指向构建主机上的路径的位置。这些不仅会泄露有关构建环境的信息，还会阻碍二进制可重现性。</p></li>
<li><p>build-deps：确定是否存在通过DEPENDS、显式RDEPENDS或任务级依赖项指定的构建时依赖项，以匹配任何运行时依赖项。这种确定特别有助于发现运行时依赖项在哪里被检测到并在打包过程中添加。如果在元数据中没有指定显式依赖项，那么在打包阶段确保依赖项已构建就太晚了，因此在do_rootfs任务中将包安装到映像中时可能会出现错误，因为自动检测的依赖项未得到满足。例如，update-rc.d类会自动向安装initscript的包添加对initscripts-functions包的依赖项，该initscript引用了/etc/init.d/functions。配方真的应该在initscripts-functions包上为所涉及的包指定显式的RDEPENDS，以便OpenEmbedded构建系统能够确保initscripts配方实际上已经构建，从而提供initscripts-functions包。</p></li>
<li><p>configure-gettext：检查如果配方正在构建使用automake的东西，并且automake文件包含AM_GNU_GETTEXT指令，那么配方也应该继承gettext类，以确保在构建过程中可以使用gettext。</p></li>
<li><p>compile-host-path：检查do_compile日志中是否有使用构建主机上的路径的迹象。使用此类路径可能导致构建输出受到主机污染。</p></li>
<li><p>debug-deps：检查所有包（除了-dbg包）是否不依赖于-dbg包，否则会导致打包错误。</p></li>
<li><p>debug-files：检查除-dbg包以外的任何内容中是否有.debug目录。调试文件应该全部在-dbg包中。因此，任何其他地方打包的内容都是不正确的打包。</p></li>
<li><p>dep-cmp：检查运行时包之间的依赖关系（即在RDEPENDS、RRECOMMENDS、RSUGGESTS、RPROVIDES、RREPLACES和RCONFLICTS变量值中）是否有无效的版本比较语句。任何无效的比较都可能在传递给包管理器时触发失败或不良行为。</p></li>
<li><p>desktop：对任何.desktop文件运行desktop-file-validate程序，以验证其内容是否符合.desktop文件的规范。</p></li>
<li><p>dev-deps：检查所有包（除了-dev或-staticdev包）是否不依赖于-dev包，否则将是一个打包错误。</p></li>
<li><p>dev-so：检查.so符号链接是否在-dev包中，而不是在任何其他包中。通常，这些符号链接仅用于开发目的。因此，-dev包是它们的正确位置。在极少数情况下，例如动态加载模块，这些符号链接需要在主包中。</p></li>
<li><p>empty-dirs：检查包是否没有将文件安装到通常预期为空的目录（如/tmp）。由QA_EMPTY_DIRS变量指定要检查的目录列表。</p></li>
<li><p>file-rdeps：检查OpenEmbedded构建系统在打包时确定的文件级依赖项是否得到满足。例如，一个shell脚本可能以#!/bin/bash行开始。这一行将转化为对/bin/bash的文件依赖项。OpenEmbedded构建系统支持的三个包管理器中，只有RPM直接处理文件级依赖项，自动解析为提供文件的包。然而，其他两个包管理器缺乏该功能并不意味着依赖项仍然不需要解决。这个QA检查试图确保明确声明的RDEPENDS存在，以处理在打包文件中检测到的任何文件级依赖项。</p></li>
<li><p>files-invalid：检查FILES变量值中是否包含“//”，这是无效的。</p></li>
<li><p>host-user-contaminated：检查配方产生的包是否不包含/home以外的任何文件，其用户或组ID与运行BitBake的用户匹配。匹配通常表明文件正在以错误的UID/GID安装，因为目标ID独立于主机ID。有关更多信息，请参阅描述do_install任务的部分。</p></li>
<li><p>incompatible-license：当包因标记为INCOMPATIBLE_LICENSE中的许可证而被排除创建时报告。</p></li>
<li><p>install-host-path：检查do_install日志中是否有使用构建主机上的路径的迹象。使用此类路径可能导致构建输出受到主机污染。</p></li>
<li><p>installed-vs-shipped：报告在do_install中已安装但未通过FILES变量包含在任何包中的文件。在构建过程中稍后的映像中不会出现任何包中的文件。理想情况下，所有已安装的文件都应打包或根本不安装。如果文件在任何包中都不需要，可以在do_install结束时删除这些文件。</p></li>
<li><p>invalid-chars：检查配方元数据变量DESCRIPTION、SUMMARY、LICENSE和SECTION中是否不包含非UTF-8字符。一些包管理器不支持此类字符。</p></li>
<li><p>invalid-packageconfig：检查PACKAGECONFIG中是否添加了未定义的特性。例如，对于不存在以下形式的名称“foo”：</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PACKAGECONFIG</span><span class="p">[</span><span class="n">foo</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>la：检查.la文件中是否包含任何TMPDIR路径。任何包含这些路径的.la文件都是错误的，因为libtool在自动使用这些文件时会添加正确的sysroot前缀。</p></li>
<li><p>ldflags：确保二进制文件是使用构建系统提供的LDFLAGS选项进行链接的。如果此测试失败，请检查LDFLAGS变量是否已传递给链接器命令。</p></li>
<li><p>libdir：检查库是否被安装到错误的（可能是硬编码的）安装路径。例如，此测试将捕获安装/lib/bar.so的配方，当<span class="math notranslate nohighlight">\({base_libdir}为“lib32”时。另一个例子是当配方安装/usr/lib64/foo.so，而\)</span>{libdir}为“/usr/lib”时。</p></li>
<li><p>libexec：检查包中是否包含/usr/libexec中的文件。如果明确将libexecdir变量设置为/usr/libexec，则不执行此检查。</p></li>
<li><p>mime：检查如果包包含mime类型文件（${datadir}/mime/packages中的.xml文件），配方是否还继承了mime类，以确保这些文件得到正确安装。</p></li>
<li><p>mime-xdg：检查如果包包含一个带有’MimeType’键的.desktop文件，配方是否继承了mime-xdg类，这是激活该文件所必需的。</p></li>
<li><p>missing-update-alternatives：检查如果配方设置了ALTERNATIVE变量，配方是否还继承了update-alternatives，以便正确设置替代项。</p></li>
<li><p>packages-list：检查通过PACKAGES变量值多次列出同一包。以这种方式安装包可能会在打包过程中引起错误。</p></li>
<li><p>patch-fuzz：检查补丁文件中是否存在模糊，这可能会使它们在底层代码更改时错误地应用。</p></li>
<li><p>patch-status-core：检查OE-Core层中配方的补丁头的Upstream-Status是否指定且有效。</p></li>
<li><p>patch-status-noncore：检查除OE-Core之外的层中配方的补丁头的Upstream-Status是否指定且有效。</p></li>
<li><p>perllocalpod：检查配方是否正确安装和打包了perllocal.pod。</p></li>
<li><p>perm-config：报告fs-perms.txt中格式无效的行。</p></li>
<li><p>perm-line：报告fs-perms.txt中格式无效的行。</p></li>
<li><p>perm-link：报告fs-perms.txt中指定’link’的行，其中指定的目标已经存在。</p></li>
<li><p>perms：目前，此检查未使用但保留。</p></li>
<li><p>pkgconfig：检查.pc文件中是否包含任何TMPDIR/WORKDIR路径。任何包含这些路径的.pc文件都是错误的，因为pkg-config在访问这些文件时会添加正确的sysroot前缀。</p></li>
<li><p>pkgname：检查PACKAGES中的所有包名称是否不包含无效字符（即除了0-9、a-z、.、+和-之外的字符）。</p></li>
<li><p>pkgv-undefined：检查do_package期间PKGV变量是否未定义。</p></li>
<li><p>pkgvarcheck：检查RDEPENDS、RREMCOMMENDS、RSUGGESTS、RCONFLICTS、RPROVIDES、RREPLACES、FILES、ALLOW_EMPTY、pkg_preinst、pkg_postinst、pkg_prerm和pkg_postrm等变量，并报告是否存在不是特定于包的变量集。在没有包后缀的情况下使用这些变量是不好的做法，可能会不必要地复杂化同一配方内其他包的依赖关系或产生其他意外后果。</p></li>
<li><dl class="simple">
<dt>pn-overrides：检查配方的名称（PN）值是否出现在OVERRIDES中。如果配方的名称使其PN值与OVERRIDES中的某个值匹配（例如，PN恰好与MACHINE或DISTRO相同），则可能会产生意外后果。例如，像FILES:${PN}</dt><dd><p>= “xyz”这样的赋值实际上会变成FILES = “xyz”。</p>
</dd>
</dl>
</li>
<li><p>rpaths：检查二进制文件中是否包含构建系统路径，如TMPDIR。如果此测试失败，说明链接器命令传递了错误的-rpath选项，您的二进制文件可能存在安全隐患。</p></li>
<li><p>shebang-size：检查打包脚本中的shebang行（第一行的#!）长度是否超过128个字符，这可能会导致运行时根据操作系统出现错误。</p></li>
<li><p>split-strip：报告从二进制文件中剥离或删除调试符号失败。</p></li>
<li><p>staticdev：检查非静态dev包中的静态库文件（ <cite>*.a</cite> ）。</p></li>
<li><p>src-uri-bad：检查配方设置的SRC_URI值是否包含对<span class="math notranslate nohighlight">\({PN}（而不是正确的\)</span>{BPN}）的引用，或者是否引用了不稳定的Github存档tarball。</p></li>
<li><p>symlink-to-sysroot：检查包中的符号链接是否指向主机上的TMPDIR。这样的符号链接在主机上可以工作，但在目标系统上运行时显然是无效的。</p></li>
<li><p>textrel：检查ELF二进制文件的.text部分是否包含重定位，这可能导致运行时性能影响。有关运行时性能问题的更多信息，请参阅“QA错误和警告消息”中的ELF二进制消息的解释。</p></li>
<li><p>unhandled-features-check：检查如果配方设置了features_check类支持的变量之一（例如REQUIRED_DISTRO_FEATURES），则配方还应继承features_check以使要求实际生效。</p></li>
<li><p>unimplemented-ptest：检查上游测试是否实现了ptest。</p></li>
<li><p>unlisted-pkg-lics：检查应用于包的所有声明的许可证也是否在配方级别声明（即LICENSE: <cite>*</cite> 中的任何许可证应出现在LICENSE中）。</p></li>
<li><p>useless-rpaths：检查二进制文件中的动态库加载路径（rpaths），默认情况下标准系统的链接器会搜索这些路径（例如/lib和/usr/lib）。虽然这些路径不会导致任何破坏，但它们确实浪费空间且没有必要。</p></li>
<li><p>usrmerge：如果usrmerge在DISTRO_FEATURES中，此检查将确保没有包将文件安装到根目录（/bin、/sbin、/lib、/lib64）中。</p></li>
<li><p>var-undefined：报告在do_package期间对打包至关重要的变量（即WORKDIR、DEPLOY_DIR、D、PN和PKGD）未定义的情况。</p></li>
<li><p>version-going-backwards：如果启用了buildhistory类，当正在写入的包的版本低于之前写入的同名包时，将会报告。如果您将输出包放入feed并在目标系统上使用该feed升级包，包的版本倒退可能导致目标系统无法正确升级到包的“新”版本。</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>这只与您在目标系统上使用运行时包管理相关。</p>
</div>
</div></blockquote>
</li>
<li><p>xorg-driver-abi：检查所有包含Xorg驱动程序的包都有ABI依赖关系。xserver-xorg配方提供了驱动程序ABI名称。所有驱动程序都应依赖于它们所针对的ABI版本。包含xorg-driver-input.inc或xorg-driver-video.inc的驱动程序配方将自动获取这些版本。因此，您只需要明确添加对二进制驱动程序配方的依赖关系。</p></li>
</ul>
</section>
<section id="kernel">
<h2>5.59 kernel类<a class="headerlink" href="#kernel" title="Permalink to this headline">¶</a></h2>
<p>kernel类描述了Linux内核构建类（kernel
class）的功能和特性。它处理构建Linux内核，并包含构建所有内核树的代码。所需的头文件被暂存到STAGING_KERNEL_DIR目录中，以允许使用module类进行树外模块构建。</p>
<p>如果SRC_URI中列出了一个名为defconfig的文件，那么默认情况下，do_configure会将其复制为.config文件，并将其自动用作构建的内核配置。如果已经存在.config文件，则不会执行此复制操作：这允许配方通过其他方式在do_configure:prepend中生成配置。</p>
<p>每个构建的内核模块都单独打包，并通过解析modinfo输出来创建模块之间的依赖关系。如果需要所有模块，则安装kernel-modules包将安装所有带有模块的包以及其他各种内核包，如kernel-vmlinux。</p>
<p>内核类包含逻辑，允许在构建内核映像时嵌入初始RAM文件系统（Initramfs）映像。有关如何构建Initramfs的信息，请参阅Yocto
Project开发任务手册中的“构建初始RAM文件系统（Initramfs）映像”部分。</p>
<p>内核和模块类内部使用了其他一些类，包括kernel-arch、module-base和linux-kernel-base类。</p>
</section>
<section id="kernel-arch">
<h2>5.60 kernel-arch类<a class="headerlink" href="#kernel-arch" title="Permalink to this headline">¶</a></h2>
<p>kernel-arch类用于设置Linux内核编译（包括模块）的ARCH环境变量。</p>
</section>
<section id="kernel-devicetree">
<h2>5.61 kernel-devicetree类<a class="headerlink" href="#kernel-devicetree" title="Permalink to this headline">¶</a></h2>
<p>kernel-devicetree类由内核类继承，支持设备树生成。</p>
<p>它的行为主要由以下变量控制：</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-KERNEL_DEVICETREE_BUNDLE">KERNEL_DEVICETREE_BUNDLE</a>：是否将内核和设备树捆绑在一起</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-KERNEL_DTBDEST">KERNEL_DTBDEST</a>：安装DTB文件的目录</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-KERNEL_DTBVENDORED">KERNEL_DTBVENDORED</a>：是否保留供应商子目录</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-KERNEL_DTC_FLAGS">KERNEL_DTC_FLAGS</a>：dtc（设备树编译器）的标志</p>
<p><a class="reference external" href="https://docs.yoctoproject.org/4.0.17/ref-manual/variables.html#term-KERNEL_PACKAGE_NAME">KERNEL_PACKAGE_NAME</a>：内核包的基本名称</p>
</section>
<section id="kernel-fitimage">
<h2>5.62 kernel-fitimage类<a class="headerlink" href="#kernel-fitimage" title="Permalink to this headline">¶</a></h2>
<p>kernel-fitimage类提供了将内核映像、设备树、U-boot脚本、Initramfs捆绑包和RAM磁盘打包到单个FIT映像中的支持。理论上，FIT映像可以支持任意数量的内核、U-boot脚本、Initramfs捆绑包、RAM磁盘和设备树。然而，kernel-fitimage目前仅支持有限的用例：一个内核映像、一个可选的U-boot脚本、一个可选的Initramfs捆绑包、一个可选的RAM磁盘和任意数量的设备树。</p>
<p>要创建FIT映像，需要将KERNEL_CLASSES设置为包含“kernel-fitimage”，并将KERNEL_IMAGETYPE、KERNEL_ALT_IMAGETYPE或KERNEL_IMAGETYPES之一设置为包含“fitImage”。</p>
<p>在创建FIT映像时传递给mkimage
-D的设备树编译器选项由UBOOT_MKIMAGE_DTCOPTS变量指定。</p>
<p>kernel-fitimage创建的FIT映像中只能添加一个内核，并且内核映像在FIT中是必需的。U-Boot加载内核映像的地址由UBOOT_LOADADDRESS指定，入口点由UBOOT_ENTRYPOINT指定。如果这些地址是64位的，则必须将FIT_ADDRESS_CELLS设置为“2”。</p>
<p>可以在kernel-fitimage创建的FIT映像中添加多个设备树，设备树是可选的。U-Boot加载设备树的地址由UBOOT_DTBO_LOADADDRESS（设备树覆盖）和UBOOT_DTB_LOADADDRESS（设备树二进制文件）指定。</p>
<p>kernel-fitimage创建的FIT映像中只能添加一个RAM磁盘，RAM磁盘在FIT中是可选的。U-Boot加载RAM磁盘映像的地址由UBOOT_RD_LOADADDRESS指定，入口点由UBOOT_RD_ENTRYPOINT指定。当指定INITRAMFS_IMAGE时，将RAM磁盘添加到FIT映像中，并要求INITRAMFS_IMAGE_BUNDLE不设置为1。</p>
<p>kernel-fitimage创建的FIT映像中只能添加一个Initramfs捆绑包，Initramfs捆绑包在FIT中是可选的。当使用Initramfs时，内核配置为将根文件系统与同一二进制文件中的内核捆绑在一起（例如：zImage-initramfs-MACHINE.bin）。当将内核复制到RAM并执行时，它会解压缩Initramfs根文件系统。可以通过指定INITRAMFS_IMAGE来启用Initramfs捆绑包，并要求INITRAMFS_IMAGE_BUNDLE设置为1。U-boot加载Initramfs捆绑包的地址由UBOOT_LOADADDRESS指定，入口点由UBOOT_ENTRYPOINT指定。</p>
<p>kernel-fitimage创建的FIT映像中只能添加一个U-boot启动脚本，启动脚本是可选的。启动脚本在ITS文件中指定为包含U-boot命令的文本文件。使用启动脚本时，用户应配置U-boot
do_install任务以将脚本复制到sysroot。因此，可以通过kernel-fitimage类将脚本包含在FIT映像中。在运行时，可以通过配置U-boot
CONFIG_BOOTCOMMAND定义从FIT映像加载启动脚本并执行它。</p>
<p>kernel-fitimage生成的FIT映像在适当设置UBOOT_SIGN_ENABLE、UBOOT_MKIMAGE_DTCOPTS、UBOOT_SIGN_KEYDIR和UBOOT_SIGN_KEYNAME变量时会进行签名。kernel-fitimage使用的默认FIT_HASH_ALG和FIT_SIGN_ALG值分别为“sha256”和“rsa2048”。可以使用kernel-fitimage类在将FIT_GENERATE_KEYS和UBOOT_SIGN_ENABLE都设置为“1”时生成用于签名FIT映像的密钥。</p>
</section>
<section id="kernel-grub">
<h2>5.63 kernel-grub类<a class="headerlink" href="#kernel-grub" title="Permalink to this headline">¶</a></h2>
<p>kernel-grub类在安装RPM以更新部署目标上的内核时，使用内核作为优先级启动机制来更新引导区域和引导菜单。</p>
</section>
<section id="kernel-module-split">
<h2>5.64 kernel-module-split类<a class="headerlink" href="#kernel-module-split" title="Permalink to this headline">¶</a></h2>
<p>kernel-module-split类为将 Linux 内核模块分割成单独的包提供了通用功能。</p>
</section>
<section id="kernel-uboot">
<h2>5.65 kernel-uboot类<a class="headerlink" href="#kernel-uboot" title="Permalink to this headline">¶</a></h2>
<p>kernel-uboot类提供了从vmlinux风格内核源代码构建的支持。</p>
</section>
<section id="kernel-uimage">
<h2>5.66 kernel-uimage类<a class="headerlink" href="#kernel-uimage" title="Permalink to this headline">¶</a></h2>
<p>kernel-uimage类提供对打包uImage的支持。</p>
</section>
<section id="kernel-yocto">
<h2>5.67 kernel-yocto类<a class="headerlink" href="#kernel-yocto" title="Permalink to this headline">¶</a></h2>
<p>kernel-yocto类提供了从linux-yocto风格内核源仓库构建的通用功能。</p>
</section>
<section id="kernelsrc">
<h2>5.68 kernelsrc类<a class="headerlink" href="#kernelsrc" title="Permalink to this headline">¶</a></h2>
<p>kernelsrc类设置了Linux内核源代码和版本。</p>
</section>
<section id="lib-package">
<h2>5.69 lib_package类<a class="headerlink" href="#lib-package" title="Permalink to this headline">¶</a></h2>
<p>lib_package类支持构建库并生成可执行二进制文件的配方，其中这些二进制文件不应默认与库一起安装。相反，这些二进制文件被添加到单独的${PN}-bin包中，以使它们的安装成为可选。</p>
</section>
<section id="libc">
<h2>5.70 libc*类<a class="headerlink" href="#libc" title="Permalink to this headline">¶</a></h2>
<p>libc*类支持构建带有libc的包的配方：</p>
<ul class="simple">
<li><p>libc-common类提供构建libc的通用支持。</p></li>
<li><p>libc-package类支持打包glibc和eglibc。</p></li>
</ul>
</section>
<section id="license">
<h2>5.71 license类<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h2>
<p>license类提供许可证清单的创建和许可证排除。该类默认启用，使用INHERIT_DISTRO变量的默认值。</p>
</section>
<section id="linux-kernel-base">
<h2>5.72 linux-kernel-base类<a class="headerlink" href="#linux-kernel-base" title="Permalink to this headline">¶</a></h2>
<p>linux-kernel-base类为从Linux内核源代码树构建的配方提供通用功能。这些构建超出了内核本身。例如，Perf配方也继承这个类。</p>
</section>
<section id="linuxloader">
<h2>5.73 linuxloader类<a class="headerlink" href="#linuxloader" title="Permalink to this headline">¶</a></h2>
<p>提供linuxloader()函数，该函数给出平台上提供的动态加载器/链接器的值。这个值被许多其他类使用。</p>
</section>
<section id="logging">
<h2>5.74 logging类<a class="headerlink" href="#logging" title="Permalink to this headline">¶</a></h2>
<p>logging类提供了用于记录各种BitBake严重性级别（即bbplain、bbnote、bbwarn、bberror、bbfatal和bbdebug）的消息的标准shell函数。</p>
<p>该类默认启用，因为它被基类继承。</p>
</section>
<section id="meson">
<h2>5.75 meson类<a class="headerlink" href="#meson" title="Permalink to this headline">¶</a></h2>
<p>meson类允许创建使用Meson构建系统构建软件的配方。您可以使用MESON_BUILDTYPE、MESON_TARGET和EXTRA_OEMESON变量来指定要通过meson命令行传递的其他配置选项。</p>
</section>
<section id="metadata-scm">
<h2>5.76 metadata_scm类<a class="headerlink" href="#metadata-scm" title="Permalink to this headline">¶</a></h2>
<p>metadata_scm类提供了查询源代码管理器（SCM）仓库的分支和修订的功能。</p>
<p>基类使用这个类在每次构建开始前打印每个层的修订版本。metadata_scm类默认启用，因为它被基类继承。</p>
</section>
<section id="migrate-localcount">
<h2>5.77 migrate_localcount类<a class="headerlink" href="#migrate-localcount" title="Permalink to this headline">¶</a></h2>
<p>migrate_localcount类验证配方的localcount数据并适当增加它。</p>
</section>
<section id="mime">
<h2>5.78 mime类<a class="headerlink" href="#mime" title="Permalink to this headline">¶</a></h2>
<p>mime类为安装MIME类型文件的包生成适当的post-install和post-remove（postinst/postrm）脚本。这些脚本调用update-mime-database将MIME类型添加到共享数据库中。</p>
</section>
<section id="mime-xdg">
<h2>5.79 mime-xdg类<a class="headerlink" href="#mime-xdg" title="Permalink to this headline">¶</a></h2>
<p>mime-xdg类为安装包含MimeType条目的.desktop文件的包生成适当的post-install和post-remove（postinst/postrm）脚本。这些脚本调用update-desktop-database将MIME类型添加到由桌面文件处理的MIME类型数据库中。</p>
<p>由于这个类，当用户在最近创建的图像上通过文件浏览器打开文件时，他们不必从所有已知应用程序的池中选择要打开文件的应用程序，即使它们无法打开选定的文件。</p>
<p>如果您的配方将其.desktop文件作为绝对符号链接安装，则无法通过此类的当前实现检测到此类文件。在这种情况下，您必须将相应的包名称添加到MIME_XDG_PACKAGES变量中。</p>
</section>
<section id="mirrors">
<h2>5.80 mirrors类<a class="headerlink" href="#mirrors" title="Permalink to this headline">¶</a></h2>
<p>mirrors类为源代码镜像设置了一些标准的MIRRORS条目。这些镜像提供了一条备用路径，以防配方中指定的上游源在SRC_URI中无法使用。</p>
<p>该类默认启用，因为它被基类继承。</p>
</section>
<section id="module">
<h2>5.81 module类<a class="headerlink" href="#module" title="Permalink to this headline">¶</a></h2>
<p>module类提供对构建树外Linux内核模块的支持。该类继承了module-base和kernel-module-split类，并实现了do_compile和do_install任务。该类提供了构建和打包内核模块所需的一切。</p>
<p>有关树外Linux内核模块的一般信息，请参阅Yocto Project
Linux内核开发手册中的“<a class="reference external" href="https://docs.yoctoproject.org/4.0.17/kernel-dev/common.html#incorporating-out-of-tree-modules">Incorporating Out-of-Tree
Modules</a>”部分。</p>
</section>
<section id="module-base">
<h2>5.82 module-base类<a class="headerlink" href="#module-base" title="Permalink to this headline">¶</a></h2>
<p>module-base类提供了构建Linux内核模块的基本功能。通常，包含一个或多个内核模块并具有自己的构建模块方式的软件的配方会继承这个类，而不是继承module类。</p>
</section>
<section id="multilib">
<h2>5.83 multilib*类<a class="headerlink" href="#multilib" title="Permalink to this headline">¶</a></h2>
<p>multilib*类提供支持，用于构建具有不同目标优化或目标架构的库，并在同一图像中并行安装它们。</p>
<p>有关使用Multilib功能的更多信息，请参阅Yocto
Project开发任务手册中的“<a class="reference external" href="https://docs.yoctoproject.org/4.0.17/dev-manual/libraries.html#combining-multiple-versions-of-library-files-into-one-image">将多个版本的库文件组合到一个映像中</a>”部分。</p>
</section>
<section id="native">
<h2>5.84 native类<a class="headerlink" href="#native" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">native</span></code>类提供了为在构建主机上运行的工具（即使用构建主机上的编译器或其他工具的工具）构建配方的常见功能。</p>
<p>您可以通过几种不同的方式创建在主机上本地运行的工具的配方：</p>
<ul>
<li><p>创建一个继承<code class="docutils literal notranslate"><span class="pre">native</span></code>类的<code class="docutils literal notranslate"><span class="pre">myrecipe-native.bb</span></code>配方。如果您使用此方法，必须在配方中将继承语句放在所有其他继承语句之后，以便最后继承<code class="docutils literal notranslate"><span class="pre">native</span></code>类。注意：</p>
<blockquote>
<div><p>当以这种方式创建配方时，配方名称必须遵循以下命名约定：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myrecipe</span><span class="o">-</span><span class="n">native</span><span class="o">.</span><span class="n">bb</span>
</pre></div>
</div>
<p>不使用这种命名约定可能导致由于现有代码依赖于该命名约定而引起的微妙问题。</p>
</div></blockquote>
</li>
<li><p>创建或修改包含以下内容的目标配方：</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BBCLASSEXTEND</span> <span class="o">=</span> <span class="s2">&quot;native&quot;</span>
</pre></div>
</div>
<p>在配方内部，使用：class-native和：class-target覆盖来指定特定于各自本地或目标情况的任何功能。</p>
</div></blockquote>
</li>
</ul>
<p>尽管应用方式不同，但<code class="docutils literal notranslate"><span class="pre">native</span></code>类在两种方法中都有使用。第二种方法的优势在于，您不需要为本地和目标分别拥有两个单独的配方（假设您需要两者）。配方的所有共同部分都会自动共享。</p>
</section>
<section id="nativesdk">
<h2>5.85 nativesdk类<a class="headerlink" href="#nativesdk" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">nativesdk</span></code>类提供了希望构建作为SDK一部分运行的工具的配方的常见功能（即在SDKMACHINE上运行的工具）。</p>
<p>您可以通过几种不同的方式创建在SDK机器上运行的工具的配方：</p>
<ul>
<li><p>创建一个继承<code class="docutils literal notranslate"><span class="pre">nativesdk</span></code>类的<code class="docutils literal notranslate"><span class="pre">nativesdk-myrecipe.bb</span></code>配方。如果您使用此方法，必须在配方中将继承语句放在所有其他继承语句之后，以便最后继承<code class="docutils literal notranslate"><span class="pre">nativesdk</span></code>类。</p></li>
<li><p>通过添加以下内容来创建任何配方的<code class="docutils literal notranslate"><span class="pre">nativesdk</span></code>变体：</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BBCLASSEXTEND</span> <span class="o">=</span> <span class="s2">&quot;nativesdk&quot;</span>
</pre></div>
</div>
<p>在配方内部，使用：class-nativesdk和：class-target覆盖来指定特定于各自的SDK机器或目标情况的任何功能。</p>
</div></blockquote>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>创建配方时，必须遵循以下命名约定：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nativesdk</span><span class="o">-</span><span class="n">myrecipe</span><span class="o">.</span><span class="n">bb</span>
</pre></div>
</div>
<p>不这样做可能会导致代码依赖于该命名约定而引起微妙的问题。</p>
</div>
<p>尽管应用方式不同，但<code class="docutils literal notranslate"><span class="pre">nativesdk</span></code>类在两种方法中都有使用。第二种方法的优势在于，您不需要为SDK机器和目标分别拥有两个单独的配方（假设您需要两者）。配方的所有共同部分都会自动共享。</p>
</section>
<section id="nopackages">
<h2>5.86 nopackages类<a class="headerlink" href="#nopackages" title="Permalink to this headline">¶</a></h2>
<p>禁用不需要打包的配方和类中的打包任务。</p>
</section>
<section id="npm">
<h2>5.87 npm类<a class="headerlink" href="#npm" title="Permalink to this headline">¶</a></h2>
<p>提供使用节点包管理器（NPM）获取的Node.js软件的支持。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>目前，继承此类的配方必须使用npm://获取器来自动获取和打包依赖项。</p>
</div>
<p>有关如何创建NPM包的信息，请参阅Yocto
Project开发任务手册中的“<a class="reference external" href="https://docs.yoctoproject.org/4.0.17/dev-manual/packages.html#creating-node-package-manager-npm-packages">创建Node包管理器（NPM）包</a>”部分。</p>
</section>
<section id="oelint">
<h2>5.88 oelint类<a class="headerlink" href="#oelint" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">oelint</span></code>类是元数据/类中可用的过时的lint检查工具，位于源目录中。</p>
<p>有一些类可能在OE-Core中一般有用，但实际上从未在OE-Core本身中使用过。<code class="docutils literal notranslate"><span class="pre">oelint</span></code>类就是这样一个示例。然而，了解这个类可以减少多个层之间不同版本的类似类的传播。</p>
</section>
<section id="overlayfs">
<h2>5.89 overlayfs类<a class="headerlink" href="#overlayfs" title="Permalink to this headline">¶</a></h2>
<p>在嵌入式系统设计中，通常希望拥有一个只读的根文件系统。但是，许多不同的应用程序可能希望对文件系统的某部分具有读写访问权限。当更新机制覆盖整个根文件系统时，但您可能希望在更新之间保留应用程序数据，这尤其有用。overlayfs类通过使用overlayfs并同时保持基础根文件系统为只读来实现这一点。</p>
<p>要使用此类，请在机器配置中设置分区overlayfs将用作上层的挂载点。底层文件系统可以是任何受overlayfs支持的文件系统。这必须在您的机器配置中完成：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OVERLAYFS_MOUNT_POINT</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;/data&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>如果您在配方中重新定义此变量，QA检查将无法捕获文件存在！</p></li>
<li><p>只有systemd挂载单元文件的存在被检查，而不是其内容。</p></li>
<li><p>要获取有关overlayfs、其内部和受支持操作的更多详细信息，请参阅Linux内核的官方文档。</p></li>
</ul>
</div>
<p>该类假设您在BSP（例如systemd-machine-units配方）中的其他地方定义了一个名为data.mount的systemd单元，并将其安装到映像中。</p>
<p>然后您可以在配方基础上指定可写目录（例如在my-application.bb中）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OVERLAYFS_WRITABLE_PATHS</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;/usr/share/my-custom-application&quot;</span>
</pre></div>
</div>
<p>要支持多个挂载点，您可以使用不同的标志变量。假设我们希望文件系统上有一个可写位置，但不需要数据在重新启动后仍然存在，那么我们可以为tmpfs文件系统使用mnt-overlay.mount单元。</p>
<p>在您的机器配置中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OVERLAYFS_MOUNT_POINT</span><span class="p">[</span><span class="n">mnt</span><span class="o">-</span><span class="n">overlay</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;/mnt/overlay&quot;</span>
</pre></div>
</div>
<p>然后在您的配方中：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OVERLAYFS_WRITABLE_PATHS</span><span class="p">[</span><span class="n">mnt</span><span class="o">-</span><span class="n">overlay</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;/usr/share/another-application&quot;</span>
</pre></div>
</div>
<p>在实践中，您的应用程序配方可能需要在运行之前挂载多个覆盖层以避免写入底层文件系统（在只读文件系统的情况下可能是禁止的）。overlayfs提供了一个用于挂载覆盖层的systemd辅助服务。此辅助服务的名称为${PN}-overlays.service，可以在您的应用程序配方（以下示例中的application）systemd单元中添加以下内容来依赖它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Unit</span><span class="p">]</span>
<span class="n">After</span><span class="o">=</span><span class="n">application</span><span class="o">-</span><span class="n">overlays</span><span class="o">.</span><span class="n">service</span>
<span class="n">Requires</span><span class="o">=</span><span class="n">application</span><span class="o">-</span><span class="n">overlays</span><span class="o">.</span><span class="n">service</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>该类不支持/etc目录本身，因为systemd依赖于它。要在overlayfs中获取/etc，请参见overlayfs-etc。</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="参考手册" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../oebuild/intro.html" class="btn btn-neutral float-right" title="简介" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, openEuler Embedded.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: master
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Branches</dt>
      <dd><a href="5classes.html">master</a></dd>
      <dd><a href="../../../openEuler-21.09/index.html">openEuler-21.09</a></dd>
      <dd><a href="../../../openEuler-22.03-LTS/index.html">openEuler-22.03-LTS</a></dd>
      <dd><a href="../../../openEuler-22.03-LTS-SP1/index.html">openEuler-22.03-LTS-SP1</a></dd>
      <dd><a href="../../../openEuler-22.03-LTS-SP2/index.html">openEuler-22.03-LTS-SP2</a></dd>
      <dd><a href="../../../openEuler-22.03-LTS-SP3/index.html">openEuler-22.03-LTS-SP3</a></dd>
      <dd><a href="../../../openEuler-22.09/index.html">openEuler-22.09</a></dd>
      <dd><a href="../../../openEuler-23.03/index.html">openEuler-23.03</a></dd>
      <dd><a href="../../../openEuler-23.09/index.html">openEuler-23.09</a></dd>
    </dl>
  </div>
</div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>