From 60e4dccc0d724a75a12f484896c170022ad0a60b Mon Sep 17 00:00:00 2001
From: liu-yudong003 <lydcumt@foxmail.com>
Date: Thu, 20 Apr 2023 07:02:29 +0000
Subject: [PATCH] support-jh7110-starfive

---
 arch/riscv/Kconfig                            |   20 +
 arch/riscv/Kconfig.socs                       |   13 +
 arch/riscv/boot/dts/Makefile                  |    1 +
 arch/riscv/boot/dts/starfive/Makefile         |    2 +
 .../boot/dts/starfive/codecs/sf_hdmi.dtsi     |   20 +
 .../boot/dts/starfive/codecs/sf_pwmdac.dtsi   |   18 +
 arch/riscv/boot/dts/starfive/jh7110-clk.dtsi  |  126 +
 .../dts/starfive/jh7110-visionfive-v2.dts     |  208 ++
 .../dts/starfive/jh7110-visionfive-v2.dtsi    |  835 +++++
 arch/riscv/boot/dts/starfive/jh7110.dtsi      | 1809 +++++++++
 arch/riscv/configs/defconfig                  |   30 +-
 arch/riscv/configs/starfive_jh7110_defconfig  |  284 ++
 .../configs/starfive_visionfive2_defconfig    |  287 ++
 drivers/Kconfig                               |    2 +
 drivers/char/hw_random/Kconfig                |   11 +
 drivers/char/hw_random/Makefile               |    1 +
 drivers/char/hw_random/starfive-trng.c        |  415 +++
 drivers/clk/Kconfig                           |    1 +
 drivers/clk/Makefile                          |    1 +
 drivers/clk/starfive/Kconfig                  |   34 +
 drivers/clk/starfive/Makefile                 |    9 +
 .../clk/starfive/clk-starfive-jh7110-aon.c    |  165 +
 .../clk/starfive/clk-starfive-jh7110-gen.c    |  634 ++++
 .../clk/starfive/clk-starfive-jh7110-isp.c    |  358 ++
 .../clk/starfive/clk-starfive-jh7110-pll.c    |  455 +++
 .../clk/starfive/clk-starfive-jh7110-pll.h    |  273 ++
 .../clk/starfive/clk-starfive-jh7110-stg.c    |  170 +
 .../clk/starfive/clk-starfive-jh7110-sys.c    |  845 +++++
 .../clk/starfive/clk-starfive-jh7110-vout.c   |  403 ++
 drivers/clk/starfive/clk-starfive-jh7110.h    |  157 +
 drivers/clocksource/Kconfig                   |   11 +
 drivers/clocksource/Makefile                  |    1 +
 drivers/clocksource/timer-starfive.c          |  531 +++
 drivers/clocksource/timer-starfive.h          |  110 +
 drivers/cpufreq/Makefile                      |    4 +
 drivers/cpufreq/cpufreq-dt-platdev.c          |    1 +
 drivers/crypto/Kconfig                        |    2 +
 drivers/crypto/Makefile                       |    1 +
 drivers/crypto/starfive/Kconfig               |   18 +
 drivers/crypto/starfive/Makefile              |    2 +
 drivers/crypto/starfive/jh7110/Makefile       |    3 +
 drivers/crypto/starfive/jh7110/jh7110-aes.c   | 1802 +++++++++
 drivers/crypto/starfive/jh7110/jh7110-pka.c   |  733 ++++
 drivers/crypto/starfive/jh7110/jh7110-regs.h  |  237 ++
 drivers/crypto/starfive/jh7110/jh7110-sec.c   |  432 +++
 drivers/crypto/starfive/jh7110/jh7110-sha.c   | 1260 +++++++
 drivers/crypto/starfive/jh7110/jh7110-str.h   |  276 ++
 .../dma/dw-axi-dmac/dw-axi-dmac-platform.c    |   14 +
 drivers/dma/jh7110-pl08x.c                    | 3200 ++++++++++++++++
 drivers/gpu/drm/i2c/tda998x_pin.c             |   47 +
 .../gpu/drm/panel/panel-jadard-jd9365da-h3.c  |  704 ++++
 drivers/hwmon/Kconfig                         |   10 +
 drivers/hwmon/Makefile                        |    1 +
 drivers/hwmon/sfctemp.c                       |  392 ++
 drivers/mailbox/Kconfig                       |   15 +
 drivers/mailbox/Makefile                      |    4 +
 drivers/mailbox/starfive_mailbox-test.c       |  419 +++
 drivers/mailbox/starfive_mailbox.c            |  358 ++
 drivers/media/platform/Kconfig                |   12 +
 drivers/media/platform/Makefile               |    2 +
 drivers/media/platform/starfive/Kconfig       |   43 +
 drivers/media/platform/starfive/Makefile      |   33 +
 .../platform/starfive/v4l2_driver/Readme.txt  |   10 +
 .../starfive/v4l2_driver/imx219_mipi.c        | 1583 ++++++++
 .../starfive/v4l2_driver/ov13850_mipi.c       | 1930 ++++++++++
 .../starfive/v4l2_driver/ov4689_mipi.c        | 2974 +++++++++++++++
 .../platform/starfive/v4l2_driver/ov5640.c    | 3227 +++++++++++++++++
 .../platform/starfive/v4l2_driver/sc2235.c    | 1918 ++++++++++
 .../starfive/v4l2_driver/stf_common.h         |  183 +
 .../platform/starfive/v4l2_driver/stf_csi.c   |  424 +++
 .../platform/starfive/v4l2_driver/stf_csi.h   |   57 +
 .../starfive/v4l2_driver/stf_csi_hw_ops.c     |  282 ++
 .../starfive/v4l2_driver/stf_csiphy.c         |  356 ++
 .../starfive/v4l2_driver/stf_csiphy.h         |  186 +
 .../starfive/v4l2_driver/stf_csiphy_hw_ops.c  |  331 ++
 .../starfive/v4l2_driver/stf_dmabuf.c         |  123 +
 .../starfive/v4l2_driver/stf_dmabuf.h         |   10 +
 .../platform/starfive/v4l2_driver/stf_dvp.c   |  383 ++
 .../platform/starfive/v4l2_driver/stf_dvp.h   |   65 +
 .../starfive/v4l2_driver/stf_dvp_hw_ops.c     |  185 +
 .../platform/starfive/v4l2_driver/stf_event.c |   36 +
 .../platform/starfive/v4l2_driver/stf_isp.c   | 1501 ++++++++
 .../platform/starfive/v4l2_driver/stf_isp.h   |  220 ++
 .../starfive/v4l2_driver/stf_isp_hw_ops.c     | 1552 ++++++++
 .../starfive/v4l2_driver/stf_isp_ioctl.h      |  131 +
 .../platform/starfive/v4l2_driver/stf_video.c | 1551 ++++++++
 .../platform/starfive/v4l2_driver/stf_video.h |   80 +
 .../platform/starfive/v4l2_driver/stf_vin.c   | 1488 ++++++++
 .../platform/starfive/v4l2_driver/stf_vin.h   |  180 +
 .../starfive/v4l2_driver/stf_vin_hw_ops.c     |  432 +++
 .../platform/starfive/v4l2_driver/stfcamss.c  | 1384 +++++++
 .../platform/starfive/v4l2_driver/stfcamss.h  |  120 +
 drivers/mmc/host/Kconfig                      |    9 +
 drivers/mmc/host/Makefile                     |    1 +
 drivers/mmc/host/dw_mmc-starfive.c            |  230 ++
 drivers/net/ethernet/stmicro/stmmac/Kconfig   |   10 +
 drivers/net/ethernet/stmicro/stmmac/Makefile  |    3 +-
 .../stmicro/stmmac/dwmac-starfive-plat.c      |  177 +
 drivers/pci/controller/pcie-plda.c            | 1062 ++++++
 drivers/perf/riscv_pmu_sbi.c                  |  627 ++++
 drivers/phy/m31/7110-m31-dphy.h               |  419 +++
 drivers/phy/m31/Kconfig                       |   15 +
 drivers/phy/m31/Makefile                      |    3 +
 drivers/phy/m31/phy-m31-dphy-tx0.c            |  486 +++
 drivers/pinctrl/Kconfig                       |    1 +
 drivers/pinctrl/Makefile                      |    1 +
 drivers/pinctrl/starfive/Kconfig              |   24 +
 drivers/pinctrl/starfive/Makefile             |    6 +
 .../starfive/pinctrl-starfive-jh7110.c        | 1808 +++++++++
 drivers/pinctrl/starfive/pinctrl-starfive.c   |  481 +++
 drivers/pinctrl/starfive/pinctrl-starfive.h   |  126 +
 drivers/pwm/Kconfig                           |   10 +
 drivers/pwm/Makefile                          |    1 +
 drivers/pwm/pwm-starfive-ptc.c                |  314 ++
 drivers/regulator/Kconfig                     |   10 +
 drivers/regulator/Makefile                    |    1 +
 drivers/regulator/starfive-jh7110-regulator.c |  126 +
 drivers/reset/Kconfig                         |    1 +
 drivers/reset/Makefile                        |    1 +
 drivers/reset/starfive/Kconfig                |    6 +
 drivers/reset/starfive/Makefile               |    2 +
 .../reset/starfive/reset-starfive-jh7110.c    |  273 ++
 drivers/rtc/Kconfig                           |    8 +
 drivers/rtc/Makefile                          |    1 +
 drivers/rtc/rtc-starfive.c                    |  743 ++++
 drivers/soc/Kconfig                           |    1 +
 drivers/soc/Makefile                          |    3 +-
 drivers/soc/sifive/Kconfig                    |   16 +-
 drivers/soc/sifive/sifive_l2_cache.c          |   39 +
 drivers/soc/starfive/Kconfig                  |    8 +
 drivers/soc/starfive/Makefile                 |    3 +
 drivers/soc/starfive/jh7110_pmu.c             |  380 ++
 drivers/spi/Kconfig                           |   10 +-
 drivers/spi/Makefile                          |    1 +
 drivers/spi/spi-pl022-starfive.c              | 2874 +++++++++++++++
 drivers/usb/cdns3/Kconfig                     |    9 +
 drivers/usb/cdns3/Makefile                    |    1 +
 drivers/usb/cdns3/cdns3-starfive.c            |  421 +++
 drivers/usb/cdns3/core.h                      |    1 +
 drivers/usb/cdns3/host.c                      |   85 +
 drivers/watchdog/Kconfig                      |    8 +
 drivers/watchdog/Makefile                     |    3 +
 drivers/watchdog/starfive-wdt.c               |  887 +++++
 include/crypto/sha.h                          |  167 +
 .../clock/starfive-jh7110-clkgen.h            |  374 ++
 .../dt-bindings/clock/starfive-jh7110-isp.h   |   47 +
 .../dt-bindings/clock/starfive-jh7110-vout.h  |   59 +
 .../pinctrl/starfive,jh7110-pinfunc.h         | 1578 ++++++++
 include/dt-bindings/power/jh7110-power.h      |   18 +
 include/dt-bindings/reset/starfive-jh7110.h   |  217 ++
 include/linux/amba/bus.h                      |    2 +-
 include/linux/dma/starfive-dma.h              |    9 +
 include/linux/regulator/jh7110.h              |   24 +
 include/soc/starfive/jh7110.h                 |   15 +
 include/soc/starfive/jh7110_pmu.h             |  111 +
 include/video/stf-vin.h                       |  443 +++
 sound/soc/Kconfig                             |    2 +-
 sound/soc/Makefile                            |    1 +
 sound/soc/starfive/Kconfig                    |   70 +
 sound/soc/starfive/Makefile                   |   13 +
 sound/soc/starfive/pwmdac.h                   |  159 +
 sound/soc/starfive/starfive_i2s.c             | 1378 +++++++
 sound/soc/starfive/starfive_i2s.h             |  160 +
 sound/soc/starfive/starfive_pdm.c             |  445 +++
 sound/soc/starfive/starfive_pdm.h             |   63 +
 sound/soc/starfive/starfive_pwmdac.c          |  958 +++++
 sound/soc/starfive/starfive_pwmdac_pcm.c      |  251 ++
 .../starfive/starfive_pwmdac_transmitter.c    |  110 +
 sound/soc/starfive/starfive_spdif.c           |  617 ++++
 sound/soc/starfive/starfive_spdif.h           |  179 +
 sound/soc/starfive/starfive_spdif_pcm.c       |  339 ++
 sound/soc/starfive/starfive_tdm.c             |  704 ++++
 sound/soc/starfive/starfive_tdm.h             |  153 +
 173 files changed, 61555 insertions(+), 14 deletions(-)
 create mode 100644 arch/riscv/boot/dts/starfive/Makefile
 create mode 100644 arch/riscv/boot/dts/starfive/codecs/sf_hdmi.dtsi
 create mode 100644 arch/riscv/boot/dts/starfive/codecs/sf_pwmdac.dtsi
 create mode 100755 arch/riscv/boot/dts/starfive/jh7110-clk.dtsi
 create mode 100644 arch/riscv/boot/dts/starfive/jh7110-visionfive-v2.dts
 create mode 100755 arch/riscv/boot/dts/starfive/jh7110-visionfive-v2.dtsi
 create mode 100644 arch/riscv/boot/dts/starfive/jh7110.dtsi
 create mode 100755 arch/riscv/configs/starfive_jh7110_defconfig
 create mode 100755 arch/riscv/configs/starfive_visionfive2_defconfig
 create mode 100644 drivers/char/hw_random/starfive-trng.c
 create mode 100644 drivers/clk/starfive/Kconfig
 create mode 100644 drivers/clk/starfive/Makefile
 create mode 100755 drivers/clk/starfive/clk-starfive-jh7110-aon.c
 create mode 100644 drivers/clk/starfive/clk-starfive-jh7110-gen.c
 create mode 100644 drivers/clk/starfive/clk-starfive-jh7110-isp.c
 create mode 100644 drivers/clk/starfive/clk-starfive-jh7110-pll.c
 create mode 100644 drivers/clk/starfive/clk-starfive-jh7110-pll.h
 create mode 100755 drivers/clk/starfive/clk-starfive-jh7110-stg.c
 create mode 100644 drivers/clk/starfive/clk-starfive-jh7110-sys.c
 create mode 100644 drivers/clk/starfive/clk-starfive-jh7110-vout.c
 create mode 100644 drivers/clk/starfive/clk-starfive-jh7110.h
 create mode 100644 drivers/clocksource/timer-starfive.c
 create mode 100644 drivers/clocksource/timer-starfive.h
 create mode 100644 drivers/crypto/starfive/Kconfig
 create mode 100644 drivers/crypto/starfive/Makefile
 create mode 100644 drivers/crypto/starfive/jh7110/Makefile
 create mode 100644 drivers/crypto/starfive/jh7110/jh7110-aes.c
 create mode 100644 drivers/crypto/starfive/jh7110/jh7110-pka.c
 create mode 100644 drivers/crypto/starfive/jh7110/jh7110-regs.h
 create mode 100644 drivers/crypto/starfive/jh7110/jh7110-sec.c
 create mode 100644 drivers/crypto/starfive/jh7110/jh7110-sha.c
 create mode 100644 drivers/crypto/starfive/jh7110/jh7110-str.h
 create mode 100755 drivers/dma/jh7110-pl08x.c
 create mode 100644 drivers/gpu/drm/i2c/tda998x_pin.c
 create mode 100755 drivers/gpu/drm/panel/panel-jadard-jd9365da-h3.c
 create mode 100644 drivers/hwmon/sfctemp.c
 create mode 100644 drivers/mailbox/starfive_mailbox-test.c
 create mode 100644 drivers/mailbox/starfive_mailbox.c
 create mode 100644 drivers/media/platform/starfive/Kconfig
 create mode 100644 drivers/media/platform/starfive/Makefile
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/Readme.txt
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/imx219_mipi.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/ov13850_mipi.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/ov4689_mipi.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/ov5640.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/sc2235.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_common.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_csi.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_csi.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_csi_hw_ops.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_csiphy.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_csiphy.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_csiphy_hw_ops.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_dmabuf.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_dmabuf.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_dvp.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_dvp.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_dvp_hw_ops.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_event.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_isp.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_isp.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_isp_hw_ops.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_isp_ioctl.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_video.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_video.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_vin.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_vin.h
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stf_vin_hw_ops.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stfcamss.c
 create mode 100644 drivers/media/platform/starfive/v4l2_driver/stfcamss.h
 create mode 100644 drivers/mmc/host/dw_mmc-starfive.c
 create mode 100644 drivers/net/ethernet/stmicro/stmmac/dwmac-starfive-plat.c
 create mode 100644 drivers/pci/controller/pcie-plda.c
 create mode 100644 drivers/perf/riscv_pmu_sbi.c
 create mode 100644 drivers/phy/m31/7110-m31-dphy.h
 create mode 100644 drivers/phy/m31/Kconfig
 create mode 100644 drivers/phy/m31/Makefile
 create mode 100755 drivers/phy/m31/phy-m31-dphy-tx0.c
 create mode 100644 drivers/pinctrl/starfive/Kconfig
 create mode 100644 drivers/pinctrl/starfive/Makefile
 create mode 100644 drivers/pinctrl/starfive/pinctrl-starfive-jh7110.c
 create mode 100644 drivers/pinctrl/starfive/pinctrl-starfive.c
 create mode 100644 drivers/pinctrl/starfive/pinctrl-starfive.h
 create mode 100644 drivers/pwm/pwm-starfive-ptc.c
 create mode 100644 drivers/regulator/starfive-jh7110-regulator.c
 create mode 100644 drivers/reset/starfive/Kconfig
 create mode 100644 drivers/reset/starfive/Makefile
 create mode 100644 drivers/reset/starfive/reset-starfive-jh7110.c
 create mode 100644 drivers/rtc/rtc-starfive.c
 create mode 100644 drivers/soc/starfive/Kconfig
 create mode 100644 drivers/soc/starfive/Makefile
 create mode 100755 drivers/soc/starfive/jh7110_pmu.c
 create mode 100644 drivers/spi/spi-pl022-starfive.c
 create mode 100644 drivers/usb/cdns3/cdns3-starfive.c
 create mode 100644 drivers/watchdog/starfive-wdt.c
 create mode 100644 include/crypto/sha.h
 create mode 100755 include/dt-bindings/clock/starfive-jh7110-clkgen.h
 create mode 100755 include/dt-bindings/clock/starfive-jh7110-isp.h
 create mode 100755 include/dt-bindings/clock/starfive-jh7110-vout.h
 create mode 100644 include/dt-bindings/pinctrl/starfive,jh7110-pinfunc.h
 create mode 100755 include/dt-bindings/power/jh7110-power.h
 create mode 100644 include/dt-bindings/reset/starfive-jh7110.h
 create mode 100755 include/linux/dma/starfive-dma.h
 create mode 100644 include/linux/regulator/jh7110.h
 create mode 100644 include/soc/starfive/jh7110.h
 create mode 100755 include/soc/starfive/jh7110_pmu.h
 create mode 100644 include/video/stf-vin.h
 create mode 100644 sound/soc/starfive/Kconfig
 create mode 100644 sound/soc/starfive/Makefile
 create mode 100644 sound/soc/starfive/pwmdac.h
 create mode 100644 sound/soc/starfive/starfive_i2s.c
 create mode 100644 sound/soc/starfive/starfive_i2s.h
 create mode 100644 sound/soc/starfive/starfive_pdm.c
 create mode 100644 sound/soc/starfive/starfive_pdm.h
 create mode 100644 sound/soc/starfive/starfive_pwmdac.c
 create mode 100644 sound/soc/starfive/starfive_pwmdac_pcm.c
 create mode 100644 sound/soc/starfive/starfive_pwmdac_transmitter.c
 create mode 100644 sound/soc/starfive/starfive_spdif.c
 create mode 100644 sound/soc/starfive/starfive_spdif.h
 create mode 100644 sound/soc/starfive/starfive_spdif_pcm.c
 create mode 100644 sound/soc/starfive/starfive_tdm.c
 create mode 100644 sound/soc/starfive/starfive_tdm.h

diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index e52cd2cefe8e..23aaaae1d8d6 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -15,6 +15,7 @@ config RISCV
 	select ARCH_32BIT_OFF_T if !64BIT
 	select ARCH_CLOCKSOURCE_INIT
 	select ARCH_SUPPORTS_ATOMIC_RMW
+	select ARCH_STACKWALK
 	select ARCH_HAS_BINFMT_FLAT
 	select ARCH_HAS_DEBUG_VM_PGTABLE
 	select ARCH_HAS_DEBUG_VIRTUAL if MMU
@@ -35,6 +36,7 @@ config RISCV
 	select CLONE_BACKWARDS
 	select CLINT_TIMER if !MMU
 	select COMMON_CLK
+	select CPU_PM if CPU_IDLE
 	select EDAC_SUPPORT
 	select GENERIC_ARCH_TOPOLOGY if SMP
 	select GENERIC_ATOMIC64 if !64BIT
@@ -423,6 +425,12 @@ config EFI
 	  allow the kernel to be booted as an EFI application. This
 	  is only useful on systems that have UEFI firmware.
 
+config ARCH_SUSPEND_POSSIBLE
+        def_bool y
+
+config ARCH_HIBERNATION_POSSIBLE
+       def_bool y
+
 endmenu
 
 config BUILTIN_DTB
@@ -434,7 +442,19 @@ menu "Power management options"
 
 source "kernel/power/Kconfig"
 
+config ARCH_HIBERNATION_POSSIBLE
+       def_bool y
+
+config ARCH_HIBERNATION_HEADER
+       def_bool y
+       depends on HIBERNATION
+
 endmenu
 
 source "arch/riscv/kvm/Kconfig"
 source "drivers/firmware/Kconfig"
+menu "CPU Power Management"
+
+source "drivers/cpuidle/Kconfig"
+
+endmenu
diff --git a/arch/riscv/Kconfig.socs b/arch/riscv/Kconfig.socs
index 8a55f6156661..69ee95076d9b 100644
--- a/arch/riscv/Kconfig.socs
+++ b/arch/riscv/Kconfig.socs
@@ -10,6 +10,19 @@ config SOC_SIFIVE
 	help
 	  This enables support for SiFive SoC platform hardware.
 
+config SOC_STARFIVE
+	bool "StarFive Socs"
+	select OF_RESERVED_MEM
+	select SIFIVE_L2
+	select SIFIVE_L2_FLUSH
+	select SIFIVE_PLIC
+	select CLK_STARFIVE_JH7110
+	select RESET_STARFIVE_JH7110
+	select PINCTRL_STARFIVE
+	select ARM_AMBA
+	help
+	  StarFive SOC platform
+
 config SOC_VIRT
 	bool "QEMU Virt Machine"
 	select CLINT_TIMER if RISCV_M_MODE
diff --git a/arch/riscv/boot/dts/Makefile b/arch/riscv/boot/dts/Makefile
index 3ea94ea0a18a..5db96e7b6b69 100644
--- a/arch/riscv/boot/dts/Makefile
+++ b/arch/riscv/boot/dts/Makefile
@@ -2,5 +2,6 @@
 subdir-y += sifive
 subdir-y += kendryte
 subdir-y += microchip
+subdir-y += starfive
 
 obj-$(CONFIG_BUILTIN_DTB) := $(addsuffix /, $(subdir-y))
diff --git a/arch/riscv/boot/dts/starfive/Makefile b/arch/riscv/boot/dts/starfive/Makefile
new file mode 100644
index 000000000000..b194e4f6efb6
--- /dev/null
+++ b/arch/riscv/boot/dts/starfive/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_SOC_STARFIVE) += jh7110-visionfive-v2.dtb		\
diff --git a/arch/riscv/boot/dts/starfive/codecs/sf_hdmi.dtsi b/arch/riscv/boot/dts/starfive/codecs/sf_hdmi.dtsi
new file mode 100644
index 000000000000..22143c76ec3d
--- /dev/null
+++ b/arch/riscv/boot/dts/starfive/codecs/sf_hdmi.dtsi
@@ -0,0 +1,20 @@
+&sound1 {
+	/* i2s + hdmi */
+	simple-audio-card,dai-link@0 {
+		reg = <0>;
+		format = "i2s";
+		bitclock-master = <&sndi2s0>;
+		frame-master = <&sndi2s0>;
+		mclk-fs = <256>;
+		status = "okay";
+
+		sndi2s0: cpu {
+			sound-dai = <&i2stx_4ch0>;
+		};
+
+		sndhdmi0: codec {
+			sound-dai = <&hdmi>;
+		};
+	};
+};
+
diff --git a/arch/riscv/boot/dts/starfive/codecs/sf_pwmdac.dtsi b/arch/riscv/boot/dts/starfive/codecs/sf_pwmdac.dtsi
new file mode 100644
index 000000000000..901231b93313
--- /dev/null
+++ b/arch/riscv/boot/dts/starfive/codecs/sf_pwmdac.dtsi
@@ -0,0 +1,18 @@
+&sound3 {
+	simple-audio-card,dai-link@0 {
+		reg = <0>;
+		format = "left_j";
+		bitclock-master = <&sndcpu0>;
+		frame-master = <&sndcpu0>;
+		status = "okay";
+
+		sndcpu0: cpu {
+			sound-dai = <&pwmdac>;
+		};
+
+		codec {
+			sound-dai = <&pwmdac_codec>;
+		};
+	};
+};
+
diff --git a/arch/riscv/boot/dts/starfive/jh7110-clk.dtsi b/arch/riscv/boot/dts/starfive/jh7110-clk.dtsi
new file mode 100755
index 000000000000..701bc213ca39
--- /dev/null
+++ b/arch/riscv/boot/dts/starfive/jh7110-clk.dtsi
@@ -0,0 +1,126 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+
+/ {
+	osc: osc {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+	};
+
+	clk_ext_camera: clk-ext-camera {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+	};
+
+	gmac1_rmii_refin: gmac1_rmii_refin {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <50000000>;
+	};
+
+	gmac1_rgmii_rxin: gmac1_rgmii_rxin {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <125000000>;
+	};
+
+	i2stx_bclk_ext: i2stx_bclk_ext {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <12288000>;
+	};
+
+	i2stx_lrck_ext: i2stx_lrck_ext {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <192000>;
+	};
+
+	i2srx_bclk_ext: i2srx_bclk_ext {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <12288000>;
+	};
+
+	i2srx_lrck_ext: i2srx_lrck_ext {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <192000>;
+	};
+
+	tdm_ext: tdm_ext {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <49152000>;
+	};
+
+	mclk_ext: mclk_ext {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <12288000>;
+	};
+
+	jtag_tck_inner: jtag_tck_inner {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <50000000>;
+	};
+
+	bist_apb: bist_apb {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <50000000>;
+	};
+
+	gmac0_rmii_refin: gmac0_rmii_refin {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <50000000>;
+	};
+
+	gmac0_rgmii_rxin: gmac0_rgmii_rxin {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <125000000>;
+	};
+
+	clk_rtc: clk_rtc {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+	};
+
+	hdmitx0_pixelclk: hdmitx0_pixelclk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <297000000>;
+	};
+
+	mipitx_dphy_rxesc: mipitx_dphy_rxesc {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <10000000>;
+	};
+
+	mipitx_dphy_txbytehs: mipitx_dphy_txbytehs {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <297000000>;
+	};
+
+	wm8960_mclk: wm8960_mclk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24576000>;
+	};
+
+	ac108_mclk: ac108_mclk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+	};
+};
diff --git a/arch/riscv/boot/dts/starfive/jh7110-visionfive-v2.dts b/arch/riscv/boot/dts/starfive/jh7110-visionfive-v2.dts
new file mode 100644
index 000000000000..7056854d8d8c
--- /dev/null
+++ b/arch/riscv/boot/dts/starfive/jh7110-visionfive-v2.dts
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ * Copyright (C) 2022 Hal Feng <hal.feng@starfivetech.com>
+ */
+
+/dts-v1/;
+#include "jh7110-visionfive-v2.dtsi"
+#include "codecs/sf_hdmi.dtsi"
+
+/ {
+	model = "StarFive VisionFive V2";
+	compatible = "starfive,visionfive-v2", "starfive,jh7110";
+
+	gpio-restart {
+		compatible = "gpio-restart";
+		gpios = <&gpio 35 GPIO_ACTIVE_HIGH>;
+		priority = <160>;
+	};
+
+};
+
+&gpio {
+	uart0_pins: uart0-pins {
+		uart0-pins-tx {
+			starfive,pins = <PAD_GPIO5>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | GPIO_DS(3))>;
+			starfive,pin-gpio-dout = <GPO_UART0_SOUT>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+
+		uart0-pins-rx {
+			starfive,pins = <PAD_GPIO6>;
+			starfive,pinmux = <PAD_GPIO6_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | GPIO_PU(1))>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+			starfive,pin-gpio-din =  <GPI_UART0_SIN>;
+		};
+	};
+
+	i2c2_pins: i2c2-pins {
+		i2c2-pins-scl {
+			starfive,pins = <PAD_GPIO3>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_I2C2_IC_CLK_OE>;
+			starfive,pin-gpio-din =  <GPI_I2C2_IC_CLK_IN_A>;
+		};
+
+		i2c2-pins-sda {
+			starfive,pins = <PAD_GPIO2>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_I2C2_IC_DATA_OE>;
+			starfive,pin-gpio-din =  <GPI_I2C2_IC_DATA_IN_A>;
+		};
+	};
+
+	mmc0_pins: mmc0-pins {
+		 mmc0-pins-rest {
+			starfive,pins = <PAD_GPIO62>;
+			starfive,pinmux = <PAD_GPIO62_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_SDIO0_RST_N>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	sdcard1_pins: sdcard1-pins {
+		sdcard1-pins0 {
+			starfive,pins = <PAD_GPIO10>;
+			starfive,pinmux = <PAD_GPIO10_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)) | GPIO_DS(3))>;
+			starfive,pin-gpio-dout = <GPO_SDIO1_CCLK_OUT>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+
+		sdcard1-pins1 {
+			starfive,pins = <PAD_GPIO9>;
+			starfive,pinmux = <PAD_GPIO9_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)) | GPIO_DS(3))>;
+			starfive,pin-gpio-dout = <GPO_SDIO1_CCMD_OUT>;
+			starfive,pin-gpio-doen = <OEN_SDIO1_CCMD_OUT_EN>;
+			starfive,pin-gpio-din =  <GPI_SDIO1_CCMD_IN>;
+		};
+
+		sdcard1-pins2 {
+			starfive,pins = <PAD_GPIO11>;
+			starfive,pinmux = <PAD_GPIO11_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)) | GPIO_DS(3))>;
+			starfive,pin-gpio-dout = <GPO_SDIO1_CDATA_OUT_0>;
+			starfive,pin-gpio-doen = <OEN_SDIO1_CDATA_OUT_EN_0>;
+			starfive,pin-gpio-din =  <GPI_SDIO1_CDATA_IN_0>;
+		};
+
+		sdcard1-pins3 {
+			starfive,pins = <PAD_GPIO12>;
+			starfive,pinmux = <PAD_GPIO12_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)) | GPIO_DS(3))>;
+			starfive,pin-gpio-dout = <GPO_SDIO1_CDATA_OUT_1>;
+			starfive,pin-gpio-doen = <OEN_SDIO1_CDATA_OUT_EN_1>;
+			starfive,pin-gpio-din =  <GPI_SDIO1_CDATA_IN_1>;
+		};
+
+		sdcard1-pins4 {
+			starfive,pins = <PAD_GPIO7>;
+			starfive,pinmux = <PAD_GPIO7_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)) | GPIO_DS(3))>;
+			starfive,pin-gpio-dout = <GPO_SDIO1_CDATA_OUT_2>;
+			starfive,pin-gpio-doen = <OEN_SDIO1_CDATA_OUT_EN_2>;
+			starfive,pin-gpio-din =  <GPI_SDIO1_CDATA_IN_2>;
+		};
+
+		sdcard1-pins5 {
+			starfive,pins = <PAD_GPIO8>;
+			starfive,pinmux = <PAD_GPIO8_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)) | GPIO_DS(3))>;
+			starfive,pin-gpio-dout = <GPO_SDIO1_CDATA_OUT_3>;
+			starfive,pin-gpio-doen = <OEN_SDIO1_CDATA_OUT_EN_3>;
+			starfive,pin-gpio-din =  <GPI_SDIO1_CDATA_IN_3>;
+		};
+	};
+
+	inno_hdmi_pins: inno_hdmi-pins {
+		inno_hdmi-scl {
+			starfive,pins = <PAD_GPIO0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_HDMI0_DDC_SCL_OUT>;
+			starfive,pin-gpio-doen = <OEN_HDMI0_DDC_SCL_OEN>;
+			starfive,pin-gpio-din =  <GPI_HDMI0_DDC_SCL_IN>;
+		};
+
+		inno_hdmi-sda {
+			starfive,pins = <PAD_GPIO1>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_HDMI0_DDC_SDA_OUT>;
+			starfive,pin-gpio-doen = <OEN_HDMI0_DDC_SDA_OEN>;
+			starfive,pin-gpio-din =  <GPI_HDMI0_DDC_SDA_IN>;
+		};
+		inno_hdmi-cec-pins {
+			starfive,pins = <PAD_GPIO14>;
+			//starfive,pinmux = <PAD_GPIO14_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-doen = <OEN_HDMI0_CEC_SDA_OEN>;
+			starfive,pin-gpio-dout = <GPO_HDMI0_CEC_SDA_OUT>;
+			starfive,pin-gpio-din =  <GPI_HDMI0_CEC_SDA_IN>;
+		};
+		inno_hdmi-hpd-pins {
+			starfive,pins = <PAD_GPIO15>;
+			//starfive,pinmux = <PAD_GPIO15_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+			starfive,pin-gpio-din =  <GPI_HDMI0_HPD>;
+		};
+	};
+
+	mclk_ext_pins: mclk_ext_pins {
+		mclk_ext_pins {
+			starfive,pins = <PAD_GPIO4>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-din = <GPI_CRG0_EXT_MCLK>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+		};
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	status = "okay";
+};
+
+&i2c2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_pins>;
+	status = "okay";
+};
+
+&sdio0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc0_pins>;
+	status = "okay";
+};
+
+&sdio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdcard1_pins>;
+	//cd-gpios = <&gpio 41 0>;
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&inno_hdmi_pins>;
+};
+
+&i2stx_4ch0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&mclk_ext_pins>;
+	status = "okay";
+};
+
+&cpu1 {
+	cpu-supply = <&cpu_vdd>;
+	clocks = <&clkgen JH7110_CPU_CORE>;
+	clock-names = "cpu";
+};
diff --git a/arch/riscv/boot/dts/starfive/jh7110-visionfive-v2.dtsi b/arch/riscv/boot/dts/starfive/jh7110-visionfive-v2.dtsi
new file mode 100755
index 000000000000..c79ba3a58af2
--- /dev/null
+++ b/arch/riscv/boot/dts/starfive/jh7110-visionfive-v2.dtsi
@@ -0,0 +1,835 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ * Copyright (C) 2022 Hal Feng <hal.feng@starfivetech.com>
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/starfive,jh7110-pinfunc.h>
+#include "jh7110.dtsi"
+#include "codecs/sf_pwmdac.dtsi"
+
+/ {
+	model = "StarFive VisionFive V2";
+	compatible = "starfive,visionfive-v2", "starfive,jh7110";
+
+	aliases {
+		spi0 = &qspi;
+		gpio0 = &gpio;
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+		mmc0 = &sdio0;
+		mmc1 = &sdio1;
+		serial0 = &uart0;
+		serial3 = &uart3;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c4;
+		i2c5 = &i2c5;
+		i2c6 = &i2c6;
+	};
+
+	chosen {
+		linux,initrd-start = <0x0 0x46100000>;
+		linux,initrd-end = <0x0 0x4c000000>;
+		stdout-path = "serial0:115200";
+		#bootargs = "debug console=ttyS0 rootwait";
+	};
+
+	cpus {
+		timebase-frequency = <4000000>;
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0x1 0x0>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x20000000>;
+			alignment = <0x0 0x1000>;
+			alloc-ranges = <0x0 0x80000000 0x0 0x20000000>;
+			linux,cma-default;
+		};
+
+		e24_mem: e24@c0000000 {
+			no-map;
+			reg = <0x0 0xc0110000 0x0 0xf0000>;
+		};
+
+		xrp_reserved: xrpbuffer@f0000000 {
+			reg = <0x0 0xf0000000 0x0 0x01ffffff
+				0x0 0xf2000000 0x0 0x00001000
+				0x0 0xf2001000 0x0 0x00fff000
+				0x0 0xf3000000 0x0 0x00001000>;
+		};
+
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led-ack {
+			gpios = <&gpioa 3 GPIO_ACTIVE_HIGH>;
+			color = <LED_COLOR_ID_GREEN>;
+			function = LED_FUNCTION_HEARTBEAT;
+			linux,default-trigger = "heartbeat";
+			label = "ack";
+		};
+	};
+};
+
+&gpio {
+	i2c0_pins: i2c0-pins {
+		i2c0-pins-scl {
+			starfive,pins = <PAD_GPIO57>;
+			starfive,pinmux = <PAD_GPIO57_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_I2C0_IC_CLK_OE>;
+			starfive,pin-gpio-din =  <GPI_I2C0_IC_CLK_IN_A>;
+		};
+
+		i2c0-pins-sda {
+			starfive,pins = <PAD_GPIO58>;
+			starfive,pinmux = <PAD_GPIO58_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_I2C0_IC_DATA_OE>;
+			starfive,pin-gpio-din =  <GPI_I2C0_IC_DATA_IN_A>;
+		};
+	};
+
+	i2c5_pins: i2c5-pins {
+		i2c5-pins-scl {
+			starfive,pins = <PAD_GPIO19>;
+			starfive,pinmux = <PAD_GPIO19_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_I2C5_IC_CLK_OE>;
+			starfive,pin-gpio-din =  <GPI_I2C5_IC_CLK_IN_A>;
+		};
+
+		i2c5-pins-sda {
+			starfive,pins = <PAD_GPIO20>;
+			starfive,pinmux = <PAD_GPIO20_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_I2C5_IC_DATA_OE>;
+			starfive,pin-gpio-din =  <GPI_I2C5_IC_DATA_IN_A>;
+		};
+	};
+
+	i2c6_pins: i2c6-pins {
+		i2c6-pins-scl {
+			starfive,pins = <PAD_GPIO16>;
+			starfive,pinmux = <PAD_GPIO16_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_I2C6_IC_CLK_OE>;
+			starfive,pin-gpio-din =  <GPI_I2C6_IC_CLK_IN_A>;
+		};
+
+		i2c6-pins-sda {
+			starfive,pins = <PAD_GPIO17>;
+			starfive,pinmux = <PAD_GPIO17_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_I2C6_IC_DATA_OE>;
+			starfive,pin-gpio-din =  <GPI_I2C6_IC_DATA_IN_A>;
+		};
+	};
+
+	csi_pins: csi-pins {
+		csi-pins-pwdn {
+			starfive,pins = <PAD_GPIO18>;
+			starfive,pinmux = <PAD_GPIO18_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_HIGH>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	pwmdac0_pins: pwmdac0-pins {
+		pwmdac0-pins-left {
+			starfive,pins = <PAD_GPIO33>;
+			starfive,pinmux = <PAD_GPIO33_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_PWMDAC0_LEFT_OUTPUT>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+
+		pwmdac0-pins-right {
+			starfive,pins = <PAD_GPIO34>;
+			starfive,pinmux = <PAD_GPIO34_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1) | (GPIO_PU(1)))>;
+			starfive,pin-gpio-dout = <GPO_PWMDAC0_RIGHT_OUTPUT>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	pwm_pins: pwm-pins {
+		pwm_ch0-pins {
+			starfive,pins = <PAD_GPIO46>;
+			starfive,pinmux = <PAD_GPIO46_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_PTC0_PWM_0>;
+			starfive,pin-gpio-doen = <OEN_PTC0_PWM_0_OE_N>;
+		};
+
+		pwm_ch1-pins {
+			starfive,pins = <PAD_GPIO59>;
+			starfive,pinmux = <PAD_GPIO59_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_PTC0_PWM_1>;
+			starfive,pin-gpio-doen = <OEN_PTC0_PWM_1_OE_N>;
+		};
+	};
+
+	ssp0_pins: ssp0-pins {
+		ssp0-pins_tx {
+			starfive,pins = <PAD_GPIO52>;
+			starfive,pinmux = <PAD_GPIO52_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_SPI0_SSPTXD>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+
+		ssp0-pins_rx {
+			starfive,pins = <PAD_GPIO53>;
+			starfive,pinmux = <PAD_GPIO53_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+			starfive,pin-gpio-din =  <GPI_SPI0_SSPRXD>;
+		};
+
+		ssp0-pins_clk {
+			starfive,pins = <PAD_GPIO48>;
+			starfive,pinmux = <PAD_GPIO48_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_SPI0_SSPCLKOUT>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+
+		ssp0-pins_cs {
+			starfive,pins = <PAD_GPIO49>;
+			starfive,pinmux = <PAD_GPIO49_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_SPI0_SSPFSSOUT>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	pcie0_perst_default: pcie0_perst_default {
+		perst-pins {
+			starfive,pins = <PAD_GPIO26>;
+			starfive,pinmux = <PAD_GPIO26_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_HIGH>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	pcie0_perst_active: pcie0_perst_active {
+		perst-pins {
+			starfive,pins = <PAD_GPIO26>;
+			starfive,pinmux = <PAD_GPIO26_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	pcie0_wake_default: pcie0_wake_default {
+		wake-pins {
+			starfive,pins = <PAD_GPIO32>;
+			starfive,pinmux = <PAD_GPIO32_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+		};
+	};
+
+	pcie0_clkreq_default: pcie0_clkreq_default {
+		clkreq-pins {
+			starfive,pins = <PAD_GPIO27>;
+			starfive,pinmux = <PAD_GPIO27_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+		};
+	};
+
+	pcie1_perst_default: pcie1_perst_default {
+		perst-pins {
+			starfive,pins = <PAD_GPIO28>;
+			starfive,pinmux = <PAD_GPIO28_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_HIGH>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	pcie1_perst_active: pcie1_perst_active {
+		perst-pins {
+			starfive,pins = <PAD_GPIO28>;
+			starfive,pinmux = <PAD_GPIO28_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_LOW>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	pcie1_wake_default: pcie1_wake_default {
+		wake-pins {
+			starfive,pins = <PAD_GPIO21>;
+			starfive,pinmux = <PAD_GPIO21_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+		};
+	};
+
+	pcie1_clkreq_default: pcie1_clkreq_default {
+		clkreq-pins {
+			starfive,pins = <PAD_GPIO29>;
+			starfive,pinmux = <PAD_GPIO29_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+		};
+	};
+
+	usb_pins: usb-pins {
+		drive-vbus-pin {
+			starfive,pins = <PAD_GPIO25>;
+			starfive,pinmux = <PAD_GPIO25_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_USB0_DRIVE_VBUS_IO>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+
+	i2srx_pins: i2srx-pins {
+		i2srx-pins0 {
+			starfive,pins = <PAD_GPIO61>;
+			starfive,pinmux = <PAD_GPIO61_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+			starfive,pin-gpio-din =  <GPI_I2SRX0_EXT_SDIN0>;
+		};
+	};
+
+	i2s_clk_pins: i2s-clk0 {
+		i2s-clk0_bclk {
+			starfive,pins = <PAD_GPIO38>;
+			starfive,pinmux = <PAD_GPIO38_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-din = <GPI_I2STX0_BCLK_SLV GPI_I2SRX0_BCLK_SLV>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+		};
+
+		i2s-clk0_lrclk {
+			starfive,pins = <PAD_GPIO63>;
+			starfive,pinmux = <PAD_GPIO63_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-din = <GPI_I2STX0_LRCK_SLV GPI_I2SRX0_LRCK_SLV>;
+			starfive,pin-gpio-doen = <OEN_HIGH>;
+		};
+	};
+
+	i2stx_pins: i2stx-pins {
+		i2stx-pins0 {
+			starfive,pins = <PAD_GPIO44>;
+			starfive,pinmux = <PAD_GPIO44_FUNC_SEL 0>;
+			starfive,pin-ioconfig = <IO(GPIO_IE(1))>;
+			starfive,pin-gpio-dout = <GPO_I2STX_4CH1_SDO0>;
+			starfive,pin-gpio-doen = <OEN_LOW>;
+		};
+	};
+};
+
+&uart0 {
+	status = "okay";
+};
+
+&dma {
+	status = "okay";
+};
+
+&trng {
+	status = "okay";
+};
+
+&crypto {
+	status = "okay";
+};
+
+&sec_dma {
+	status = "okay";
+};
+
+&i2c0 {
+	clock-frequency = <100000>;
+	i2c-sda-hold-time-ns = <300>;
+	i2c-sda-falling-time-ns = <510>;
+	i2c-scl-falling-time-ns = <510>;
+	auto_calc_scl_lhcnt;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0_pins>;
+	status = "okay";
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	i2c-sda-hold-time-ns = <300>;
+	i2c-sda-falling-time-ns = <510>;
+	i2c-scl-falling-time-ns = <510>;
+	auto_calc_scl_lhcnt;
+	status = "okay";
+
+	seeed_plane_i2c@45 {
+		compatible = "seeed_panel";
+		reg = <0x45>;
+
+		port {
+			panel_out0: endpoint {
+				remote-endpoint = <&dsi0_output>;
+			};
+		};
+	};
+
+	tinker_ft5406: tinker_ft5406@38 {
+		compatible = "tinker_ft5406";
+		reg = <0x38>;
+	};
+
+	panel_radxa@19 {
+		compatible ="starfive_jadard";
+		reg = <0x19>;
+		reset-gpio = <&gpio 23 0>;
+		enable-gpio = <&gpio 22 0>;
+
+		port {
+			panel_out1: endpoint {
+				remote-endpoint = <&dsi1_output>;
+				};
+		};
+	};
+
+	touchscreen@14 {
+		compatible = "goodix,gt911";
+		reg = <0x14>;
+		irq-gpios = <&gpio 30 GPIO_ACTIVE_HIGH>;
+		reset-gpios = <&gpio 31 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&i2c5 {
+	clock-frequency = <100000>;
+	i2c-sda-hold-time-ns = <300>;
+	i2c-sda-falling-time-ns = <510>;
+	i2c-scl-falling-time-ns = <510>;
+	auto_calc_scl_lhcnt;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5_pins>;
+	status = "okay";
+
+	eeprom@50 {
+		compatible = "atmel,24c04";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+
+	pmic: axp15060_reg@36 {
+		compatible = "stf,axp15060-regulator";
+		reg = <0x36>;
+
+		regulators {
+			mipi_0p9: ALDO1 {
+				regulator-boot-on;
+				regulator-compatible = "mipi_0p9";
+				regulator-name = "mipi_0p9";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+			};
+			hdmi_0p9: ALDO5 {
+				regulator-boot-on;
+				regulator-compatible = "hdmi_0p9";
+				regulator-name = "hdmi_0p9";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+			};
+			hdmi_1p8: ALDO3 {
+				regulator-boot-on;
+				regulator-compatible = "hdmi_1p8";
+				regulator-name = "hdmi_1p8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+			};
+			cpu_vdd: DCDC2 {
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-compatible = "cpu_vdd";
+				regulator-name = "cpu_vdd";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1540000>;
+			};
+		};
+	};
+};
+
+&i2c6 {
+	clock-frequency = <100000>;
+	i2c-sda-hold-time-ns = <300>;
+	i2c-sda-falling-time-ns = <510>;
+	i2c-scl-falling-time-ns = <510>;
+	auto_calc_scl_lhcnt;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6_pins>;
+	status = "okay";
+
+	imx219: imx219@10 {
+		compatible = "sony,imx219";
+		reg = <0x10>;
+		clocks = <&clk_ext_camera>;
+		clock-names = "xclk";
+		//reset-gpio = <&gpio 18 0>;
+		//DOVDD-supply = <&v2v8>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&csi_pins>;
+		rotation = <0>;
+		orientation = <1>; //CAMERA_ORIENTATION_BACK
+
+		port {
+			/* CSI2 bus endpoint */
+			imx219_to_csi2rx0: endpoint {
+				remote-endpoint = <&csi2rx0_from_imx219>;
+				bus-type = <4>;      /* MIPI CSI-2 D-PHY */
+				clock-lanes = <4>;
+				data-lanes = <0 1>;
+				lane-polarities = <0 0 0>;
+				link-frequencies = /bits/ 64 <456000000>;
+			};
+		};
+	};
+};
+
+&sdio0 {
+	max-frequency = <100000000>;
+	card-detect-delay = <300>;
+	bus-width = <8>;
+	cap-mmc-highspeed;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	non-removable;
+	cap-mmc-hw-reset;
+	post-power-on-delay-ms = <200>;
+	status = "okay";
+};
+
+&sdio1 {
+	max-frequency = <100000000>;
+	card-detect-delay = <300>;
+	bus-width = <4>;
+	no-sdio;
+	no-mmc;
+	broken-cd;
+	cap-sd-highspeed;
+	post-power-on-delay-ms = <200>;
+	status = "okay";
+};
+
+&vin_sysctl {
+	/* when use dvp open this pinctrl*/
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* CSI2 bus endpoint */
+			csi2rx0_from_imx219: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&imx219_to_csi2rx0>;
+				bus-type = <4>;      /* MIPI CSI-2 D-PHY */
+				clock-lanes = <4>;
+				data-lanes = <0 1>;
+				lane-polarities = <0 0 0>;
+				status = "okay";
+			};
+		};
+	};
+};
+
+&sfctemp {
+	status = "okay";
+};
+
+&jpu {
+	status = "okay";
+};
+
+&vpu_dec {
+	status = "okay";
+};
+
+&vpu_enc {
+	status = "okay";
+};
+
+&gmac0 {
+	status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	phy0: ethernet-phy@0 {
+		rxc_dly_en = <1>;
+		tx_delay_sel_fe = <5>;
+		tx_delay_sel = <0xa>;
+		tx_inverted_10 = <0x1>;
+		tx_inverted_100 = <0x1>;
+		tx_inverted_1000 = <0x1>;
+	};
+};
+
+&gmac1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+	phy1: ethernet-phy@1 {
+		tx_delay_sel_fe = <5>;
+		tx_delay_sel = <0>;
+		rxc_dly_en = <0>;
+		tx_inverted_10 = <0x1>;
+		tx_inverted_100 = <0x1>;
+		tx_inverted_1000 = <0x0>;
+	};
+};
+
+&gpu {
+	status = "okay";
+};
+
+&pwmdac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwmdac0_pins>;
+	status = "okay";
+};
+
+&i2srx_3ch {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s_clk_pins &i2srx_pins>;
+	status = "disabled";
+};
+
+&i2stx_4ch1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2stx_pins>;
+	status = "disabled";
+};
+
+&pwmdac_codec {
+	status = "okay";
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ssp0_pins>;
+	status = "okay";
+
+	spi_dev0: spi@0 {
+		compatible = "rohm,dh2228fv";
+		pl022,com-mode = <1>;
+		spi-max-frequency = <10000000>;
+		reg = <0>;
+		status = "okay";
+	};
+};
+
+&pcie0 {
+	pinctrl-names = "default", "perst-default", "perst-active";
+	pinctrl-0 = <&pcie0_wake_default>,
+		    <&pcie0_clkreq_default>;
+	pinctrl-1 = <&pcie0_perst_default>;
+	pinctrl-2 = <&pcie0_perst_active>;
+	status = "okay";
+};
+
+&pcie1 {
+	pinctrl-names = "default", "perst-default", "perst-active";
+	pinctrl-0 = <&pcie1_wake_default>,
+		    <&pcie1_clkreq_default>;
+	pinctrl-1 = <&pcie1_perst_default>;
+	pinctrl-2 = <&pcie1_perst_active>;
+	status = "okay";
+};
+
+&mailbox_contrl0 {
+	status = "okay";
+};
+
+&mailbox_client0 {
+	status = "okay";
+};
+
+&display {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+
+	hdmi_in: port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		hdmi_in_lcdc: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dc_out_dpi1>;
+		};
+	};
+};
+
+&dc8200 {
+	status = "okay";
+
+	dc_out: port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dc_out_dpi0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&hdmi_input0>;
+		};
+		dc_out_dpi1: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&hdmi_in_lcdc>;
+		};
+
+		dc_out_dpi2: endpoint@2 {
+			reg = <2>;
+			remote-endpoint = <&mipi_in>;
+		};
+	};
+};
+
+&rgb_output {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0>;
+			hdmi_input0:endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&dc_out_dpi0>;
+			};
+		};
+	};
+};
+
+&dsi_output {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			mipi_in: endpoint {
+				remote-endpoint = <&dc_out_dpi2>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			sf_dpi_output: endpoint {
+				remote-endpoint = <&dsi_in_port>;
+			};
+		};
+	};
+};
+
+&mipi_dsi {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dsi0_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&panel_out0>;
+			};
+
+			dsi1_output: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&panel_out1>;
+			};
+		};
+
+		port@1{
+			reg = <1>;
+			dsi_in_port: endpoint {
+				remote-endpoint = <&sf_dpi_output>;
+			};
+		};
+
+	};
+};
+
+&mipi_dphy {
+	status = "disabled";
+};
+
+&co_process {
+	status = "okay";
+};
+
+&usbdrd30 {
+	clocks = <&clkgen JH7110_USB_125M>,
+		 <&clkgen JH7110_USB0_CLK_APP_125>,
+		 <&clkgen JH7110_USB0_CLK_LPM>,
+		 <&clkgen JH7110_USB0_CLK_STB>,
+		 <&clkgen JH7110_USB0_CLK_USB_APB>,
+		 <&clkgen JH7110_USB0_CLK_AXI>,
+		 <&clkgen JH7110_USB0_CLK_UTMI_APB>;
+	clock-names = "125m","app","lpm","stb","apb","axi","utmi";
+	resets = <&rstgen RSTN_U0_CDN_USB_PWRUP>,
+		 <&rstgen RSTN_U0_CDN_USB_APB>,
+		 <&rstgen RSTN_U0_CDN_USB_AXI>,
+		 <&rstgen RSTN_U0_CDN_USB_UTMI_APB>;
+	reset-names = "pwrup","apb","axi","utmi";
+	starfive,usb2-only;
+	dr_mode = "peripheral"; /*host or peripheral*/
+	status = "okay";
+};
+
+&xrp {
+	status = "okay";
+};
+
+&ptc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm_pins>;
+	status = "okay";
+};
diff --git a/arch/riscv/boot/dts/starfive/jh7110.dtsi b/arch/riscv/boot/dts/starfive/jh7110.dtsi
new file mode 100644
index 000000000000..e5813f3809d5
--- /dev/null
+++ b/arch/riscv/boot/dts/starfive/jh7110.dtsi
@@ -0,0 +1,1809 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ * Copyright (C) 2022 Hal Feng <hal.feng@starfivetech.com>
+ */
+
+/dts-v1/;
+#include "jh7110-clk.dtsi"
+#include <dt-bindings/reset/starfive-jh7110.h>
+#include <dt-bindings/clock/starfive-jh7110-clkgen.h>
+#include <dt-bindings/clock/starfive-jh7110-vout.h>
+#include <dt-bindings/clock/starfive-jh7110-isp.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/power/jh7110-power.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	compatible = "starfive,jh7110";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cluster0_opp: opp-table-0 {
+			compatible = "operating-points-v2";
+			opp-shared;
+			opp-375000000 {
+					opp-hz = /bits/ 64 <375000000>;
+					opp-microvolt = <800000>;
+			};
+			opp-500000000 {
+					opp-hz = /bits/ 64 <500000000>;
+					opp-microvolt = <800000>;
+			};
+			opp-750000000 {
+					opp-hz = /bits/ 64 <750000000>;
+					opp-microvolt = <800000>;
+					opp-suspend;
+			};
+			opp-1500000000 {
+					opp-hz = /bits/ 64 <1500000000>;
+					opp-microvolt = <1040000>;
+			};
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "sifive,u74-mc", "riscv";
+			reg = <0>;
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <8192>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <40>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <16384>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <40>;
+			mmu-type = "riscv,sv39";
+			next-level-cache = <&cachectrl>;
+			riscv,isa = "rv64imac";
+			tlb-split;
+			#cooling-cells = <2>;
+			status = "disabled";
+
+			cpu0intctrl: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu1: cpu@1 {
+			compatible = "sifive,u74-mc", "riscv";
+			reg = <1>;
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <40>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <40>;
+			mmu-type = "riscv,sv39";
+			next-level-cache = <&cachectrl>;
+			riscv,isa = "rv64imafdc";
+			tlb-split;
+			#cooling-cells = <2>;
+			status = "okay";
+			operating-points-v2 = <&cluster0_opp>;
+
+			cpu1intctrl: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu2: cpu@2 {
+			compatible = "sifive,u74-mc", "riscv";
+			reg = <2>;
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <40>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <40>;
+			mmu-type = "riscv,sv39";
+			next-level-cache = <&cachectrl>;
+			riscv,isa = "rv64imafdc";
+			tlb-split;
+			#cooling-cells = <2>;
+			status = "okay";
+			operating-points-v2 = <&cluster0_opp>;
+
+			cpu2intctrl: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu3: cpu@3 {
+			compatible = "sifive,u74-mc", "riscv";
+			reg = <3>;
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <40>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <40>;
+			mmu-type = "riscv,sv39";
+			next-level-cache = <&cachectrl>;
+			riscv,isa = "rv64imafdc";
+			tlb-split;
+			#cooling-cells = <2>;
+			status = "okay";
+			operating-points-v2 = <&cluster0_opp>;
+
+			cpu3intctrl: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu4: cpu@4 {
+			compatible = "sifive,u74-mc", "riscv";
+			reg = <4>;
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <40>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <40>;
+			mmu-type = "riscv,sv39";
+			next-level-cache = <&cachectrl>;
+			riscv,isa = "rv64imafdc";
+			tlb-split;
+			#cooling-cells = <2>;
+			status = "okay";
+			operating-points-v2 = <&cluster0_opp>;
+
+			cpu4intctrl: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+	};
+
+	soc: soc {
+		compatible = "simple-bus";
+		interrupt-parent = <&plic>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		#clock-cells = <1>;
+		ranges;
+
+		cachectrl: cache-controller@2010000 {
+			compatible = "sifive,fu740-c000-ccache", "cache";
+			reg = <0x0 0x2010000 0x0 0x4000 0x0 0x8000000 0x0 0x2000000>;
+			reg-names = "control", "sideband";
+			interrupts = <1 3 4 2>;
+			cache-block-size = <64>;
+			cache-level = <2>;
+			cache-sets = <2048>;
+			cache-size = <2097152>;
+			cache-unified;
+		};
+
+		aon_syscon: aon_syscon@17010000 {
+			compatible = "syscon";
+			reg = <0x0 0x17010000 0x0 0x1000>;
+		};
+
+		phyctrl0: multi-phyctrl@10210000 {
+			compatible = "starfive,phyctrl";
+			reg = <0x0 0x10210000 0x0 0x10000>;
+		};
+
+		phyctrl1: pcie1-phyctrl@10220000 {
+			compatible = "starfive,phyctrl";
+			reg = <0x0 0x10220000 0x0 0x10000>;
+		};
+
+		stg_syscon: stg_syscon@10240000 {
+			compatible = "syscon";
+			reg = <0x0 0x10240000 0x0 0x1000>;
+		};
+
+		sys_syscon: sys_syscon@13030000 {
+			compatible = "syscon";
+			reg = <0x0 0x13030000 0x0 0x1000>;
+		};
+
+		clint: clint@2000000 {
+			compatible = "riscv,clint0";
+			reg = <0x0 0x2000000 0x0 0x10000>;
+			reg-names = "control";
+			interrupts-extended = <&cpu0intctrl 3 &cpu0intctrl 7
+						&cpu1intctrl 3 &cpu1intctrl 7
+						&cpu2intctrl 3 &cpu2intctrl 7
+						&cpu3intctrl 3 &cpu3intctrl 7
+						&cpu4intctrl 3 &cpu4intctrl 7>;
+			#interrupt-cells = <1>;
+		};
+
+		plic: plic@c000000 {
+			compatible = "riscv,plic0";
+			reg = <0x0 0xc000000 0x0 0x4000000>;
+			reg-names = "control";
+			interrupts-extended = <&cpu0intctrl 11
+						&cpu1intctrl 11 &cpu1intctrl 9
+						&cpu2intctrl 11 &cpu2intctrl 9
+						&cpu3intctrl 11 &cpu3intctrl 9
+						&cpu4intctrl 11 &cpu4intctrl 9>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+			riscv,max-priority = <7>;
+			riscv,ndev = <136>;
+		};
+
+		clkgen: clock-controller {
+			compatible = "starfive,jh7110-clkgen";
+			reg = <0x0 0x13020000 0x0 0x10000>,
+				<0x0 0x10230000 0x0 0x10000>,
+				<0x0 0x17000000 0x0 0x10000>;
+			reg-names = "sys", "stg", "aon";
+			clocks = <&osc>, <&gmac1_rmii_refin>,
+				 <&gmac1_rgmii_rxin>,
+				 <&i2stx_bclk_ext>, <&i2stx_lrck_ext>,
+				 <&i2srx_bclk_ext>, <&i2srx_lrck_ext>,
+				 <&tdm_ext>, <&mclk_ext>,
+				 <&jtag_tck_inner>, <&bist_apb>,
+				 <&clk_rtc>,
+				 <&gmac0_rmii_refin>, <&gmac0_rgmii_rxin>;
+			clock-names = "osc", "gmac1_rmii_refin",
+				"gmac1_rgmii_rxin",
+				"i2stx_bclk_ext", "i2stx_lrck_ext",
+				"i2srx_bclk_ext", "i2srx_lrck_ext",
+				"tdm_ext", "mclk_ext",
+				"jtag_tck_inner", "bist_apb",
+				"clk_rtc",
+				"gmac0_rmii_refin", "gmac0_rgmii_rxin";
+			#clock-cells = <1>;
+			starfive,sys-syscon = <&sys_syscon 0x18 0x1c
+					0x20 0x24 0x28 0x2c 0x30 0x34>;
+			status = "okay";
+		};
+
+		clkvout: clock-controller@295C0000 {
+			compatible = "starfive,jh7110-clk-vout";
+			reg = <0x0 0x295C0000 0x0 0x10000>;
+			reg-names = "vout";
+			clocks = <&hdmitx0_pixelclk>,
+				 <&mipitx_dphy_rxesc>,
+				 <&mipitx_dphy_txbytehs>,
+				 <&clkgen JH7110_VOUT_SRC>,
+				 <&clkgen JH7110_VOUT_TOP_CLK_VOUT_AHB>;
+			clock-names = "hdmitx0_pixelclk",
+				      "mipitx_dphy_rxesc",
+				      "mipitx_dphy_txbytehs",
+				      "vout_src",
+				      "vout_top_ahb";
+			resets = <&rstgen RSTN_U0_DOM_VOUT_TOP_SRC>;
+			reset-names = "vout_src";
+			#clock-cells = <1>;
+			power-domains = <&pwrc JH7110_PD_VOUT>;
+			status = "okay";
+		};
+
+		clkisp: clock-controller@19810000 {
+			compatible = "starfive,jh7110-clk-isp";
+			reg = <0x0 0x19810000 0x0 0x10000>;
+			reg-names = "isp";
+			#clock-cells = <1>;
+			clocks = <&clkgen JH7110_ISP_TOP_CLK_DVP>,
+				 <&clkgen JH7110_ISP_TOP_CLK_ISPCORE_2X>,
+				 <&clkgen JH7110_ISP_TOP_CLK_ISP_AXI>,
+				 <&clkgen JH7110_NOC_BUS_CLK_ISP_AXI>;
+			clock-names = "u0_dom_isp_top_clk_dom_isp_top_clk_dvp",
+				      "u0_dom_isp_top_clk_dom_isp_top_clk_ispcore_2x",
+				      "u0_dom_isp_top_clk_dom_isp_top_clk_isp_axi",
+				      "u0_sft7110_noc_bus_clk_isp_axi";
+			resets = <&rstgen RSTN_U0_DOM_ISP_TOP_N>,
+				 <&rstgen RSTN_U0_DOM_ISP_TOP_AXI>,
+				 <&rstgen RSTN_U0_NOC_BUS_ISP_AXI_N>;
+			reset-names = "rst_isp_top_n", "rst_isp_top_axi",
+				      "rst_isp_noc_bus_n";
+			power-domains = <&pwrc JH7110_PD_ISP>;
+			status = "okay";
+		};
+
+		qspi: spi@13010000 {
+			compatible = "cdns,qspi-nor";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x13010000 0x0 0x10000
+				0x0 0x21000000 0x0 0x400000>;
+			interrupts = <25>;
+			clocks = <&clkgen JH7110_QSPI_CLK_REF>,
+				 <&clkgen JH7110_QSPI_CLK_APB>,
+				 <&clkgen JH7110_AHB1>,
+				 <&clkgen JH7110_QSPI_CLK_AHB>;
+			clock-names = "clk_ref",
+				      "clk_apb",
+				      "ahb1",
+				      "clk_ahb";
+			resets = <&rstgen RSTN_U0_CDNS_QSPI_APB>,
+				 <&rstgen RSTN_U0_CDNS_QSPI_AHB>,
+				 <&rstgen RSTN_U0_CDNS_QSPI_REF>;
+
+			cdns,fifo-depth = <256>;
+			cdns,fifo-width = <4>;
+			cdns,trigger-address = <0x0>;
+			spi-max-frequency = <250000000>;
+
+			nor_flash: nor-flash@0 {
+				compatible = "jedec,spi-nor";
+				reg=<0>;
+				cdns,read-delay = <5>;
+				spi-max-frequency = <100000000>;
+				cdns,tshsl-ns = <1>;
+				cdns,tsd2d-ns = <1>;
+				cdns,tchsh-ns = <1>;
+				cdns,tslch-ns = <1>;
+
+				partitions {
+					compatible = "fixed-partitions";
+					#address-cells = <1>;
+					#size-cells = <1>;
+
+					spl@0 {
+						reg = <0x0 0x40000>;
+					};
+					uboot@100000 {
+						reg = <0x100000 0x300000>;
+					};
+					data@f00000 {
+						reg = <0xf00000 0x100000>;
+					};
+				};
+			};
+		};
+
+		otp: otp@17050000 {
+			compatible = "starfive,jh7110-otp";
+			reg = <0x0 0x17050000 0x0 0x10000>;
+			clock-frequency = <4000000>;
+			clocks = <&clkgen JH7110_OTPC_CLK_APB>;
+			clock-names = "apb";
+		};
+
+		usbdrd30: usbdrd{
+			compatible = "starfive,jh7110-cdns3";
+			reg = <0x0 0x10210000 0x0 0x1000>,
+			      <0x0 0x10200000 0x0 0x1000>;
+			clocks = <&clkgen JH7110_USB_125M>,
+				 <&clkgen JH7110_USB0_CLK_APP_125>,
+				 <&clkgen JH7110_USB0_CLK_LPM>,
+				 <&clkgen JH7110_USB0_CLK_STB>,
+				 <&clkgen JH7110_USB0_CLK_USB_APB>,
+				 <&clkgen JH7110_USB0_CLK_AXI>,
+				 <&clkgen JH7110_USB0_CLK_UTMI_APB>,
+				 <&clkgen JH7110_PCIE0_CLK_APB>;
+			clock-names = "125m","app","lpm","stb","apb","axi","utmi", "phy";
+			resets = <&rstgen RSTN_U0_CDN_USB_PWRUP>,
+				 <&rstgen RSTN_U0_CDN_USB_APB>,
+				 <&rstgen RSTN_U0_CDN_USB_AXI>,
+				 <&rstgen RSTN_U0_CDN_USB_UTMI_APB>,
+				 <&rstgen RSTN_U0_PLDA_PCIE_APB>;
+			reset-names = "pwrup","apb","axi","utmi", "phy";
+			starfive,stg-syscon = <&stg_syscon 0x4 0xc4 0x148 0x1f4>;
+			starfive,sys-syscon = <&sys_syscon 0x18>;
+			status = "disabled";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			ranges;
+			usbdrd_cdns3: usb@10100000 {
+				compatible = "cdns,usb3";
+				reg = <0x0 0x10100000 0x0 0x10000>,
+				      <0x0 0x10110000 0x0 0x10000>,
+				      <0x0 0x10120000 0x0 0x10000>;
+				reg-names = "otg", "xhci", "dev";
+				interrupts = <100>, <108>, <110>;
+				interrupt-names = "host", "peripheral", "otg";
+				phy-names = "cdns3,usb3-phy", "cnds3,usb2-phy";
+				maximum-speed = "super-speed";
+			};
+		};
+
+		timer: timer@13050000 {
+			compatible = "starfive,jh7110-timers";
+			reg = <0x0 0x13050000 0x0 0x10000>;
+			interrupts = <69>, <70>, <71> ,<72>;
+			interrupt-names = "timer0", "timer1",
+					  "timer2", "timer3";
+			clocks = <&clkgen JH7110_TIMER_CLK_TIMER0>,
+				 <&clkgen JH7110_TIMER_CLK_TIMER1>,
+				 <&clkgen JH7110_TIMER_CLK_TIMER2>,
+				 <&clkgen JH7110_TIMER_CLK_TIMER3>,
+				 <&clkgen JH7110_TIMER_CLK_APB>;
+			clock-names = "timer0", "timer1",
+				      "timer2", "timer3", "apb_clk";
+			resets = <&rstgen RSTN_U0_TIMER_TIMER0>,
+				 <&rstgen RSTN_U0_TIMER_TIMER1>,
+				 <&rstgen RSTN_U0_TIMER_TIMER2>,
+				 <&rstgen RSTN_U0_TIMER_TIMER3>,
+				 <&rstgen RSTN_U0_TIMER_APB>;
+			reset-names = "timer0", "timer1",
+				      "timer2", "timer3", "apb_rst";
+			clock-frequency = <24000000>;
+			status = "okay";
+		};
+
+		wdog: wdog@13070000 {
+			compatible = "starfive,jh7110-wdt";
+			reg = <0x0 0x13070000 0x0 0x10000>;
+			interrupts = <68>;
+			interrupt-names = "wdog";
+			clocks = <&clkgen JH7110_DSKIT_WDT_CLK_WDT>,
+				 <&clkgen JH7110_DSKIT_WDT_CLK_APB>;
+			clock-names = "core_clk", "apb_clk";
+			resets = <&rstgen RSTN_U0_DSKIT_WDT_APB>,
+				 <&rstgen RSTN_U0_DSKIT_WDT_CORE>;
+			reset-names = "rst_apb", "rst_core";
+			timeout-sec = <15>;
+			status = "okay";
+		};
+
+		rtc: rtc@17040000 {
+			compatible = "starfive,jh7110-rtc";
+			reg = <0x0 0x17040000 0x0 0x10000>;
+			interrupts = <10>, <11>, <12>;
+			interrupt-names = "rtc_ms_pulse", "rtc_sec_pulse", "rtc";
+			clocks = <&clkgen JH7110_RTC_HMS_CLK_APB>,
+				 <&clkgen JH7110_RTC_HMS_CLK_CAL>;
+			clock-names = "pclk", "cal_clk";
+			resets = <&rstgen RSTN_U0_RTC_HMS_OSC32K>,
+				 <&rstgen RSTN_U0_RTC_HMS_APB>,
+				 <&rstgen RSTN_U0_RTC_HMS_CAL>;
+			reset-names = "rst_osc", "rst_apb", "rst_cal";
+			rtc,cal-clock-freq = <1000000>;
+			status = "okay";
+		};
+
+		pwrc: power-controller@17030000 {
+			compatible = "starfive,jh7110-pmu";
+			reg = <0x0 0x17030000 0x0 0x10000>;
+			interrupts = <111>;
+			#power-domain-cells = <1>;
+			status = "okay";
+		};
+
+		uart0: serial@10000000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x10000000 0x0 0x10000>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			clocks = <&clkgen JH7110_UART0_CLK_CORE>,
+				 <&clkgen JH7110_UART0_CLK_APB>;
+			clock-names = "baudclk", "apb_pclk";
+			resets = <&rstgen RSTN_U0_DW_UART_APB>,
+				<&rstgen RSTN_U0_DW_UART_CORE>;
+			interrupts = <32>;
+			status = "disabled";
+		};
+
+		uart1: serial@10010000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x10010000 0x0 0x10000>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			clocks = <&clkgen JH7110_UART1_CLK_CORE>,
+				 <&clkgen JH7110_UART1_CLK_APB>;
+			clock-names = "baudclk", "apb_pclk";
+			resets = <&rstgen RSTN_U1_DW_UART_APB>,
+				<&rstgen RSTN_U1_DW_UART_CORE>;
+			interrupts = <33>;
+			status = "disabled";
+		};
+
+		uart2: serial@10020000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x10020000 0x0 0x10000>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			clocks = <&clkgen JH7110_UART2_CLK_CORE>,
+				 <&clkgen JH7110_UART2_CLK_APB>;
+			clock-names = "baudclk", "apb_pclk";
+			resets = <&rstgen RSTN_U2_DW_UART_APB>,
+				<&rstgen RSTN_U2_DW_UART_CORE>;
+			interrupts = <34>;
+			status = "disabled";
+		};
+
+		uart3: serial@12000000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x12000000 0x0 0x10000>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			clocks = <&clkgen JH7110_UART3_CLK_CORE>,
+				 <&clkgen JH7110_UART3_CLK_APB>;
+			clock-names = "baudclk", "apb_pclk";
+			resets = <&rstgen RSTN_U3_DW_UART_APB>,
+				<&rstgen RSTN_U3_DW_UART_CORE>;
+			interrupts = <45>;
+			status = "disabled";
+		};
+
+		uart4: serial@12010000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x12010000 0x0 0x10000>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			clocks = <&clkgen JH7110_UART4_CLK_CORE>,
+				 <&clkgen JH7110_UART4_CLK_APB>;
+			clock-names = "baudclk", "apb_pclk";
+			resets = <&rstgen RSTN_U4_DW_UART_APB>,
+				<&rstgen RSTN_U4_DW_UART_CORE>;
+			interrupts = <46>;
+			status = "disabled";
+		};
+
+		uart5: serial@12020000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x12020000 0x0 0x10000>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			clocks = <&clkgen JH7110_UART5_CLK_CORE>,
+				 <&clkgen JH7110_UART5_CLK_APB>;
+			clock-names = "baudclk", "apb_pclk";
+			resets = <&rstgen RSTN_U5_DW_UART_APB>,
+				<&rstgen RSTN_U5_DW_UART_CORE>;
+			interrupts = <47>;
+			status = "disabled";
+		};
+
+		dma: dma-controller@16050000 {
+			compatible = "starfive,jh7110-dma", "snps,axi-dma-1.01a";
+			reg = <0x0 0x16050000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_DMA1P_CLK_AXI>,
+				 <&clkgen JH7110_DMA1P_CLK_AHB>,
+				 <&clkgen JH7110_NOC_BUS_CLK_STG_AXI>;
+			clock-names = "core-clk", "cfgr-clk", "stg_clk";
+			resets = <&rstgen RSTN_U0_DW_DMA1P_AXI>,
+				 <&rstgen RSTN_U0_DW_DMA1P_AHB>,
+				 <&rstgen RSTN_U0_NOC_BUS_STG_AXI_N>;
+			reset-names = "rst_axi", "rst_ahb", "rst_stg";
+			interrupts = <73>;
+			#dma-cells = <2>;
+			dma-channels = <4>;
+			snps,dma-masters = <1>;
+			snps,data-width = <3>;
+			snps,num-hs-if = <56>;
+			snps,block-size = <65536 65536 65536 65536>;
+			snps,priority = <0 1 2 3>;
+			snps,axi-max-burst-len = <16>;
+			status = "disabled";
+		};
+
+		gpio: gpio@13040000 {
+			compatible = "starfive,jh7110-sys-pinctrl";
+			reg = <0x0 0x13040000 0x0 0x10000>;
+			reg-names = "control";
+			clocks = <&clkgen JH7110_SYS_IOMUX_PCLK>;
+			resets = <&rstgen RSTN_U0_SYS_IOMUX_PRESETN>;
+			interrupts = <86>;
+			interrupt-controller;
+			#gpio-cells = <2>;
+			ngpios = <64>;
+			status = "okay";
+		};
+
+		gpioa: gpio@17020000 {
+			compatible = "starfive,jh7110-aon-pinctrl";
+			reg = <0x0 0x17020000 0x0 0x10000>;
+			reg-names = "control";
+			resets = <&rstgen RSTN_U0_AON_IOMUX_PRESETN>;
+			interrupts = <85>;
+			interrupt-controller;
+			#gpio-cells = <2>;
+			ngpios = <4>;
+			status = "okay";
+		};
+
+		sfctemp: tmon@120e0000  {
+			compatible = "starfive,jh7110-temp";
+			reg = <0x0 0x120e0000 0x0 0x10000>;
+			interrupts = <81>;
+			clocks = <&clkgen JH7110_TEMP_SENSOR_CLK_TEMP>,
+				 <&clkgen JH7110_TEMP_SENSOR_CLK_APB>;
+			clock-names = "sense", "bus";
+			resets = <&rstgen RSTN_U0_TEMP_SENSOR_TEMP>,
+				 <&rstgen RSTN_U0_TEMP_SENSOR_APB>;
+			reset-names = "sense", "bus";
+			#thermal-sensor-cells = <0>;
+			status = "disabled";
+		};
+
+		thermal-zones {
+			cpu-thermal {
+				polling-delay-passive = <250>;
+				polling-delay = <15000>;
+
+				thermal-sensors = <&sfctemp>;
+
+				trips {
+					cpu_alert0: cpu_alert0 {
+						/* milliCelsius */
+						temperature = <75000>;
+						hysteresis = <2000>;
+						type = "passive";
+					};
+
+					cpu_crit: cpu_crit {
+						/* milliCelsius */
+						temperature = <90000>;
+						hysteresis = <2000>;
+						type = "critical";
+					};
+				};
+				cooling-maps {
+					map0 {
+						trip = <&cpu_alert0>;
+						cooling-device =
+							<&cpu0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							<&cpu1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							<&cpu2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+							<&cpu3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+					};
+				};
+			};
+		};
+
+		trng: trng@1600C000 {
+			compatible = "starfive,jh7110-trng";
+			reg = <0x0 0x1600C000 0x0 0x4000>;
+			clocks = <&clkgen JH7110_SEC_HCLK>,
+				 <&clkgen JH7110_SEC_MISCAHB_CLK>;
+			clock-names = "hclk", "ahb";
+			resets = <&rstgen RSTN_U0_SEC_TOP_HRESETN>;
+			interrupts = <30>;
+			status = "disabled";
+		};
+
+		sec_dma: sec_dma@16008000 {
+			compatible = "arm,pl080", "arm,primecell";
+			arm,primecell-periphid = <0x00041080>;
+			reg = <0x0 0x16008000 0x0 0x4000>;
+			reg-names = "sec_dma";
+			interrupts = <29>;
+			clocks = <&clkgen JH7110_SEC_HCLK>,
+				 <&clkgen JH7110_SEC_MISCAHB_CLK>;
+			clock-names = "sec_hclk","apb_pclk";
+			resets = <&rstgen RSTN_U0_SEC_TOP_HRESETN>;
+			reset-names = "sec_hre";
+			lli-bus-interface-ahb1;
+			mem-bus-interface-ahb1;
+			memcpy-burst-size = <256>;
+			memcpy-bus-width = <32>;
+			#dma-cells = <2>;
+			status = "disabled";
+		};
+
+		crypto: crypto@16000000 {
+			compatible = "starfive,jh7110-sec";
+			reg = <0x0 0x16000000 0x0 0x4000>,
+			      <0x0 0x16008000 0x0 0x4000>;
+			reg-names = "secreg","secdma";
+			interrupts = <28>, <29>;
+			interrupt-names = "secirq", "dmairq";
+			clocks = <&clkgen JH7110_SEC_HCLK>,
+				 <&clkgen JH7110_SEC_MISCAHB_CLK>;
+			clock-names = "sec_hclk","sec_ahb";
+			resets = <&rstgen RSTN_U0_SEC_TOP_HRESETN>;
+			reset-names = "sec_hre";
+			enable-side-channel-mitigation = "true";
+			enable-dma = "true";
+			dmas = <&sec_dma 1 2>,
+			       <&sec_dma 0 2>;
+			dma-names = "sec_m","sec_p";
+			status = "disabled";
+		};
+
+		i2c0: i2c@10030000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x10030000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_I2C0_CLK_CORE>,
+				 <&clkgen JH7110_I2C0_CLK_APB>;
+			clock-names = "ref", "pclk";
+			resets = <&rstgen RSTN_U0_DW_I2C_APB>;
+			interrupts = <35>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@10040000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x10040000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_I2C1_CLK_CORE>,
+				 <&clkgen JH7110_I2C1_CLK_APB>;
+			clock-names = "ref", "pclk";
+			resets = <&rstgen RSTN_U1_DW_I2C_APB>;
+			interrupts = <36>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@10050000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x10050000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_I2C2_CLK_CORE>,
+				 <&clkgen JH7110_I2C2_CLK_APB>;
+			clock-names = "ref", "pclk";
+			resets = <&rstgen RSTN_U2_DW_I2C_APB>;
+			interrupts = <37>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@12030000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x12030000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_I2C3_CLK_CORE>,
+				 <&clkgen JH7110_I2C3_CLK_APB>;
+			clock-names = "ref", "pclk";
+			resets = <&rstgen RSTN_U3_DW_I2C_APB>;
+			interrupts = <48>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c4: i2c@12040000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x12040000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_I2C4_CLK_CORE>,
+				 <&clkgen JH7110_I2C4_CLK_APB>;
+			clock-names = "ref", "pclk";
+			resets = <&rstgen RSTN_U4_DW_I2C_APB>;
+			interrupts = <49>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c5: i2c@12050000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x12050000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_I2C5_CLK_CORE>,
+				 <&clkgen JH7110_I2C5_CLK_APB>;
+			clock-names = "ref", "pclk";
+			resets = <&rstgen RSTN_U5_DW_I2C_APB>;
+			interrupts = <50>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		i2c6: i2c@12060000 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x12060000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_I2C6_CLK_CORE>,
+				 <&clkgen JH7110_I2C6_CLK_APB>;
+			clock-names = "ref", "pclk";
+			resets = <&rstgen RSTN_U6_DW_I2C_APB>;
+			interrupts = <51>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		/* unremovable emmc as mmcblk0 */
+		sdio0: sdio0@16010000 {
+			compatible = "starfive,jh7110-sdio";
+			reg = <0x0 0x16010000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SDIO0_CLK_AHB>,
+				 <&clkgen JH7110_SDIO0_CLK_SDCARD>;
+			clock-names = "biu","ciu";
+			resets = <&rstgen RSTN_U0_DW_SDIO_AHB>;
+			reset-names = "reset";
+			interrupts = <74>;
+			fifo-depth = <32>;
+			fifo-watermark-aligned;
+			data-addr = <0>;
+			starfive,sys-syscon = <&sys_syscon 0x14 0x1a 0x7c000000>;
+			status = "disabled";
+		};
+
+		sdio1: sdio1@16020000 {
+			compatible = "starfive,jh7110-sdio";
+			reg = <0x0 0x16020000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SDIO1_CLK_AHB>,
+				 <&clkgen JH7110_SDIO1_CLK_SDCARD>;
+			clock-names = "biu","ciu";
+			resets = <&rstgen RSTN_U1_DW_SDIO_AHB>;
+			reset-names = "reset";
+			interrupts = <75>;
+			fifo-depth = <32>;
+			fifo-watermark-aligned;
+			data-addr = <0>;
+			starfive,sys-syscon = <&sys_syscon 0x9c 0x1 0x3e>;
+			status = "disabled";
+		};
+
+		vin_sysctl: vin_sysctl@19800000 {
+			compatible = "starfive,jh7110-vin";
+			reg = <0x0 0x19800000 0x0 0x10000>,
+				<0x0 0x19810000 0x0 0x10000>,
+				<0x0 0x19820000 0x0 0x10000>,
+				<0x0 0x19840000 0x0 0x10000>,
+				<0x0 0x19870000 0x0 0x30000>,
+				<0x0 0x11840000 0x0 0x10000>,
+				<0x0 0x17030000 0x0 0x10000>,
+				<0x0 0x13020000 0x0 0x10000>;
+			reg-names = "csi2rx", "vclk", "vrst", "sctrl",
+				"isp", "trst", "pmu", "syscrg";
+			clocks = <&clkisp JH7110_DOM4_APB_FUNC>,
+				 <&clkisp JH7110_U0_VIN_PCLK>,
+				 <&clkisp JH7110_U0_VIN_SYS_CLK>,
+				 <&clkisp JH7110_U0_ISPV2_TOP_WRAPPER_CLK_C>,
+				 <&clkisp JH7110_DVP_INV>,
+				 <&clkisp JH7110_U0_VIN_CLK_P_AXIWR>,
+				 <&clkisp JH7110_MIPI_RX0_PXL>,
+				 <&clkisp JH7110_U0_VIN_PIXEL_CLK_IF0>,
+				 <&clkisp JH7110_U0_VIN_PIXEL_CLK_IF1>,
+				 <&clkisp JH7110_U0_VIN_PIXEL_CLK_IF2>,
+				 <&clkisp JH7110_U0_VIN_PIXEL_CLK_IF3>,
+				 <&clkisp JH7110_U0_M31DPHY_CFGCLK_IN>,
+				 <&clkisp JH7110_U0_M31DPHY_REFCLK_IN>,
+				 <&clkisp JH7110_U0_M31DPHY_TXCLKESC_LAN0>,
+				 <&clkgen JH7110_ISP_TOP_CLK_ISPCORE_2X>,
+				 <&clkgen JH7110_ISP_TOP_CLK_ISP_AXI>;
+			clock-names = "clk_apb_func", "clk_pclk", "clk_sys_clk",
+				"clk_wrapper_clk_c", "clk_dvp_inv", "clk_axiwr",
+				"clk_mipi_rx0_pxl", "clk_pixel_clk_if0",
+				"clk_pixel_clk_if1", "clk_pixel_clk_if2",
+				"clk_pixel_clk_if3", "clk_m31dphy_cfgclk_in",
+				"clk_m31dphy_refclk_in", "clk_m31dphy_txclkesc_lan0",
+				"clk_ispcore_2x", "clk_isp_axi";
+			resets = <&rstgen RSTN_U0_ISPV2_TOP_WRAPPER_P>,
+				 <&rstgen RSTN_U0_ISPV2_TOP_WRAPPER_C>,
+				 <&rstgen RSTN_U0_VIN_N_PCLK>,
+				 <&rstgen RSTN_U0_VIN_N_SYS_CLK>,
+				 <&rstgen RSTN_U0_VIN_P_AXIRD>,
+				 <&rstgen RSTN_U0_VIN_P_AXIWR>,
+				 <&rstgen RSTN_U0_VIN_N_PIXEL_CLK_IF0>,
+				 <&rstgen RSTN_U0_VIN_N_PIXEL_CLK_IF1>,
+				 <&rstgen RSTN_U0_VIN_N_PIXEL_CLK_IF2>,
+				 <&rstgen RSTN_U0_VIN_N_PIXEL_CLK_IF3>,
+				 <&rstgen RSTN_U0_M31DPHY_HW>,
+				 <&rstgen RSTN_U0_M31DPHY_B09_ALWAYS_ON>,
+				 <&rstgen RSTN_U0_DOM_ISP_TOP_N>,
+				 <&rstgen RSTN_U0_DOM_ISP_TOP_AXI>;
+			reset-names = "rst_wrapper_p", "rst_wrapper_c", "rst_pclk",
+				"rst_sys_clk", "rst_axird", "rst_axiwr", "rst_pixel_clk_if0",
+				"rst_pixel_clk_if1", "rst_pixel_clk_if2", "rst_pixel_clk_if3",
+				"rst_m31dphy_hw", "rst_m31dphy_b09_always_on",
+				"rst_isp_top_n", "rst_isp_top_axi";
+			starfive,aon-syscon = <&aon_syscon 0x00>;
+			power-domains = <&pwrc JH7110_PD_ISP>;
+			/* irq nr: vin, isp, isp_csi, isp_scd, isp_csiline */
+			interrupts = <92 87 88 89 90>;
+			status = "disabled";
+		};
+
+		jpu: jpu@11900000 {
+			compatible = "starfive,jpu";
+			reg = <0x0 0x13090000 0x0 0x300>;
+			interrupts = <14>;
+			clocks = <&clkgen JH7110_CODAJ12_CLK_AXI>,
+				 <&clkgen JH7110_CODAJ12_CLK_CORE>,
+				 <&clkgen JH7110_CODAJ12_CLK_APB>,
+				 <&clkgen JH7110_NOC_BUS_CLK_VDEC_AXI>;
+			clock-names = "axi_clk", "core_clk",
+				      "apb_clk", "noc_bus";
+			resets = <&rstgen RSTN_U0_CODAJ12_AXI>,
+				 <&rstgen RSTN_U0_CODAJ12_CORE>,
+				 <&rstgen RSTN_U0_CODAJ12_APB>;
+			reset-names = "rst_axi", "rst_core", "rst_apb";
+			power-domains = <&pwrc JH7110_PD_VDEC>;
+			status = "disabled";
+		};
+
+		vpu_dec: vpu_dec@130A0000 {
+			compatible = "starfive,vdec";
+			reg = <0x0 0x130A0000 0x0 0x10000>;
+			interrupts = <13>;
+			clocks = <&clkgen JH7110_WAVE511_CLK_AXI>,
+				 <&clkgen JH7110_WAVE511_CLK_BPU>,
+				 <&clkgen JH7110_WAVE511_CLK_VCE>,
+				 <&clkgen JH7110_WAVE511_CLK_APB>,
+				 <&clkgen JH7110_NOC_BUS_CLK_VDEC_AXI>;
+			clock-names = "axi_clk", "bpu_clk", "vce_clk",
+				      "apb_clk", "noc_bus";
+			resets = <&rstgen RSTN_U0_WAVE511_AXI>,
+				<&rstgen RSTN_U0_WAVE511_BPU>,
+				<&rstgen RSTN_U0_WAVE511_VCE>,
+				<&rstgen RSTN_U0_WAVE511_APB>,
+				<&rstgen RSTN_U0_AXIMEM_128B_AXI>;
+			reset-names = "rst_axi", "rst_bpu", "rst_vce",
+				      "rst_apb", "rst_sram";
+			starfive,vdec_noc_ctrl;
+			power-domains = <&pwrc JH7110_PD_VDEC>;
+			status = "disabled";
+		};
+
+		vpu_enc: vpu_enc@130B0000 {
+			compatible = "starfive,venc";
+			reg = <0x0 0x130B0000 0x0 0x10000>;
+			interrupts = <15>;
+			clocks = <&clkgen JH7110_WAVE420L_CLK_AXI>,
+				 <&clkgen JH7110_WAVE420L_CLK_BPU>,
+				 <&clkgen JH7110_WAVE420L_CLK_VCE>,
+				 <&clkgen JH7110_WAVE420L_CLK_APB>,
+				 <&clkgen JH7110_NOC_BUS_CLK_VENC_AXI>;
+			clock-names = "axi_clk", "bpu_clk", "vce_clk",
+				      "apb_clk", "noc_bus";
+			resets = <&rstgen RSTN_U0_WAVE420L_AXI>,
+				 <&rstgen RSTN_U0_WAVE420L_BPU>,
+				 <&rstgen RSTN_U0_WAVE420L_VCE>,
+				 <&rstgen RSTN_U0_WAVE420L_APB>,
+				 <&rstgen RSTN_U1_AXIMEM_128B_AXI>;
+			reset-names = "rst_axi", "rst_bpu", "rst_vce",
+				      "rst_apb", "rst_sram";
+			starfive,venc_noc_ctrl;
+			power-domains = <&pwrc JH7110_PD_VENC>;
+			status = "disabled";
+		};
+
+		rstgen: reset-controller {
+			compatible = "starfive,jh7110-reset";
+			reg = <0x0 0x13020000 0x0 0x10000>,
+				<0x0 0x10230000 0x0 0x10000>,
+				<0x0 0x17000000 0x0 0x10000>,
+				<0x0 0x19810000 0x0 0x10000>,
+				<0x0 0x295C0000 0x0 0x10000>;
+			reg-names = "syscrg", "stgcrg", "aoncrg", "ispcrg", "voutcrg";
+			#reset-cells = <1>;
+			status = "okay";
+		};
+
+		stmmac_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <0xf>;
+			snps,rd_osr_lmt = <0xf>;
+			snps,blen = <256 128 64 32 0 0 0>;
+		};
+
+		gmac0: ethernet@16030000 {
+			compatible = "starfive,dwmac","snps,dwmac-5.10a";
+			reg = <0x0 0x16030000 0x0 0x10000>;
+			clock-names = "gtx",
+				"tx",
+				"ptp_ref",
+				"stmmaceth",
+				"pclk",
+				"gtxc",
+				"rmii_rtx";
+			clocks = <&clkgen JH7110_GMAC0_GTXCLK>,
+				 <&clkgen JH7110_U0_GMAC5_CLK_TX>,
+				 <&clkgen JH7110_GMAC0_PTP>,
+				 <&clkgen JH7110_U0_GMAC5_CLK_AHB>,
+				 <&clkgen JH7110_U0_GMAC5_CLK_AXI>,
+				 <&clkgen JH7110_GMAC0_GTXC>,
+				 <&clkgen JH7110_GMAC0_RMII_RTX>;
+			resets = <&rstgen RSTN_U0_DW_GMAC5_AXI64_AHB>,
+				 <&rstgen RSTN_U0_DW_GMAC5_AXI64_AXI>;
+			reset-names = "ahb", "stmmaceth";
+			interrupts = <7>, <6>, <5> ;
+			interrupt-names = "macirq", "eth_wake_irq", "eth_lpi";
+			max-frame-size = <9000>;
+			phy-mode = "rgmii-id";
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			rx-fifo-depth = <2048>;
+			tx-fifo-depth = <2048>;
+			snps,fixed-burst;
+			snps,no-pbl-x8;
+			snps,force_thresh_dma_mode;
+			snps,axi-config = <&stmmac_axi_setup>;
+			snps,tso;
+			snps,en-tx-lpi-clockgating;
+			snps,en-lpi;
+			snps,write-requests = <4>;
+			snps,read-requests = <4>;
+			snps,burst-map = <0x7>;
+			snps,txpbl = <16>;
+			snps,rxpbl = <16>;
+			status = "disabled";
+		};
+
+		gmac1: ethernet@16040000 {
+			compatible = "starfive,dwmac","snps,dwmac-5.10a";
+			reg = <0x0 0x16040000 0x0 0x10000>;
+			clock-names = "gtx",
+				"tx",
+				"ptp_ref",
+				"stmmaceth",
+				"pclk",
+				"gtxc",
+				"rmii_rtx";
+			clocks = <&clkgen JH7110_GMAC1_GTXCLK>,
+				 <&clkgen JH7110_GMAC5_CLK_TX>,
+				 <&clkgen JH7110_GMAC5_CLK_PTP>,
+				 <&clkgen JH7110_GMAC5_CLK_AHB>,
+				 <&clkgen JH7110_GMAC5_CLK_AXI>,
+				 <&clkgen JH7110_GMAC1_GTXC>,
+				 <&clkgen JH7110_GMAC1_RMII_RTX>;
+			resets = <&rstgen RSTN_U1_DW_GMAC5_AXI64_H_N>,
+				 <&rstgen RSTN_U1_DW_GMAC5_AXI64_A_I>;
+			reset-names = "ahb", "stmmaceth";
+			interrupts = <78>, <77>, <76> ;
+			interrupt-names = "macirq", "eth_wake_irq", "eth_lpi";
+			max-frame-size = <9000>;
+			phy-mode = "rgmii-id";
+			snps,multicast-filter-bins = <64>;
+			snps,perfect-filter-entries = <128>;
+			rx-fifo-depth = <2048>;
+			tx-fifo-depth = <2048>;
+			snps,fixed-burst;
+			snps,no-pbl-x8;
+			snps,force_thresh_dma_mode;
+			snps,axi-config = <&stmmac_axi_setup>;
+			snps,tso;
+			snps,en-tx-lpi-clockgating;
+			snps,en-lpi;
+			snps,write-requests = <4>;
+			snps,read-requests = <4>;
+			snps,burst-map = <0x7>;
+			snps,txpbl = <16>;
+			snps,rxpbl = <16>;
+			status = "disabled";
+		};
+
+		gpu: gpu@18000000 {
+			compatible = "img-gpu";
+			reg = <0x0 0x18000000 0x0 0x100000>,
+				<0x0 0x130C000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_GPU_CORE>,
+				 <&clkgen JH7110_GPU_CLK_APB>,
+				 <&clkgen JH7110_GPU_RTC_TOGGLE>,
+				 <&clkgen JH7110_GPU_CORE_CLK>,
+				 <&clkgen JH7110_GPU_SYS_CLK>,
+				 <&clkgen JH7110_NOC_BUS_CLK_GPU_AXI>;
+			clock-names = "clk_bv", "clk_apb", "clk_rtc",
+					"clk_core", "clk_sys", "clk_axi";
+			resets = <&rstgen RSTN_U0_IMG_GPU_APB>,
+				 <&rstgen RSTN_U0_IMG_GPU_DOMA>;
+			reset-names = "rst_apb", "rst_doma";
+			power-domains = <&pwrc JH7110_PD_GPUA>;
+			interrupts = <82>;
+			current-clock = <8000000>;
+			status = "disabled";
+		};
+
+		can0: can@130d0000 {
+			compatible = "starfive,jh7110-can", "ipms,can";
+			reg = <0x0 0x130d0000 0x0 0x1000>;
+			interrupts = <112>;
+			clocks = <&clkgen JH7110_CAN0_CTRL_CLK_APB>,
+				 <&clkgen JH7110_CAN0_CTRL_CLK_CAN>,
+				 <&clkgen JH7110_CAN0_CTRL_CLK_TIMER>;
+			clock-names = "apb_clk", "core_clk", "timer_clk";
+			resets = <&rstgen RSTN_U0_CAN_CTRL_APB>,
+				 <&rstgen RSTN_U0_CAN_CTRL_CORE>,
+				 <&rstgen RSTN_U0_CAN_CTRL_TIMER>;
+			reset-names = "rst_apb", "rst_core", "rst_timer";
+			frequency = <40000000>;
+			starfive,sys-syscon = <&sys_syscon 0x10 0x3 0x8>;
+			syscon,can_or_canfd = <0>;
+			status = "disabled";
+		};
+
+		can1: can@130e0000 {
+			compatible = "starfive,jh7110-can", "ipms,can";
+			reg = <0x0 0x130e0000 0x0 0x1000>;
+			interrupts = <113>;
+			clocks = <&clkgen JH7110_CAN1_CTRL_CLK_APB>,
+				 <&clkgen JH7110_CAN1_CTRL_CLK_CAN>,
+				 <&clkgen JH7110_CAN1_CTRL_CLK_TIMER>;
+			clock-names = "apb_clk", "core_clk", "timer_clk";
+			resets = <&rstgen RSTN_U1_CAN_CTRL_APB>,
+				 <&rstgen RSTN_U1_CAN_CTRL_CORE>,
+				 <&rstgen RSTN_U1_CAN_CTRL_TIMER>;
+			reset-names = "rst_apb", "rst_core", "rst_timer";
+			frequency = <40000000>;
+			starfive,sys-syscon = <&sys_syscon 0x88 0x12 0x40000>;
+			syscon,can_or_canfd = <1>;
+			status = "disabled";
+		};
+
+		tdm: tdm@10090000 {
+			compatible = "starfive,jh7110-tdm";
+			reg = <0x0 0x10090000 0x0 0x1000>;
+			reg-names = "tdm";
+			clocks = <&clkgen JH7110_TDM_CLK_AHB>,
+				 <&clkgen JH7110_TDM_CLK_APB>,
+				 <&clkgen JH7110_TDM_INTERNAL>,
+				 <&tdm_ext>,
+				 <&clkgen JH7110_TDM_CLK_TDM>,
+				 <&clkgen JH7110_MCLK_INNER>;
+			clock-names = "clk_tdm_ahb", "clk_tdm_apb",
+				      "clk_tdm_internal", "clk_tdm_ext",
+				      "clk_tdm", "mclk_inner";
+			resets = <&rstgen RSTN_U0_TDM16SLOT_AHB>,
+				 <&rstgen RSTN_U0_TDM16SLOT_APB>,
+				 <&rstgen RSTN_U0_TDM16SLOT_TDM>;
+			reset-names = "tdm_ahb", "tdm_apb", "tdm_rst";
+			dmas = <&dma 20 1>, <&dma 21 1>;
+			dma-names = "rx","tx";
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		spdif0: spdif0@100a0000 {
+			compatible = "starfive,jh7110-spdif";
+			reg = <0x0 0x100a0000 0x0 0x1000>;
+			clocks = <&clkgen JH7110_SPDIF_CLK_APB>,
+				 <&clkgen JH7110_SPDIF_CLK_CORE>,
+				 <&clkgen JH7110_AUDIO_ROOT>,
+				 <&clkgen JH7110_MCLK_INNER>,
+				 <&mclk_ext>, <&clkgen JH7110_MCLK>;
+			clock-names = "spdif-apb", "spdif-core",
+				      "audroot", "mclk_inner",
+				      "mclk_ext", "mclk";
+			resets = <&rstgen RSTN_U0_CDNS_SPDIF_APB>;
+			reset-names = "rst_apb";
+			interrupts = <84>;
+			interrupt-names = "tx";
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		pwmdac: pwmdac@100b0000 {
+			compatible = "starfive,jh7110-pwmdac";
+			reg = <0x0 0x100b0000 0x0 0x1000>;
+			clocks = <&clkgen JH7110_APB0>,
+				 <&clkgen JH7110_PWMDAC_CLK_APB>,
+				 <&clkgen JH7110_PWMDAC_CLK_CORE>;
+			clock-names = "apb0", "pwmdac-apb", "pwmdac-core";
+			resets = <&rstgen RSTN_U0_PWMDAC_APB>;
+			reset-names = "rst-apb";
+			dmas = <&dma 22 1>;
+			dma-names = "tx";
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		i2stx: i2stx@100c0000 {
+			compatible = "snps,designware-i2stx";
+			reg = <0x0 0x100c0000 0x0 0x1000>;
+			interrupt-names = "tx";
+			#sound-dai-cells = <0>;
+			dmas = <&dma 28 1>;
+			dma-names = "rx";
+			status = "disabled";
+		};
+
+		pdm: pdm@100d0000 {
+			compatible = "starfive,jh7110-pdm";
+			reg = <0x0 0x100d0000 0x0 0x1000>;
+			reg-names = "pdm";
+			clocks = <&clkgen JH7110_PDM_CLK_DMIC>,
+				 <&clkgen JH7110_PDM_CLK_APB>,
+				 <&clkgen JH7110_MCLK>,
+				 <&mclk_ext>;
+			clock-names = "pdm_mclk",
+				      "pdm_apb", "clk_mclk",
+				      "mclk_ext";
+			resets = <&rstgen RSTN_U0_PDM_4MIC_DMIC>,
+				 <&rstgen RSTN_U0_PDM_4MIC_APB>;
+			reset-names = "pdm_dmic", "pdm_apb";
+			#sound-dai-cells = <0>;
+		};
+
+		i2srx_mst: i2srx_mst@100e0000 {
+			compatible = "starfive,jh7110-i2srx-master";
+			reg = <0x0 0x100e0000 0x0 0x1000>;
+			clocks = <&clkgen JH7110_APB0>,
+				 <&clkgen JH7110_I2SRX0_3CH_CLK_APB>,
+				 <&clkgen JH7110_I2SRX_3CH_BCLK_MST>,
+				 <&clkgen JH7110_I2SRX_3CH_LRCK_MST>,
+				 <&clkgen JH7110_I2SRX0_3CH_BCLK>,
+				 <&clkgen JH7110_I2SRX0_3CH_LRCK>,
+				 <&clkgen JH7110_MCLK>,
+				 <&mclk_ext>;
+			clock-names = "apb0", "i2srx_apb",
+				      "i2srx_bclk_mst", "i2srx_lrck_mst",
+				      "i2srx_bclk", "i2srx_lrck",
+				      "mclk", "mclk_ext";
+			resets = <&rstgen RSTN_U0_I2SRX_3CH_APB>,
+				 <&rstgen RSTN_U0_I2SRX_3CH_BCLK>;
+			reset-names = "rst_apb_rx", "rst_bclk_rx";
+			dmas = <&dma 24 1>;
+			dma-names = "rx";
+			starfive,sys-syscon = <&sys_syscon 0x18 0x34>;
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		i2srx_3ch: i2srx_3ch@100e0000 {
+			compatible = "starfive,jh7110-i2srx", "snps,designware-i2s";
+			reg = <0x0 0x100e0000 0x0 0x1000>;
+			clocks = <&clkgen JH7110_APB0>,
+				 <&clkgen JH7110_I2SRX0_3CH_CLK_APB>,
+				 <&clkgen JH7110_AUDIO_ROOT>,
+				 <&clkgen JH7110_MCLK_INNER>,
+				 <&clkgen JH7110_I2SRX_3CH_BCLK_MST>,
+				 <&clkgen JH7110_I2SRX_3CH_LRCK_MST>,
+				 <&clkgen JH7110_I2SRX0_3CH_BCLK>,
+				 <&clkgen JH7110_I2SRX0_3CH_LRCK>,
+				 <&clkgen JH7110_MCLK>,
+				 <&mclk_ext>,
+				 <&i2srx_bclk_ext>,
+				 <&i2srx_lrck_ext>;
+			clock-names = "apb0", "3ch-apb",
+				      "audioroot", "mclk-inner",
+				      "bclk_mst", "3ch-lrck",
+				      "rx-bclk", "rx-lrck",
+				      "mclk", "mclk_ext",
+				      "bclk-ext", "lrck-ext";
+			resets = <&rstgen RSTN_U0_I2SRX_3CH_APB>,
+				 <&rstgen RSTN_U0_I2SRX_3CH_BCLK>;
+			dmas = <&dma 24 1>;
+			dma-names = "rx";
+			starfive,sys-syscon = <&sys_syscon 0x18 0x34>;
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		i2stx_4ch0: i2stx_4ch0@120b0000 {
+			compatible = "starfive,jh7110-i2stx-4ch0", "snps,designware-i2s";
+			reg = <0x0 0x120b0000 0x0 0x1000>;
+			clocks = <&clkgen JH7110_MCLK_INNER>,
+				 <&clkgen JH7110_I2STX_4CH0_BCLK_MST>,
+				 <&clkgen JH7110_I2STX_4CH0_LRCK_MST>,
+				 <&clkgen JH7110_MCLK>,
+				 <&clkgen JH7110_I2STX0_4CHBCLK>,
+				 <&clkgen JH7110_I2STX0_4CHLRCK>,
+				 <&clkgen JH7110_I2STX0_4CHCLK_APB>,
+				 <&mclk_ext>;
+			clock-names = "inner", "bclk-mst",
+					"lrck-mst", "mclk",
+					"bclk0", "lrck0",
+					"i2s_apb", "mclk_ext";
+			resets = <&rstgen RSTN_U0_I2STX_4CH_APB>,
+				 <&rstgen RSTN_U0_I2STX_4CH_BCLK>;
+			reset-names = "rst_apb", "rst_bclk";
+			dmas = <&dma 47 1>;
+			dma-names = "tx";
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		i2stx_4ch1: i2stx_4ch1@120c0000 {
+			compatible = "starfive,jh7110-i2stx-4ch1", "snps,designware-i2s";
+			reg = <0x0 0x120c0000 0x0 0x1000>;
+			clocks = <&clkgen JH7110_AUDIO_ROOT>,
+				 <&clkgen JH7110_MCLK_INNER>,
+				 <&clkgen JH7110_I2STX_4CH1_BCLK_MST>,
+				 <&clkgen JH7110_I2STX_4CH1_LRCK_MST>,
+				 <&clkgen JH7110_MCLK>,
+				 <&clkgen JH7110_I2STX1_4CHBCLK>,
+				 <&clkgen JH7110_I2STX1_4CHLRCK>,
+				 <&clkgen JH7110_MCLK_OUT>,
+				 <&clkgen JH7110_APB0>,
+				 <&clkgen JH7110_I2STX1_4CHCLK_APB>,
+				 <&mclk_ext>,
+				 <&i2stx_bclk_ext>,
+				 <&i2stx_lrck_ext>;
+			clock-names = "audroot", "mclk_inner", "bclk_mst",
+				      "lrck_mst", "mclk", "4chbclk",
+				      "4chlrck", "mclk_out",
+				      "apb0", "clk_apb",
+				      "mclk_ext", "bclk_ext", "lrck_ext";
+			resets = <&rstgen RSTN_U1_I2STX_4CH_APB>,
+				 <&rstgen RSTN_U1_I2STX_4CH_BCLK>;
+			dmas = <&dma 48 1>;
+			dma-names = "tx";
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		ptc: pwm@120d0000 {
+			compatible = "starfive,jh7110-pwm";
+			reg = <0x0 0x120d0000 0x0 0x10000>;
+			reg-names = "control";
+			clocks = <&clkgen JH7110_PWM_CLK_APB>;
+			resets = <&rstgen RSTN_U0_PWM_8CH_APB>;
+			starfive,approx-freq = <2000000>;
+			#pwm-cells=<3>;
+			starfive,npwm = <8>;
+			status = "disabled";
+		};
+
+		spdif_transmitter: spdif_transmitter {
+			compatible = "linux,spdif-dit";
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		pwmdac_codec: pwmdac-transmitter {
+			compatible = "starfive,jh7110-pwmdac-dit";
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		dmic_codec: dmic_codec {
+			compatible = "dmic-codec";
+			#sound-dai-cells = <0>;
+			status = "disabled";
+		};
+
+		spi0: spi@10060000 {
+			compatible = "arm,pl022", "arm,primecell";
+			reg = <0x0 0x10060000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SPI0_CLK_APB>;
+			clock-names = "apb_pclk";
+			resets = <&rstgen RSTN_U0_SSP_SPI_APB>;
+			reset-names = "rst_apb";
+			interrupts = <38>;
+			/* shortage of dma channel that not be used */
+			/*dmas = <&dma 14 1>, <&dma 15 1>;*/
+			/*dma-names = "rx","tx";*/
+			arm,primecell-periphid = <0x00041022>;
+			num-cs = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi1: spi@10070000 {
+			compatible = "arm,pl022", "arm,primecell";
+			reg = <0x0 0x10070000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SPI1_CLK_APB>;
+			clock-names = "apb_pclk";
+			resets = <&rstgen RSTN_U1_SSP_SPI_APB>;
+			reset-names = "rst_apb";
+			interrupts = <39>;
+			/* shortage of dma channel that not be used */
+			/*dmas = <&dma 16 1>, <&dma 17 1>;*/
+			/*dma-names = "rx","tx";*/
+			arm,primecell-periphid = <0x00041022>;
+			num-cs = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi2: spi@10080000 {
+			compatible = "arm,pl022", "arm,primecell";
+			reg = <0x0 0x10080000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SPI2_CLK_APB>;
+			clock-names = "apb_pclk";
+			resets = <&rstgen RSTN_U2_SSP_SPI_APB>;
+			reset-names = "rst_apb";
+			interrupts = <40>;
+			/* shortage of dma channel that not be used */
+			/*dmas = <&dma 18 1>, <&dma 19 1>;*/
+			/*dma-names = "rx","tx";*/
+			arm,primecell-periphid = <0x00041022>;
+			num-cs = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi3: spi@12070000 {
+			compatible = "arm,pl022", "arm,primecell";
+			reg = <0x0 0x12070000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SPI3_CLK_APB>;
+			clock-names = "apb_pclk";
+			resets = <&rstgen RSTN_U3_SSP_SPI_APB>;
+			reset-names = "rst_apb";
+			interrupts = <52>;
+			/* shortage of dma channel that not be used */
+			/*dmas = <&dma 39 1>, <&dma 40 1>;*/
+			/*dma-names = "rx","tx";*/
+			arm,primecell-periphid = <0x00041022>;
+			num-cs = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi4: spi@12080000 {
+			compatible = "arm,pl022", "arm,primecell";
+			reg = <0x0 0x12080000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SPI4_CLK_APB>;
+			clock-names = "apb_pclk";
+			resets = <&rstgen RSTN_U4_SSP_SPI_APB>;
+			reset-names = "rst_apb";
+			interrupts = <53>;
+			/* shortage of dma channel that not be used */
+			/*dmas = <&dma 41 1>, <&dma 42 1>;*/
+			/*dma-names = "rx","tx";*/
+			arm,primecell-periphid = <0x00041022>;
+			num-cs = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi5: spi@12090000 {
+			compatible = "arm,pl022", "arm,primecell";
+			reg = <0x0 0x12090000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SPI5_CLK_APB>;
+			clock-names = "apb_pclk";
+			resets = <&rstgen RSTN_U5_SSP_SPI_APB>;
+			reset-names = "rst_apb";
+			interrupts = <54>;
+			/* shortage of dma channel that not be used */
+			/*dmas = <&dma 43 1>, <&dma 44 1>;*/
+			/*dma-names = "rx","tx";*/
+			arm,primecell-periphid = <0x00041022>;
+			num-cs = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi6: spi@120A0000 {
+			compatible = "arm,pl022", "arm,primecell";
+			reg = <0x0 0x120A0000 0x0 0x10000>;
+			clocks = <&clkgen JH7110_SPI6_CLK_APB>;
+			clock-names = "apb_pclk";
+			resets = <&rstgen RSTN_U6_SSP_SPI_APB>;
+			reset-names = "rst_apb";
+			interrupts = <55>;
+			/* shortage of dma channel that not be used */
+			/*dmas = <&dma 45 1>, <&dma 46 1>;*/
+			/*dma-names = "rx","tx";*/
+			arm,primecell-periphid = <0x00041022>;
+			num-cs = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		pcie0: pcie@2B000000 {
+			compatible = "starfive,jh7110-pcie","plda,pci-xpressrich3-axi";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x0 0x2B000000 0x0 0x1000000
+			       0x9 0x40000000 0x0 0x10000000>;
+			reg-names = "reg", "config";
+			device_type = "pci";
+			starfive,stg-syscon = <&stg_syscon 0xc0 0xc4 0x130 0x1b8>;
+			starfive,phyctrl = <&phyctrl0 0x28 0x80>;
+			bus-range = <0x0 0xff>;
+			ranges = <0x82000000  0x0 0x30000000  0x0 0x30000000 0x0 0x08000000>,
+				 <0xc3000000  0x9 0x00000000  0x9 0x00000000 0x0 0x40000000>;
+			msi-parent = <&plic>;
+			interrupts = <56>;
+			interrupt-controller;
+			interrupt-names = "msi";
+			interrupt-parent = <&plic>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &plic 0x1>,
+					<0x0 0x0 0x0 0x2 &plic 0x2>,
+					<0x0 0x0 0x0 0x3 &plic 0x3>,
+					<0x0 0x0 0x0 0x4 &plic 0x4>;
+			resets = <&rstgen RSTN_U0_PLDA_PCIE_AXI_MST0>,
+				 <&rstgen RSTN_U0_PLDA_PCIE_AXI_SLV0>,
+				 <&rstgen RSTN_U0_PLDA_PCIE_AXI_SLV>,
+				 <&rstgen RSTN_U0_PLDA_PCIE_BRG>,
+				 <&rstgen RSTN_U0_PLDA_PCIE_CORE>,
+				 <&rstgen RSTN_U0_PLDA_PCIE_APB>;
+			reset-names = "rst_mst0", "rst_slv0", "rst_slv",
+				      "rst_brg", "rst_core", "rst_apb";
+			clocks = <&clkgen JH7110_NOC_BUS_CLK_STG_AXI>,
+				 <&clkgen JH7110_PCIE0_CLK_TL>,
+				 <&clkgen JH7110_PCIE0_CLK_AXI_MST0>,
+				 <&clkgen JH7110_PCIE0_CLK_APB>;
+			clock-names = "noc", "tl", "axi_mst0", "apb";
+			status = "disabled";
+		};
+
+		pcie1: pcie@2C000000 {
+			compatible = "starfive,jh7110-pcie","plda,pci-xpressrich3-axi";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x0 0x2C000000 0x0 0x1000000
+			       0x9 0xc0000000 0x0 0x10000000>;
+			reg-names = "reg", "config";
+			device_type = "pci";
+			starfive,stg-syscon = <&stg_syscon 0x270 0x274 0x2e0 0x368>;
+			starfive,phyctrl = <&phyctrl1 0x28 0x80>;
+			bus-range = <0x0 0xff>;
+			ranges = <0x82000000  0x0 0x38000000  0x0 0x38000000 0x0 0x08000000>,
+				 <0xc3000000  0x9 0x80000000  0x9 0x80000000 0x0 0x40000000>;
+			msi-parent = <&plic>;
+			interrupts = <57>;
+			interrupt-controller;
+			interrupt-names = "msi";
+			interrupt-parent = <&plic>;
+			interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+			interrupt-map = <0x0 0x0 0x0 0x1 &plic 0x1>,
+					<0x0 0x0 0x0 0x2 &plic 0x2>,
+					<0x0 0x0 0x0 0x3 &plic 0x3>,
+					<0x0 0x0 0x0 0x4 &plic 0x4>;
+			resets = <&rstgen RSTN_U1_PLDA_PCIE_AXI_MST0>,
+				 <&rstgen RSTN_U1_PLDA_PCIE_AXI_SLV0>,
+				 <&rstgen RSTN_U1_PLDA_PCIE_AXI_SLV>,
+				 <&rstgen RSTN_U1_PLDA_PCIE_BRG>,
+				 <&rstgen RSTN_U1_PLDA_PCIE_CORE>,
+				 <&rstgen RSTN_U1_PLDA_PCIE_APB>;
+			reset-names = "rst_mst0", "rst_slv0", "rst_slv",
+				      "rst_brg", "rst_core", "rst_apb";
+			clocks = <&clkgen JH7110_NOC_BUS_CLK_STG_AXI>,
+				 <&clkgen JH7110_PCIE1_CLK_TL>,
+				 <&clkgen JH7110_PCIE1_CLK_AXI_MST0>,
+				 <&clkgen JH7110_PCIE1_CLK_APB>;
+			clock-names = "noc", "tl", "axi_mst0", "apb";
+			status = "disabled";
+		};
+
+		mailbox_contrl0: mailbox@0 {
+			compatible = "starfive,mail_box";
+			reg = <0x0 0x13060000 0x0 0x0001000>;
+			clocks = <&clkgen JH7110_MAILBOX_CLK_APB>;
+			clock-names = "clk_apb";
+			resets = <&rstgen RSTN_U0_MAILBOX_RRESETN>;
+			reset-names = "mbx_rre";
+			interrupts = <26 27>;
+			#mbox-cells = <2>;
+			status = "disabled";
+		};
+
+		mailbox_client0: mailbox_client@0 {
+			compatible = "starfive,mailbox-test";
+			mbox-names = "rx", "tx";
+			mboxes = <&mailbox_contrl0 0 1>,<&mailbox_contrl0 1 0>;
+			status = "disabled";
+		};
+
+		display: display-subsystem {
+			compatible = "starfive,jh7110-display","verisilicon,display-subsystem";
+			ports = <&dc_out_dpi0>;
+			status = "disabled";
+		};
+
+		dssctrl: dssctrl@295B0000 {
+			compatible = "starfive,jh7110-dssctrl","verisilicon,dss-ctrl", "syscon";
+			reg = <0 0x295B0000 0 0x90>;
+		};
+
+		tda988x_pin: tda988x_pin {
+			compatible = "starfive,tda998x_rgb_pin";
+			status = "disabled";
+		};
+
+		rgb_output: rgb-output {
+			compatible = "starfive,jh7110-rgb_output","verisilicon,rgb-encoder";
+			//verisilicon,dss-syscon = <&dssctrl>;
+			//verisilicon,mux-mask = <0x70 0x380>;
+			//verisilicon,mux-val = <0x40 0x280>;
+			status = "disabled";
+		};
+
+		dc8200: dc8200@29400000 {
+			compatible = "starfive,jh7110-dc8200","verisilicon,dc8200";
+			verisilicon,dss-syscon = <&dssctrl>;//20220624 panel syscon
+			reg = <0x0 0x29400000 0x0 0x100>,
+			      <0x0 0x29400800 0x0 0x2000>,
+			      <0x0 0x17030000 0x0 0x1000>;
+			interrupts = <95>;
+			status = "disabled";
+			clocks = <&clkgen JH7110_NOC_BUS_CLK_DISP_AXI>,
+			<&clkgen JH7110_VOUT_SRC>,
+			<&clkgen JH7110_VOUT_TOP_CLK_VOUT_AXI>,
+			<&clkgen JH7110_VOUT_TOP_CLK_VOUT_AHB>,
+			<&clkvout JH7110_U0_DC8200_CLK_PIX0>,
+			<&clkvout JH7110_U0_DC8200_CLK_PIX1>,
+			<&clkvout JH7110_U0_DC8200_CLK_AXI>,
+			<&clkvout JH7110_U0_DC8200_CLK_CORE>,
+			<&clkvout JH7110_U0_DC8200_CLK_AHB>,
+			<&clkgen JH7110_VOUT_TOP_CLK_VOUT_AXI>,
+			<&clkvout JH7110_DOM_VOUT_TOP_LCD_CLK>,
+			<&hdmitx0_pixelclk>,
+			<&clkvout JH7110_DC8200_PIX0>,
+			<&clkvout JH7110_U0_DC8200_CLK_PIX0_OUT>,
+			<&clkvout JH7110_U0_DC8200_CLK_PIX1_OUT>;
+			clock-names = "noc_disp","vout_src",
+			   "top_vout_axi","top_vout_ahb",
+			   "pix_clk","vout_pix1",
+			   "axi_clk","core_clk","vout_ahb",
+			   "vout_top_axi","vout_top_lcd","hdmitx0_pixelclk","dc8200_pix0",
+			   "dc8200_pix0_out","dc8200_pix1_out";
+			resets = <&rstgen RSTN_U0_DOM_VOUT_TOP_SRC>,
+				 <&rstgen RSTN_U0_DC8200_AXI>,
+				 <&rstgen RSTN_U0_DC8200_AHB>,
+				 <&rstgen RSTN_U0_DC8200_CORE>,
+				 <&rstgen RSTN_U0_NOC_BUS_DISP_AXI_N>;
+			reset-names = "rst_vout_src","rst_axi","rst_ahb","rst_core",
+					"rst_noc_disp";
+		};
+
+		dsi_output: dsi-output {
+			compatible = "starfive,jh7110-display-encoder","verisilicon,dsi-encoder";
+			status = "disabled";
+		};
+
+		mipi_dphy: mipi-dphy@295e0000{
+			compatible = "starfive,jh7110-mipi-dphy-tx","m31,mipi-dphy-tx";
+			reg = <0x0 0x295e0000 0x0 0x10000>;
+			clocks = <&clkvout JH7110_U0_MIPITX_DPHY_CLK_TXESC>;
+			clock-names = "dphy_txesc";
+			resets = <&rstgen RSTN_U0_MIPITX_DPHY_SYS>,
+				 <&rstgen RSTN_U0_MIPITX_DPHY_TXBYTEHS>;
+			reset-names = "dphy_sys", "dphy_txbytehs";
+			#phy-cells = <0>;
+			status = "disabled";
+		};
+
+		 mipi_dsi: mipi@295d0000 {
+			compatible = "starfive,jh7110-mipi_dsi","cdns,dsi";
+			reg = <0x0 0x295d0000 0x0 0x10000>;
+			interrupts = <98>;
+			reg-names = "dsi";
+			clocks = <&clkvout JH7110_U0_CDNS_DSITX_CLK_SYS>,
+				 <&clkvout JH7110_U0_CDNS_DSITX_CLK_APB>,
+				 <&clkvout JH7110_U0_CDNS_DSITX_CLK_TXESC>,
+				 <&clkvout JH7110_U0_CDNS_DSITX_CLK_DPI>;
+			clock-names = "sys", "apb", "txesc", "dpi";
+			resets = <&rstgen RSTN_U0_CDNS_DSITX_DPI>,
+				 <&rstgen RSTN_U0_CDNS_DSITX_APB>,
+				 <&rstgen RSTN_U0_CDNS_DSITX_RXESC>,
+				 <&rstgen RSTN_U0_CDNS_DSITX_SYS>,
+				 <&rstgen RSTN_U0_CDNS_DSITX_TXBYTEHS>,
+				 <&rstgen RSTN_U0_CDNS_DSITX_TXESC>;
+			reset-names = "dsi_dpi", "dsi_apb", "dsi_rxesc",
+					"dsi_sys", "dsi_txbytehs", "dsi_txesc";
+			phys = <&mipi_dphy>;
+			phy-names = "dphy";
+			status = "disabled";
+
+		};
+
+		hdmi: hdmi@29590000 {
+			compatible = "starfive,jh7110-hdmi","inno,hdmi";
+			reg = <0x0 0x29590000 0x0 0x4000>;
+			interrupts = <99>;
+			/*interrupts = <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;*/
+			/*clocks = <&cru  PCLK_HDMI>;*/
+			/*clock-names = "pclk";*/
+			/*pinctrl-names = "default";*/
+			/*pinctrl-0 = <&hdmi_ctl>;*/
+			status = "disabled";
+			clocks = <&clkvout JH7110_U0_HDMI_TX_CLK_SYS>,
+				 <&clkvout JH7110_U0_HDMI_TX_CLK_MCLK>,
+				 <&clkvout JH7110_U0_HDMI_TX_CLK_BCLK>,
+				 <&hdmitx0_pixelclk>;
+			clock-names = "sysclk", "mclk","bclk","pclk";
+			resets = <&rstgen RSTN_U0_HDMI_TX_HDMI>;
+			reset-names = "hdmi_tx";
+			#sound-dai-cells = <0>;
+		};
+
+		sound0: snd-card0 {
+			compatible = "simple-audio-card";
+			simple-audio-card,name = "Starfive-AC108-Sound-Card";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sound1: snd-card1 {
+			compatible = "simple-audio-card";
+			simple-audio-card,name = "Starfive-HDMI-Sound-Card";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sound2: snd-card2 {
+			compatible = "simple-audio-card";
+			simple-audio-card,name = "Starfive-PDM-Sound-Card";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sound3: snd-card3 {
+			compatible = "simple-audio-card";
+			simple-audio-card,name = "Starfive-PWMDAC-Sound-Card";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sound4: snd-card4 {
+			compatible = "simple-audio-card";
+			simple-audio-card,name = "Starfive-SPDIF-Sound-Card";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sound5: snd-card5 {
+			compatible = "simple-audio-card";
+			simple-audio-card,name = "Starfive-TDM-Sound-Card";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sound6: snd-card6 {
+			compatible = "simple-audio-card";
+			simple-audio-card,name = "Starfive-WM8960-Sound-Card";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		co_process: e24@0 {
+			compatible = "starfive,e24";
+			reg = <0x0 0xc0110000 0x0 0x00001000>,
+				<0x0 0xc0111000 0x0 0x0001f000>;
+			reg-names = "ecmd", "espace";
+			clocks = <&clkgen JH7110_E2_RTC_CLK>,
+				 <&clkgen JH7110_E2_CLK_CORE>,
+				 <&clkgen JH7110_E2_CLK_DBG>;
+			clock-names = "clk_rtc", "clk_core", "clk_dbg";
+			resets = <&rstgen RSTN_U0_E24_CORE>;
+			reset-names = "e24_core";
+			starfive,stg-syscon = <&stg_syscon>;
+			interrupt-parent = <&plic>;
+			firmware-name = "e24_elf";
+			irq-mode = <1>;
+			mbox-names = "tx", "rx";
+			mboxes = <&mailbox_contrl0 0 2>,<&mailbox_contrl0 2 0>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0xc0000000 0x0 0xc0000000 0x200000>;
+			status = "disabled";
+			dsp@0 {};
+		};
+
+		xrp: xrp@0 {
+			compatible = "cdns,xrp";
+			reg = <0x0  0x10230000 0x0 0x00010000
+				0x0  0x10240000 0x0 0x00010000>;
+			memory-region = <&xrp_reserved>;
+			clocks = <&clkgen JH7110_HIFI4_CLK_CORE>;
+			clock-names = "core_clk";
+			resets = <&rstgen RSTN_U0_HIFI4_CORE>,
+				 <&rstgen RSTN_U0_HIFI4_AXI>;
+			reset-names = "rst_core","rst_axi";
+			starfive,stg-syscon = <&stg_syscon>;
+			firmware-name = "hifi4_elf";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x40000000 0x0 0x20000000 0x040000
+				0xf0000000 0x0 0xf0000000 0x03000000>;
+			status = "disabled";
+			dsp@0 {
+			};
+		};
+
+		starfive_cpufreq: starfive,jh7110-cpufreq {
+			compatible = "starfive,jh7110-cpufreq";
+			clocks = <&clkgen JH7110_CPU_CORE>;
+			clock-names = "cpu_clk";
+		};
+	};
+};
diff --git a/arch/riscv/configs/defconfig b/arch/riscv/configs/defconfig
index a20c51dadef2..8c3d1e451703 100644
--- a/arch/riscv/configs/defconfig
+++ b/arch/riscv/configs/defconfig
@@ -16,11 +16,7 @@ CONFIG_EXPERT=y
 CONFIG_BPF_SYSCALL=y
 CONFIG_SOC_SIFIVE=y
 CONFIG_SOC_VIRT=y
-CONFIG_SOC_MICROCHIP_POLARFIRE=y
 CONFIG_SMP=y
-CONFIG_HOTPLUG_CPU=y
-CONFIG_VIRTUALIZATION=y
-CONFIG_KVM=y
 CONFIG_JUMP_LABEL=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
@@ -71,6 +67,7 @@ CONFIG_SPI_SIFIVE=y
 CONFIG_GPIOLIB=y
 CONFIG_GPIO_SIFIVE=y
 # CONFIG_PTP_1588_CLOCK is not set
+CONFIG_POWER_RESET=y
 CONFIG_DRM=y
 CONFIG_DRM_RADEON=y
 CONFIG_DRM_VIRTIO_GPU=y
@@ -85,9 +82,6 @@ CONFIG_USB_OHCI_HCD_PLATFORM=y
 CONFIG_USB_STORAGE=y
 CONFIG_USB_UAS=y
 CONFIG_MMC=y
-CONFIG_MMC_SDHCI=y
-CONFIG_MMC_SDHCI_PLTFM=y
-CONFIG_MMC_SDHCI_CADENCE=y
 CONFIG_MMC_SPI=y
 CONFIG_RTC_CLASS=y
 CONFIG_VIRTIO_PCI=y
@@ -103,7 +97,6 @@ CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_TMPFS=y
 CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_HUGETLBFS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V4=y
 CONFIG_NFS_V4_1=y
@@ -114,8 +107,29 @@ CONFIG_CRYPTO_USER_API_HASH=y
 CONFIG_CRYPTO_DEV_VIRTIO=y
 CONFIG_PRINTK_TIME=y
 CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_SCHED_STACK_END_CHECK=y
+CONFIG_DEBUG_VM=y
+CONFIG_DEBUG_VM_PGFLAGS=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_PER_CPU_MAPS=y
 CONFIG_SOFTLOCKUP_DETECTOR=y
 CONFIG_WQ_WATCHDOG=y
+CONFIG_DEBUG_TIMEKEEPING=y
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_RWSEMS=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
 CONFIG_STACKTRACE=y
+CONFIG_DEBUG_LIST=y
+CONFIG_DEBUG_PLIST=y
+CONFIG_DEBUG_SG=y
 # CONFIG_RCU_TRACE is not set
+CONFIG_RCU_EQS_DEBUG=y
+CONFIG_DEBUG_BLOCK_EXT_DEVT=y
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
+CONFIG_MEMTEST=y
+# CONFIG_SYSFS_SYSCALL is not set
 CONFIG_EFI=y
diff --git a/arch/riscv/configs/starfive_jh7110_defconfig b/arch/riscv/configs/starfive_jh7110_defconfig
new file mode 100755
index 000000000000..d31249f1d396
--- /dev/null
+++ b/arch/riscv/configs/starfive_jh7110_defconfig
@@ -0,0 +1,284 @@
+CONFIG_COMPILE_TEST=y
+CONFIG_DEFAULT_HOSTNAME="StarFive"
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_USELIB=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SOC_STARFIVE=y
+CONFIG_SMP=y
+CONFIG_HZ_100=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION="PARTLABEL=hibernation"
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_ENERGY_MODEL=y
+CONFIG_CPU_IDLE=y
+CONFIG_RISCV_SBI_CPUIDLE=y
+# CONFIG_SECCOMP is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_PAGE_REPORTING=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK_ACCT=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_TABLES=y
+CONFIG_NFT_CT=y
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_IPCOMP=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_DUP_IPV4=y
+CONFIG_NFT_FIB_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NETLINK_DIAG=y
+CONFIG_CAN=y
+CONFIG_IPMS_CAN=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+# CONFIG_PCIEASPM is not set
+CONFIG_PCIE_PLDA=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_OF_CONFIGFS=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_SCSI_VIRTIO=y
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_NETDEVICES=y
+CONFIG_VIRTIO_NET=y
+CONFIG_R8169=y
+CONFIG_STMMAC_ETH=y
+CONFIG_STMMAC_SELFTESTS=y
+CONFIG_DWMAC_STARFIVE_PLAT=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_MOTORCOMM_PHY=y
+CONFIG_IWLWIFI=y
+CONFIG_IWLDVM=y
+CONFIG_IWLMVM=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_TINKER_FT5406=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=6
+CONFIG_SERIAL_8250_RUNTIME_UARTS=6
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_SERIAL_SIFIVE=y
+CONFIG_SERIAL_SIFIVE_CONSOLE=y
+CONFIG_HVC_RISCV_SBI=y
+CONFIG_TTY_PRINTK=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_STARFIVE=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_SPI_PL022_STARFIVE=y
+CONFIG_SPI_SIFIVE=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_STARFIVE_JH7110=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_SENSORS_SFCTEMP=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_CPU_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_SYSFS=y
+CONFIG_STARFIVE_WATCHDOG=y
+# CONFIG_ABX500_CORE is not set
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_AXP15060=y
+CONFIG_REGULATOR_STARFIVE_JH7110=y
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_STF_VIN=y
+CONFIG_VIN_SENSOR_SC2235=y
+CONFIG_VIN_SENSOR_OV4689=y
+CONFIG_VIN_SENSOR_IMX219=y
+CONFIG_DRM_I2C_NXP_TDA998X=y
+CONFIG_DRM_VERISILICON=y
+CONFIG_STARFIVE_INNO_HDMI=y
+CONFIG_STARFIVE_DSI=y
+CONFIG_DRM_IMG_ROGUE=y
+CONFIG_DRM_LEGACY=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_STARFIVE=y
+CONFIG_SND_SOC_STARFIVE_PWMDAC=y
+CONFIG_SND_SOC_STARFIVE_PDM=y
+CONFIG_SND_SOC_STARFIVE_TDM=y
+CONFIG_SND_SOC_STARFIVE_SPDIF=y
+CONFIG_SND_SOC_STARFIVE_SPDIF_PCM=y
+CONFIG_SND_SOC_AC108=y
+CONFIG_SND_SOC_SPDIF=y
+CONFIG_SND_SOC_WM8960=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_UAS=y
+CONFIG_USB_CDNS3=y
+CONFIG_USB_CDNS3_GADGET=y
+CONFIG_USB_CDNS3_HOST=y
+CONFIG_USB_CDNS3_STARFIVE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_MMC=y
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+CONFIG_MMC_SPI=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_STARFIVE=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_STARFIVE=y
+CONFIG_RTC_DRV_GOLDFISH=y
+CONFIG_DMADEVICES=y
+CONFIG_DW_AXI_DMAC=y
+CONFIG_DMATEST=y
+CONFIG_GOLDFISH=y
+CONFIG_CLK_STARFIVE_JH7110_PLL=y
+CONFIG_STARFIVE_TIMER=y
+CONFIG_MAILBOX=y
+CONFIG_RPMSG_CHAR=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_STARFIVE_PMU=y
+CONFIG_PWM=y
+CONFIG_PWM_STARFIVE_PTC=y
+CONFIG_PHY_M31_DPHY_RX0=y
+CONFIG_RAS=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_VIRTIO_FS=y
+CONFIG_OVERLAY_FS=y
+CONFIG_OVERLAY_FS_INDEX=y
+CONFIG_OVERLAY_FS_XINO_AUTO=y
+CONFIG_OVERLAY_FS_METACOPY=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_ECDH=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+CONFIG_CRYPTO_USER_API_AKCIPHER=y
+CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_CRYPTO_DEV_JH7110_ENCRYPT=y
+CONFIG_DMA_CMA=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_FS=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+CONFIG_WQ_WATCHDOG=y
+CONFIG_DEBUG_TIMEKEEPING=y
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_RWSEMS=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_STACKTRACE=y
+CONFIG_DEBUG_LIST=y
+CONFIG_DEBUG_PLIST=y
+CONFIG_DEBUG_SG=y
+CONFIG_RCU_EQS_DEBUG=y
+CONFIG_MEMTEST=y
diff --git a/arch/riscv/configs/starfive_visionfive2_defconfig b/arch/riscv/configs/starfive_visionfive2_defconfig
new file mode 100755
index 000000000000..f3fd3ec329f6
--- /dev/null
+++ b/arch/riscv/configs/starfive_visionfive2_defconfig
@@ -0,0 +1,287 @@
+CONFIG_DEFAULT_HOSTNAME="StarFive"
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_USELIB=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_BPF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_PERF_EVENTS=y
+CONFIG_SOC_STARFIVE=y
+CONFIG_SMP=y
+CONFIG_HZ_100=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION="PARTLABEL=hibernation"
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_CPU_IDLE=y
+CONFIG_RISCV_SBI_CPUIDLE=y
+# CONFIG_SECCOMP is not set
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_PAGE_REPORTING=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_NETLINK_ACCT=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_TABLES=y
+CONFIG_NFT_CT=y
+CONFIG_NFT_COMPAT=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_IPCOMP=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+CONFIG_NETFILTER_XT_MATCH_SOCKET=y
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_U32=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_DUP_IPV4=y
+CONFIG_NFT_FIB_IPV4=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NETLINK_DIAG=y
+CONFIG_CAN=y
+CONFIG_IPMS_CAN=y
+CONFIG_CFG80211=y
+CONFIG_MAC80211=y
+CONFIG_NET_9P=y
+CONFIG_NET_9P_VIRTIO=y
+CONFIG_PCI=y
+# CONFIG_PCIEASPM is not set
+CONFIG_PCIE_PLDA=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_OF_CONFIGFS=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_EEPROM_AT24=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_SCSI_VIRTIO=y
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_NETDEVICES=y
+CONFIG_VIRTIO_NET=y
+CONFIG_R8169=y
+CONFIG_STMMAC_ETH=y
+CONFIG_STMMAC_SELFTESTS=y
+CONFIG_DWMAC_DWC_QOS_ETH=y
+CONFIG_DWMAC_STARFIVE_PLAT=y
+CONFIG_MARVELL_PHY=y
+CONFIG_MICREL_PHY=y
+CONFIG_MOTORCOMM_PHY=y
+CONFIG_IWLWIFI=y
+CONFIG_IWLDVM=y
+CONFIG_IWLMVM=y
+CONFIG_HOSTAP=y
+# CONFIG_RTL_CARDS is not set
+CONFIG_USB_WIFI_ECR6600U=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_GOODIX=y
+CONFIG_TOUCHSCREEN_TINKER_FT5406=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=6
+CONFIG_SERIAL_8250_RUNTIME_UARTS=6
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_SERIAL_SIFIVE=y
+CONFIG_SERIAL_SIFIVE_CONSOLE=y
+CONFIG_HVC_RISCV_SBI=y
+CONFIG_TTY_PRINTK=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_STARFIVE=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_SPI=y
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_SPI_PL022_STARFIVE=y
+CONFIG_SPI_SIFIVE=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_STARFIVE_JH7110=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_RESET_GPIO_RESTART=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+CONFIG_SENSORS_SFCTEMP=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_CPU_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_SYSFS=y
+CONFIG_STARFIVE_WATCHDOG=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_AXP15060=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_STF_VIN=y
+CONFIG_VIN_SENSOR_IMX219=y
+CONFIG_DRM_I2C_NXP_TDA998X=y
+CONFIG_DRM_PANEL_JADARD_JD9365DA_H3=y
+CONFIG_DRM_VERISILICON=y
+CONFIG_STARFIVE_INNO_HDMI=y
+CONFIG_STARFIVE_DSI=y
+CONFIG_DRM_IMG_ROGUE=y
+CONFIG_DRM_LEGACY=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_SOC=y
+CONFIG_SND_DESIGNWARE_I2S=y
+CONFIG_SND_SOC_STARFIVE=y
+CONFIG_SND_SOC_STARFIVE_PWMDAC=y
+CONFIG_SND_SOC_STARFIVE_I2S=y
+CONFIG_SND_SOC_AC108=y
+CONFIG_SND_SOC_WM8960=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_USB=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_UAS=y
+CONFIG_USB_CDNS3=y
+CONFIG_USB_CDNS3_GADGET=y
+CONFIG_USB_CDNS3_HOST=y
+CONFIG_USB_CDNS3_STARFIVE=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_MMC=y
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_DWCMSHC=y
+CONFIG_MMC_SPI=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_STARFIVE=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_STARFIVE=y
+CONFIG_RTC_DRV_GOLDFISH=y
+CONFIG_DMADEVICES=y
+CONFIG_DW_AXI_DMAC=y
+CONFIG_DMATEST=y
+CONFIG_GOLDFISH=y
+CONFIG_CLK_STARFIVE_JH7110_PLL=y
+CONFIG_STARFIVE_TIMER=y
+CONFIG_MAILBOX=y
+CONFIG_RPMSG_CHAR=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_STARFIVE_PMU=y
+CONFIG_PWM=y
+CONFIG_PWM_STARFIVE_PTC=y
+CONFIG_PHY_M31_DPHY_RX0=y
+CONFIG_RAS=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_VIRTIO_FS=y
+CONFIG_OVERLAY_FS=y
+CONFIG_OVERLAY_FS_INDEX=y
+CONFIG_OVERLAY_FS_XINO_AUTO=y
+CONFIG_OVERLAY_FS_METACOPY=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_EXFAT_FS=y
+CONFIG_NTFS_FS=y
+CONFIG_NTFS_RW=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_ECDH=y
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+CONFIG_CRYPTO_USER_API_AKCIPHER=y
+CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_CRYPTO_DEV_JH7110_ENCRYPT=y
+CONFIG_DMA_CMA=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_FS=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+CONFIG_WQ_WATCHDOG=y
+CONFIG_DEBUG_TIMEKEEPING=y
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_RWSEMS=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_STACKTRACE=y
+CONFIG_DEBUG_LIST=y
+CONFIG_DEBUG_PLIST=y
+CONFIG_DEBUG_SG=y
+CONFIG_RCU_EQS_DEBUG=y
+CONFIG_MEMTEST=y
diff --git a/drivers/Kconfig b/drivers/Kconfig
index b1b3d958f065..6182f144ea29 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -240,4 +240,6 @@ source "drivers/most/Kconfig"
 
 source "drivers/roh/Kconfig"
 
+source "drivers/cpufreq/Kconfig"
+
 endmenu
diff --git a/drivers/char/hw_random/Kconfig b/drivers/char/hw_random/Kconfig
index 53e63d68ffb1..994105828610 100644
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@ -550,6 +550,17 @@ config HW_RANDOM_XIPHERA
 	  To compile this driver as a module, choose M here: the
 	  module will be called xiphera-trng.
 
+config HW_RANDOM_STARFIVE
+	tristate "Starfive True Random Number Generator support"
+	depends on SOC_STARFIVE
+	depends on HW_RANDOM
+	help
+	  This driver provides kernel-side support for the Random Number
+	  Generator hardware found on Starfive SoC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called starfive-trng.
+
 endif # HW_RANDOM
 
 config UML_RANDOM
diff --git a/drivers/char/hw_random/Makefile b/drivers/char/hw_random/Makefile
index 67377d9e10f7..e6357933c748 100644
--- a/drivers/char/hw_random/Makefile
+++ b/drivers/char/hw_random/Makefile
@@ -47,3 +47,4 @@ obj-$(CONFIG_HW_RANDOM_OPTEE) += optee-rng.o
 obj-$(CONFIG_HW_RANDOM_NPCM) += npcm-rng.o
 obj-$(CONFIG_HW_RANDOM_CCTRNG) += cctrng.o
 obj-$(CONFIG_HW_RANDOM_XIPHERA) += xiphera-trng.o
+obj-$(CONFIG_HW_RANDOM_STARFIVE) += starfive-trng.o
diff --git a/drivers/char/hw_random/starfive-trng.c b/drivers/char/hw_random/starfive-trng.c
new file mode 100644
index 000000000000..4c7d60109385
--- /dev/null
+++ b/drivers/char/hw_random/starfive-trng.c
@@ -0,0 +1,415 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * TRNG driver for the StarFive SoC
+ *
+ * Copyright (C) 2022 StarFive Technology Co.
+ */
+
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/hw_random.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/random.h>
+#include <linux/reset.h>
+
+/* trng register offset */
+#define STARFIVE_CTRL			0x00
+#define STARFIVE_STAT			0x04
+#define STARFIVE_MODE			0x08
+#define STARFIVE_SMODE			0x0C
+#define STARFIVE_IE			0x10
+#define STARFIVE_ISTAT			0x14
+#define STARFIVE_RAND0			0x20
+#define STARFIVE_RAND1			0x24
+#define STARFIVE_RAND2			0x28
+#define STARFIVE_RAND3			0x2C
+#define STARFIVE_RAND4			0x30
+#define STARFIVE_RAND5			0x34
+#define STARFIVE_RAND6			0x38
+#define STARFIVE_RAND7			0x3C
+#define STARFIVE_AUTO_RQSTS		0x60
+#define STARFIVE_AUTO_AGE		0x64
+
+/* CTRL CMD */
+#define STARFIVE_CTRL_EXEC_NOP		(0x0)
+#define STARFIVE_CTRL_GENE_RANDNUM	(0x1)
+#define STARFIVE_CTRL_EXEC_RANDRESEED	(0x2)
+
+/* STAT */
+#define STARFIVE_STAT_NONCE_MODE	BIT(2)
+#define STARFIVE_STAT_R256		BIT(3)
+#define STARFIVE_STAT_MISSION_MODE	BIT(8)
+#define STARFIVE_STAT_SEEDED		BIT(9)
+#define STARFIVE_STAT_LAST_RESEED(x)	((x) << 16)
+#define STARFIVE_STAT_SRVC_RQST		BIT(27)
+#define STARFIVE_STAT_RAND_GENERATING	BIT(30)
+#define STARFIVE_STAT_RAND_SEEDING	BIT(31)
+
+/* MODE */
+#define STARFIVE_MODE_R256		BIT(3)
+
+/* SMODE */
+#define STARFIVE_SMODE_NONCE_MODE	BIT(2)
+#define STARFIVE_SMODE_MISSION_MODE	BIT(8)
+#define STARFIVE_SMODE_MAX_REJECTS(x)	((x) << 16)
+
+/* IE */
+#define STARFIVE_IE_RAND_RDY_EN		BIT(0)
+#define STARFIVE_IE_SEED_DONE_EN	BIT(1)
+#define STARFIVE_IE_LFSR_LOCKUP_EN	BIT(4)
+#define STARFIVE_IE_GLBL_EN		BIT(31)
+
+#define STARFIVE_IE_ALL			(STARFIVE_IE_GLBL_EN | \
+					 STARFIVE_IE_RAND_RDY_EN | \
+					 STARFIVE_IE_SEED_DONE_EN | \
+					 STARFIVE_IE_LFSR_LOCKUP_EN)
+
+/* ISTAT */
+#define STARFIVE_ISTAT_RAND_RDY		BIT(0)
+#define STARFIVE_ISTAT_SEED_DONE	BIT(1)
+#define STARFIVE_ISTAT_LFSR_LOCKUP	BIT(4)
+
+#define STARFIVE_RAND_LEN		sizeof(u32)
+
+#define to_trng(p)			container_of(p, struct starfive_trng, rng)
+
+enum reseed {
+	RANDOM_RESEED,
+	NONCE_RESEED,
+};
+
+enum mode {
+	PRNG_128BIT,
+	PRNG_256BIT,
+};
+
+struct starfive_trng {
+	struct device		*dev;
+	void __iomem		*base;
+	struct clk		*hclk;
+	struct clk		*ahb;
+	struct reset_control	*rst;
+	struct hwrng		rng;
+	struct completion	random_done;
+	struct completion	reseed_done;
+	u32			mode;
+	u32			mission;
+	u32			reseed;
+};
+
+static u16 autoreq;
+module_param(autoreq, ushort, 0);
+MODULE_PARM_DESC(autoreq, "Auto-reseeding after random number requests by host reaches specified counter:\n"
+				" 0 - disable counter\n"
+				" other - reload value for internal counter");
+
+static u16 autoage;
+module_param(autoage, ushort, 0);
+MODULE_PARM_DESC(autoage, "Auto-reseeding after specified timer countdowns to 0:\n"
+				" 0 - disable timer\n"
+				" other - reload value for internal timer");
+
+static inline int starfive_trng_wait_idle(struct starfive_trng *trng)
+{
+	u32 stat;
+
+	return readl_relaxed_poll_timeout(trng->base + STARFIVE_STAT, stat,
+					  !(stat & (STARFIVE_STAT_RAND_GENERATING |
+						    STARFIVE_STAT_RAND_SEEDING)),
+					  10, 100000);
+}
+
+static inline int starfive_trng_random_done(struct starfive_trng *trng)
+{
+	return wait_for_completion_timeout(&trng->random_done, 3000);
+}
+
+static inline int starfive_trng_reseed_done(struct starfive_trng *trng)
+{
+	return wait_for_completion_timeout(&trng->reseed_done, 3000);
+}
+
+static inline void starfive_trng_irq_mask_clear(struct starfive_trng *trng)
+{
+	/* clear register: ISTAT */
+	u32 data = readl(trng->base + STARFIVE_ISTAT);
+
+	writel(data, trng->base + STARFIVE_ISTAT);
+}
+
+static int starfive_trng_cmd(struct starfive_trng *trng, u32 cmd)
+{
+	int ret;
+
+	ret = starfive_trng_wait_idle(trng);
+	if (ret)
+		return -ETIMEDOUT;
+
+	switch (cmd) {
+	case STARFIVE_CTRL_EXEC_NOP:
+		writel(cmd, trng->base + STARFIVE_CTRL);
+		break;
+	case STARFIVE_CTRL_GENE_RANDNUM:
+		reinit_completion(&trng->random_done);
+		writel(cmd, trng->base + STARFIVE_CTRL);
+		ret = starfive_trng_random_done(trng);
+		if (!ret)
+			return -ETIMEDOUT;
+		break;
+	case STARFIVE_CTRL_EXEC_RANDRESEED:
+		reinit_completion(&trng->reseed_done);
+		writel(cmd, trng->base + STARFIVE_CTRL);
+		ret = starfive_trng_reseed_done(trng);
+		if (!ret)
+			return -ETIMEDOUT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int starfive_trng_init(struct hwrng *rng)
+{
+	struct starfive_trng *trng = to_trng(rng);
+	u32 mode, smode, intr = 0;
+
+	/* disable Auto Request/Age register */
+	writel(autoage, trng->base + STARFIVE_AUTO_AGE);
+	writel(autoreq, trng->base + STARFIVE_AUTO_RQSTS);
+
+	/* clear register: ISTAT */
+	starfive_trng_irq_mask_clear(trng);
+
+	/* set smode/mode */
+	mode  = readl(trng->base + STARFIVE_MODE);
+	smode = readl(trng->base + STARFIVE_SMODE);
+
+	switch (trng->mode) {
+	case PRNG_128BIT:
+		mode &= ~STARFIVE_MODE_R256;
+		break;
+	case PRNG_256BIT:
+		mode |= STARFIVE_MODE_R256;
+		break;
+	default:
+		mode |= STARFIVE_MODE_R256;
+		break;
+	}
+
+	intr |= STARFIVE_IE_ALL;
+	writel(intr, trng->base + STARFIVE_IE);
+	writel(mode, trng->base + STARFIVE_MODE);
+	writel(smode, trng->base + STARFIVE_SMODE);
+
+	starfive_trng_cmd(trng, STARFIVE_CTRL_EXEC_NOP);
+
+	return starfive_trng_cmd(trng, STARFIVE_CTRL_EXEC_RANDRESEED);
+}
+
+static irqreturn_t starfive_trng_irq(int irq, void *priv)
+{
+	u32 status;
+	struct starfive_trng *trng = (struct starfive_trng *)priv;
+
+	status = readl(trng->base + STARFIVE_ISTAT);
+	if (status & STARFIVE_ISTAT_RAND_RDY) {
+		writel(STARFIVE_ISTAT_RAND_RDY, trng->base + STARFIVE_ISTAT);
+		complete(&trng->random_done);
+	}
+
+	if (status & STARFIVE_ISTAT_SEED_DONE) {
+		writel(STARFIVE_ISTAT_SEED_DONE, trng->base + STARFIVE_ISTAT);
+		complete(&trng->reseed_done);
+	}
+
+	if (status & STARFIVE_ISTAT_LFSR_LOCKUP) {
+		writel(STARFIVE_ISTAT_LFSR_LOCKUP, trng->base + STARFIVE_ISTAT);
+		starfive_trng_cmd(trng, STARFIVE_CTRL_EXEC_RANDRESEED);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void starfive_trng_cleanup(struct hwrng *rng)
+{
+	struct starfive_trng *trng = to_trng(rng);
+
+	writel(0, trng->base + STARFIVE_CTRL);
+
+	reset_control_assert(trng->rst);
+	clk_disable_unprepare(trng->hclk);
+	clk_disable_unprepare(trng->ahb);
+}
+
+static int starfive_trng_read(struct hwrng *rng, void *buf, size_t max, bool wait)
+{
+	struct starfive_trng *trng = to_trng(rng);
+	int ret;
+
+	pm_runtime_get_sync(trng->dev);
+
+	if (trng->mode == PRNG_256BIT)
+		max = min_t(size_t, max, (STARFIVE_RAND_LEN * 8));
+	else
+		max = min_t(size_t, max, (STARFIVE_RAND_LEN * 4));
+
+	ret = starfive_trng_cmd(trng, STARFIVE_CTRL_GENE_RANDNUM);
+	if (ret)
+		return ret;
+
+	memcpy_fromio(buf, trng->base + STARFIVE_RAND0, max);
+
+	pm_runtime_put_sync(trng->dev);
+
+	return max;
+}
+
+static int starfive_trng_probe(struct platform_device *pdev)
+{
+	int ret;
+	int irq;
+	struct starfive_trng *trng;
+
+	trng = devm_kzalloc(&pdev->dev, sizeof(*trng), GFP_KERNEL);
+	if (!trng)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, trng);
+	trng->dev = &pdev->dev;
+
+	trng->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(trng->base))
+		return dev_err_probe(&pdev->dev, PTR_ERR(trng->base),
+				     "Error remapping memory for platform device.\n");
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	ret = devm_request_irq(&pdev->dev, irq, starfive_trng_irq, 0, pdev->name,
+			       (void *)trng);
+	if (ret)
+		return dev_err_probe(&pdev->dev, irq,
+				     "Failed to register interrupt handler\n");
+
+	trng->hclk = devm_clk_get(&pdev->dev, "hclk");
+	if (IS_ERR(trng->hclk))
+		return dev_err_probe(&pdev->dev, PTR_ERR(trng->hclk),
+				     "Error getting hardware reference clock\n");
+
+	trng->ahb = devm_clk_get(&pdev->dev, "ahb");
+	if (IS_ERR(trng->ahb))
+		return dev_err_probe(&pdev->dev, PTR_ERR(trng->ahb),
+				     "Error getting ahb reference clock\n");
+
+	trng->rst = devm_reset_control_get_shared(&pdev->dev, NULL);
+	if (IS_ERR(trng->rst))
+		return dev_err_probe(&pdev->dev, PTR_ERR(trng->rst),
+				     "Error getting hardware reset line\n");
+
+	clk_prepare_enable(trng->hclk);
+	clk_prepare_enable(trng->ahb);
+	reset_control_deassert(trng->rst);
+
+	init_completion(&trng->random_done);
+	init_completion(&trng->reseed_done);
+
+	trng->rng.name = dev_driver_string(&pdev->dev);
+	trng->rng.init = starfive_trng_init;
+	trng->rng.cleanup = starfive_trng_cleanup;
+	trng->rng.read = starfive_trng_read;
+
+	trng->mode = PRNG_256BIT;
+	trng->mission = 1;
+	trng->reseed = RANDOM_RESEED;
+
+	ret = devm_hwrng_register(&pdev->dev, &trng->rng);
+	if (ret) {
+		dev_err_probe(&pdev->dev, ret, "Failed to register hwrng\n");
+		goto err_fail_register;
+	}
+
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 100);
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
+
+err_fail_register:
+	pm_runtime_disable(&pdev->dev);
+
+	reset_control_assert(trng->rst);
+	clk_disable_unprepare(trng->ahb);
+	clk_disable_unprepare(trng->hclk);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int starfive_trng_runtime_suspend(struct device *dev)
+{
+	struct starfive_trng *trng = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(trng->hclk);
+	clk_disable_unprepare(trng->ahb);
+
+	return 0;
+}
+
+static int starfive_trng_runtime_resume(struct device *dev)
+{
+	struct starfive_trng *trng = dev_get_drvdata(dev);
+
+	clk_prepare_enable(trng->hclk);
+	clk_prepare_enable(trng->ahb);
+
+	return 0;
+}
+
+static int starfive_trng_runtime_idle(struct device *dev)
+{
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_autosuspend(dev);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops starfive_trng_pm_ops = {
+	SET_RUNTIME_PM_OPS(starfive_trng_runtime_suspend,
+			   starfive_trng_runtime_resume,
+			   starfive_trng_runtime_idle)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
+static const struct of_device_id trng_dt_ids[] = {
+	{ .compatible = "starfive,jh7110-trng" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, trng_dt_ids);
+
+static struct platform_driver starfive_trng_driver = {
+	.probe	= starfive_trng_probe,
+	.driver	= {
+		.name		= "starfive-trng",
+		.pm		= &starfive_trng_pm_ops,
+		.of_match_table	= of_match_ptr(trng_dt_ids),
+	},
+};
+
+module_platform_driver(starfive_trng_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("StarFive True Random Number Generator");
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index c715d4681a0b..bf736fc45bc5 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -377,6 +377,7 @@ source "drivers/clk/rockchip/Kconfig"
 source "drivers/clk/samsung/Kconfig"
 source "drivers/clk/sifive/Kconfig"
 source "drivers/clk/sprd/Kconfig"
+source "drivers/clk/starfive/Kconfig"
 source "drivers/clk/sunxi/Kconfig"
 source "drivers/clk/sunxi-ng/Kconfig"
 source "drivers/clk/tegra/Kconfig"
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index da8fcf147eb1..f5ab7752aa74 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -111,6 +111,7 @@ obj-$(CONFIG_ARCH_STRATIX10)		+= socfpga/
 obj-$(CONFIG_PLAT_SPEAR)		+= spear/
 obj-y					+= sprd/
 obj-$(CONFIG_ARCH_STI)			+= st/
+obj-$(CONFIG_SOC_STARFIVE)		+= starfive/
 obj-$(CONFIG_ARCH_SUNXI)		+= sunxi/
 obj-$(CONFIG_SUNXI_CCU)			+= sunxi-ng/
 obj-$(CONFIG_ARCH_TEGRA)		+= tegra/
diff --git a/drivers/clk/starfive/Kconfig b/drivers/clk/starfive/Kconfig
new file mode 100644
index 000000000000..839538e33708
--- /dev/null
+++ b/drivers/clk/starfive/Kconfig
@@ -0,0 +1,34 @@
+# SPDX-License-Identifier: GPL-2.0
+
+config CLK_STARFIVE_JH7110
+	bool "StarFive JH7110 clock support"
+	depends on SOC_STARFIVE || COMPILE_TEST
+	default y if SOC_STARFIVE
+	help
+		Say yes here to support the clock controller on the StarFive
+		JH7110 SoC.
+
+config CLK_STARFIVE_JH7110_VOUT
+	bool "StarFive JH7110 vout clock support"
+	depends on CLK_STARFIVE_JH7110
+	default y if SOC_STARFIVE
+	help
+		Say yes here to support the vout clocks on the StarFive
+		JH7100 SoC.
+
+config CLK_STARFIVE_JH7110_ISP
+	bool "StarFive JH7110 isp clock support"
+	depends on CLK_STARFIVE_JH7110
+	default y if SOC_STARFIVE
+	help
+		Say yes here to support the isp clocks on the StarFive
+		JH7110 SoC.
+
+config CLK_STARFIVE_JH7110_PLL
+	bool "StarFive JH7110 pll clock support"
+	depends on CLK_STARFIVE_JH7110
+	default y if SOC_STARFIVE_JH7110
+	help
+		Say yes here to support the pll clocks on the StarFive
+		JH7110 SoC and then change or read the pll clock's rate
+		through setting or reading the syscon registers and calculate.
diff --git a/drivers/clk/starfive/Makefile b/drivers/clk/starfive/Makefile
new file mode 100644
index 000000000000..8f01cb796309
--- /dev/null
+++ b/drivers/clk/starfive/Makefile
@@ -0,0 +1,9 @@
+# SPDX-License-Identifier: GPL-2.0
+# StarFive Clock
+obj-$(CONFIG_CLK_STARFIVE_JH7110)	+= clk-starfive-jh7110-gen.o \
+						clk-starfive-jh7110-sys.o \
+						clk-starfive-jh7110-stg.o \
+						clk-starfive-jh7110-aon.o
+obj-$(CONFIG_CLK_STARFIVE_JH7110_VOUT)	+= clk-starfive-jh7110-vout.o
+obj-$(CONFIG_CLK_STARFIVE_JH7110_ISP)	+= clk-starfive-jh7110-isp.o
+obj-$(CONFIG_CLK_STARFIVE_JH7110_PLL)	+= clk-starfive-jh7110-pll.o
diff --git a/drivers/clk/starfive/clk-starfive-jh7110-aon.c b/drivers/clk/starfive/clk-starfive-jh7110-aon.c
new file mode 100755
index 000000000000..2786b37cc08f
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110-aon.c
@@ -0,0 +1,165 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * StarFive JH7110 aon Clock Generator Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <dt-bindings/clock/starfive-jh7110-clkgen.h>
+#include "clk-starfive-jh7110.h"
+
+/* external clocks */
+#define JH7110_OSC				(JH7110_CLK_END + 0)
+/* aon external clocks */
+#define JH7110_GMAC0_RMII_REFIN			(JH7110_CLK_END + 12)
+#define JH7110_GMAC0_RGMII_RXIN			(JH7110_CLK_END + 13)
+#define JH7110_CLK_RTC				(JH7110_CLK_END + 14)
+
+static const struct jh7110_clk_data jh7110_clk_aon_data[] __initconst = {
+	//source
+	JH7110__DIV(JH7110_OSC_DIV4, "osc_div4", 4, JH7110_OSC),
+	JH7110__MUX(JH7110_AON_APB_FUNC, "aon_apb_func", PARENT_NUMS_2,
+			JH7110_OSC_DIV4,
+			JH7110_OSC),
+	//gmac5
+	JH7110_GATE(JH7110_U0_GMAC5_CLK_AHB,
+			"u0_dw_gmac5_axi64_clk_ahb",
+			GATE_FLAG_NORMAL, JH7110_AON_AHB),
+	JH7110_GATE(JH7110_U0_GMAC5_CLK_AXI,
+			"u0_dw_gmac5_axi64_clk_axi",
+			GATE_FLAG_NORMAL, JH7110_AON_AHB),
+	JH7110__DIV(JH7110_GMAC0_RMII_RTX,
+			"gmac0_rmii_rtx", 30, JH7110_GMAC0_RMII_REFIN),
+	JH7110_GMUX(JH7110_U0_GMAC5_CLK_TX,
+			"u0_dw_gmac5_axi64_clk_tx",
+			GATE_FLAG_NORMAL, PARENT_NUMS_2,
+			JH7110_GMAC0_GTXCLK,
+			JH7110_GMAC0_RMII_RTX),
+	JH7110__INV(JH7110_U0_GMAC5_CLK_TX_INV,
+			"u0_dw_gmac5_axi64_clk_tx_inv",
+			JH7110_U0_GMAC5_CLK_TX),
+	JH7110__MUX(JH7110_U0_GMAC5_CLK_RX,
+			"u0_dw_gmac5_axi64_clk_rx", PARENT_NUMS_2,
+			JH7110_GMAC0_RGMII_RXIN,
+			JH7110_GMAC0_RMII_RTX),
+	JH7110__INV(JH7110_U0_GMAC5_CLK_RX_INV,
+			"u0_dw_gmac5_axi64_clk_rx_inv",
+			JH7110_U0_GMAC5_CLK_RX),
+	//otpc
+	JH7110_GATE(JH7110_OTPC_CLK_APB,
+			"u0_otpc_clk_apb",
+			CLK_IGNORE_UNUSED, JH7110_AON_APB),
+	//rtc
+	JH7110_GATE(JH7110_RTC_HMS_CLK_APB,
+			"u0_rtc_hms_clk_apb",
+			CLK_IGNORE_UNUSED, JH7110_AON_APB),
+	JH7110__DIV(JH7110_RTC_INTERNAL,
+			"rtc_internal", 1022, JH7110_OSC),
+	JH7110__MUX(JH7110_RTC_HMS_CLK_OSC32K,
+			"u0_rtc_hms_clk_osc32k", PARENT_NUMS_2,
+			JH7110_CLK_RTC,
+			JH7110_RTC_INTERNAL),
+	JH7110_GATE(JH7110_RTC_HMS_CLK_CAL,
+			"u0_rtc_hms_clk_cal",
+			GATE_FLAG_NORMAL, JH7110_OSC),
+};
+
+int __init clk_starfive_jh7110_aon_init(struct platform_device *pdev,
+						struct jh7110_clk_priv *priv)
+{
+	unsigned int idx;
+	int ret = 0;
+
+	priv->aon_base = devm_platform_ioremap_resource_byname(pdev, "aon");
+	if (IS_ERR(priv->aon_base))
+		return PTR_ERR(priv->aon_base);
+
+	priv->pll[PLL_OF(JH7110_U0_GMAC5_CLK_PTP)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dw_gmac5_axi64_clk_ptp", "gmac0_ptp", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_U0_GMAC5_CLK_RMII)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dw_gmac5_axi64_clk_rmii",
+			"gmac0_rmii_refin", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_AON_SYSCON_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_aon_syscon_pclk", "aon_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_AON_IOMUX_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_aon_iomux_pclk", "aon_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_AON_CRG_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_aon_crg_pclk", "aon_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PMU_CLK_APB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pmu_clk_apb", "aon_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PMU_CLK_WKUP)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pmu_clk_wkup", "aon_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_RTC_HMS_CLK_OSC32K_G)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_rtc_hms_clk_osc32k_g",
+			"u0_rtc_hms_clk_osc32k", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_32K_OUT)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"32k_out", "clk_rtc", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_RESET0_CTRL_CLK_SRC)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_reset_ctrl_clk_src", "osc", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCLK_MUX_FUNC_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_pclk_mux_func_pclk", "aon_apb_func", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCLK_MUX_BIST_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_pclk_mux_bist_pclk", "bist_apb", 0, 1, 1);
+
+	for (idx = JH7110_CLK_STG_REG_END; idx < JH7110_CLK_REG_END; idx++) {
+		u32 max = jh7110_clk_aon_data[idx].max;
+		struct clk_parent_data parents[4] = {};
+		struct clk_init_data init = {
+			.name = jh7110_clk_aon_data[idx].name,
+			.ops = starfive_jh7110_clk_ops(max),
+			.parent_data = parents,
+			.num_parents = ((max & JH7110_CLK_MUX_MASK) >>
+				JH7110_CLK_MUX_SHIFT) + 1,
+			.flags = jh7110_clk_aon_data[idx].flags,
+		};
+		struct jh7110_clk *clk = &priv->reg[idx];
+		unsigned int i;
+
+		for (i = 0; i < init.num_parents; i++) {
+			unsigned int pidx = jh7110_clk_aon_data[idx].parents[i];
+
+			if (pidx < JH7110_CLK_REG_END)
+				parents[i].hw = &priv->reg[pidx].hw;
+			else if ((pidx < JH7110_CLK_END) &&
+				(pidx > JH7110_RTC_HMS_CLK_CAL))
+				parents[i].hw = priv->pll[PLL_OF(pidx)];
+			else if (pidx == JH7110_OSC)
+				parents[i].fw_name = "osc";
+			else if (pidx == JH7110_GMAC0_RMII_REFIN)
+				parents[i].fw_name = "gmac0_rmii_refin";
+			else if (pidx == JH7110_GMAC0_RGMII_RXIN)
+				parents[i].fw_name = "gmac0_rgmii_rxin";
+			else if (pidx == JH7110_CLK_RTC)
+				parents[i].fw_name = "clk_rtc";
+		}
+
+		clk->hw.init = &init;
+		clk->idx = idx;
+		clk->max_div = max & JH7110_CLK_DIV_MASK;
+		clk->reg_flags = JH7110_CLK_AON_FLAG;
+
+		ret = devm_clk_hw_register(priv->dev, &clk->hw);
+		if (ret)
+			return ret;
+	}
+
+	dev_dbg(&pdev->dev,  "starfive JH7110 clk_aon init successfully.");
+	return 0;
+}
diff --git a/drivers/clk/starfive/clk-starfive-jh7110-gen.c b/drivers/clk/starfive/clk-starfive-jh7110-gen.c
new file mode 100644
index 000000000000..ac2e2f3fded1
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110-gen.c
@@ -0,0 +1,634 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * StarFive JH7110 Clock Generator Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+
+#include <dt-bindings/clock/starfive-jh7110-clkgen.h>
+#include "clk-starfive-jh7110.h"
+#include "clk-starfive-jh7110-pll.h"
+
+static struct jh7110_clk * __init jh7110_clk_from(struct clk_hw *hw)
+{
+	return container_of(hw, struct jh7110_clk, hw);
+}
+
+static struct jh7110_clk_priv *jh7110_priv_from(struct jh7110_clk *clk)
+{
+	return container_of(clk, struct jh7110_clk_priv, reg[clk->idx]);
+}
+
+void __iomem *jh7110_clk_reg_addr_get(struct jh7110_clk *clk)
+{
+	void __iomem *reg;
+	struct jh7110_clk_priv *priv = jh7110_priv_from(clk);
+
+	if (clk->reg_flags == JH7110_CLK_SYS_FLAG)
+		reg = priv->sys_base + 4 * clk->idx;
+	else if (clk->reg_flags == JH7110_CLK_STG_FLAG)
+		reg = priv->stg_base + 4 * (clk->idx - JH7110_CLK_SYS_REG_END);
+	else if (clk->reg_flags == JH7110_CLK_AON_FLAG)
+		reg = priv->aon_base + 4 * (clk->idx - JH7110_CLK_STG_REG_END);
+	else if (clk->reg_flags == JH7110_CLK_VOUT_FLAG)
+		reg = priv->vout_base + 4 * clk->idx;
+	else if (clk->reg_flags == JH7110_CLK_ISP_FLAG)
+		reg = priv->isp_base + 4 * clk->idx;
+
+	return reg;
+}
+
+static u32 jh7110_clk_reg_get(struct jh7110_clk *clk)
+{
+	void __iomem *reg = jh7110_clk_reg_addr_get(clk);
+
+	if ((clk->reg_flags == JH7110_CLK_ISP_FLAG) || (clk->reg_flags == JH7110_CLK_VOUT_FLAG)) {
+		int ret;
+		struct jh7110_clk_priv *priv = jh7110_priv_from(clk);
+
+		if (pm_runtime_suspended(priv->dev)) {
+			ret = pm_runtime_get_sync(priv->dev);
+			if (ret < 0) {
+				dev_err(priv->dev, "cannot resume device :%d.\n", ret);
+				return 0;
+			}
+			pm_runtime_put(priv->dev);
+		}
+	}
+
+	return readl_relaxed(reg);
+}
+
+static void jh7110_clk_reg_rmw(struct jh7110_clk *clk, u32 mask, u32 value)
+{
+	struct jh7110_clk_priv *priv = jh7110_priv_from(clk);
+	void __iomem *reg = jh7110_clk_reg_addr_get(clk);
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->rmw_lock, flags);
+	value |= jh7110_clk_reg_get(clk) & ~mask;
+	writel_relaxed(value, reg);
+	spin_unlock_irqrestore(&priv->rmw_lock, flags);
+}
+
+static int jh7110_clk_enable(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_ENABLE, JH7110_CLK_ENABLE);
+	return 0;
+}
+
+static void jh7110_clk_disable(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_ENABLE, 0);
+}
+
+static int jh7110_clk_is_enabled(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+
+	return !!(jh7110_clk_reg_get(clk) & JH7110_CLK_ENABLE);
+}
+
+static unsigned long jh7110_clk_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	u32 div = jh7110_clk_reg_get(clk) & JH7110_CLK_DIV_MASK;
+
+	if (clk->idx == JH7110_UART3_CLK_CORE
+		|| clk->idx == JH7110_UART4_CLK_CORE
+		|| clk->idx == JH7110_UART5_CLK_CORE)
+		div = div >> 8;
+
+	return div ? parent_rate / div : 0;
+}
+
+static int jh7110_clk_determine_rate(struct clk_hw *hw,
+					struct clk_rate_request *req)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	unsigned long parent = req->best_parent_rate;
+	unsigned long rate = clamp(req->rate, req->min_rate, req->max_rate);
+	unsigned long div = min_t(unsigned long,
+				DIV_ROUND_UP(parent, rate), clk->max_div);
+	unsigned long result = parent / div;
+
+	/*
+	 * we want the result clamped by min_rate and max_rate if possible:
+	 * case 1: div hits the max divider value, which means it's less than
+	 * parent / rate, so the result is greater than rate and min_rate in
+	 * particular. we can't do anything about result > max_rate because the
+	 * divider doesn't go any further.
+	 * case 2: div = DIV_ROUND_UP(parent, rate) which means the result is
+	 * always lower or equal to rate and max_rate. however the result may
+	 * turn out lower than min_rate, but then the next higher rate is fine:
+	 *	div - 1 = ceil(parent / rate) - 1 < parent / rate
+	 * and thus
+	 *	min_rate <= rate < parent / (div - 1)
+	 */
+	if (result < req->min_rate && div > 1)
+		result = parent / (div - 1);
+
+	req->rate = result;
+	return 0;
+}
+
+static int jh7110_clk_set_rate(struct clk_hw *hw,
+				unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	unsigned long div = clamp(DIV_ROUND_CLOSEST(parent_rate, rate),
+					1UL, (unsigned long)clk->max_div);
+
+	/* UART3-5: [15:8]: integer part of the divisor. [7:0] fraction part of the divisor */
+	if (clk->idx == JH7110_UART3_CLK_CORE ||
+	    clk->idx == JH7110_UART4_CLK_CORE ||
+	    clk->idx == JH7110_UART5_CLK_CORE)
+		div <<= 8;
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_DIV_MASK, div);
+	return 0;
+}
+
+static u8 jh7110_clk_get_parent(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	u32 value = jh7110_clk_reg_get(clk);
+
+	return (value & JH7110_CLK_MUX_MASK) >> JH7110_CLK_MUX_SHIFT;
+}
+
+static int jh7110_clk_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	u32 value = (u32)index << JH7110_CLK_MUX_SHIFT;
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_MUX_MASK, value);
+	return 0;
+}
+
+static int jh7110_clk_mux_determine_rate(struct clk_hw *hw,
+					 struct clk_rate_request *req)
+{
+	return clk_mux_determine_rate_flags(hw, req, 0);
+}
+
+static int jh7110_clk_get_phase(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	u32 value = jh7110_clk_reg_get(clk);
+
+	return (value & JH7110_CLK_INVERT) ? 180 : 0;
+}
+
+static int jh7110_clk_set_phase(struct clk_hw *hw, int degrees)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	u32 value;
+
+	if (degrees == 0)
+		value = 0;
+	else if (degrees == 180)
+		value = JH7110_CLK_INVERT;
+	else
+		return -EINVAL;
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_INVERT, value);
+	return 0;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static void jh7110_clk_debug_init(struct clk_hw *hw, struct dentry *dentry)
+{
+	static const struct debugfs_reg32 jh7110_clk_reg = {
+		.name = "CTRL",
+		.offset = 0,
+	};
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	struct jh7110_clk_priv *priv = jh7110_priv_from(clk);
+	struct debugfs_regset32 *regset;
+
+	regset = devm_kzalloc(priv->dev, sizeof(*regset), GFP_KERNEL);
+	if (!regset)
+		return;
+
+	regset->regs = &jh7110_clk_reg;
+	regset->nregs = 1;
+	regset->base = jh7110_clk_reg_addr_get(clk);
+
+	debugfs_create_regset32("registers", 0400, dentry, regset);
+}
+#else
+#define jh7110_clk_debug_init NULL
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int jh7110_clk_save_context(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+	void __iomem *reg = jh7110_clk_reg_addr_get(clk);
+	struct jh7110_clk_priv *priv = jh7110_priv_from(clk);
+
+	if (!clk || !priv)
+		return 0;
+
+	if ((clk->reg_flags == JH7110_CLK_ISP_FLAG) || (clk->reg_flags == JH7110_CLK_VOUT_FLAG))
+		return 0;
+
+	if (clk->idx >= JH7110_CLK_REG_END)
+		return 0;
+
+	spin_lock(&priv->rmw_lock);
+	clk->saved_reg_value = readl_relaxed(reg);
+	spin_unlock(&priv->rmw_lock);
+
+	return 0;
+}
+
+static void jh7110_clk_gate_restore_context(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+
+	if (!clk)
+		return;
+
+	if ((clk->reg_flags == JH7110_CLK_ISP_FLAG) || (clk->reg_flags == JH7110_CLK_VOUT_FLAG))
+		return;
+
+	if (clk->idx >= JH7110_CLK_REG_END)
+		return;
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_ENABLE, clk->saved_reg_value);
+
+	return;
+}
+
+static void jh7110_clk_div_restore_context(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+
+	if (!clk)
+		return;
+
+	if ((clk->reg_flags == JH7110_CLK_ISP_FLAG) || (clk->reg_flags == JH7110_CLK_VOUT_FLAG))
+		return;
+
+	if (clk->idx >= JH7110_CLK_REG_END)
+		return;
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_DIV_MASK, clk->saved_reg_value);
+
+	return;
+}
+
+static void jh7110_clk_mux_restore_context(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+
+	if (!clk)
+		return;
+
+	if ((clk->reg_flags == JH7110_CLK_ISP_FLAG) || (clk->reg_flags == JH7110_CLK_VOUT_FLAG))
+		return;
+
+	if (clk->idx >= JH7110_CLK_REG_END)
+		return;
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_MUX_MASK, clk->saved_reg_value);
+
+	return;
+}
+
+static void jh7110_clk_inv_restore_context(struct clk_hw *hw)
+{
+	struct jh7110_clk *clk = jh7110_clk_from(hw);
+
+	if (!clk)
+		return;
+
+	if ((clk->reg_flags == JH7110_CLK_ISP_FLAG) || (clk->reg_flags == JH7110_CLK_VOUT_FLAG))
+		return;
+
+	if (clk->idx >= JH7110_CLK_REG_END)
+		return;
+
+	jh7110_clk_reg_rmw(clk, JH7110_CLK_INVERT, clk->saved_reg_value);
+
+	return;
+}
+
+static void jh7110_clk_gdiv_restore_context(struct clk_hw *hw)
+{
+	jh7110_clk_div_restore_context(hw);
+	jh7110_clk_gate_restore_context(hw);
+
+	return;
+}
+
+static void jh7110_clk_gmux_restore_context(struct clk_hw *hw)
+{
+	jh7110_clk_mux_restore_context(hw);
+	jh7110_clk_gate_restore_context(hw);
+
+	return;
+}
+
+static void jh7110_clk_mdiv_restore_context(struct clk_hw *hw)
+{
+	jh7110_clk_mux_restore_context(hw);
+	jh7110_clk_div_restore_context(hw);
+
+	return;
+}
+
+static void jh7110_clk_gmd_restore_context(struct clk_hw *hw)
+{
+	jh7110_clk_mux_restore_context(hw);
+	jh7110_clk_div_restore_context(hw);
+	jh7110_clk_gate_restore_context(hw);
+
+	return;
+}
+
+#endif
+
+static const struct clk_ops jh7110_clk_gate_ops = {
+	.enable = jh7110_clk_enable,
+	.disable = jh7110_clk_disable,
+	.is_enabled = jh7110_clk_is_enabled,
+	.debug_init = jh7110_clk_debug_init,
+#ifdef CONFIG_PM_SLEEP
+	.save_context = jh7110_clk_save_context,
+	.restore_context = jh7110_clk_gate_restore_context,
+#endif
+};
+
+static const struct clk_ops jh7110_clk_div_ops = {
+	.recalc_rate = jh7110_clk_recalc_rate,
+	.determine_rate = jh7110_clk_determine_rate,
+	.set_rate = jh7110_clk_set_rate,
+	.debug_init = jh7110_clk_debug_init,
+#ifdef CONFIG_PM_SLEEP
+	.save_context = jh7110_clk_save_context,
+	.restore_context = jh7110_clk_div_restore_context,
+#endif
+};
+
+static const struct clk_ops jh7110_clk_gdiv_ops = {
+	.enable = jh7110_clk_enable,
+	.disable = jh7110_clk_disable,
+	.is_enabled = jh7110_clk_is_enabled,
+	.recalc_rate = jh7110_clk_recalc_rate,
+	.determine_rate = jh7110_clk_determine_rate,
+	.set_rate = jh7110_clk_set_rate,
+	.debug_init = jh7110_clk_debug_init,
+#ifdef CONFIG_PM_SLEEP
+	.save_context = jh7110_clk_save_context,
+	.restore_context = jh7110_clk_gdiv_restore_context,
+#endif
+};
+
+static const struct clk_ops jh7110_clk_mux_ops = {
+	.determine_rate = jh7110_clk_mux_determine_rate,
+	.set_parent = jh7110_clk_set_parent,
+	.get_parent = jh7110_clk_get_parent,
+	.debug_init = jh7110_clk_debug_init,
+#ifdef CONFIG_PM_SLEEP
+	.save_context = jh7110_clk_save_context,
+	.restore_context = jh7110_clk_mux_restore_context,
+#endif
+};
+
+static const struct clk_ops jh7110_clk_gmux_ops = {
+	.enable = jh7110_clk_enable,
+	.disable = jh7110_clk_disable,
+	.is_enabled = jh7110_clk_is_enabled,
+	.determine_rate = jh7110_clk_mux_determine_rate,
+	.set_parent = jh7110_clk_set_parent,
+	.get_parent = jh7110_clk_get_parent,
+	.debug_init = jh7110_clk_debug_init,
+#ifdef CONFIG_PM_SLEEP
+	.save_context = jh7110_clk_save_context,
+	.restore_context = jh7110_clk_gmux_restore_context,
+#endif
+};
+
+static const struct clk_ops jh7110_clk_mdiv_ops = {
+	.recalc_rate = jh7110_clk_recalc_rate,
+	.determine_rate = jh7110_clk_determine_rate,
+	.get_parent = jh7110_clk_get_parent,
+	.set_parent = jh7110_clk_set_parent,
+	.set_rate = jh7110_clk_set_rate,
+	.debug_init = jh7110_clk_debug_init,
+#ifdef CONFIG_PM_SLEEP
+	.save_context = jh7110_clk_save_context,
+	.restore_context = jh7110_clk_mdiv_restore_context,
+#endif
+};
+
+static const struct clk_ops jh7110_clk_gmd_ops = {
+	.enable = jh7110_clk_enable,
+	.disable = jh7110_clk_disable,
+	.is_enabled = jh7110_clk_is_enabled,
+	.recalc_rate = jh7110_clk_recalc_rate,
+	.determine_rate = jh7110_clk_determine_rate,
+	.get_parent = jh7110_clk_get_parent,
+	.set_parent = jh7110_clk_set_parent,
+	.set_rate = jh7110_clk_set_rate,
+	.debug_init = jh7110_clk_debug_init,
+#ifdef CONFIG_PM_SLEEP
+	.save_context = jh7110_clk_save_context,
+	.restore_context = jh7110_clk_gmd_restore_context,
+#endif
+};
+
+static const struct clk_ops jh7110_clk_inv_ops = {
+	.get_phase = jh7110_clk_get_phase,
+	.set_phase = jh7110_clk_set_phase,
+	.debug_init = jh7110_clk_debug_init,
+#ifdef CONFIG_PM_SLEEP
+	.save_context = jh7110_clk_save_context,
+	.restore_context = jh7110_clk_inv_restore_context,
+#endif
+};
+
+const struct clk_ops *starfive_jh7110_clk_ops(u32 max)
+{
+	const struct clk_ops *ops;
+
+	if (max & JH7110_CLK_DIV_MASK) {
+		if (max & JH7110_CLK_MUX_MASK) {
+			if (max & JH7110_CLK_ENABLE)
+				ops = &jh7110_clk_gmd_ops;
+			else
+				ops = &jh7110_clk_mdiv_ops;
+		} else if (max & JH7110_CLK_ENABLE)
+			ops = &jh7110_clk_gdiv_ops;
+		else
+			ops = &jh7110_clk_div_ops;
+	} else if (max & JH7110_CLK_MUX_MASK) {
+		if (max & JH7110_CLK_ENABLE)
+			ops = &jh7110_clk_gmux_ops;
+		else
+			ops = &jh7110_clk_mux_ops;
+	} else if (max & JH7110_CLK_ENABLE)
+		ops = &jh7110_clk_gate_ops;
+	else
+		ops = &jh7110_clk_inv_ops;
+
+	return ops;
+}
+EXPORT_SYMBOL_GPL(starfive_jh7110_clk_ops);
+
+#ifdef CONFIG_PM_SLEEP
+static int clk_starfive_jh7110_gen_system_suspend(struct device *dev)
+{
+	return clk_save_context();
+}
+
+static int clk_starfive_jh7110_gen_system_resume(struct device *dev)
+{
+	clk_restore_context();
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops clk_starfive_jh7110_gen_pm_ops = {
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(clk_starfive_jh7110_gen_system_suspend,
+				     clk_starfive_jh7110_gen_system_resume)
+};
+
+static struct clk_hw *jh7110_clk_get(struct of_phandle_args *clkspec,
+						void *data)
+{
+	struct jh7110_clk_priv *priv = data;
+	unsigned int idx = clkspec->args[0];
+
+	if (idx < JH7110_PLL0_OUT)
+		return &priv->reg[idx].hw;
+
+	if (idx < JH7110_CLK_END) {
+#ifdef CONFIG_CLK_STARFIVE_JH7110_PLL
+		if ((idx == JH7110_PLL0_OUT) || (idx == JH7110_PLL2_OUT))
+			return &priv->pll_priv[PLL_OF(idx)].hw;
+#endif
+		return priv->pll[PLL_OF(idx)];
+	}
+
+	return ERR_PTR(-EINVAL);
+}
+
+
+static int __init clk_starfive_jh7110_probe(struct platform_device *pdev)
+{
+	struct jh7110_clk_priv *priv;
+	int ret = 0;
+
+	priv = devm_kzalloc(&pdev->dev, struct_size(priv, reg, JH7110_PLL0_OUT),
+					GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	spin_lock_init(&priv->rmw_lock);
+	priv->dev = &pdev->dev;
+
+	pm_runtime_enable(priv->dev);
+
+#ifdef CONFIG_CLK_STARFIVE_JH7110_PLL
+	ret = clk_starfive_jh7110_pll_init(pdev, priv->pll_priv);
+	if (ret)
+		return ret;
+#endif
+
+	ret = clk_starfive_jh7110_sys_init(pdev, priv);
+	if (ret)
+		return ret;
+
+/* set PLL0 default rate */
+#ifdef CONFIG_CLK_STARFIVE_JH7110_PLL
+	if (PLL0_DEFAULT_FREQ) {
+		struct clk *pll0_clk = priv->pll_priv[PLL0_INDEX].hw.clk;
+		struct clk *cpu_root = priv->reg[JH7110_CPU_ROOT].hw.clk;
+		struct clk *osc_clk = clk_get(&pdev->dev, "osc");
+
+		if (IS_ERR(osc_clk))
+			dev_err(&pdev->dev, "get osc_clk failed\n");
+
+		if (PLL0_DEFAULT_FREQ >= PLL0_FREQ_1500_VALUE) {
+			struct clk *cpu_core = priv->reg[JH7110_CPU_CORE].hw.clk;
+
+			if (clk_set_rate(cpu_core, clk_get_rate(pll0_clk) / 2)) {
+				dev_err(&pdev->dev, "set cpu_core rate failed\n");
+				goto failed_set;
+			}
+		}
+
+		if (clk_set_parent(cpu_root, osc_clk)) {
+			dev_err(&pdev->dev, "set parent to osc_clk failed\n");
+			goto failed_set;
+		}
+
+		if (clk_set_rate(pll0_clk, PLL0_DEFAULT_FREQ))
+			dev_err(&pdev->dev, "set pll0 rate failed\n");
+
+		if (clk_set_parent(cpu_root, pll0_clk))
+			dev_err(&pdev->dev, "set parent to pll0_clk failed\n");
+
+failed_set:
+		clk_put(osc_clk);
+	}
+#endif
+
+	ret = clk_starfive_jh7110_stg_init(pdev, priv);
+	if (ret)
+		return ret;
+
+	ret = clk_starfive_jh7110_aon_init(pdev, priv);
+	if (ret)
+		return ret;
+
+	ret = devm_of_clk_add_hw_provider(priv->dev, jh7110_clk_get, priv);
+	if (ret)
+		return ret;
+
+	dev_info(&pdev->dev, "starfive JH7110 clkgen init successfully.");
+	return 0;
+}
+
+static const struct of_device_id clk_starfive_jh7110_match[] = {
+	{.compatible = "starfive,jh7110-clkgen"},
+	{ }
+};
+
+static struct platform_driver clk_starfive_jh7110_driver = {
+	.driver = {
+		.name = "clk-starfive-jh7110",
+		.of_match_table = clk_starfive_jh7110_match,
+		.pm = &clk_starfive_jh7110_gen_pm_ops,
+	},
+};
+builtin_platform_driver_probe(clk_starfive_jh7110_driver,
+			clk_starfive_jh7110_probe);
+
+MODULE_AUTHOR("Xingyu Wu <xingyu.wu@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive JH7110 sysgen clock driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/clk/starfive/clk-starfive-jh7110-isp.c b/drivers/clk/starfive/clk-starfive-jh7110-isp.c
new file mode 100644
index 000000000000..e56be950986a
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110-isp.c
@@ -0,0 +1,358 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * StarFive JH7110 Isp Clock Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/reset.h>
+#include <linux/reset-controller.h>
+#include <dt-bindings/clock/starfive-jh7110-isp.h>
+#include <linux/pm_runtime.h>
+#include "clk-starfive-jh7110.h"
+
+/* external clocks */
+#define JH7110_ISP_TOP_CLK_ISPCORE_2X_CLKGEN   (JH7110_CLK_ISP_END + 0)
+#define JH7110_ISP_TOP_CLK_ISP_AXI_CLKGEN      (JH7110_CLK_ISP_END + 1)
+#define JH7110_ISP_TOP_CLK_BIST_APB_CLKGEN     (JH7110_CLK_ISP_END + 2)
+#define JH7110_ISP_TOP_CLK_DVP_CLKGEN          (JH7110_CLK_ISP_END + 3)
+
+struct isp_init_crg {
+	int num_clks;
+	struct clk_bulk_data *clks;
+	struct reset_control *rsts;
+};
+
+static const struct jh7110_clk_data jh7110_clk_isp_data[] __initconst = {
+	//syscon
+	JH7110__DIV(JH7110_DOM4_APB_FUNC, "dom4_apb_func",
+			15, JH7110_ISP_TOP_CLK_ISP_AXI_CLKGEN),
+	//crg
+	JH7110__DIV(JH7110_MIPI_RX0_PXL, "mipi_rx0_pxl",
+			8, JH7110_ISP_TOP_CLK_ISPCORE_2X_CLKGEN),
+	JH7110__INV(JH7110_DVP_INV, "dvp_inv", JH7110_ISP_TOP_CLK_DVP_CLKGEN),
+	//vin
+	JH7110__DIV(JH7110_U0_M31DPHY_CFGCLK_IN, "u0_m31dphy_cfgclk_in",
+			16, JH7110_ISP_TOP_CLK_ISPCORE_2X_CLKGEN),
+	JH7110__DIV(JH7110_U0_M31DPHY_REFCLK_IN, "u0_m31dphy_refclk_in",
+			16, JH7110_ISP_TOP_CLK_ISPCORE_2X_CLKGEN),
+	JH7110__DIV(JH7110_U0_M31DPHY_TXCLKESC_LAN0, "u0_m31dphy_txclkesc_lan0",
+			60, JH7110_ISP_TOP_CLK_ISPCORE_2X_CLKGEN),
+	JH7110_GATE(JH7110_U0_VIN_PCLK, "u0_vin_pclk",
+			CLK_IGNORE_UNUSED, JH7110_DOM4_APB),
+	JH7110__DIV(JH7110_U0_VIN_SYS_CLK, "u0_vin_sys_clk",
+			8, JH7110_ISP_TOP_CLK_ISPCORE_2X_CLKGEN),
+	JH7110_GATE(JH7110_U0_VIN_PIXEL_CLK_IF0, "u0_vin_pixel_clk_if0",
+			CLK_IGNORE_UNUSED, JH7110_MIPI_RX0_PXL),
+	JH7110_GATE(JH7110_U0_VIN_PIXEL_CLK_IF1, "u0_vin_pixel_clk_if1",
+			CLK_IGNORE_UNUSED, JH7110_MIPI_RX0_PXL),
+	JH7110_GATE(JH7110_U0_VIN_PIXEL_CLK_IF2, "u0_vin_pixel_clk_if2",
+			CLK_IGNORE_UNUSED, JH7110_MIPI_RX0_PXL),
+	JH7110_GATE(JH7110_U0_VIN_PIXEL_CLK_IF3, "u0_vin_pixel_clk_if3",
+			CLK_IGNORE_UNUSED, JH7110_MIPI_RX0_PXL),
+	JH7110__MUX(JH7110_U0_VIN_CLK_P_AXIWR, "u0_vin_clk_p_axiwr",
+			PARENT_NUMS_2,
+			JH7110_MIPI_RX0_PXL,
+			JH7110_DVP_INV),
+	//ispv2_top_wrapper
+	JH7110_GMUX(JH7110_U0_ISPV2_TOP_WRAPPER_CLK_C,
+			"u0_ispv2_top_wrapper_clk_c",
+			CLK_IGNORE_UNUSED, PARENT_NUMS_2,
+			JH7110_MIPI_RX0_PXL,
+			JH7110_DVP_INV),
+};
+
+static struct clk_bulk_data isp_top_clks[] = {
+	{ .id = "u0_dom_isp_top_clk_dom_isp_top_clk_ispcore_2x" },
+	{ .id = "u0_dom_isp_top_clk_dom_isp_top_clk_isp_axi" },
+};
+
+static int jh7110_isp_crg_get(struct device *dev, struct isp_init_crg *crg)
+{
+	int ret;
+
+	crg->rsts = devm_reset_control_array_get_shared(dev);
+	if (IS_ERR(crg->rsts)) {
+		dev_err(dev, "rst get failed\n");
+		return PTR_ERR(crg->rsts);
+	}
+
+	crg->clks = isp_top_clks;
+	crg->num_clks = ARRAY_SIZE(isp_top_clks);
+	ret = clk_bulk_get(dev, crg->num_clks, crg->clks);
+	if (ret) {
+		dev_err(dev, "clks get failed: %d\n", ret);
+		goto clks_get_failed;
+	}
+
+	return 0;
+
+clks_get_failed:
+	reset_control_assert(crg->rsts);
+	reset_control_put(crg->rsts);
+
+	return ret;
+}
+
+static int jh7110_isp_crg_enable(struct device *dev, struct isp_init_crg *crg, bool enable)
+{
+	int ret;
+
+	dev_dbg(dev, "starfive jh7110 isp clk&rst %sable\n", enable ? "en":"dis");
+	if (enable) {
+		ret = reset_control_deassert(crg->rsts);
+		if (ret) {
+			dev_err(dev, "rst deassert failed: %d\n", ret);
+			goto crg_failed;
+		}
+
+		ret = clk_bulk_prepare_enable(crg->num_clks, crg->clks);
+		if (ret) {
+			dev_err(dev, "clks enable failed: %d\n", ret);
+			goto crg_failed;
+		}
+	} else {
+		clk_bulk_disable_unprepare(crg->num_clks, crg->clks);
+	}
+
+	return 0;
+crg_failed:
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int clk_isp_system_suspend(struct device *dev)
+{
+	return pm_runtime_force_suspend(dev);
+}
+
+static int clk_isp_system_resume(struct device *dev)
+{
+	return pm_runtime_force_resume(dev);
+}
+#endif
+
+#ifdef CONFIG_PM
+static int clk_isp_runtime_suspend(struct device *dev)
+{
+	struct isp_init_crg *crg = dev_get_drvdata(dev);
+
+	return jh7110_isp_crg_enable(dev, crg, false);
+}
+
+static int clk_isp_runtime_resume(struct device *dev)
+{
+	struct isp_init_crg *crg = dev_get_drvdata(dev);
+
+	return jh7110_isp_crg_enable(dev, crg, true);
+}
+#endif
+
+static const struct dev_pm_ops clk_isp_pm_ops = {
+	SET_RUNTIME_PM_OPS(clk_isp_runtime_suspend, clk_isp_runtime_resume, NULL)
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(clk_isp_system_suspend, clk_isp_system_resume)
+};
+
+static struct clk_hw *jh7110_isp_clk_get(struct of_phandle_args *clkspec,
+					void *data)
+{
+	struct jh7110_clk_priv *priv = data;
+	unsigned int idx = clkspec->args[0];
+
+	if (idx < JH7110_CLK_ISP_REG_END)
+		return &priv->reg[idx].hw;
+
+	if (idx < JH7110_CLK_ISP_END)
+		return priv->pll[PLL_OFI(idx)];
+
+	return ERR_PTR(-EINVAL);
+}
+
+static int __init clk_starfive_jh7110_isp_probe(struct platform_device *pdev)
+{
+	struct jh7110_clk_priv *priv;
+	struct isp_init_crg *crg;
+	unsigned int idx;
+	int ret = 0;
+
+	priv = devm_kzalloc(&pdev->dev, struct_size(priv, reg,
+				JH7110_CLK_ISP_END), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	spin_lock_init(&priv->rmw_lock);
+	priv->dev = &pdev->dev;
+	priv->isp_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(priv->isp_base))
+		return PTR_ERR(priv->isp_base);
+
+	crg = devm_kzalloc(&pdev->dev, sizeof(*crg), GFP_KERNEL);
+	if (!crg)
+		return -ENOMEM;
+	dev_set_drvdata(&pdev->dev, crg);
+
+	ret = jh7110_isp_crg_get(&pdev->dev, crg);
+	if (ret)
+		goto init_failed;
+
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
+	pm_runtime_enable(&pdev->dev);
+	ret = pm_runtime_get_sync(&pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to get pm runtime: %d\n", ret);
+		goto init_failed;
+	}
+
+	priv->pll[PLL_OFI(JH7110_U3_PCLK_MUX_FUNC_PCLK)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "u3_pclk_mux_func_pclk",
+			"dom4_apb_func", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U3_PCLK_MUX_BIST_PCLK)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "u3_pclk_mux_bist_pclk",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_bist_apb", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_DOM4_APB)] =
+			clk_hw_register_fixed_factor(priv->dev, "dom4_apb",
+			"u3_pclk_mux_pclk", 0, 1, 1);
+	/*vin*/
+	priv->pll[PLL_OFI(JH7110_U0_VIN_PCLK_FREE)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "u0_vin_pclk_free",
+			"dom4_apb", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_VIN_CLK_P_AXIRD)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "u0_vin_clk_p_axird",
+			"mipi_rx0_pxl", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_VIN_ACLK)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "u0_vin_ACLK",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_isp_axi", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_ISPV2_TOP_WRAPPER_CLK_ISP_AXI_IN)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ispv2_top_wrapper_clk_isp_axi_in",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_isp_axi", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_ISPV2_TOP_WRAPPER_CLK_ISP_X2)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ispv2_top_wrapper_clk_isp_x2",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_ispcore_2x",
+			0, 1, 1);
+	/*wrapper*/
+	priv->pll[PLL_OFI(JH7110_U0_ISPV2_TOP_WRAPPER_CLK_ISP)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ispv2_top_wrapper_clk_isp",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_isp_axi", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_ISPV2_TOP_WRAPPER_CLK_P)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ispv2_top_wrapper_clk_p",
+			"mipi_rx0_pxl", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_CRG_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_crg_pclk", "dom4_apb", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_SYSCON_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_syscon_pclk", "dom4_apb", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_M31DPHY_APBCFG_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_m31dphy_apbcfg_pclk", "dom4_apb", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_AXI2APB_BRIDGE_CLK_DOM4_APB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_axi2apb_bridge_clk_dom4_apb", "dom4_apb", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U0_AXI2APB_BRIDGE_ISP_AXI4SLV_CLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_axi2apb_bridge_isp_axi4slv_clk",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_isp_axi", 0, 1, 1);
+	priv->pll[PLL_OFI(JH7110_U3_PCLK_MUX_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u3_pclk_mux_pclk", "u3_pclk_mux_func_pclk", 0, 1, 1);
+
+	for (idx = 0; idx < JH7110_CLK_ISP_REG_END; idx++) {
+		u32 max = jh7110_clk_isp_data[idx].max;
+		struct clk_parent_data parents[2] = {};
+		struct clk_init_data init = {
+			.name = jh7110_clk_isp_data[idx].name,
+			.ops = starfive_jh7110_clk_ops(max),
+			.parent_data = parents,
+			.num_parents = ((max & JH7110_CLK_MUX_MASK) >>
+					JH7110_CLK_MUX_SHIFT) + 1,
+			.flags = jh7110_clk_isp_data[idx].flags,
+		};
+		struct jh7110_clk *clk = &priv->reg[idx];
+		unsigned int i;
+		char *fw_name[4] = {
+			"u0_dom_isp_top_clk_dom_isp_top_clk_ispcore_2x",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_isp_axi",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_bist_apb",
+			"u0_dom_isp_top_clk_dom_isp_top_clk_dvp"
+		};
+
+		for (i = 0; i < init.num_parents; i++) {
+			unsigned int pidx = jh7110_clk_isp_data[idx].parents[i];
+
+			if (pidx < JH7110_CLK_ISP_REG_END)
+				parents[i].hw = &priv->reg[pidx].hw;
+			else if (pidx < JH7110_CLK_ISP_END)
+				parents[i].hw = priv->pll[PLL_OFI(pidx)];
+			else if (pidx == JH7110_ISP_TOP_CLK_ISPCORE_2X_CLKGEN)
+				parents[i].fw_name = fw_name[0];
+			else if (pidx == JH7110_ISP_TOP_CLK_ISP_AXI_CLKGEN)
+				parents[i].fw_name = fw_name[1];
+			else if (pidx == JH7110_ISP_TOP_CLK_BIST_APB_CLKGEN)
+				parents[i].fw_name = fw_name[2];
+			else if (pidx == JH7110_ISP_TOP_CLK_DVP_CLKGEN)
+				parents[i].fw_name = fw_name[3];
+		}
+
+		clk->hw.init = &init;
+		clk->idx = idx;
+		clk->max_div = max & JH7110_CLK_DIV_MASK;
+		clk->reg_flags = JH7110_CLK_ISP_FLAG;
+
+		ret = devm_clk_hw_register(priv->dev, &clk->hw);
+		if (ret)
+			goto init_failed;
+	}
+
+	ret = devm_of_clk_add_hw_provider(priv->dev, jh7110_isp_clk_get, priv);
+	if (ret)
+		goto init_failed;
+
+	pm_runtime_put_sync(&pdev->dev);
+
+	dev_info(&pdev->dev, "starfive JH7110 clk_isp init successfully.");
+	return 0;
+
+init_failed:
+	return ret;
+}
+
+static const struct of_device_id clk_starfive_jh7110_isp_match[] = {
+		{.compatible = "starfive,jh7110-clk-isp" },
+		{ }
+};
+
+static struct platform_driver clk_starfive_jh7110_isp_driver = {
+	.probe = clk_starfive_jh7110_isp_probe,
+		.driver = {
+		.name = "clk-starfive-jh7110-isp",
+		.of_match_table = clk_starfive_jh7110_isp_match,
+		.pm	= &clk_isp_pm_ops,
+	},
+};
+module_platform_driver(clk_starfive_jh7110_isp_driver);
+
+MODULE_AUTHOR("Xingyu Wu <xingyu.wu@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive JH7110 isp clock driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/clk/starfive/clk-starfive-jh7110-pll.c b/drivers/clk/starfive/clk-starfive-jh7110-pll.c
new file mode 100644
index 000000000000..e58dc4c4d32a
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110-pll.c
@@ -0,0 +1,455 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * StarFive JH7110 PLL Clock Generator Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/kernel.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/debugfs.h>
+#include <linux/init.h>
+
+#include "clk-starfive-jh7110-pll.h"
+
+static struct jh7110_clk_pll_data * __init
+		jh7110_pll_data_from(struct clk_hw *hw)
+{
+	return container_of(hw, struct jh7110_clk_pll_data, hw);
+}
+
+static unsigned long pll_calculate_freq(struct jh7110_clk_pll_data *data)
+{
+	u32 dacpd;
+	u32 dsmpd;
+	u32 fbdiv;
+	u32 prediv;
+	u32 postdiv1;
+	u32 frac;
+	unsigned long refclk;
+	u32 reg_value;
+	unsigned long frac_cal;
+	unsigned long freq;
+	struct pll_syscon_offset *offset = &data->offset;
+	struct pll_syscon_mask *mask = &data->mask;
+	struct pll_syscon_shift *shift = &data->shift;
+
+	if (regmap_read(data->sys_syscon_regmap,
+			offset->dacpd_offset, &reg_value))
+		goto read_register_error;
+	dacpd = (reg_value & mask->dacpd_mask) >> shift->dacpd_shift;
+	dev_dbg(data->dev, "pll%d read register dacpd:%d\n", data->idx, dacpd);
+
+	if (regmap_read(data->sys_syscon_regmap,
+			offset->dsmpd_offset, &reg_value))
+		goto read_register_error;
+	dsmpd = (reg_value & mask->dsmpd_mask) >> shift->dsmpd_shift;
+	dev_dbg(data->dev, "pll%d read register dsmpd:%d\n", data->idx, dsmpd);
+
+	if (regmap_read(data->sys_syscon_regmap,
+			offset->fbdiv_offset, &reg_value))
+		goto read_register_error;
+	fbdiv = (reg_value & mask->fbdiv_mask) >> shift->fbdiv_shift;
+	/* fbdiv value should be 8 to 4095 */
+	if (fbdiv < 8)
+		goto read_register_error;
+	dev_dbg(data->dev, "pll%d read register fbdiv:%d\n", data->idx, fbdiv);
+
+	if (regmap_read(data->sys_syscon_regmap,
+			offset->prediv_offset, &reg_value))
+		goto read_register_error;
+	prediv = (reg_value & mask->prediv_mask) >> shift->prediv_shift;
+	dev_dbg(data->dev, "pll%d read register prediv:%d\n", data->idx, prediv);
+
+	if (regmap_read(data->sys_syscon_regmap,
+			offset->postdiv1_offset, &reg_value))
+		goto read_register_error;
+	/* postdiv1 = 2^reg */
+	postdiv1 = 1 << ((reg_value & mask->postdiv1_mask) >>
+			shift->postdiv1_shift);
+	dev_dbg(data->dev, "pll%d read register postdiv1:%d\n",
+				data->idx, postdiv1);
+
+	if (regmap_read(data->sys_syscon_regmap,
+			offset->frac_offset, &reg_value))
+		goto read_register_error;
+	frac = (reg_value & mask->frac_mask) >> shift->frac_shift;
+	dev_dbg(data->dev, "pll%d read register frac:0x%x\n", data->idx, frac);
+
+	refclk = data->refclk_freq;
+	/* Integer Mode or Fraction Mode */
+	if ((dacpd == 1) && (dsmpd == 1))
+		frac_cal = 0;
+	else
+		frac_cal = (unsigned long) frac * FRAC_PATR_SIZE / (1 << 24);
+
+	freq = (unsigned long) refclk / FRAC_PATR_SIZE *
+		(fbdiv * FRAC_PATR_SIZE + frac_cal) / prediv / postdiv1;
+
+	dev_dbg(data->dev, "pll%d calculate freq:%ld\n", data->idx, freq);
+	return freq;
+
+read_register_error:
+	return 0;
+}
+
+static unsigned long pll_get_freq(struct jh7110_clk_pll_data *data)
+{
+	unsigned long freq;
+
+	freq = pll_calculate_freq(data);
+	if (freq == 0) {
+		dev_err(data->dev, "PLL calculate error or read syscon error.\n");
+		return 0;
+	}
+
+	return freq;
+}
+
+static int pll_select_freq_syscon(struct jh7110_clk_pll_data *data,
+				unsigned long target_rate)
+{
+	unsigned int id;
+	unsigned int pll_arry_size;
+	const struct starfive_pll_syscon_value *syscon_value;
+
+	if (data->idx == PLL0_INDEX)
+		pll_arry_size = ARRAY_SIZE(jh7110_pll0_syscon_freq);
+	else if (data->idx == PLL1_INDEX)
+		pll_arry_size = ARRAY_SIZE(jh7110_pll1_syscon_freq);
+	else
+		pll_arry_size = ARRAY_SIZE(jh7110_pll2_syscon_freq);
+
+	for (id = 0; id < pll_arry_size; id++) {
+		if (data->idx == PLL0_INDEX)
+			syscon_value = &jh7110_pll0_syscon_freq[id];
+		else if (data->idx == PLL1_INDEX)
+			syscon_value = &jh7110_pll1_syscon_freq[id];
+		else
+			syscon_value = &jh7110_pll2_syscon_freq[id];
+
+		if (target_rate == syscon_value->freq)
+			goto select_end;
+	}
+
+	dev_err(data->dev, "pll%d frequency:%ld do not match, please check it.\n",
+			data->idx, target_rate);
+	return -EINVAL;
+
+select_end:
+	data->freq_select_idx = id;
+	return 0;
+}
+
+static int pll_set_freq_syscon(struct jh7110_clk_pll_data *data)
+{
+	int ret;
+	const struct starfive_pll_syscon_value *syscon_value;
+	unsigned int freq_idx = data->freq_select_idx;
+	struct pll_syscon_offset *offset = &data->offset;
+	struct pll_syscon_mask *mask = &data->mask;
+	struct pll_syscon_shift *shift = &data->shift;
+
+	if (data->idx == PLL0_INDEX)
+		syscon_value = &jh7110_pll0_syscon_freq[freq_idx];
+	else if (data->idx == PLL1_INDEX)
+		syscon_value = &jh7110_pll1_syscon_freq[freq_idx];
+	else
+		syscon_value = &jh7110_pll2_syscon_freq[freq_idx];
+
+	dev_dbg(data->dev, "dacpd:offset=0x%x, mask=0x%x, shift=%d, value=%d\n",
+			offset->dacpd_offset, mask->dacpd_mask,
+			shift->dacpd_shift, syscon_value->dacpd);
+	ret = regmap_update_bits(data->sys_syscon_regmap, offset->dacpd_offset,
+		mask->dacpd_mask, (syscon_value->dacpd << shift->dacpd_shift));
+	if (ret)
+		goto set_failed;
+	dev_dbg(data->dev, "dsmpd:offset=%x, mask=%x, shift=%d, value=%d\n",
+			offset->dsmpd_offset, mask->dsmpd_mask,
+			shift->dsmpd_shift, syscon_value->dsmpd);
+	ret = regmap_update_bits(data->sys_syscon_regmap, offset->dsmpd_offset,
+		mask->dsmpd_mask, (syscon_value->dsmpd << shift->dsmpd_shift));
+	if (ret)
+		goto set_failed;
+
+	dev_dbg(data->dev, "prediv:offset=%x, mask=%x, shift=%d, value=%d\n",
+			offset->prediv_offset, mask->prediv_mask,
+			shift->prediv_shift, syscon_value->prediv);
+	ret = regmap_update_bits(data->sys_syscon_regmap, offset->prediv_offset,
+		mask->prediv_mask, (syscon_value->prediv << shift->prediv_shift));
+	if (ret)
+		goto set_failed;
+
+	dev_dbg(data->dev, "fbdiv:offset=%x, mask=%x, shift=%d, value=%d\n",
+			offset->fbdiv_offset, mask->fbdiv_mask,
+			shift->fbdiv_shift, syscon_value->fbdiv);
+	ret = regmap_update_bits(data->sys_syscon_regmap, offset->fbdiv_offset,
+		mask->fbdiv_mask, (syscon_value->fbdiv << shift->fbdiv_shift));
+	if (ret)
+		goto set_failed;
+
+	dev_dbg(data->dev, "postdiv:offset=0x%x, mask=0x%x, shift=%d, value=%d\n",
+			offset->postdiv1_offset, mask->postdiv1_mask,
+			shift->postdiv1_shift, syscon_value->postdiv1);
+	ret = regmap_update_bits(data->sys_syscon_regmap,
+		offset->postdiv1_offset, mask->postdiv1_mask,
+		((syscon_value->postdiv1 >> 1) << shift->postdiv1_shift));
+	if (ret)
+		goto set_failed;
+	/* frac */
+	if ((syscon_value->dacpd == 0) && (syscon_value->dsmpd == 0)) {
+		dev_dbg(data->dev, "frac:offset=0x%x mask=0x%x shift=%d value=0x%x\n",
+			offset->frac_offset, mask->frac_mask,
+			shift->frac_shift, syscon_value->frac);
+		ret = regmap_update_bits(data->sys_syscon_regmap, offset->frac_offset,
+				mask->frac_mask, (syscon_value->frac << shift->frac_shift));
+		if (ret)
+			goto set_failed;
+	}
+
+	dev_dbg(data->dev, "pll%d set syscon register done and rate is %ld\n",
+				data->idx, syscon_value->freq);
+	return 0;
+
+set_failed:
+	dev_err(data->dev, "pll set syscon failed:%d\n", ret);
+	return ret;
+}
+
+static unsigned long jh7110_clk_pll_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct jh7110_clk_pll_data *data = jh7110_pll_data_from(hw);
+
+	return pll_get_freq(data);
+}
+
+static int jh7110_clk_pll_determine_rate(struct clk_hw *hw,
+					struct clk_rate_request *req)
+{
+	int ret;
+	struct jh7110_clk_pll_data *data = jh7110_pll_data_from(hw);
+
+	ret = pll_select_freq_syscon(data, req->rate);
+	if (ret)
+		return ret;
+
+	if (data->idx == PLL0_INDEX)
+		req->rate = jh7110_pll0_syscon_freq[data->freq_select_idx].freq;
+	else if (data->idx == PLL1_INDEX)
+		req->rate = jh7110_pll1_syscon_freq[data->freq_select_idx].freq;
+	else
+		req->rate = jh7110_pll2_syscon_freq[data->freq_select_idx].freq;
+
+	return 0;
+}
+
+static int jh7110_clk_pll_set_rate(struct clk_hw *hw,
+				unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct jh7110_clk_pll_data *data = jh7110_pll_data_from(hw);
+
+	return pll_set_freq_syscon(data);
+
+}
+
+#ifdef CONFIG_DEBUG_FS
+static void jh7110_clk_pll_debug_init(struct clk_hw *hw,
+				struct dentry *dentry)
+{
+	static const struct debugfs_reg32 jh7110_clk_pll_reg = {
+		.name = "CTRL",
+		.offset = 0,
+	};
+	struct jh7110_clk_pll_data *data = jh7110_pll_data_from(hw);
+	struct debugfs_regset32 *regset;
+
+	regset = devm_kzalloc(data->dev, sizeof(*regset), GFP_KERNEL);
+	if (!regset)
+		return;
+
+	regset->regs = &jh7110_clk_pll_reg;
+	regset->nregs = 1;
+
+	debugfs_create_regset32("registers", 0400, dentry, regset);
+}
+#else
+#define jh7110_clk_debug_init NULL
+#endif
+
+static const struct clk_ops jh7110_clk_pll_ops = {
+	.recalc_rate = jh7110_clk_pll_recalc_rate,
+	.determine_rate = jh7110_clk_pll_determine_rate,
+	.set_rate = jh7110_clk_pll_set_rate,
+	.debug_init = jh7110_clk_pll_debug_init,
+};
+
+static int pll_data_offset_get(struct jh7110_clk_pll_data *data,
+			struct of_phandle_args *args, int index)
+{
+	struct pll_syscon_offset *offset = &data->offset;
+	struct pll_syscon_mask *mask = &data->mask;
+	struct pll_syscon_shift *shift = &data->shift;
+
+	if (index == PLL0_INDEX) {
+		offset->dacpd_offset = args->args[0];
+		offset->dsmpd_offset = args->args[0];
+		offset->fbdiv_offset = args->args[1];
+		offset->frac_offset = args->args[2];
+		offset->prediv_offset = args->args[3];
+		offset->postdiv1_offset = args->args[2];
+
+		mask->dacpd_mask = PLL0_DACPD_MASK;
+		mask->dsmpd_mask = PLL0_DSMPD_MASK;
+		mask->fbdiv_mask = PLL0_FBDIV_MASK;
+		mask->frac_mask = PLL0_FRAC_MASK;
+		mask->prediv_mask = PLL0_PREDIV_MASK;
+		mask->postdiv1_mask = PLL0_POSTDIV1_MASK;
+
+		shift->dacpd_shift = PLL0_DACPD_SHIFT;
+		shift->dsmpd_shift = PLL0_DSMPD_SHIFT;
+		shift->fbdiv_shift = PLL0_FBDIV_SHIFT;
+		shift->frac_shift = PLL0_FRAC_SHIFT;
+		shift->prediv_shift = PLL0_PREDIV_SHIFT;
+		shift->postdiv1_shift = PLL0_POSTDIV1_SHIFT;
+	} else if (index == PLL1_INDEX) {
+		offset->dacpd_offset = args->args[3];
+		offset->dsmpd_offset = args->args[3];
+		offset->fbdiv_offset = args->args[3];
+		offset->frac_offset = args->args[4];
+		offset->prediv_offset = args->args[5];
+		offset->postdiv1_offset = args->args[4];
+
+		mask->dacpd_mask = PLL1_DACPD_MASK;
+		mask->dsmpd_mask = PLL1_DSMPD_MASK;
+		mask->fbdiv_mask = PLL1_FBDIV_MASK;
+		mask->frac_mask = PLL1_FRAC_MASK;
+		mask->prediv_mask = PLL1_PREDIV_MASK;
+		mask->postdiv1_mask = PLL1_POSTDIV1_MASK;
+
+		shift->dacpd_shift = PLL1_DACPD_SHIFT;
+		shift->dsmpd_shift = PLL1_DSMPD_SHIFT;
+		shift->fbdiv_shift = PLL1_FBDIV_SHIFT;
+		shift->frac_shift = PLL1_FRAC_SHIFT;
+		shift->prediv_shift = PLL1_PREDIV_SHIFT;
+		shift->postdiv1_shift = PLL1_POSTDIV1_SHIFT;
+	} else if (index == PLL2_INDEX) {
+		offset->dacpd_offset = args->args[5];
+		offset->dsmpd_offset = args->args[5];
+		offset->fbdiv_offset = args->args[5];
+		offset->frac_offset = args->args[6];
+		offset->prediv_offset = args->args[7];
+		offset->postdiv1_offset = args->args[6];
+
+		mask->dacpd_mask = PLL2_DACPD_MASK;
+		mask->dsmpd_mask = PLL2_DSMPD_MASK;
+		mask->fbdiv_mask = PLL2_FBDIV_MASK;
+		mask->frac_mask = PLL2_FRAC_MASK;
+		mask->prediv_mask = PLL2_PREDIV_MASK;
+		mask->postdiv1_mask = PLL2_POSTDIV1_MASK;
+
+		shift->dacpd_shift = PLL2_DACPD_SHIFT;
+		shift->dsmpd_shift = PLL2_DSMPD_SHIFT;
+		shift->fbdiv_shift = PLL2_FBDIV_SHIFT;
+		shift->frac_shift = PLL2_FRAC_SHIFT;
+		shift->prediv_shift = PLL2_PREDIV_SHIFT;
+		shift->postdiv1_shift = PLL2_POSTDIV1_SHIFT;
+	} else
+		return -ENOENT;
+
+	return 0;
+}
+
+int __init clk_starfive_jh7110_pll_init(struct platform_device *pdev,
+			struct jh7110_clk_pll_data *pll_priv)
+{
+	int ret;
+	struct of_phandle_args args;
+	struct regmap *pll_syscon_regmap;
+	unsigned int idx;
+	struct clk *osc_clk;
+	unsigned long refclk_freq;
+	struct jh7110_clk_pll_data *data;
+	char *pll_name[3] = {
+		"pll0_out",
+		"pll1_out",
+		"pll2_out"
+	};
+
+	ret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+				"starfive,sys-syscon", 8, 0, &args);
+	if (ret) {
+		dev_warn(&pdev->dev, "Failed to parse starfive,sys-syscon\n");
+		goto pll_init_failed;
+	}
+
+	pll_syscon_regmap = syscon_node_to_regmap(args.np);
+	of_node_put(args.np);
+	if (IS_ERR(pll_syscon_regmap)) {
+		ret = PTR_ERR(pll_syscon_regmap);
+		goto pll_init_failed;
+	}
+
+	osc_clk = clk_get(&pdev->dev, "osc");
+	if (!IS_ERR(osc_clk)) {
+		refclk_freq = clk_get_rate(osc_clk);
+		clk_put(osc_clk);
+	} else {
+		ret = PTR_ERR(osc_clk);
+		dev_err(&pdev->dev, "get osc clk failed :%d.\n", ret);
+		goto pll_init_failed;
+	}
+
+	for (idx = 0; idx < PLL_INDEX_MAX; idx++) {
+		struct clk_parent_data parents = {
+			.fw_name = "osc",
+		};
+		struct clk_init_data init = {
+			.name = pll_name[idx],
+			.ops = &jh7110_clk_pll_ops,
+			.parent_data = &parents,
+			.num_parents = 1,
+			.flags = 0,
+		};
+
+		data = &pll_priv[idx];
+		data->dev = &pdev->dev;
+		data->sys_syscon_regmap = pll_syscon_regmap;
+
+		ret = pll_data_offset_get(data, &args, idx);
+		if (ret)
+			goto pll_init_failed;
+
+		data->hw.init = &init;
+		data->idx = idx;
+		data->refclk_freq = refclk_freq;
+
+		ret = devm_clk_hw_register(&pdev->dev, &data->hw);
+		if (ret)
+			return ret;
+	}
+
+	dev_dbg(&pdev->dev, "PLL0, PLL1 and PLL2 clock registered done\n");
+
+/* Change PLL2 rate before other driver up */
+	if (PLL2_DEFAULT_FREQ) {
+		struct clk *pll2_clk = pll_priv[PLL2_INDEX].hw.clk;
+
+		if (clk_set_rate(pll2_clk, PLL2_DEFAULT_FREQ))
+			dev_info(&pdev->dev, "set pll2 failed\n");
+	}
+
+	return 0;
+
+pll_init_failed:
+	return ret;
+}
+
+
+
diff --git a/drivers/clk/starfive/clk-starfive-jh7110-pll.h b/drivers/clk/starfive/clk-starfive-jh7110-pll.h
new file mode 100644
index 000000000000..87843181ecf8
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110-pll.h
@@ -0,0 +1,273 @@
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
+/*
+ * StarFive JH7110 PLL Clock Generator Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#ifndef _CLK_STARFIVE_JH7110_PLL_H_
+#define _CLK_STARFIVE_JH7110_PLL_H_
+
+/*
+ * If set PLL2_DEFAULT_FREQ NULL of 0 , then PLL2 frequency is original.
+ * If set PLL2_DEFAULT_FREQ one of 'starfive_pll2_freq_value', then PLL2
+ * frequency will be set the new rate during clock tree registering.
+ */
+#define PLL0_DEFAULT_FREQ	PLL0_FREQ_1500_VALUE
+#define PLL2_DEFAULT_FREQ	PLL2_FREQ_1188_VALUE
+
+#define PLL0_INDEX		0
+#define PLL1_INDEX		1
+#define PLL2_INDEX		2
+
+#define PLL_INDEX_MAX	3
+
+#define PLL0_DACPD_SHIFT	24
+#define PLL0_DACPD_MASK		0x1000000
+#define PLL0_DSMPD_SHIFT	25
+#define PLL0_DSMPD_MASK		0x2000000
+#define PLL0_FBDIV_SHIFT	0
+#define PLL0_FBDIV_MASK		0xFFF
+#define PLL0_FRAC_SHIFT		0
+#define PLL0_FRAC_MASK		0xFFFFFF
+#define PLL0_POSTDIV1_SHIFT	28
+#define PLL0_POSTDIV1_MASK	0x30000000
+#define PLL0_PREDIV_SHIFT	0
+#define PLL0_PREDIV_MASK	0x3F
+
+#define PLL1_DACPD_SHIFT	15
+#define PLL1_DACPD_MASK		0x8000
+#define PLL1_DSMPD_SHIFT	16
+#define PLL1_DSMPD_MASK		0x10000
+#define PLL1_FBDIV_SHIFT	17
+#define PLL1_FBDIV_MASK		0x1FFE0000
+#define PLL1_FRAC_SHIFT		0
+#define PLL1_FRAC_MASK		0xFFFFFF
+#define PLL1_POSTDIV1_SHIFT	28
+#define PLL1_POSTDIV1_MASK	0x30000000
+#define PLL1_PREDIV_SHIFT	0
+#define PLL1_PREDIV_MASK	0x3F
+
+#define PLL2_DACPD_SHIFT	15
+#define PLL2_DACPD_MASK		0x8000
+#define PLL2_DSMPD_SHIFT	16
+#define PLL2_DSMPD_MASK		0x10000
+#define PLL2_FBDIV_SHIFT	17
+#define PLL2_FBDIV_MASK		0x1FFE0000
+#define PLL2_FRAC_SHIFT		0
+#define PLL2_FRAC_MASK		0xFFFFFF
+#define PLL2_POSTDIV1_SHIFT	28
+#define PLL2_POSTDIV1_MASK	0x30000000
+#define PLL2_PREDIV_SHIFT	0
+#define PLL2_PREDIV_MASK	0x3F
+
+#define FRAC_PATR_SIZE		1000
+
+struct pll_syscon_offset {
+	u32 dacpd_offset;
+	u32 dsmpd_offset;
+	u32 fbdiv_offset;
+	u32 frac_offset;
+	u32 prediv_offset;
+	u32 postdiv1_offset;
+};
+
+struct pll_syscon_mask {
+	u32 dacpd_mask;
+	u32 dsmpd_mask;
+	u32 fbdiv_mask;
+	u32 frac_mask;
+	u32 prediv_mask;
+	u32 postdiv1_mask;
+};
+
+struct pll_syscon_shift {
+	u32 dacpd_shift;
+	u32 dsmpd_shift;
+	u32 fbdiv_shift;
+	u32 frac_shift;
+	u32 prediv_shift;
+	u32 postdiv1_shift;
+};
+
+struct jh7110_clk_pll_data {
+	struct device *dev;
+	struct clk_hw hw;
+	unsigned long refclk_freq;
+	unsigned int idx;
+	unsigned int freq_select_idx;
+
+	struct regmap *sys_syscon_regmap;
+	struct pll_syscon_offset offset;
+	struct pll_syscon_mask mask;
+	struct pll_syscon_shift shift;
+};
+
+struct starfive_pll_syscon_value {
+	unsigned long freq;
+	u32 prediv;
+	u32 fbdiv;
+	u32 postdiv1;
+/* Both daxpd and dsmpd set 1 while integer multiple mode */
+/* Both daxpd and dsmpd set 0 while fraction multiple mode */
+	u32 dacpd;
+	u32 dsmpd;
+/* frac value should be decimals multiplied by 2^24 */
+	u32 frac;
+};
+
+enum starfive_pll0_freq_value {
+	PLL0_FREQ_375_VALUE = 375000000,
+	PLL0_FREQ_500_VALUE = 500000000,
+	PLL0_FREQ_625_VALUE = 625000000,
+	PLL0_FREQ_750_VALUE = 750000000,
+	PLL0_FREQ_875_VALUE = 875000000,
+	PLL0_FREQ_1000_VALUE = 1000000000,
+	PLL0_FREQ_1250_VALUE = 1250000000,
+	PLL0_FREQ_1375_VALUE = 1375000000,
+	PLL0_FREQ_1500_VALUE = 1500000000
+};
+
+enum starfive_pll0_freq {
+	PLL0_FREQ_375 = 0,
+	PLL0_FREQ_500,
+	PLL0_FREQ_625,
+	PLL0_FREQ_750,
+	PLL0_FREQ_875,
+	PLL0_FREQ_1000,
+	PLL0_FREQ_1250,
+	PLL0_FREQ_1375,
+	PLL0_FREQ_1500,
+	PLL0_FREQ_MAX = PLL0_FREQ_1500
+};
+
+enum starfive_pll1_freq_value {
+	PLL1_FREQ_1066_VALUE = 1066000000,
+};
+
+enum starfive_pll1_freq {
+	PLL1_FREQ_1066 = 0,
+};
+
+enum starfive_pll2_freq_value {
+	PLL2_FREQ_1188_VALUE = 1188000000,
+	PLL2_FREQ_12288_VALUE = 1228800000,
+};
+
+enum starfive_pll2_freq {
+	PLL2_FREQ_1188 = 0,
+	PLL2_FREQ_12288,
+};
+
+static const struct starfive_pll_syscon_value
+	jh7110_pll0_syscon_freq[] = {
+	[PLL0_FREQ_375] = {
+		.freq = PLL0_FREQ_375_VALUE,
+		.prediv = 8,
+		.fbdiv = 125,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL0_FREQ_500] = {
+		.freq = PLL0_FREQ_500_VALUE,
+		.prediv = 6,
+		.fbdiv = 125,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL0_FREQ_625] = {
+		.freq = PLL0_FREQ_625_VALUE,
+		.prediv = 24,
+		.fbdiv = 625,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL0_FREQ_750] = {
+		.freq = PLL0_FREQ_750_VALUE,
+		.prediv = 4,
+		.fbdiv = 125,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL0_FREQ_875] = {
+		.freq = PLL0_FREQ_875_VALUE,
+		.prediv = 24,
+		.fbdiv = 875,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL0_FREQ_1000] = {
+		.freq = PLL0_FREQ_1000_VALUE,
+		.prediv = 3,
+		.fbdiv = 125,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL0_FREQ_1250] = {
+		.freq = PLL0_FREQ_1250_VALUE,
+		.prediv = 12,
+		.fbdiv = 625,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL0_FREQ_1375] = {
+		.freq = PLL0_FREQ_1375_VALUE,
+		.prediv = 24,
+		.fbdiv = 1375,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL0_FREQ_1500] = {
+		.freq = PLL0_FREQ_1500_VALUE,
+		.prediv = 2,
+		.fbdiv = 125,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+};
+
+static const struct starfive_pll_syscon_value
+	jh7110_pll1_syscon_freq[] = {
+	[PLL1_FREQ_1066] = {
+		.freq = PLL1_FREQ_1066_VALUE,
+		.prediv = 12,
+		.fbdiv = 533,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+};
+
+static const struct starfive_pll_syscon_value
+	jh7110_pll2_syscon_freq[] = {
+	[PLL2_FREQ_1188] = {
+		.freq = PLL2_FREQ_1188_VALUE,
+		.prediv = 2,
+		.fbdiv = 99,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+	[PLL2_FREQ_12288] = {
+		.freq = PLL2_FREQ_12288_VALUE,
+		.prediv = 5,
+		.fbdiv = 256,
+		.postdiv1 = 1,
+		.dacpd = 1,
+		.dsmpd = 1,
+	},
+};
+
+int __init clk_starfive_jh7110_pll_init(struct platform_device *pdev,
+				struct jh7110_clk_pll_data *pll_priv);
+
+#endif
diff --git a/drivers/clk/starfive/clk-starfive-jh7110-stg.c b/drivers/clk/starfive/clk-starfive-jh7110-stg.c
new file mode 100755
index 000000000000..d47b04e0fbc9
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110-stg.c
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * StarFive JH7110 stg Clock Generator Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <dt-bindings/clock/starfive-jh7110-clkgen.h>
+#include "clk-starfive-jh7110.h"
+
+/* external clocks */
+#define JH7110_OSC				(JH7110_CLK_END + 0)
+
+static const struct jh7110_clk_data jh7110_clk_stg_data[] __initconst = {
+	//hifi4
+	JH7110_GATE(JH7110_HIFI4_CLK_CORE, "u0_hifi4_clk_core",
+			GATE_FLAG_NORMAL, JH7110_HIFI4_CORE),
+	//usb
+	JH7110_GATE(JH7110_USB0_CLK_USB_APB, "u0_cdn_usb_clk_usb_apb",
+			GATE_FLAG_NORMAL, JH7110_STG_APB),
+	JH7110_GATE(JH7110_USB0_CLK_UTMI_APB, "u0_cdn_usb_clk_utmi_apb",
+			GATE_FLAG_NORMAL, JH7110_STG_APB),
+	JH7110_GATE(JH7110_USB0_CLK_AXI, "u0_cdn_usb_clk_axi",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	JH7110_GDIV(JH7110_USB0_CLK_LPM, "u0_cdn_usb_clk_lpm",
+			GATE_FLAG_NORMAL, 2, JH7110_OSC),
+	JH7110_GDIV(JH7110_USB0_CLK_STB, "u0_cdn_usb_clk_stb",
+			GATE_FLAG_NORMAL, 4, JH7110_OSC),
+	JH7110_GATE(JH7110_USB0_CLK_APP_125, "u0_cdn_usb_clk_app_125",
+			GATE_FLAG_NORMAL, JH7110_USB_125M),
+	JH7110__DIV(JH7110_USB0_REFCLK, "u0_cdn_usb_refclk", 2, JH7110_OSC),
+	//pci-e
+	JH7110_GATE(JH7110_PCIE0_CLK_AXI_MST0, "u0_plda_pcie_clk_axi_mst0",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_PCIE0_CLK_APB, "u0_plda_pcie_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_STG_APB),
+	JH7110_GATE(JH7110_PCIE0_CLK_TL, "u0_plda_pcie_clk_tl",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_PCIE1_CLK_AXI_MST0, "u1_plda_pcie_clk_axi_mst0",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_PCIE1_CLK_APB, "u1_plda_pcie_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_STG_APB),
+	JH7110_GATE(JH7110_PCIE1_CLK_TL, "u1_plda_pcie_clk_tl",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_PCIE01_SLV_DEC_MAINCLK, "u0_pcie01_slv_dec_mainclk",
+			CLK_IGNORE_UNUSED, JH7110_STG_AXIAHB),
+	//security
+	JH7110_GATE(JH7110_SEC_HCLK, "u0_sec_top_hclk",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_SEC_MISCAHB_CLK, "u0_sec_top_miscahb_clk",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	//stg mtrx
+	JH7110_GATE(JH7110_STG_MTRX_GRP0_CLK_MAIN, "u0_stg_mtrx_grp0_clk_main",
+			CLK_IGNORE_UNUSED, JH7110_CPU_BUS),
+	JH7110_GATE(JH7110_STG_MTRX_GRP0_CLK_BUS, "u0_stg_mtrx_grp0_clk_bus",
+			CLK_IGNORE_UNUSED, JH7110_NOCSTG_BUS),
+	JH7110_GATE(JH7110_STG_MTRX_GRP0_CLK_STG, "u0_stg_mtrx_grp0_clk_stg",
+			CLK_IGNORE_UNUSED, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_STG_MTRX_GRP1_CLK_MAIN, "u0_stg_mtrx_grp1_clk_main",
+			CLK_IGNORE_UNUSED, JH7110_CPU_BUS),
+	JH7110_GATE(JH7110_STG_MTRX_GRP1_CLK_BUS, "u0_stg_mtrx_grp1_clk_bus",
+			CLK_IGNORE_UNUSED, JH7110_NOCSTG_BUS),
+	JH7110_GATE(JH7110_STG_MTRX_GRP1_CLK_STG, "u0_stg_mtrx_grp1_clk_stg",
+			CLK_IGNORE_UNUSED, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_STG_MTRX_GRP1_CLK_HIFI, "u0_stg_mtrx_grp1_clk_hifi",
+			CLK_IGNORE_UNUSED, JH7110_HIFI4_AXI),
+	//e24_rvpi
+	JH7110_GDIV(JH7110_E2_RTC_CLK, "u0_e2_sft7110_rtc_clk",
+			GATE_FLAG_NORMAL, 24, JH7110_OSC),
+	JH7110_GATE(JH7110_E2_CLK_CORE, "u0_e2_sft7110_clk_core",
+			CLK_IGNORE_UNUSED, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_E2_CLK_DBG, "u0_e2_sft7110_clk_dbg",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	//dw_sgdma1p
+	JH7110_GATE(JH7110_DMA1P_CLK_AXI, "u0_dw_dma1p_8ch_56hs_clk_axi",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_DMA1P_CLK_AHB, "u0_dw_dma1p_8ch_56hs_clk_ahb",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+};
+
+int __init clk_starfive_jh7110_stg_init(struct platform_device *pdev,
+						struct jh7110_clk_priv *priv)
+{
+	unsigned int idx;
+	int ret = 0;
+
+	priv->stg_base = devm_platform_ioremap_resource_byname(pdev, "stg");
+	if (IS_ERR(priv->stg_base))
+		return PTR_ERR(priv->stg_base);
+
+	priv->pll[PLL_OF(JH7110_PCIE0_CLK_AXI_SLV0)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_plda_pcie_clk_axi_slv0",
+			"u0_plda_pcie_clk_axi_mst0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCIE0_CLK_AXI_SLV)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_plda_pcie_clk_axi_slv",
+			"u0_plda_pcie_clk_axi_mst0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCIE0_CLK_OSC)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_plda_pcie_clk_osc", "osc", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCIE1_CLK_AXI_SLV0)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_plda_pcie_clk_axi_slv0",
+			"u1_plda_pcie_clk_axi_mst0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCIE1_CLK_AXI_SLV)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_plda_pcie_clk_axi_slv",
+			"u1_plda_pcie_clk_axi_mst0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCIE1_CLK_OSC)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_plda_pcie_clk_osc", "osc", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_E2_IRQ_SYNC_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_e2_sft7110_irq_sync_clk_core",
+			"stg_axiahb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_STG_CRG_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_stg_crg_pclk", "stg_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_STG_SYSCON_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_stg_syscon_pclk", "stg_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_STG_APB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"stg_apb", "apb_bus", 0, 1, 1);
+
+	for (idx = JH7110_CLK_SYS_REG_END; idx < JH7110_CLK_STG_REG_END; idx++) {
+		u32 max = jh7110_clk_stg_data[idx].max;
+		struct clk_parent_data parents[4] = {};
+		struct clk_init_data init = {
+			.name = jh7110_clk_stg_data[idx].name,
+			.ops = starfive_jh7110_clk_ops(max),
+			.parent_data = parents,
+			.num_parents = ((max & JH7110_CLK_MUX_MASK) >>
+				JH7110_CLK_MUX_SHIFT) + 1,
+			.flags = jh7110_clk_stg_data[idx].flags,
+		};
+		struct jh7110_clk *clk = &priv->reg[idx];
+		unsigned int i;
+
+		for (i = 0; i < init.num_parents; i++) {
+			unsigned int pidx = jh7110_clk_stg_data[idx].parents[i];
+
+			if (pidx < JH7110_CLK_REG_END )
+				parents[i].hw = &priv->reg[pidx].hw;
+			else if ((pidx < JH7110_CLK_STG_END) &&
+				(pidx > (JH7110_CLK_SYS_END - 1)))
+				parents[i].hw = priv->pll[PLL_OF(pidx)];
+			else if (pidx == JH7110_OSC)
+				parents[i].fw_name = "osc";
+		}
+
+		clk->hw.init = &init;
+		clk->idx = idx;
+		clk->max_div = max & JH7110_CLK_DIV_MASK;
+		clk->reg_flags = JH7110_CLK_STG_FLAG;
+
+		ret = devm_clk_hw_register(priv->dev, &clk->hw);
+		if (ret)
+			return ret;
+	}
+
+	dev_dbg(&pdev->dev, "starfive JH7110 clk_stg init successfully.");
+	return 0;
+}
diff --git a/drivers/clk/starfive/clk-starfive-jh7110-sys.c b/drivers/clk/starfive/clk-starfive-jh7110-sys.c
new file mode 100644
index 000000000000..8f94e61957fa
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110-sys.c
@@ -0,0 +1,845 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * StarFive JH7110 sys Clock Generator Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include <dt-bindings/clock/starfive-jh7110-clkgen.h>
+#include "clk-starfive-jh7110.h"
+
+/* sys external clocks */
+#define JH7110_OSC				(JH7110_CLK_END + 0)
+#define JH7110_GMAC1_RMII_REFIN			(JH7110_CLK_END + 1)
+#define JH7110_GMAC1_RGMII_RXIN			(JH7110_CLK_END + 2)
+#define JH7110_I2STX_BCLK_EXT			(JH7110_CLK_END + 3)
+#define JH7110_I2STX_LRCK_EXT			(JH7110_CLK_END + 4)
+#define JH7110_I2SRX_BCLK_EXT			(JH7110_CLK_END + 5)
+#define JH7110_I2SRX_LRCK_EXT			(JH7110_CLK_END + 6)
+#define JH7110_TDM_EXT				(JH7110_CLK_END + 7)
+#define JH7110_MCLK_EXT				(JH7110_CLK_END + 8)
+#define JH7110_JTAG_TCK_INNER			(JH7110_CLK_END + 9)
+#define JH7110_BIST_APB				(JH7110_CLK_END + 10)
+
+static const struct jh7110_clk_data jh7110_clk_sys_data[] __initconst = {
+	/*root*/
+	JH7110__MUX(JH7110_CPU_ROOT, "cpu_root", PARENT_NUMS_2,
+			JH7110_OSC,
+			JH7110_PLL0_OUT),
+	JH7110__DIV(JH7110_CPU_CORE, "cpu_core", 7, JH7110_CPU_ROOT),
+	JH7110__DIV(JH7110_CPU_BUS, "cpu_bus", 2, JH7110_CPU_CORE),
+	JH7110__MUX(JH7110_GPU_ROOT, "gpu_root", PARENT_NUMS_2,
+			JH7110_PLL2_OUT,
+			JH7110_PLL1_OUT),
+	JH7110_MDIV(JH7110_PERH_ROOT, "perh_root", 2, PARENT_NUMS_2,
+			JH7110_PLL0_OUT,
+			JH7110_PLL2_OUT),
+	JH7110__MUX(JH7110_BUS_ROOT, "bus_root", PARENT_NUMS_2,
+			JH7110_OSC,
+			JH7110_PLL2_OUT),
+	JH7110__DIV(JH7110_NOCSTG_BUS, "nocstg_bus", 3, JH7110_BUS_ROOT),
+	JH7110__DIV(JH7110_AXI_CFG0, "axi_cfg0", 3, JH7110_BUS_ROOT),
+	JH7110__DIV(JH7110_STG_AXIAHB, "stg_axiahb", 2, JH7110_AXI_CFG0),
+	JH7110_GATE(JH7110_AHB0, "ahb0", CLK_IS_CRITICAL, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_AHB1, "ahb1", CLK_IS_CRITICAL, JH7110_STG_AXIAHB),
+	JH7110__DIV(JH7110_APB_BUS_FUNC, "apb_bus_func",
+			8, JH7110_STG_AXIAHB),
+	JH7110_GATE(JH7110_APB0, "apb0", CLK_IS_CRITICAL, JH7110_APB_BUS),
+	JH7110__DIV(JH7110_PLL0_DIV2, "pll0_div2", 2, JH7110_PLL0_OUT),
+	JH7110__DIV(JH7110_PLL1_DIV2, "pll1_div2", 2, JH7110_PLL1_OUT),
+	JH7110__DIV(JH7110_PLL2_DIV2, "pll2_div2", 2, JH7110_PLL2_OUT),
+	JH7110__DIV(JH7110_AUDIO_ROOT, "audio_root", 8, JH7110_PLL2_OUT),
+	JH7110__DIV(JH7110_MCLK_INNER, "mclk_inner", 64, JH7110_AUDIO_ROOT),
+	JH7110__MUX(JH7110_MCLK, "mclk", PARENT_NUMS_2,
+			JH7110_MCLK_INNER,
+			JH7110_MCLK_EXT),
+	JH7110_GATE(JH7110_MCLK_OUT, "mclk_out", GATE_FLAG_NORMAL,
+			JH7110_MCLK_INNER),
+	JH7110_MDIV(JH7110_ISP_2X, "isp_2x", 8, PARENT_NUMS_2,
+			JH7110_PLL2_OUT,
+			JH7110_PLL1_OUT),
+	JH7110__DIV(JH7110_ISP_AXI, "isp_axi", 4, JH7110_ISP_2X),
+	JH7110_GDIV(JH7110_GCLK0, "gclk0", GATE_FLAG_NORMAL,
+			62, JH7110_PLL0_DIV2),
+	JH7110_GDIV(JH7110_GCLK1, "gclk1", GATE_FLAG_NORMAL,
+			62, JH7110_PLL1_DIV2),
+	JH7110_GDIV(JH7110_GCLK2, "gclk2", GATE_FLAG_NORMAL,
+			62, JH7110_PLL2_DIV2),
+	/*u0_u7mc_sft7110*/
+	JH7110_GATE(JH7110_U7_CORE_CLK, "u0_u7mc_sft7110_core_clk",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_CORE_CLK1, "u0_u7mc_sft7110_core_clk1",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_CORE_CLK2, "u0_u7mc_sft7110_core_clk2",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_CORE_CLK3, "u0_u7mc_sft7110_core_clk3",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_CORE_CLK4, "u0_u7mc_sft7110_core_clk4",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_DEBUG_CLK, "u0_u7mc_sft7110_debug_clk",
+			CLK_IGNORE_UNUSED, JH7110_CPU_BUS),
+	JH7110__DIV(JH7110_U7_RTC_TOGGLE, "u0_u7mc_sft7110_rtc_toggle",
+			6, JH7110_OSC),
+	JH7110_GATE(JH7110_U7_TRACE_CLK0, "u0_u7mc_sft7110_trace_clk0",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_TRACE_CLK1, "u0_u7mc_sft7110_trace_clk1",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_TRACE_CLK2, "u0_u7mc_sft7110_trace_clk2",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_TRACE_CLK3, "u0_u7mc_sft7110_trace_clk3",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_TRACE_CLK4, "u0_u7mc_sft7110_trace_clk4",
+			CLK_IGNORE_UNUSED, JH7110_CPU_CORE),
+	JH7110_GATE(JH7110_U7_TRACE_COM_CLK, "u0_u7mc_sft7110_trace_com_clk",
+			CLK_IGNORE_UNUSED, JH7110_CPU_BUS),
+	//NOC
+	JH7110_GATE(JH7110_NOC_BUS_CLK_CPU_AXI,
+			"u0_sft7110_noc_bus_clk_cpu_axi",
+			CLK_IS_CRITICAL, JH7110_CPU_BUS),
+	JH7110_GATE(JH7110_NOC_BUS_CLK_AXICFG0_AXI,
+			"u0_sft7110_noc_bus_clk_axicfg0_axi",
+			CLK_IS_CRITICAL, JH7110_AXI_CFG0),
+	//DDRC
+	JH7110__DIV(JH7110_OSC_DIV2, "osc_div2", 2, JH7110_OSC),
+	JH7110__DIV(JH7110_PLL1_DIV4, "pll1_div4", 2, JH7110_PLL1_DIV2),
+	JH7110__DIV(JH7110_PLL1_DIV8, "pll1_div8", 2, JH7110_PLL1_DIV4),
+	JH7110__MUX(JH7110_DDR_BUS, "ddr_bus", PARENT_NUMS_4,
+			JH7110_OSC_DIV2,
+			JH7110_PLL1_DIV2,
+			JH7110_PLL1_DIV4,
+			JH7110_PLL1_DIV8),
+	JH7110_GATE(JH7110_DDR_CLK_AXI, "u0_ddr_sft7110_clk_axi",
+			CLK_IGNORE_UNUSED, JH7110_DDR_BUS),
+	//GPU
+	JH7110__DIV(JH7110_GPU_CORE, "gpu_core", 7, JH7110_GPU_ROOT),
+	JH7110_GATE(JH7110_GPU_CORE_CLK, "u0_img_gpu_core_clk",
+			GATE_FLAG_NORMAL, JH7110_GPU_CORE),
+	JH7110_GATE(JH7110_GPU_SYS_CLK, "u0_img_gpu_sys_clk",
+			GATE_FLAG_NORMAL, JH7110_AXI_CFG1),
+	JH7110_GATE(JH7110_GPU_CLK_APB, "u0_img_gpu_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GDIV(JH7110_GPU_RTC_TOGGLE, "u0_img_gpu_rtc_toggle",
+			GATE_FLAG_NORMAL, 12, JH7110_OSC),
+	JH7110_GATE(JH7110_NOC_BUS_CLK_GPU_AXI,
+			"u0_sft7110_noc_bus_clk_gpu_axi",
+			GATE_FLAG_NORMAL, JH7110_GPU_CORE),
+	//ISP
+	JH7110_GATE(JH7110_ISP_TOP_CLK_ISPCORE_2X,
+			"u0_dom_isp_top_clk_dom_isp_top_clk_ispcore_2x",
+			GATE_FLAG_NORMAL, JH7110_ISP_2X),
+	JH7110_GATE(JH7110_ISP_TOP_CLK_ISP_AXI,
+			"u0_dom_isp_top_clk_dom_isp_top_clk_isp_axi",
+			GATE_FLAG_NORMAL, JH7110_ISP_AXI),
+	JH7110_GATE(JH7110_NOC_BUS_CLK_ISP_AXI,
+			"u0_sft7110_noc_bus_clk_isp_axi",
+			CLK_IS_CRITICAL, JH7110_ISP_AXI),
+	//HIFI4
+	JH7110__DIV(JH7110_HIFI4_CORE, "hifi4_core", 15, JH7110_BUS_ROOT),
+	JH7110__DIV(JH7110_HIFI4_AXI, "hifi4_axi", 2, JH7110_HIFI4_CORE),
+	//AXICFG1_DEC
+	JH7110_GATE(JH7110_AXI_CFG1_DEC_CLK_MAIN, "u0_axi_cfg1_dec_clk_main",
+			CLK_IGNORE_UNUSED, JH7110_AXI_CFG1),
+	JH7110_GATE(JH7110_AXI_CFG1_DEC_CLK_AHB, "u0_axi_cfg1_dec_clk_ahb",
+			CLK_IGNORE_UNUSED, JH7110_AHB0),
+	//VOUT
+	JH7110_GATE(JH7110_VOUT_SRC,
+			"u0_dom_vout_top_clk_dom_vout_top_clk_vout_src",
+			GATE_FLAG_NORMAL, JH7110_VOUT_ROOT),
+	JH7110__DIV(JH7110_VOUT_AXI, "vout_axi", 7, JH7110_VOUT_ROOT),
+	JH7110_GATE(JH7110_NOC_BUS_CLK_DISP_AXI,
+			"u0_sft7110_noc_bus_clk_disp_axi",
+			GATE_FLAG_NORMAL, JH7110_VOUT_AXI),
+	JH7110_GATE(JH7110_VOUT_TOP_CLK_VOUT_AHB,
+			"u0_dom_vout_top_clk_dom_vout_top_clk_vout_ahb",
+			GATE_FLAG_NORMAL, JH7110_AHB1),
+	JH7110_GATE(JH7110_VOUT_TOP_CLK_VOUT_AXI,
+			"u0_dom_vout_top_clk_dom_vout_top_clk_vout_axi",
+			GATE_FLAG_NORMAL, JH7110_VOUT_AXI),
+	JH7110_GATE(JH7110_VOUT_TOP_CLK_HDMITX0_MCLK,
+			"u0_dom_vout_top_clk_dom_vout_top_clk_hdmitx0_mclk",
+			GATE_FLAG_NORMAL, JH7110_MCLK),
+	JH7110__DIV(JH7110_VOUT_TOP_CLK_MIPIPHY_REF,
+			"u0_dom_vout_top_clk_dom_vout_top_clk_mipiphy_ref",
+			2, JH7110_OSC),
+	//JPEGC
+	JH7110__DIV(JH7110_JPEGC_AXI, "jpegc_axi", 16, JH7110_VENC_ROOT),
+	JH7110_GATE(JH7110_CODAJ12_CLK_AXI, "u0_CODAJ12_clk_axi",
+			GATE_FLAG_NORMAL, JH7110_JPEGC_AXI),
+	JH7110_GDIV(JH7110_CODAJ12_CLK_CORE, "u0_CODAJ12_clk_core",
+			GATE_FLAG_NORMAL, 16, JH7110_VENC_ROOT),
+	JH7110_GATE(JH7110_CODAJ12_CLK_APB, "u0_CODAJ12_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	//VDEC
+	JH7110__DIV(JH7110_VDEC_AXI, "vdec_axi", 7, JH7110_BUS_ROOT),
+	JH7110_GATE(JH7110_WAVE511_CLK_AXI, "u0_WAVE511_clk_axi",
+			GATE_FLAG_NORMAL, JH7110_VDEC_AXI),
+	JH7110_GDIV(JH7110_WAVE511_CLK_BPU, "u0_WAVE511_clk_bpu",
+			GATE_FLAG_NORMAL, 7, JH7110_BUS_ROOT),
+	JH7110_GDIV(JH7110_WAVE511_CLK_VCE, "u0_WAVE511_clk_vce",
+			GATE_FLAG_NORMAL, 7, JH7110_VDEC_ROOT),
+	JH7110_GATE(JH7110_WAVE511_CLK_APB, "u0_WAVE511_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GATE(JH7110_VDEC_JPG_ARB_JPGCLK, "u0_vdec_jpg_arb_jpgclk",
+			CLK_IGNORE_UNUSED, JH7110_JPEGC_AXI),
+	JH7110_GATE(JH7110_VDEC_JPG_ARB_MAINCLK, "u0_vdec_jpg_arb_mainclk",
+			CLK_IGNORE_UNUSED, JH7110_VDEC_AXI),
+	JH7110_GATE(JH7110_NOC_BUS_CLK_VDEC_AXI,
+			"u0_sft7110_noc_bus_clk_vdec_axi",
+			GATE_FLAG_NORMAL, JH7110_VDEC_AXI),
+	//VENC
+	JH7110__DIV(JH7110_VENC_AXI, "venc_axi", 15, JH7110_VENC_ROOT),
+	JH7110_GATE(JH7110_WAVE420L_CLK_AXI, "u0_wave420l_clk_axi",
+			GATE_FLAG_NORMAL, JH7110_VENC_AXI),
+	JH7110_GDIV(JH7110_WAVE420L_CLK_BPU, "u0_wave420l_clk_bpu",
+			GATE_FLAG_NORMAL, 15, JH7110_VENC_ROOT),
+	JH7110_GDIV(JH7110_WAVE420L_CLK_VCE, "u0_wave420l_clk_vce",
+			GATE_FLAG_NORMAL, 15, JH7110_VENC_ROOT),
+	JH7110_GATE(JH7110_WAVE420L_CLK_APB, "u0_wave420l_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GATE(JH7110_NOC_BUS_CLK_VENC_AXI,
+			"u0_sft7110_noc_bus_clk_venc_axi",
+			GATE_FLAG_NORMAL, JH7110_VENC_AXI),
+	//INTMEM
+	JH7110_GATE(JH7110_AXI_CFG0_DEC_CLK_MAIN_DIV,
+			"u0_axi_cfg0_dec_clk_main_div",
+			CLK_IGNORE_UNUSED, JH7110_AHB1),
+	JH7110_GATE(JH7110_AXI_CFG0_DEC_CLK_MAIN, "u0_axi_cfg0_dec_clk_main",
+			CLK_IGNORE_UNUSED, JH7110_AXI_CFG0),
+	JH7110_GATE(JH7110_AXI_CFG0_DEC_CLK_HIFI4, "u0_axi_cfg0_dec_clk_hifi4",
+			CLK_IGNORE_UNUSED, JH7110_HIFI4_AXI),
+	JH7110_GATE(JH7110_AXIMEM2_128B_CLK_AXI, "u2_aximem_128b_clk_axi",
+			CLK_IGNORE_UNUSED, JH7110_AXI_CFG0),
+	//QSPI
+	JH7110_GATE(JH7110_QSPI_CLK_AHB, "u0_cdns_qspi_clk_ahb",
+			CLK_IGNORE_UNUSED, JH7110_AHB1),
+	JH7110_GATE(JH7110_QSPI_CLK_APB, "u0_cdns_qspi_clk_apb",
+			CLK_IGNORE_UNUSED, JH7110_APB12),
+	JH7110__DIV(JH7110_QSPI_REF_SRC, "u0_cdns_qspi_ref_src",
+			16, JH7110_GMACUSB_ROOT),
+	JH7110_GMUX(JH7110_QSPI_CLK_REF, "u0_cdns_qspi_clk_ref",
+			CLK_IGNORE_UNUSED, PARENT_NUMS_2,
+			JH7110_OSC,
+			JH7110_QSPI_REF_SRC),
+	//SDIO
+	JH7110_GATE(JH7110_SDIO0_CLK_AHB, "u0_dw_sdio_clk_ahb",
+			CLK_IGNORE_UNUSED, JH7110_AHB0),
+	JH7110_GATE(JH7110_SDIO1_CLK_AHB, "u1_dw_sdio_clk_ahb",
+			CLK_IGNORE_UNUSED, JH7110_AHB0),
+	JH7110_GDIV(JH7110_SDIO0_CLK_SDCARD, "u0_dw_sdio_clk_sdcard",
+			CLK_IGNORE_UNUSED, 15, JH7110_AXI_CFG0),
+	JH7110_GDIV(JH7110_SDIO1_CLK_SDCARD, "u1_dw_sdio_clk_sdcard",
+			CLK_IGNORE_UNUSED, 15, JH7110_AXI_CFG0),
+	//STG
+	JH7110__DIV(JH7110_USB_125M, "usb_125m", 15, JH7110_GMACUSB_ROOT),
+	JH7110_GATE(JH7110_NOC_BUS_CLK_STG_AXI,
+			"u0_sft7110_noc_bus_clk_stg_axi",
+			CLK_IGNORE_UNUSED, JH7110_NOCSTG_BUS),
+	//GMAC1
+	JH7110_GATE(JH7110_GMAC5_CLK_AHB, "u1_dw_gmac5_axi64_clk_ahb",
+			GATE_FLAG_NORMAL, JH7110_AHB0),
+	JH7110_GATE(JH7110_GMAC5_CLK_AXI, "u1_dw_gmac5_axi64_clk_axi",
+			GATE_FLAG_NORMAL, JH7110_STG_AXIAHB),
+	JH7110__DIV(JH7110_GMAC_SRC, "gmac_src", 7, JH7110_GMACUSB_ROOT),
+	JH7110__DIV(JH7110_GMAC1_GTXCLK, "gmac1_gtxclk",
+			15, JH7110_GMACUSB_ROOT),
+	JH7110__DIV(JH7110_GMAC1_RMII_RTX, "gmac1_rmii_rtx",
+			30, JH7110_GMAC1_RMII_REFIN),
+	JH7110_GDIV(JH7110_GMAC5_CLK_PTP, "u1_dw_gmac5_axi64_clk_ptp",
+			GATE_FLAG_NORMAL, 31, JH7110_GMAC_SRC),
+	JH7110__MUX(JH7110_GMAC5_CLK_RX, "u1_dw_gmac5_axi64_clk_rx",
+			PARENT_NUMS_2,
+			JH7110_GMAC1_RGMII_RXIN,
+			JH7110_GMAC1_RMII_RTX),
+	JH7110__INV(JH7110_GMAC5_CLK_RX_INV, "u1_dw_gmac5_axi64_clk_rx_inv",
+			JH7110_GMAC5_CLK_RX),
+	JH7110_GMUX(JH7110_GMAC5_CLK_TX, "u1_dw_gmac5_axi64_clk_tx",
+			GATE_FLAG_NORMAL, PARENT_NUMS_2,
+			JH7110_GMAC1_GTXCLK,
+			JH7110_GMAC1_RMII_RTX),
+	JH7110__INV(JH7110_GMAC5_CLK_TX_INV, "u1_dw_gmac5_axi64_clk_tx_inv",
+			JH7110_GMAC5_CLK_TX),
+	JH7110_GATE(JH7110_GMAC1_GTXC, "gmac1_gtxc",
+			GATE_FLAG_NORMAL, JH7110_GMAC1_GTXCLK),
+	//GMAC0
+	JH7110_GDIV(JH7110_GMAC0_GTXCLK, "gmac0_gtxclk",
+			GATE_FLAG_NORMAL, 15, JH7110_GMACUSB_ROOT),
+	JH7110_GDIV(JH7110_GMAC0_PTP, "gmac0_ptp",
+			GATE_FLAG_NORMAL, 31, JH7110_GMAC_SRC),
+	JH7110_GDIV(JH7110_GMAC_PHY, "gmac_phy",
+			GATE_FLAG_NORMAL, 31, JH7110_GMAC_SRC),
+	JH7110_GATE(JH7110_GMAC0_GTXC, "gmac0_gtxc",
+			GATE_FLAG_NORMAL, JH7110_GMAC0_GTXCLK),
+	//SYS MISC
+	JH7110_GATE(JH7110_SYS_IOMUX_PCLK, "u0_sys_iomux_pclk",
+			CLK_IGNORE_UNUSED, JH7110_APB12),
+	JH7110_GATE(JH7110_MAILBOX_CLK_APB, "u0_mailbox_clk_apb",
+			CLK_IGNORE_UNUSED, JH7110_APB12),
+	JH7110_GATE(JH7110_INT_CTRL_CLK_APB, "u0_int_ctrl_clk_apb",
+			CLK_IGNORE_UNUSED, JH7110_APB12),
+	//CAN
+	JH7110_GATE(JH7110_CAN0_CTRL_CLK_APB, "u0_can_ctrl_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GDIV(JH7110_CAN0_CTRL_CLK_TIMER, "u0_can_ctrl_clk_timer",
+			GATE_FLAG_NORMAL, 24, JH7110_OSC),
+	JH7110_GDIV(JH7110_CAN0_CTRL_CLK_CAN, "u0_can_ctrl_clk_can",
+			GATE_FLAG_NORMAL, 63, JH7110_PERH_ROOT),
+	JH7110_GATE(JH7110_CAN1_CTRL_CLK_APB, "u1_can_ctrl_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GDIV(JH7110_CAN1_CTRL_CLK_TIMER, "u1_can_ctrl_clk_timer",
+			GATE_FLAG_NORMAL, 24, JH7110_OSC),
+	JH7110_GDIV(JH7110_CAN1_CTRL_CLK_CAN, "u1_can_ctrl_clk_can",
+			GATE_FLAG_NORMAL, 63, JH7110_PERH_ROOT),
+	//PWM
+	JH7110_GATE(JH7110_PWM_CLK_APB, "u0_pwm_8ch_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	//WDT
+	JH7110_GATE(JH7110_DSKIT_WDT_CLK_APB, "u0_dskit_wdt_clk_apb",
+			CLK_IGNORE_UNUSED, JH7110_APB12),
+	JH7110_GATE(JH7110_DSKIT_WDT_CLK_WDT, "u0_dskit_wdt_clk_wdt",
+			CLK_IGNORE_UNUSED, JH7110_OSC),
+	//TIMER
+	JH7110_GATE(JH7110_TIMER_CLK_APB, "u0_si5_timer_clk_apb",
+			CLK_IGNORE_UNUSED, JH7110_APB12),
+	JH7110_GATE(JH7110_TIMER_CLK_TIMER0, "u0_si5_timer_clk_timer0",
+			CLK_IGNORE_UNUSED, JH7110_OSC),
+	JH7110_GATE(JH7110_TIMER_CLK_TIMER1, "u0_si5_timer_clk_timer1",
+			CLK_IGNORE_UNUSED, JH7110_OSC),
+	JH7110_GATE(JH7110_TIMER_CLK_TIMER2, "u0_si5_timer_clk_timer2",
+			CLK_IGNORE_UNUSED, JH7110_OSC),
+	JH7110_GATE(JH7110_TIMER_CLK_TIMER3, "u0_si5_timer_clk_timer3",
+			CLK_IGNORE_UNUSED, JH7110_OSC),
+	//TEMP SENSOR
+	JH7110_GATE(JH7110_TEMP_SENSOR_CLK_APB, "u0_temp_sensor_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GDIV(JH7110_TEMP_SENSOR_CLK_TEMP, "u0_temp_sensor_clk_temp",
+			GATE_FLAG_NORMAL, 24, JH7110_OSC),
+	//SPI
+	JH7110_GATE(JH7110_SPI0_CLK_APB, "u0_ssp_spi_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_SPI1_CLK_APB, "u1_ssp_spi_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_SPI2_CLK_APB, "u2_ssp_spi_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_SPI3_CLK_APB, "u3_ssp_spi_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GATE(JH7110_SPI4_CLK_APB, "u4_ssp_spi_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GATE(JH7110_SPI5_CLK_APB, "u5_ssp_spi_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GATE(JH7110_SPI6_CLK_APB, "u6_ssp_spi_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	//I2C
+	JH7110_GATE(JH7110_I2C0_CLK_APB, "u0_dw_i2c_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_I2C1_CLK_APB, "u1_dw_i2c_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_I2C2_CLK_APB, "u2_dw_i2c_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_I2C3_CLK_APB, "u3_dw_i2c_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GATE(JH7110_I2C4_CLK_APB, "u4_dw_i2c_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GATE(JH7110_I2C5_CLK_APB, "u5_dw_i2c_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	JH7110_GATE(JH7110_I2C6_CLK_APB, "u6_dw_i2c_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB12),
+	//UART
+	JH7110_GATE(JH7110_UART0_CLK_APB, "u0_dw_uart_clk_apb",
+			CLK_IGNORE_UNUSED, JH7110_APB0),
+	JH7110_GATE(JH7110_UART0_CLK_CORE, "u0_dw_uart_clk_core",
+			CLK_IGNORE_UNUSED, JH7110_OSC),
+	JH7110_GATE(JH7110_UART1_CLK_APB, "u1_dw_uart_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_UART1_CLK_CORE, "u1_dw_uart_clk_core",
+			GATE_FLAG_NORMAL, JH7110_OSC),
+	JH7110_GATE(JH7110_UART2_CLK_APB, "u2_dw_uart_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_UART2_CLK_CORE, "u2_dw_uart_clk_core",
+			GATE_FLAG_NORMAL, JH7110_OSC),
+	JH7110_GATE(JH7110_UART3_CLK_APB, "u3_dw_uart_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GDIV(JH7110_UART3_CLK_CORE, "u3_dw_uart_clk_core",
+			GATE_FLAG_NORMAL, 10, JH7110_PERH_ROOT),
+	JH7110_GATE(JH7110_UART4_CLK_APB, "u4_dw_uart_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GDIV(JH7110_UART4_CLK_CORE, "u4_dw_uart_clk_core",
+			GATE_FLAG_NORMAL, 10, JH7110_PERH_ROOT),
+	JH7110_GATE(JH7110_UART5_CLK_APB, "u5_dw_uart_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GDIV(JH7110_UART5_CLK_CORE, "u5_dw_uart_clk_core",
+			GATE_FLAG_NORMAL, 10, JH7110_PERH_ROOT),
+	//PWMDAC
+	JH7110_GATE(JH7110_PWMDAC_CLK_APB, "u0_pwmdac_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GDIV(JH7110_PWMDAC_CLK_CORE, "u0_pwmdac_clk_core",
+			GATE_FLAG_NORMAL, 256, JH7110_AUDIO_ROOT),
+	//SPDIF
+	JH7110_GATE(JH7110_SPDIF_CLK_APB, "u0_cdns_spdif_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GATE(JH7110_SPDIF_CLK_CORE, "u0_cdns_spdif_clk_core",
+			GATE_FLAG_NORMAL, JH7110_MCLK),
+	//I2STX0_4CH0
+	JH7110_GATE(JH7110_I2STX0_4CHCLK_APB, "u0_i2stx_4ch_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GDIV(JH7110_I2STX_4CH0_BCLK_MST, "i2stx_4ch0_bclk_mst",
+			GATE_FLAG_NORMAL, 32, JH7110_MCLK),
+	JH7110__INV(JH7110_I2STX_4CH0_BCLK_MST_INV, "i2stx_4ch0_bclk_mst_inv",
+			JH7110_I2STX_4CH0_BCLK_MST),
+	JH7110_MDIV(JH7110_I2STX_4CH0_LRCK_MST, "i2stx_4ch0_lrck_mst",
+			64, PARENT_NUMS_2,
+			JH7110_I2STX_4CH0_BCLK_MST_INV,
+			JH7110_I2STX_4CH0_BCLK_MST),
+	JH7110__MUX(JH7110_I2STX0_4CHBCLK, "u0_i2stx_4ch_bclk",
+			PARENT_NUMS_2,
+			JH7110_I2STX_4CH0_BCLK_MST,
+			JH7110_I2STX_BCLK_EXT),
+	JH7110__INV(JH7110_I2STX0_4CHBCLK_N, "u0_i2stx_4ch_bclk_n",
+			JH7110_I2STX0_4CHBCLK),
+	JH7110__MUX(JH7110_I2STX0_4CHLRCK, "u0_i2stx_4ch_lrck",
+			PARENT_NUMS_2,
+			JH7110_I2STX_4CH0_LRCK_MST,
+			JH7110_I2STX_LRCK_EXT),
+	//I2STX1_4CH0
+	JH7110_GATE(JH7110_I2STX1_4CHCLK_APB, "u1_i2stx_4ch_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GDIV(JH7110_I2STX_4CH1_BCLK_MST, "i2stx_4ch1_bclk_mst",
+			GATE_FLAG_NORMAL, 32, JH7110_MCLK),
+	JH7110__INV(JH7110_I2STX_4CH1_BCLK_MST_INV, "i2stx_4ch1_bclk_mst_inv",
+			JH7110_I2STX_4CH1_BCLK_MST),
+	JH7110_MDIV(JH7110_I2STX_4CH1_LRCK_MST, "i2stx_4ch1_lrck_mst",
+			64, PARENT_NUMS_2,
+			JH7110_I2STX_4CH1_BCLK_MST_INV,
+			JH7110_I2STX_4CH1_BCLK_MST),
+	JH7110__MUX(JH7110_I2STX1_4CHBCLK, "u1_i2stx_4ch_bclk",
+			PARENT_NUMS_2,
+			JH7110_I2STX_4CH1_BCLK_MST,
+			JH7110_I2STX_BCLK_EXT),
+	JH7110__INV(JH7110_I2STX1_4CHBCLK_N, "u1_i2stx_4ch_bclk_n",
+			JH7110_I2STX1_4CHBCLK),
+	JH7110__MUX(JH7110_I2STX1_4CHLRCK, "u1_i2stx_4ch_lrck",
+			PARENT_NUMS_2,
+			JH7110_I2STX_4CH1_LRCK_MST,
+			JH7110_I2STX_LRCK_EXT),
+	//I2SRX_3CH
+	JH7110_GATE(JH7110_I2SRX0_3CH_CLK_APB, "u0_i2srx_3ch_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GDIV(JH7110_I2SRX_3CH_BCLK_MST, "i2srx_3ch_bclk_mst",
+			GATE_FLAG_NORMAL, 32, JH7110_MCLK),
+	JH7110__INV(JH7110_I2SRX_3CH_BCLK_MST_INV, "i2srx_3ch_bclk_mst_inv",
+			JH7110_I2SRX_3CH_BCLK_MST),
+	JH7110_MDIV(JH7110_I2SRX_3CH_LRCK_MST, "i2srx_3ch_lrck_mst",
+			64, PARENT_NUMS_2,
+			JH7110_I2SRX_3CH_BCLK_MST_INV,
+			JH7110_I2SRX_3CH_BCLK_MST),
+	JH7110__MUX(JH7110_I2SRX0_3CH_BCLK, "u0_i2srx_3ch_bclk",
+			PARENT_NUMS_2,
+			JH7110_I2SRX_3CH_BCLK_MST,
+			JH7110_I2SRX_BCLK_EXT),
+	JH7110__INV(JH7110_I2SRX0_3CH_BCLK_N, "u0_i2srx_3ch_bclk_n",
+			JH7110_I2SRX0_3CH_BCLK),
+	JH7110__MUX(JH7110_I2SRX0_3CH_LRCK, "u0_i2srx_3ch_lrck",
+			PARENT_NUMS_2,
+			JH7110_I2SRX_3CH_LRCK_MST,
+			JH7110_I2SRX_LRCK_EXT),
+	//PDM_4MIC
+	JH7110_GDIV(JH7110_PDM_CLK_DMIC, "u0_pdm_4mic_clk_dmic",
+			GATE_FLAG_NORMAL, 64, JH7110_MCLK),
+	JH7110_GATE(JH7110_PDM_CLK_APB, "u0_pdm_4mic_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	//TDM
+	JH7110_GATE(JH7110_TDM_CLK_AHB, "u0_tdm16slot_clk_ahb",
+			GATE_FLAG_NORMAL, JH7110_AHB0),
+	JH7110_GATE(JH7110_TDM_CLK_APB, "u0_tdm16slot_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_APB0),
+	JH7110_GDIV(JH7110_TDM_INTERNAL, "tdm_internal",
+			GATE_FLAG_NORMAL, 64, JH7110_MCLK),
+	JH7110__MUX(JH7110_TDM_CLK_TDM, "u0_tdm16slot_clk_tdm",
+			PARENT_NUMS_2,
+			JH7110_TDM_INTERNAL,
+			JH7110_TDM_EXT),
+	JH7110__INV(JH7110_TDM_CLK_TDM_N, "u0_tdm16slot_clk_tdm_n",
+			JH7110_TDM_CLK_TDM),
+	JH7110__DIV(JH7110_JTAG_CERTIFICATION_TRNG_CLK,
+			"u0_jtag_certification_trng_clk", 4, JH7110_OSC),
+};
+
+int __init clk_starfive_jh7110_sys_init(struct platform_device *pdev,
+						struct jh7110_clk_priv *priv)
+{
+	unsigned int idx;
+	int ret = 0;
+
+	priv->sys_base = devm_platform_ioremap_resource_byname(pdev, "sys");
+	if (IS_ERR(priv->sys_base))
+		return PTR_ERR(priv->sys_base);
+
+#ifndef CONFIG_CLK_STARFIVE_JH7110_PLL
+	priv->pll[PLL_OF(JH7110_PLL0_OUT)] =
+			clk_hw_register_fixed_rate(priv->dev,
+			"pll0_out", "osc", 0, 1250000000);
+	if (IS_ERR(priv->pll[PLL_OF(JH7110_PLL0_OUT)]))
+		return PTR_ERR(priv->pll[PLL_OF(JH7110_PLL0_OUT)]);
+
+	priv->pll[PLL_OF(JH7110_PLL1_OUT)] =
+			clk_hw_register_fixed_rate(priv->dev,
+			"pll1_out", "osc", 0, 1066000000);
+	if (IS_ERR(priv->pll[PLL_OF(JH7110_PLL1_OUT)]))
+		return PTR_ERR(priv->pll[PLL_OF(JH7110_PLL1_OUT)]);
+
+	priv->pll[PLL_OF(JH7110_PLL2_OUT)] =
+			clk_hw_register_fixed_rate(priv->dev,
+			"pll2_out", "osc", 0, 1228800000);
+	if (IS_ERR(priv->pll[PLL_OF(JH7110_PLL2_OUT)]))
+		return PTR_ERR(priv->pll[PLL_OF(JH7110_PLL2_OUT)]);
+#endif
+
+	priv->pll[PLL_OF(JH7110_AON_APB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"aon_apb", "apb_bus_func", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_RESET1_CTRL_CLK_SRC)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_reset_ctrl_clk_src", "osc", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_DDR_ROOT)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"ddr_root", "pll1_out", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VDEC_ROOT)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"vdec_root", "pll0_out", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VENC_ROOT)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"venc_root", "pll2_out", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VOUT_ROOT)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"vout_root", "pll2_out", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_GMACUSB_ROOT)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"gmacusb_root", "pll0_out", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCLK2_MUX_FUNC_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u2_pclk_mux_func_pclk", "apb_bus_func", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PCLK2_MUX_BIST_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u2_pclk_mux_bist_pclk", "bist_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_APB_BUS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"apb_bus", "u2_pclk_mux_pclk", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_APB12)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"apb12", "apb_bus", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_AXI_CFG1)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"axi_cfg1", "isp_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PLL_WRAP_CRG_GCLK0)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pll_wrap_crg_gclk0", "gclk0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PLL_WRAP_CRG_GCLK1)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pll_wrap_crg_gclk1", "gclk1", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PLL_WRAP_CRG_GCLK2)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pll_wrap_crg_gclk2", "gclk2", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_JTAG2APB_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_jtag2apb_pclk", "bist_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_U7_BUS_CLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_u7mc_sft7110_bus_clk", "cpu_bus", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_U7_IRQ_SYNC_BUS_CLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_u7mc_sft7110_irq_sync_bus_clk", "cpu_bus", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_CPU_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_cpu_axi",
+			"u0_sft7110_noc_bus_clk_cpu_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK_APB_BUS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk_apb_bus", "apb_bus", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_APB_BUS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_apb_bus",
+			"u0_sft7110_noc_bus_clk_apb_bus", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_AXICFG0_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_axicfg0_axi",
+			"u0_sft7110_noc_bus_clk_axicfg0_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_DDR_CLK_DDRPHY_PLL_BYPASS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ddr_sft7110_clk_ddrphy_pll_bypass",
+			"pll1_out", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_DDR_CLK_OSC)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ddr_sft7110_clk_osc", "osc", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_DDR_CLK_APB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ddr_sft7110_clk_apb", "apb12", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK_DDRC)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk_ddrc", "ddr_bus", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_DDRC)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_ddrc",
+			"u0_sft7110_noc_bus_clk_ddrc", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SYS_AHB_DEC_CLK_AHB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_saif_amba_sys_ahb_dec_clk_ahb", "ahb0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_STG_AHB_DEC_CLK_AHB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_saif_amba_stg_ahb_dec_clk_ahb", "ahb0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_GPU_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_gpu_axi",
+			"u0_sft7110_noc_bus_clk_gpu_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_ISP_TOP_CLK_DVP)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dom_isp_top_clk_dom_isp_top_clk_dvp",
+			"dvp_clk", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_ISP_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_isp_axi",
+			"u0_sft7110_noc_bus_clk_isp_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_ISP_TOP_CLK_BIST_APB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dom_isp_top_clk_dom_isp_top_clk_bist_apb",
+			"bist_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_DISP_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_disp_axi",
+			"u0_sft7110_noc_bus_clk_disp_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VOUT_TOP_CLK_HDMITX0_BCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dom_vout_top_clk_dom_vout_top_clk_hdmitx0_bclk",
+			"u0_i2stx_4ch_bclk", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VOUT_TOP_U0_HDMI_TX_PIN_WS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dom_vout_top_u0_hdmi_tx_pin_ws",
+			"u0_i2stx_4ch_lrck", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VOUT_TOP_CLK_HDMIPHY_REF)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dom_vout_top_clk_dom_vout_top_clk_hdmiphy_ref",
+			"osc", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VOUT_TOP_BIST_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dom_vout_top_clk_dom_vout_top_bist_pclk",
+			"bist_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_AXIMEM0_128B_CLK_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_aximem_128b_clk_axi",
+			"u0_WAVE511_clk_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VDEC_INTSRAM_CLK_VDEC_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_vdec_intsram_clk_vdec_axi",
+			"u0_aximem_128b_clk_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_VDEC_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_vdec_axi",
+			"u0_sft7110_noc_bus_clk_vdec_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_AXIMEM1_128B_CLK_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_aximem_128b_clk_axi",
+			"u0_wave420l_clk_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_VENC_INTSRAM_CLK_VENC_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_venc_intsram_clk_venc_axi",
+			"u0_wave420l_clk_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_VENC_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_venc_axi",
+			"u0_sft7110_noc_bus_clk_venc_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SRAM_CLK_ROM)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_intmem_rom_sram_clk_rom",
+			"u2_aximem_128b_clk_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_NOC_BUS_CLK2_STG_AXI)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sft7110_noc_bus_clk2_stg_axi",
+			"u0_sft7110_noc_bus_clk_stg_axi", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_GMAC5_CLK_RMII)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_dw_gmac5_axi64_clk_rmii",
+			"gmac1_rmii_refin", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_AON_AHB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"aon_ahb", "stg_axiahb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SYS_CRG_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sys_crg_pclk", "apb12", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SYS_SYSCON_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sys_syscon_pclk", "apb12", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SPI0_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ssp_spi_clk_core", "u0_ssp_spi_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SPI1_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_ssp_spi_clk_core", "u1_ssp_spi_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SPI2_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u2_ssp_spi_clk_core", "u2_ssp_spi_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SPI3_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u3_ssp_spi_clk_core", "u3_ssp_spi_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SPI4_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u4_ssp_spi_clk_core", "u4_ssp_spi_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SPI5_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u5_ssp_spi_clk_core", "u5_ssp_spi_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SPI6_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u6_ssp_spi_clk_core", "u6_ssp_spi_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2C0_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dw_i2c_clk_core", "u0_dw_i2c_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2C1_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_dw_i2c_clk_core", "u1_dw_i2c_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2C2_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u2_dw_i2c_clk_core", "u2_dw_i2c_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2C3_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u3_dw_i2c_clk_core", "u3_dw_i2c_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2C4_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u4_dw_i2c_clk_core", "u4_dw_i2c_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2C5_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u5_dw_i2c_clk_core", "u5_dw_i2c_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2C6_CLK_CORE)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u6_dw_i2c_clk_core", "u6_dw_i2c_clk_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2STX_BCLK_MST)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"i2stx_bclk_mst", "i2stx_4ch1_bclk_mst", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2STX_LRCK_MST)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"i2stx_lrck_mst", "i2stx_4ch1_lrck_mst", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2SRX_BCLK_MST)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"i2srx_bclk_mst", "i2srx_3ch_bclk_mst", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_I2SRX_LRCK_MST)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"i2srx_lrck_mst", "i2srx_3ch_lrck_mst", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PDM_CLK_DMIC0_BCLK_SLV)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pdm_4mic_clk_dmic0_bclk_slv",
+			"u0_i2srx_3ch_bclk", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PDM_CLK_DMIC0_LRCK_SLV)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pdm_4mic_clk_dmic0_lrck_slv",
+			"u0_i2srx_3ch_lrck", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PDM_CLK_DMIC1_BCLK_SLV)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pdm_4mic_clk_dmic1_bclk_slv",
+			"u0_i2srx_3ch_bclk", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_PDM_CLK_DMIC1_LRCK_SLV)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pdm_4mic_clk_dmic1_lrck_slv",
+			"u0_i2srx_3ch_lrck", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_TDM_CLK_MST)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"tdm_clk_mst", "ahb0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_AHB2APB_CLK_AHB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_ahb2apb_clk_ahb", "tdm_internal", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_P2P_ASYNC_CLK_APBS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_p2p_async_clk_apbs", "apb0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_P2P_ASYNC_CLK_APBM)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u1_p2p_async_clk_apbm", "aon_apb", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_JTAG_DAISY_CHAIN_JTAG_TCK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_jtag_daisy_chain_JTAG_TCK",
+			"jtag_tck_inner", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_U7_DEBUG_SYSTEMJTAG_JTAG_TCK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_u7mc_sft7110_debug_systemjtag_jtag_TCK",
+			"u0_jtag_daisy_chain_jtag_tck_0", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_E2_DEBUG_SYSTEMJTAG_TCK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_e2_sft7110_debug_systemjtag_jtag_TCK",
+			"u0_jtag_daisy_chain_jtag_tck_1", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_JTAG_CERTIFICATION_TCK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_jtag_certification_tck",
+			"jtag_tck_inner", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_SEC_SKP_CLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_sec_top_skp_clk",
+			"u0_jtag_certification_trng_clk", 0, 1, 1);
+	priv->pll[PLL_OF(JH7110_U2_PCLK_MUX_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u2_pclk_mux_pclk",
+			"u2_pclk_mux_func_pclk", 0, 1, 1);
+
+
+	for (idx = 0; idx < JH7110_CLK_SYS_REG_END; idx++) {
+		u32 max = jh7110_clk_sys_data[idx].max;
+		struct clk_parent_data parents[4] = {};
+		struct clk_init_data init = {
+			.name = jh7110_clk_sys_data[idx].name,
+			.ops = starfive_jh7110_clk_ops(max),
+			.parent_data = parents,
+			.num_parents = ((max & JH7110_CLK_MUX_MASK) >>
+				JH7110_CLK_MUX_SHIFT) + 1,
+			.flags = jh7110_clk_sys_data[idx].flags,
+		};
+		struct jh7110_clk *clk = &priv->reg[idx];
+		unsigned int i;
+
+		for (i = 0; i < init.num_parents; i++) {
+			unsigned int pidx = jh7110_clk_sys_data[idx].parents[i];
+
+			if (pidx < JH7110_CLK_SYS_REG_END)
+				parents[i].hw = &priv->reg[pidx].hw;
+#ifdef CONFIG_CLK_STARFIVE_JH7110_PLL
+			else if ((pidx == JH7110_PLL0_OUT) || (pidx == JH7110_PLL2_OUT))
+				parents[i].hw = &priv->pll_priv[PLL_OF(pidx)].hw;
+#endif
+			else if ((pidx < JH7110_CLK_SYS_END) &&
+				(pidx > JH7110_CLK_SYS_REG_END))
+				parents[i].hw = priv->pll[PLL_OF(pidx)];
+			else if (pidx == JH7110_OSC)
+				parents[i].fw_name = "osc";
+			else if (pidx == JH7110_GMAC1_RMII_REFIN)
+				parents[i].fw_name = "gmac1_rmii_refin";
+			else if (pidx == JH7110_GMAC1_RGMII_RXIN)
+				parents[i].fw_name = "gmac1_rgmii_rxin";
+			else if (pidx == JH7110_I2STX_BCLK_EXT)
+				parents[i].fw_name = "i2stx_bclk_ext";
+			else if (pidx == JH7110_I2STX_LRCK_EXT)
+				parents[i].fw_name = "i2stx_lrck_ext";
+			else if (pidx == JH7110_I2SRX_BCLK_EXT)
+				parents[i].fw_name = "i2srx_bclk_ext";
+			else if (pidx == JH7110_I2SRX_LRCK_EXT)
+				parents[i].fw_name = "i2srx_lrck_ext";
+			else if (pidx == JH7110_TDM_EXT)
+				parents[i].fw_name = "tdm_ext";
+			else if (pidx == JH7110_MCLK_EXT)
+				parents[i].fw_name = "mclk_ext";
+			else if (pidx == JH7110_JTAG_TCK_INNER)
+				parents[i].fw_name = "jtag_tclk_inner";
+			else if (pidx == JH7110_BIST_APB)
+				parents[i].fw_name = "bist_apb";
+		}
+
+		clk->hw.init = &init;
+		clk->idx = idx;
+		clk->max_div = max & JH7110_CLK_DIV_MASK;
+		clk->reg_flags = JH7110_CLK_SYS_FLAG;
+
+		ret = devm_clk_hw_register(priv->dev, &clk->hw);
+		if (ret)
+			return ret;
+	}
+
+	dev_dbg(&pdev->dev, "starfive JH7110 clk_sys init successfully.");
+	return 0;
+}
diff --git a/drivers/clk/starfive/clk-starfive-jh7110-vout.c b/drivers/clk/starfive/clk-starfive-jh7110-vout.c
new file mode 100644
index 000000000000..fbd26303126d
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110-vout.c
@@ -0,0 +1,403 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * StarFive JH7110 vout Clock Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/debugfs.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+
+#include <dt-bindings/clock/starfive-jh7110-vout.h>
+#include "clk-starfive-jh7110.h"
+
+/* external clocks */
+#define JH7110_HDMITX0_PIXELCLK			(JH7110_CLK_VOUT_END + 0)
+#define JH7110_MIPITX_DPHY_RXESC		(JH7110_CLK_VOUT_END + 1)
+#define JH7110_MIPITX_DPHY_TXBYTEHS		(JH7110_CLK_VOUT_END + 2)
+
+struct vout_init_crg {
+	int num_clks;
+	struct clk_bulk_data *clks;
+	struct reset_control *rsts;
+};
+
+static const struct jh7110_clk_data jh7110_clk_vout_data[] __initconst = {
+	//divider
+	JH7110__DIV(JH7110_APB, "apb", 8, JH7110_DISP_AHB),
+	JH7110__DIV(JH7110_DC8200_PIX0, "dc8200_pix0", 63, JH7110_DISP_ROOT),
+	JH7110__DIV(JH7110_DSI_SYS, "dsi_sys", 31, JH7110_DISP_ROOT),
+	JH7110__DIV(JH7110_TX_ESC, "tx_esc", 31, JH7110_DISP_AHB),
+	//dc8200
+	JH7110_GATE(JH7110_U0_DC8200_CLK_AXI, "u0_dc8200_clk_axi",
+			GATE_FLAG_NORMAL, JH7110_DISP_AXI),
+	JH7110_GATE(JH7110_U0_DC8200_CLK_CORE, "u0_dc8200_clk_core",
+			GATE_FLAG_NORMAL, JH7110_DISP_AXI),
+	JH7110_GATE(JH7110_U0_DC8200_CLK_AHB, "u0_dc8200_clk_ahb",
+			GATE_FLAG_NORMAL, JH7110_DISP_AHB),
+	JH7110_GMUX(JH7110_U0_DC8200_CLK_PIX0, "u0_dc8200_clk_pix0",
+			GATE_FLAG_NORMAL, PARENT_NUMS_2,
+			JH7110_DC8200_PIX0,
+			JH7110_HDMITX0_PIXELCLK),
+	JH7110_GMUX(JH7110_U0_DC8200_CLK_PIX1, "u0_dc8200_clk_pix1",
+			GATE_FLAG_NORMAL, PARENT_NUMS_2,
+			JH7110_DC8200_PIX0,
+			JH7110_HDMITX0_PIXELCLK),
+
+	JH7110_GMUX(JH7110_DOM_VOUT_TOP_LCD_CLK, "dom_vout_top_lcd_clk",
+			GATE_FLAG_NORMAL, PARENT_NUMS_2,
+			JH7110_U0_DC8200_CLK_PIX0_OUT,
+			JH7110_U0_DC8200_CLK_PIX1_OUT),
+	//dsiTx
+	JH7110_GATE(JH7110_U0_CDNS_DSITX_CLK_APB, "u0_cdns_dsiTx_clk_apb",
+			GATE_FLAG_NORMAL, JH7110_DSI_SYS),
+	JH7110_GATE(JH7110_U0_CDNS_DSITX_CLK_SYS, "u0_cdns_dsiTx_clk_sys",
+			GATE_FLAG_NORMAL, JH7110_DSI_SYS),
+	JH7110_GMUX(JH7110_U0_CDNS_DSITX_CLK_DPI, "u0_cdns_dsiTx_clk_api",
+			GATE_FLAG_NORMAL, PARENT_NUMS_2,
+			JH7110_DC8200_PIX0,
+			JH7110_HDMITX0_PIXELCLK),
+	JH7110_GATE(JH7110_U0_CDNS_DSITX_CLK_TXESC, "u0_cdns_dsiTx_clk_txesc",
+			GATE_FLAG_NORMAL, JH7110_TX_ESC),
+	//mipitx DPHY
+	JH7110_GATE(JH7110_U0_MIPITX_DPHY_CLK_TXESC, "u0_mipitx_dphy_clk_txesc",
+			GATE_FLAG_NORMAL, JH7110_TX_ESC),
+	//hdmi
+	JH7110_GATE(JH7110_U0_HDMI_TX_CLK_MCLK, "u0_hdmi_tx_clk_mclk",
+			GATE_FLAG_NORMAL, JH7110_HDMITX0_MCLK),
+	JH7110_GATE(JH7110_U0_HDMI_TX_CLK_BCLK, "u0_hdmi_tx_clk_bclk",
+			GATE_FLAG_NORMAL, JH7110_HDMITX0_SCK),
+	JH7110_GATE(JH7110_U0_HDMI_TX_CLK_SYS, "u0_hdmi_tx_clk_sys",
+			GATE_FLAG_NORMAL, JH7110_DISP_APB),
+};
+
+static struct clk_bulk_data vout_top_clks[] = {
+	{ .id = "vout_src" },
+	{ .id = "vout_top_ahb" },
+};
+
+static int jh7110_vout_crg_get(struct device *dev, struct vout_init_crg *crg)
+{
+	int ret;
+
+	crg->rsts = devm_reset_control_array_get_shared(dev);
+	if (IS_ERR(crg->rsts)) {
+		dev_err(dev, "rst get failed\n");
+		return PTR_ERR(crg->rsts);
+	}
+
+	crg->clks = vout_top_clks;
+	crg->num_clks = ARRAY_SIZE(vout_top_clks);
+	ret = clk_bulk_get(dev, crg->num_clks, crg->clks);
+	if (ret) {
+		dev_err(dev, "clks get failed: %d\n", ret);
+		goto clks_get_failed;
+	}
+
+	return 0;
+
+clks_get_failed:
+	reset_control_assert(crg->rsts);
+	reset_control_put(crg->rsts);
+
+	return ret;
+}
+
+static int jh7110_vout_crg_enable(struct device *dev, struct vout_init_crg *crg, bool enable)
+{
+	int ret;
+
+	dev_dbg(dev, "jh7110_vout_crg_%sable\n", enable ? "en":"dis");
+
+	if (enable) {
+		ret = reset_control_deassert(crg->rsts);
+		if (ret) {
+			dev_err(dev, "rst deassert failed: %d\n", ret);
+			goto crg_failed;
+		}
+
+		ret = clk_bulk_prepare_enable(crg->num_clks, crg->clks);
+		if (ret) {
+			dev_err(dev, "clks enable failed: %d\n", ret);
+			goto crg_failed;
+		}
+	} else {
+		clk_bulk_disable_unprepare(crg->num_clks, crg->clks);
+	}
+
+	return 0;
+crg_failed:
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int clk_vout_system_pm_suspend(struct device *dev)
+{
+	return pm_runtime_force_suspend(dev);
+}
+
+static int clk_vout_system_pm_resume(struct device *dev)
+{
+	return pm_runtime_force_resume(dev);
+}
+#endif
+
+#ifdef CONFIG_PM
+static int clk_vout_runtime_suspend(struct device *dev)
+{
+	struct vout_init_crg *crg = dev_get_drvdata(dev);
+
+	return jh7110_vout_crg_enable(dev, crg, false);
+}
+
+static int clk_vout_runtime_resume(struct device *dev)
+{
+	struct vout_init_crg *crg = dev_get_drvdata(dev);
+
+	return jh7110_vout_crg_enable(dev, crg, true);
+}
+#endif
+
+static const struct dev_pm_ops clk_vout_pm_ops = {
+	SET_RUNTIME_PM_OPS(clk_vout_runtime_suspend, clk_vout_runtime_resume, NULL)
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(clk_vout_system_pm_suspend, clk_vout_system_pm_resume)
+};
+
+static struct clk_hw *jh7110_vout_clk_get(struct of_phandle_args *clkspec,
+					void *data)
+{
+	struct jh7110_clk_priv *priv = data;
+	unsigned int idx = clkspec->args[0];
+
+	if (idx < JH7110_CLK_VOUT_REG_END)
+		return &priv->reg[idx].hw;
+
+	if (idx < JH7110_CLK_VOUT_END)
+		return priv->pll[PLL_OFV(idx)];
+
+	return ERR_PTR(-EINVAL);
+}
+
+static int __init clk_starfive_jh7110_vout_probe(struct platform_device *pdev)
+{
+	struct jh7110_clk_priv *priv;
+	struct vout_init_crg *crg;
+	unsigned int idx;
+	int ret = 0;
+
+	priv = devm_kzalloc(&pdev->dev, struct_size(priv,
+				reg, JH7110_DISP_ROOT), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	spin_lock_init(&priv->rmw_lock);
+	priv->dev = &pdev->dev;
+	priv->vout_base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(priv->vout_base))
+		return PTR_ERR(priv->vout_base);
+
+	crg = devm_kzalloc(&pdev->dev, sizeof(*crg), GFP_KERNEL);
+	if (!crg)
+		return -ENOMEM;
+	dev_set_drvdata(&pdev->dev, crg);
+
+	ret = jh7110_vout_crg_get(&pdev->dev, crg);
+	if (ret)
+		goto init_failed;
+
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
+	pm_runtime_enable(&pdev->dev);
+	ret = pm_runtime_get_sync(&pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to get pm runtime: %d\n", ret);
+		goto init_failed;
+	}
+
+	/*source*/
+	priv->pll[PLL_OFV(JH7110_DISP_ROOT)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "disp_root",
+			"u0_dom_vout_top_clk_dom_vout_top_clk_vout_src",
+			0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_DISP_AXI)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "disp_axi",
+			"u0_dom_vout_top_clk_dom_vout_top_clk_vout_axi",
+			0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_DISP_AHB)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "disp_ahb",
+			"u0_dom_vout_top_clk_dom_vout_top_clk_vout_ahb",
+			0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_HDMI_PHY_REF)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "hdmi_phy_ref",
+			"u0_dom_vout_top_clk_dom_vout_top_clk_hdmiphy_ref",
+			0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_HDMITX0_MCLK)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "hdmitx0_mclk",
+			"u0_dom_vout_top_clk_dom_vout_top_clk_hdmitx0_mclk",
+			0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_HDMITX0_SCK)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "hdmitx0_sck",
+			"u0_dom_vout_top_clk_dom_vout_top_clk_hdmitx0_bclk",
+			0, 1, 1);
+
+	priv->pll[PLL_OFV(JH7110_MIPI_DPHY_REF)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "mipi_dphy_ref",
+			"u0_dom_vout_top_clk_dom_vout_top_clk_mipiphy_ref",
+			0, 1, 1);
+	//divider
+	priv->pll[PLL_OFV(JH7110_U0_PCLK_MUX_BIST_PCLK)] =
+			clk_hw_register_fixed_factor(
+			priv->dev, "u0_pclk_mux_bist_pclk",
+			"u0_dom_vout_top_clk_dom_vout_top_bist_pclk",
+			0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_DISP_APB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"disp_apb", "u0_pclk_mux_func_pclk", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_PCLK_MUX_FUNC_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_pclk_mux_func_pclk", "apb", 0, 1, 1);
+	//bus
+	priv->pll[PLL_OFV(JH7110_U0_DOM_VOUT_CRG_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dom_vout_crg_pclk", "disp_apb", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_DOM_VOUT_SYSCON_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dom_vout_syscon_pclk", "disp_apb", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_SAIF_AMBA_DOM_VOUT_AHB_DEC_CLK_AHB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_saif_amba_dom_vout_ahb_dec_clk_ahb",
+			"disp_ahb", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_AHB2APB_CLK_AHB)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_ahb2apb_clk_ahb", "disp_ahb", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_P2P_ASYNC_CLK_APBS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_p2p_async_clk_apbs", "disp_apb", 0, 1, 1);
+	//dsiTx
+	priv->pll[PLL_OFV(JH7110_U0_CDNS_DSITX_CLK_RXESC)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_cdns_dsiTx_clk_rxesc",
+			"mipitx_dphy_rxesc", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_CDNS_DSITX_CLK_TXBYTEHS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_cdns_dsiTx_clk_txbytehs",
+			"mipitx_dphy_txbytehs", 0, 1, 1);
+	//mipitx DPHY
+	priv->pll[PLL_OFV(JH7110_U0_MIPITX_DPHY_CLK_SYS)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_mipitx_dphy_clk_sys", "disp_apb", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_MIPITX_DPHY_CLK_DPHY_REF)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_mipitx_dphy_clk_dphy_ref",
+			"mipi_dphy_ref", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_MIPITX_APBIF_PCLK)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_mipitx_apbif_pclk", "disp_apb", 0, 1, 1);
+	//hdmi
+	priv->pll[PLL_OFV(JH7110_HDMI_TX_CLK_REF)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_hdmi_tx_clk_ref", "hdmi_phy_ref", 0, 1, 1);
+
+	priv->pll[PLL_OFV(JH7110_U0_DC8200_CLK_PIX0_OUT)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dc8200_clk_pix0_out",
+			"u0_dc8200_clk_pix0", 0, 1, 1);
+	priv->pll[PLL_OFV(JH7110_U0_DC8200_CLK_PIX1_OUT)] =
+			clk_hw_register_fixed_factor(priv->dev,
+			"u0_dc8200_clk_pix1_out",
+			"u0_dc8200_clk_pix1", 0, 1, 1);
+
+	for (idx = 0; idx < JH7110_DISP_ROOT; idx++) {
+		u32 max = jh7110_clk_vout_data[idx].max;
+		struct clk_parent_data parents[2] = {};
+		struct clk_init_data init = {
+			.name = jh7110_clk_vout_data[idx].name,
+			.ops = starfive_jh7110_clk_ops(max),
+			.parent_data = parents,
+			.num_parents = ((max & JH7110_CLK_MUX_MASK) >>
+				JH7110_CLK_MUX_SHIFT) + 1,
+			.flags = jh7110_clk_vout_data[idx].flags,
+		};
+		struct jh7110_clk *clk = &priv->reg[idx];
+		unsigned int i;
+
+		for (i = 0; i < init.num_parents; i++) {
+			unsigned int pidx = jh7110_clk_vout_data[idx].parents[i];
+
+			if (pidx < JH7110_DISP_ROOT)
+				parents[i].hw = &priv->reg[pidx].hw;
+			else if (pidx < JH7110_CLK_VOUT_END)
+				parents[i].hw = priv->pll[PLL_OFV(pidx)];
+			else if (pidx == JH7110_HDMITX0_PIXELCLK)
+				parents[i].fw_name = "hdmitx0_pixelclk";
+			else if (pidx == JH7110_MIPITX_DPHY_RXESC)
+				parents[i].fw_name = "mipitx_dphy_rxesc";
+			else if (pidx == JH7110_MIPITX_DPHY_TXBYTEHS)
+				parents[i].fw_name = "mipitx_dphy_txbytehs";
+			else if (pidx == JH7110_U0_DC8200_CLK_PIX0_OUT)
+				parents[i].fw_name = "u0_dc8200_clk_pix0_out";
+			else if (pidx == JH7110_U0_DC8200_CLK_PIX1_OUT)
+				parents[i].fw_name = "u0_dc8200_clk_pix1_out";
+		}
+
+		clk->hw.init = &init;
+		clk->idx = idx;
+		clk->max_div = max & JH7110_CLK_DIV_MASK;
+		clk->reg_flags = JH7110_CLK_VOUT_FLAG;
+
+		ret = devm_clk_hw_register(priv->dev, &clk->hw);
+		if (ret)
+			return ret;
+	}
+
+	ret = devm_of_clk_add_hw_provider(priv->dev, jh7110_vout_clk_get, priv);
+	if (ret)
+		return ret;
+
+	pm_runtime_put_sync(&pdev->dev);
+
+	dev_info(&pdev->dev, "starfive JH7110 clk_vout init successfully.");
+	return 0;
+
+init_failed:
+	return ret;
+
+}
+
+static const struct of_device_id clk_starfive_jh7110_vout_match[] = {
+		{.compatible = "starfive,jh7110-clk-vout" },
+		{ }
+};
+
+static struct platform_driver clk_starfive_jh7110_vout_driver = {
+	.probe = clk_starfive_jh7110_vout_probe,
+		.driver = {
+		.name = "clk-starfive-jh7110-vout",
+		.of_match_table = clk_starfive_jh7110_vout_match,
+		.pm = &clk_vout_pm_ops,
+	},
+};
+module_platform_driver(clk_starfive_jh7110_vout_driver);
+
+MODULE_AUTHOR("Xingyu Wu <xingyu.wu@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive JH7110 vout clock driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/clk/starfive/clk-starfive-jh7110.h b/drivers/clk/starfive/clk-starfive-jh7110.h
new file mode 100644
index 000000000000..e394d220bdf1
--- /dev/null
+++ b/drivers/clk/starfive/clk-starfive-jh7110.h
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * StarFive JH7110 Clock Generator Driver
+ *
+ * Copyright (C) 2022 Xingyu Wu <xingyu.wu@starfivetech.com>
+ */
+
+#ifndef _CLK_STARFIVE_JH7110_H_
+#define _CLK_STARFIVE_JH7110_H_
+
+#include <linux/bits.h>
+#include <linux/clk-provider.h>
+#include <linux/debugfs.h>
+#include <dt-bindings/clock/starfive-jh7110-clkgen.h>
+#include <dt-bindings/clock/starfive-jh7110-vout.h>
+#include <dt-bindings/clock/starfive-jh7110-isp.h>
+#include "clk-starfive-jh7110-pll.h"
+
+/* register flags */
+#define JH7110_CLK_SYS_FLAG	1
+#define JH7110_CLK_STG_FLAG	2
+#define JH7110_CLK_AON_FLAG	3
+#define JH7110_CLK_VOUT_FLAG	4
+#define JH7110_CLK_ISP_FLAG	5
+
+/* register fields */
+#define JH7110_CLK_ENABLE	BIT(31)
+#define JH7110_CLK_INVERT	BIT(30)
+#define JH7110_CLK_MUX_MASK	GENMASK(29, 24)
+#define JH7110_CLK_MUX_SHIFT	24
+#define JH7110_CLK_DIV_MASK	GENMASK(23, 0)
+
+/* clkgen PLL CLOCK offset */
+#define PLL_OF(x)	(x - JH7110_CLK_REG_END)
+/* vout PLL CLOCK offset */
+#define PLL_OFV(x)	(x - JH7110_CLK_VOUT_REG_END)
+/* isp PLL CLOCK offset */
+#define PLL_OFI(x)	(x - JH7110_CLK_ISP_REG_END)
+
+#define GATE_FLAG_NORMAL  0
+
+enum {
+	PARENT_NUMS_1 = 1,
+	PARENT_NUMS_2,
+	PARENT_NUMS_3,
+	PARENT_NUMS_4,
+};
+
+/* clock data */
+struct jh7110_clk_data {
+	const char *name;
+	unsigned long flags;
+	u32 max;
+	u16 parents[4];
+};
+
+struct jh7110_clk {
+	struct clk_hw hw;
+	unsigned int idx;
+	unsigned int max_div;
+	unsigned int reg_flags;
+	u32 saved_reg_value;
+};
+
+struct jh7110_clk_priv {
+	/* protect clk enable and set rate/parent from happening at the same time */
+	spinlock_t rmw_lock;
+	struct device *dev;
+	void __iomem *sys_base;
+	void __iomem *stg_base;
+	void __iomem *aon_base;
+	void __iomem *vout_base;
+	void __iomem *isp_base;
+	struct clk_hw *pll[PLL_OF(JH7110_CLK_END)];
+#ifdef CONFIG_CLK_STARFIVE_JH7110_PLL
+	struct jh7110_clk_pll_data pll_priv[PLL_INDEX_MAX];
+#endif
+	struct jh7110_clk reg[];
+};
+
+#define JH7110_GATE(_idx, _name, _flags, _parent)\
+[_idx] = {\
+	.name = _name,\
+	.flags = CLK_SET_RATE_PARENT | (_flags),\
+	.max = JH7110_CLK_ENABLE,\
+	.parents = { [0] = _parent },\
+}
+
+#define JH7110__DIV(_idx, _name, _max, _parent)\
+[_idx] = {\
+	.name = _name,\
+	.flags = 0,\
+	.max = _max,\
+	.parents = { [0] = _parent },\
+}
+
+#define JH7110_GDIV(_idx, _name, _flags, _max, _parent)\
+[_idx] = {\
+	.name = _name,\
+	.flags = _flags,\
+	.max = JH7110_CLK_ENABLE | (_max),\
+	.parents = { [0] = _parent },\
+}
+
+#define JH7110__MUX(_idx, _name, _nparents, ...)\
+[_idx] = {\
+	.name = _name,\
+	.flags = 0,\
+	.max = ((_nparents) - 1) << JH7110_CLK_MUX_SHIFT,\
+	.parents = { __VA_ARGS__ },\
+}
+
+#define JH7110_GMUX(_idx, _name, _flags, _nparents, ...)\
+[_idx] = {\
+	.name = _name,\
+	.flags = _flags,\
+	.max = JH7110_CLK_ENABLE |\
+		(((_nparents) - 1) << JH7110_CLK_MUX_SHIFT),\
+	.parents = { __VA_ARGS__ },\
+}
+
+#define JH7110_MDIV(_idx, _name, _max, _nparents, ...)\
+[_idx] = {\
+	.name = _name,\
+	.flags = 0,\
+	.max = (((_nparents) - 1) << JH7110_CLK_MUX_SHIFT) | (_max),\
+	.parents = { __VA_ARGS__ },\
+}
+
+#define JH7110__GMD(_idx, _name, _flags, _max, _nparents, ...)\
+[_idx] = {\
+	.name = _name,\
+	.flags = _flags,\
+	.max = JH7110_CLK_ENABLE |\
+		(((_nparents) - 1) << JH7110_CLK_MUX_SHIFT) | (_max),\
+	.parents = { __VA_ARGS__ },\
+}
+
+#define JH7110__INV(_idx, _name, _parent)\
+[_idx] = {\
+	.name = _name,\
+	.flags = CLK_SET_RATE_PARENT,\
+	.max = JH7110_CLK_INVERT,\
+	.parents = { [0] = _parent },\
+}
+
+void __iomem *jh7110_clk_reg_addr_get(struct jh7110_clk *clk);
+const struct clk_ops *starfive_jh7110_clk_ops(u32 max);
+
+int __init clk_starfive_jh7110_sys_init(struct platform_device *pdev,
+					struct jh7110_clk_priv *priv);
+int __init clk_starfive_jh7110_stg_init(struct platform_device *pdev,
+					struct jh7110_clk_priv *priv);
+int __init clk_starfive_jh7110_aon_init(struct platform_device *pdev,
+					struct jh7110_clk_priv *priv);
+
+#endif
diff --git a/drivers/clocksource/Kconfig b/drivers/clocksource/Kconfig
index a0c6e88bebe0..d7fe3d11174c 100644
--- a/drivers/clocksource/Kconfig
+++ b/drivers/clocksource/Kconfig
@@ -664,6 +664,17 @@ config RISCV_TIMER
 	  is accessed via both the SBI and the rdcycle instruction.  This is
 	  required for all RISC-V systems.
 
+config STARFIVE_TIMER
+        bool "Timer for the STARFIVE SOCS"
+        depends on RISCV && OF
+        select TIMER_OF
+        select CLKSRC_MMIO
+        help
+          This enables the starfive timers for SoCs. On RISC-V platform,
+          the system has started RISCV_TIMER. But you can also use these timers
+          to do a lot more on StarFive Soc. These timers can provide much
+          higher precision than RISCV_TIMER.
+
 config CLINT_TIMER
 	bool "CLINT Timer for the RISC-V platform" if COMPILE_TEST
 	depends on GENERIC_SCHED_CLOCK && RISCV
diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
index 1c444cc3bb44..0e5671016356 100644
--- a/drivers/clocksource/Makefile
+++ b/drivers/clocksource/Makefile
@@ -94,3 +94,4 @@ obj-$(CONFIG_CSKY_MP_TIMER)		+= timer-mp-csky.o
 obj-$(CONFIG_GX6605S_TIMER)		+= timer-gx6605s.o
 obj-$(CONFIG_HYPERV_TIMER)		+= hyperv_timer.o
 obj-$(CONFIG_MICROCHIP_PIT64B)		+= timer-microchip-pit64b.o
+obj-$(CONFIG_STARFIVE_TIMER)		+= timer-starfive.o
diff --git a/drivers/clocksource/timer-starfive.c b/drivers/clocksource/timer-starfive.c
new file mode 100644
index 000000000000..46003d13fa1d
--- /dev/null
+++ b/drivers/clocksource/timer-starfive.c
@@ -0,0 +1,531 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Starfive Timer driver
+ *
+ * Copyright 2021 StarFive, Inc. All rights reserved.
+ */
+
+#include <linux/clk.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_clk.h>
+#include <linux/of_irq.h>
+#include <linux/sched_clock.h>
+#include <linux/module.h>
+#include <linux/reset.h>
+#include "timer-starfive.h"
+
+#define CLOCK_SOURCE_RATE	200
+#define VALID_BITS		32
+#define DELAY_US		0
+#define TIMEOUT_US		10000
+#define CLOCKEVENT_RATING	300
+#define MAX_TICKS		0xffffffff
+#define MIN_TICKS		0xf
+
+struct starfive_timer __initdata jh7110_starfive_timer = {
+	.ctrl		= STF_TIMER_CTL,
+	.load		= STF_TIMER_LOAD,
+	.enable		= STF_TIMER_ENABLE,
+	.reload		= STF_TIMER_RELOAD,
+	.value		= STF_TIMER_VALUE,
+	.intclr		= STF_TIMER_INT_CLR,
+	.intmask	= STF_TIMER_INT_MASK,
+	.timer_base	= {TIMER_BASE(0), TIMER_BASE(1), TIMER_BASE(2),
+			TIMER_BASE(3), TIMER_BASE(4), TIMER_BASE(5),
+			TIMER_BASE(6), TIMER_BASE(7)},
+};
+
+struct starfive_timer_misc_count sfcmisc = {
+	.clk_count = 0,
+	.flg_init_clk = false,
+};
+
+static inline struct starfive_clkevt *
+to_starfive_clkevt(struct clock_event_device *evt)
+{
+	return container_of(evt, struct starfive_clkevt, evt);
+}
+
+static inline struct starfive_clkevt *
+to_starfive_clksrc(struct clocksource *cs)
+{
+	return container_of(cs, struct starfive_clkevt, cs);
+}
+
+static inline void timer_set_mod(struct starfive_clkevt *clkevt, int mod)
+{
+	writel(mod, clkevt->ctrl);
+}
+
+/*
+ * After disable timer, then enable, the timer will start
+ * from the reload count value(0x08[31:0]).
+ */
+static inline void timer_int_enable(struct starfive_clkevt *clkevt)
+{
+	writel(INTMASK_ENABLE_DIS, clkevt->intmask);
+}
+
+static inline void timer_int_disable(struct starfive_clkevt *clkevt)
+{
+	writel(INTMASK_ENABLE, clkevt->intmask);
+}
+
+static inline void timer_int_clear(struct starfive_clkevt *clkevt)
+{
+	/* waiting interrupt can be to clearing */
+	u32 value;
+	int ret = 0;
+
+	value = readl(clkevt->intclr);
+	ret = readl_poll_timeout_atomic(clkevt->intclr, value,
+			!(value & INT_STATUS_CLR_AVA), DELAY_US, TIMEOUT_US);
+	if (!ret)
+		writel(1, clkevt->intclr);
+}
+
+/*
+ * The initial value to be loaded into the
+ * counter and is also used as the reload value.
+ */
+static inline void timer_set_val(struct starfive_clkevt *clkevt, u32 val)
+{
+	writel(val, clkevt->load);
+}
+
+static inline u32 timer_get_val(struct starfive_clkevt *clkevt)
+{
+	return readl(clkevt->value);
+}
+
+static inline u32 timer_get_load_val(struct starfive_clkevt *clkevt)
+{
+	return readl(clkevt->load);
+}
+
+/*
+ * Write RELOAD register to reload preset value to counter.
+ * (Write 0 and write 1 are both ok)
+ */
+static inline void
+timer_set_reload(struct starfive_clkevt *clkevt)
+{
+	writel(1, clkevt->reload);
+}
+
+static inline void timer_enable(struct starfive_clkevt *clkevt)
+{
+	writel(TIMER_ENA, clkevt->enable);
+}
+
+static inline void timer_disable(struct starfive_clkevt *clkevt)
+{
+	writel(TIMER_ENA_DIS, clkevt->enable);
+}
+
+static void timer_shutdown(struct starfive_clkevt *clkevt)
+{
+	timer_int_disable(clkevt);
+	timer_disable(clkevt);
+}
+
+#ifdef CONFIG_PM_SLEEP
+
+static void starfive_timer_suspend(struct clocksource *cs)
+{
+	struct starfive_clkevt *clkevt;
+	struct clk *pclk;
+
+	clkevt = to_starfive_clksrc(cs);
+
+	clkevt->reload_val = timer_get_load_val(clkevt);
+	timer_disable(clkevt);
+	timer_int_disable(clkevt);
+
+	clkevt->misc->clk_count--;
+
+	if (clkevt->misc->clk_count < 1)
+		pclk = of_clk_get_by_name(clkevt->device_node, "apb_clk");
+
+	if (!clkevt->misc->flg_init_clk) {
+		const char *name = NULL;
+
+		of_property_read_string_index(clkevt->device_node,
+				"clock-names", clkevt->index, &name);
+		clkevt->clk = of_clk_get_by_name(clkevt->device_node, name);
+		clk_prepare_enable(clkevt->clk);
+		clk_disable_unprepare(clkevt->clk);
+
+		if (clkevt->misc->clk_count < 1) {
+			clk_prepare_enable(pclk);
+			clk_disable_unprepare(pclk);
+		}
+	} else {
+		clk_disable_unprepare(clkevt->clk);
+
+		if (clkevt->misc->clk_count < 1)
+			clk_disable_unprepare(pclk);
+	}
+}
+
+static void starfive_timer_resume(struct clocksource *cs)
+{
+	struct starfive_clkevt *clkevt;
+
+	clkevt = to_starfive_clksrc(cs);
+
+	clkevt->misc->flg_init_clk = true;
+
+	if (clkevt->misc->clk_count < 1) {
+		struct clk *pclk;
+
+		pclk = of_clk_get_by_name(clkevt->device_node, "apb_clk");
+		clk_prepare_enable(pclk);
+	}
+	clk_prepare_enable(clkevt->clk);
+	clkevt->misc->clk_count++;
+
+	timer_set_val(clkevt, clkevt->reload_val);
+	timer_set_reload(clkevt);
+	timer_int_enable(clkevt);
+	timer_enable(clkevt);
+}
+
+#endif /*CONIFG PM SLEEP*/
+
+static int starfive_timer_shutdown(struct clock_event_device *evt)
+{
+	struct starfive_clkevt *clkevt;
+
+	clkevt = to_starfive_clkevt(evt);
+	timer_shutdown(clkevt);
+
+	return 0;
+}
+
+static int
+starfive_get_clock_rate(struct starfive_clkevt *clkevt, struct device_node *np)
+{
+	int ret;
+	u32 rate;
+
+	if (clkevt->clk) {
+		clkevt->rate = clk_get_rate(clkevt->clk);
+		if (clkevt->rate > 0) {
+			pr_debug("clk_get_rate clkevt->rate: %lld\n",
+				clkevt->rate);
+			return 0;
+		}
+	}
+
+	/* Next we try to get clock-frequency from dts.*/
+	ret = of_property_read_u32(np, "clock-frequency", &rate);
+	if (!ret) {
+		pr_debug("Timer: try get clock-frequency:%d MHz\n", rate);
+		clkevt->rate = (u64)rate;
+		return 0;
+	}
+	pr_err("Timer: get rate failed, need clock-frequency define in dts.\n");
+
+	return -ENOENT;
+}
+
+static u64 starfive_clocksource_mmio_readl_down(struct clocksource *c)
+{
+	return ~(u64)readl_relaxed(to_starfive_clksrc(c)->value) & c->mask;
+}
+
+static int starfive_clocksource_init(struct starfive_clkevt *clkevt,
+				const char *name, struct device_node *np)
+{
+
+	if (VALID_BITS > 64 || VALID_BITS < 16)
+		return -EINVAL;
+
+	clkevt->cs.name = name;
+	clkevt->cs.rating = CLOCK_SOURCE_RATE;
+	clkevt->cs.read = starfive_clocksource_mmio_readl_down;
+	clkevt->cs.mask = CLOCKSOURCE_MASK(VALID_BITS);
+	clkevt->cs.flags = CLOCK_SOURCE_IS_CONTINUOUS;
+	clkevt->cs.suspend = starfive_timer_suspend;
+	clkevt->cs.resume = starfive_timer_resume;
+
+	timer_set_mod(clkevt, MOD_CONTIN);
+	timer_set_val(clkevt, MAX_TICKS);  /* val = rate --> 1s */
+	timer_int_disable(clkevt);
+	timer_int_clear(clkevt);
+	timer_int_enable(clkevt);
+	timer_enable(clkevt);
+
+	clocksource_register_hz(&clkevt->cs, clkevt->rate);
+
+	return 0;
+}
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t starfive_timer_interrupt(int irq, void *priv)
+{
+	struct clock_event_device *evt = (struct clock_event_device  *)priv;
+	struct starfive_clkevt *clkevt = to_starfive_clkevt(evt);
+
+	timer_int_clear(clkevt);
+	if (evt->event_handler)
+		evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static int starfive_timer_set_periodic(struct clock_event_device *evt)
+{
+	struct starfive_clkevt *clkevt;
+
+	clkevt = to_starfive_clkevt(evt);
+
+	timer_disable(clkevt);
+	timer_set_mod(clkevt, MOD_CONTIN);
+	timer_set_val(clkevt, clkevt->periodic);
+	timer_int_disable(clkevt);
+	timer_int_clear(clkevt);
+	timer_int_enable(clkevt);
+	timer_enable(clkevt);
+
+	return 0;
+}
+
+static int starfive_timer_set_oneshot(struct clock_event_device *evt)
+{
+	struct starfive_clkevt *clkevt;
+
+	clkevt = to_starfive_clkevt(evt);
+
+	timer_disable(clkevt);
+	timer_set_mod(clkevt, MOD_SINGLE);
+	timer_set_val(clkevt, MAX_TICKS);
+	timer_int_disable(clkevt);
+	timer_int_clear(clkevt);
+	timer_int_enable(clkevt);
+	timer_enable(clkevt);
+
+	return 0;
+}
+
+static int starfive_timer_set_next_event(unsigned long next,
+					struct clock_event_device *evt)
+{
+	struct starfive_clkevt *clkevt;
+
+	clkevt = to_starfive_clkevt(evt);
+
+	timer_disable(clkevt);
+	timer_set_mod(clkevt, MOD_SINGLE);
+	timer_set_val(clkevt, next);
+	timer_enable(clkevt);
+
+	return 0;
+}
+
+static void starfive_set_clockevent(struct clock_event_device *evt)
+{
+	evt->features	= CLOCK_EVT_FEAT_PERIODIC |
+			CLOCK_EVT_FEAT_ONESHOT |
+			CLOCK_EVT_FEAT_DYNIRQ;
+	evt->set_state_shutdown	= starfive_timer_shutdown;
+	evt->set_state_periodic	= starfive_timer_set_periodic;
+	evt->set_state_oneshot	= starfive_timer_set_oneshot;
+	evt->set_state_oneshot_stopped = starfive_timer_shutdown;
+	evt->set_next_event	= starfive_timer_set_next_event;
+	evt->rating		= CLOCKEVENT_RATING;
+}
+
+static int starfive_clockevents_register(struct starfive_clkevt *clkevt, unsigned int irq,
+				struct device_node *np, const char *name)
+{
+	int ret = 0;
+
+	ret = starfive_get_clock_rate(clkevt, np);
+	if (ret)
+		return -EINVAL;
+
+	clkevt->periodic = DIV_ROUND_CLOSEST(clkevt->rate, HZ);
+
+	starfive_set_clockevent(&clkevt->evt);
+	clkevt->evt.name = name;
+	clkevt->evt.irq = irq;
+	clkevt->evt.cpumask = cpu_possible_mask;
+
+	ret = request_irq(irq, starfive_timer_interrupt,
+			IRQF_TIMER | IRQF_IRQPOLL, name, &clkevt->evt);
+	if (ret)
+		pr_err("%s: request_irq failed\n", name);
+
+	clockevents_config_and_register(&clkevt->evt, clkevt->rate,
+			MIN_TICKS, MAX_TICKS);
+
+	return ret;
+}
+
+static void __init starfive_clkevt_init(struct starfive_timer *timer,
+					struct starfive_clkevt *clkevt,
+					void __iomem *base, int index)
+{
+	void __iomem *timer_base;
+
+	timer_base = base + timer->timer_base[index];
+	clkevt->base	= timer_base;
+	clkevt->ctrl	= timer_base + timer->ctrl;
+	clkevt->load	= timer_base + timer->load;
+	clkevt->enable	= timer_base + timer->enable;
+	clkevt->reload	= timer_base + timer->reload;
+	clkevt->value	= timer_base + timer->value;
+	clkevt->intclr	= timer_base + timer->intclr;
+	clkevt->intmask	= timer_base + timer->intmask;
+}
+
+static int __init do_starfive_timer_of_init(struct device_node *np,
+					struct starfive_timer *timer)
+{
+	int index, count, irq, ret = -EINVAL;
+	const char *name = NULL;
+	struct clk *clk;
+	struct clk *pclk;
+	struct reset_control *prst;
+	struct reset_control *rst;
+	struct starfive_clkevt *clkevt[4];
+	void __iomem *base;
+
+	base = of_iomap(np, 0);
+	if (!base)
+		return -ENXIO;
+
+	if (!of_device_is_available(np)) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	pclk = of_clk_get_by_name(np, "apb_clk");
+	if (!IS_ERR(pclk))
+		if (clk_prepare_enable(pclk))
+			pr_warn("pclk for %pOFn is present,"
+				"but could not be activated\n", np);
+
+	prst = of_reset_control_get(np, "apb_rst");
+	if (!IS_ERR(prst)) {
+		reset_control_assert(prst);
+		reset_control_deassert(prst);
+	}
+
+	count = of_irq_count(np);
+	if (count > NR_TIMERS || count <= 0) {
+		ret = -EINVAL;
+		goto count_err;
+	}
+
+	for (index = 0; index < count; index++) {
+		/* one of timer is wdog-timer, skip...*/
+		of_property_read_string_index(np, "clock-names", index, &name);
+		if (strncmp(name, "timer", strlen("timer")))
+			continue;
+
+		clkevt[index] = kzalloc(sizeof(*clkevt[index]), GFP_KERNEL);
+		if (!clkevt[index]) {
+			ret = -ENOMEM;
+			goto clkevt_err;
+		}
+		clkevt[index]->device_node = np;
+		clkevt[index]->index = index;
+		clkevt[index]->misc = &sfcmisc;
+
+		starfive_clkevt_init(timer, clkevt[index], base, index);
+
+		/* Ensure timers are disabled */
+		timer_disable(clkevt[index]);
+
+		clk = of_clk_get_by_name(np, name);
+		if (!IS_ERR(clk)) {
+			clkevt[index]->clk = clk;
+
+			if (clk_prepare_enable(clk)) {
+				pr_warn("clk for %pOFn is present,"
+					"but could not be activated\n", np);
+			}
+		}
+
+		clkevt[index]->misc->clk_count++;
+
+		rst = of_reset_control_get(np, name);
+		if (!IS_ERR(rst)) {
+			reset_control_assert(rst);
+			reset_control_deassert(rst);
+		}
+
+		irq = irq_of_parse_and_map(np, index);
+		if (irq < 0) {
+			ret = -EINVAL;
+			goto irq_err;
+		}
+
+		snprintf(clkevt[index]->name, sizeof(clkevt[index]->name), "%s.ch%d",
+					np->full_name, index);
+
+		ret = starfive_clockevents_register(clkevt[index], irq, np, clkevt[index]->name);
+		if (ret) {
+			pr_err("%s: init clockevents failed.\n", clkevt[index]->name);
+			goto register_err;
+		}
+		clkevt[index]->irq = irq;
+
+		ret = starfive_clocksource_init(clkevt[index], clkevt[index]->name, np);
+		if (ret)
+			goto init_err;
+	}
+	if (!IS_ERR(pclk))
+		clk_put(pclk);
+
+	return 0;
+
+init_err:
+register_err:
+	free_irq(clkevt[index]->irq, &clkevt[index]->evt);
+irq_err:
+	if (!rst) {
+		reset_control_assert(rst);
+		reset_control_put(rst);
+	}
+	if (!clkevt[index]->clk) {
+		clk_disable_unprepare(clkevt[index]->clk);
+		clk_put(clkevt[index]->clk);
+	}
+	kfree(clkevt[index]);
+clkevt_err:
+count_err:
+	if (!IS_ERR(pclk)) {
+		if (!index)
+			clk_disable_unprepare(pclk);
+		clk_put(pclk);
+	}
+err:
+	iounmap(base);
+	return ret;
+}
+
+static int __init starfive_timer_of_init(struct device_node *np)
+{
+	return do_starfive_timer_of_init(np, &jh7110_starfive_timer);
+}
+TIMER_OF_DECLARE(starfive_timer, "starfive,jh7110-timers", starfive_timer_of_init);
+
+MODULE_AUTHOR("xingyu.wu <xingyu.wu@starfivetech.com>");
+MODULE_AUTHOR("samin.guo <samin.guo@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive Timer Device Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/clocksource/timer-starfive.h b/drivers/clocksource/timer-starfive.h
new file mode 100644
index 000000000000..f2ccc07d0e22
--- /dev/null
+++ b/drivers/clocksource/timer-starfive.h
@@ -0,0 +1,110 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2021 StarFive, Inc <samin.guo@starfivetech.com>
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING
+ * CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER
+ * FOR THEM TO SAVE TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE
+ * FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+ * CLAIMS ARISING FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE
+ * BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION
+ * WITH THEIR PRODUCTS.
+ */
+#ifndef STARFIVE_TIMER_H
+#define STARFIVE_TIMER_H
+
+#define NR_TIMERS		TIMERS_MAX
+#define PER_TIMER_LEN		0x40
+#define TIMER_BASE(x)		((TIMER_##x)*PER_TIMER_LEN)
+
+/*
+ * JH7100 timwer TIMER_INT_STATUS:
+ * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ * |     Bits     | 08~31 | 7 | 6 | 5 |  4  | 3 | 2 | 1 | 0 |
+ * ----------------------------------------------------------
+ * | timer(n)_int |  res  | 6 | 5 | 4 | Wdt | 3 | 2 | 1 | 0 |
+ * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ *
+ * Software can read this register to know which interrupt is occurred.
+ */
+#define	STF_TIMER_INT_STATUS	0x00
+#define STF_TIMER_CTL		0x04
+#define STF_TIMER_LOAD		0x08
+#define STF_TIMER_ENABLE	0x10
+#define STF_TIMER_RELOAD	0x14
+#define STF_TIMER_VALUE		0x18
+#define STF_TIMER_INT_CLR	0x20
+#define STF_TIMER_INT_MASK	0x24
+#define INT_STATUS_CLR_AVA	BIT(1)
+
+enum STF_TIMERS {
+	TIMER_0 = 0,
+	TIMER_1,
+	TIMER_2,
+	TIMER_3,
+	TIMER_4,  /*WDT*/
+	TIMER_5,
+	TIMER_6,
+	TIMER_7,
+	TIMERS_MAX
+};
+
+enum TIMERI_INTMASK {
+	INTMASK_ENABLE_DIS = 0,
+	INTMASK_ENABLE = 1
+};
+
+enum TIMER_MOD {
+	MOD_CONTIN = 0,
+	MOD_SINGLE = 1
+};
+
+enum TIMER_CTL_EN {
+	TIMER_ENA_DIS	= 0,
+	TIMER_ENA	= 1
+};
+
+enum {
+	INT_CLR_AVAILABLE = 0,
+	INT_CLR_NOT_AVAILABLE = 1
+};
+
+struct starfive_timer {
+	u32 ctrl;
+	u32 load;
+	u32 enable;
+	u32 reload;
+	u32 value;
+	u32 intclr;
+	u32 intmask;
+	u32 wdt_lock;   /* 0x3c+i*0x40 watchdog use ONLY */
+	u32 timer_base[NR_TIMERS];
+};
+
+struct starfive_timer_misc_count {
+	u8 clk_count;
+	bool flg_init_clk;
+};
+
+struct starfive_clkevt {
+	struct clock_event_device evt;
+	struct clocksource cs;
+	struct device_node *device_node;
+	struct starfive_timer_misc_count *misc;
+	struct clk *clk;
+	char name[20];
+	int index;
+	int irq;
+	u64 periodic;
+	u64 rate;
+	u32 reload_val;
+	void __iomem *base;
+	void __iomem *ctrl;
+	void __iomem *load;
+	void __iomem *enable;
+	void __iomem *reload;
+	void __iomem *value;
+	void __iomem *intclr;
+	void __iomem *intmask;
+};
+#endif /* STARFIVE_TIMER_H */
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index 7c762e105146..7b096ab3fabd 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -100,6 +100,10 @@ obj-$(CONFIG_CPU_FREQ_PMAC64)		+= pmac64-cpufreq.o
 obj-$(CONFIG_PPC_PASEMI_CPUFREQ)	+= pasemi-cpufreq.o
 obj-$(CONFIG_POWERNV_CPUFREQ)		+= powernv-cpufreq.o
 
+##################################################################################
+# Riscv platform drivers
+obj-$(CONFIG_RISCV_STARFIVE_CPUFREQ)	+= starfive-cpufreq.o
+
 ##################################################################################
 # Other platform drivers
 obj-$(CONFIG_BMIPS_CPUFREQ)		+= bmips-cpufreq.o
diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c
index a3734014db47..9faff7ffeaed 100644
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -92,6 +92,7 @@ static const struct of_device_id whitelist[] __initconst = {
 
 	{ .compatible = "xlnx,zynq-7000", },
 	{ .compatible = "xlnx,zynqmp", },
+	{ .compatible = "starfive,jh7110", },
 
 	{ }
 };
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index ff5e85eefbf6..1445b863a4e3 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -882,6 +882,8 @@ config CRYPTO_DEV_CCREE
 
 source "drivers/crypto/hisilicon/Kconfig"
 
+source "drivers/crypto/starfive/Kconfig"
+
 source "drivers/crypto/amlogic/Kconfig"
 
 config CRYPTO_DEV_SA2UL
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index 53fc115cf459..9dfac445df93 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -49,5 +49,6 @@ obj-$(CONFIG_CRYPTO_DEV_BCM_SPU) += bcm/
 obj-$(CONFIG_CRYPTO_DEV_SAFEXCEL) += inside-secure/
 obj-$(CONFIG_CRYPTO_DEV_ARTPEC6) += axis/
 obj-$(CONFIG_CRYPTO_DEV_ZYNQMP_AES) += xilinx/
+obj-$(CONFIG_SOC_STARFIVE) += starfive/
 obj-y += hisilicon/
 obj-$(CONFIG_CRYPTO_DEV_AMLOGIC_GXL) += amlogic/
diff --git a/drivers/crypto/starfive/Kconfig b/drivers/crypto/starfive/Kconfig
new file mode 100644
index 000000000000..371e26f1c655
--- /dev/null
+++ b/drivers/crypto/starfive/Kconfig
@@ -0,0 +1,18 @@
+#
+# Starfive crypto drivers configuration
+#
+
+config CRYPTO_DEV_JH7110_ENCRYPT
+	tristate "Starfive's Cryptographic Engine driver"
+	depends on RISCV
+	select CRYPTO_ENGINE
+	select CRYPTO_RSA
+	select CRYPTO_LIB_DES
+	select CRYPTO_SKCIPHER
+	select AMBA_PL08X
+	default m
+	help
+	  Support for Starfive JH7110 cryptographic acceleration instructions
+	  on riscv64 CPU. This hardware crypto module supports acceleration for
+	  public key algo, ciphers, AEAD and hash functions.
+	  If you choose 'M' here, this module will be called jh7110-crypto.
diff --git a/drivers/crypto/starfive/Makefile b/drivers/crypto/starfive/Makefile
new file mode 100644
index 000000000000..9bdfd41069cd
--- /dev/null
+++ b/drivers/crypto/starfive/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-y += jh7110/
diff --git a/drivers/crypto/starfive/jh7110/Makefile b/drivers/crypto/starfive/jh7110/Makefile
new file mode 100644
index 000000000000..1d10020aef1a
--- /dev/null
+++ b/drivers/crypto/starfive/jh7110/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_CRYPTO_DEV_JH7110_ENCRYPT) += jh7110-crypto.o
+jh7110-crypto-objs := jh7110-sec.o jh7110-sha.o jh7110-aes.o jh7110-pka.o
diff --git a/drivers/crypto/starfive/jh7110/jh7110-aes.c b/drivers/crypto/starfive/jh7110/jh7110-aes.c
new file mode 100644
index 000000000000..0c9310ca2dfd
--- /dev/null
+++ b/drivers/crypto/starfive/jh7110/jh7110-aes.c
@@ -0,0 +1,1802 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2021 StarFive, Inc <william.qiu@starfivetech.com>
+ * Copyright 2021 StarFive, Inc <huan.feng@starfivetech.com>
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING
+ * CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER
+ * FOR THEM TO SAVE TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE
+ * FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+ * CLAIMS ARISING FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE
+ * BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION
+ * WITH THEIR PRODUCTS.
+ */
+
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <linux/amba/pl080.h>
+#include <crypto/hash.h>
+#include <crypto/gcm.h>
+
+#include <linux/dma-direct.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/internal/aead.h>
+#include <crypto/internal/hash.h>
+#include <crypto/internal/skcipher.h>
+
+#include "jh7110-str.h"
+
+/* Mode mask = bits [3..0] */
+#define FLG_MODE_MASK				GENMASK(2, 0)
+
+/* Bit [4] encrypt / decrypt */
+#define FLG_ENCRYPT				BIT(4)
+
+/* Bit [31..16] status  */
+#define FLG_CCM_PADDED_WA			BIT(5)
+
+#define SR_BUSY					0x00000010
+#define SR_OFNE					0x00000004
+
+#define IMSCR_IN				BIT(0)
+#define IMSCR_OUT				BIT(1)
+
+#define MISR_IN					BIT(0)
+#define MISR_OUT				BIT(1)
+
+/* Misc */
+#define AES_BLOCK_32				(AES_BLOCK_SIZE / sizeof(u32))
+#define GCM_CTR_INIT				1
+#define CRYP_AUTOSUSPEND_DELAY			50
+
+static inline int jh7110_aes_wait_busy(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	u32 status;
+
+	return readl_relaxed_poll_timeout(sdev->io_base + JH7110_AES_CSR, status,
+				   !(status & JH7110_AES_BUSY), 10, 100000);
+}
+
+static inline int jh7110_aes_wait_keydone(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	u32 status;
+
+	return readl_relaxed_poll_timeout(sdev->io_base + JH7110_AES_CSR, status,
+				   (status & JH7110_AES_KEY_DONE), 10, 100000);
+}
+
+static inline int jh7110_aes_wait_gcmdone(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	u32 status;
+
+	return readl_relaxed_poll_timeout(sdev->io_base + JH7110_AES_CSR, status,
+				   (status & JH7110_AES_GCM_DONE), 10, 100000);
+}
+
+static int jh7110_cryp_check_aligned(struct scatterlist *sg, size_t total,
+		size_t align)
+{
+	int len = 0;
+
+	if (!total)
+		return 0;
+
+	if (!IS_ALIGNED(total, align))
+		return -EINVAL;
+
+	while (sg) {
+		if (!IS_ALIGNED(sg->offset, sizeof(u32)))
+			return -EINVAL;
+
+		if (!IS_ALIGNED(sg->length, align))
+			return -EINVAL;
+
+		len += sg->length;
+		sg = sg_next(sg);
+	}
+
+	if (len != total)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int jh7110_cryp_check_io_aligned(struct jh7110_sec_request_ctx *rctx)
+{
+	int ret;
+
+	ret = jh7110_cryp_check_aligned(rctx->in_sg, rctx->total_in,
+			rctx->hw_blocksize);
+
+	if (ret)
+		return ret;
+
+	ret = jh7110_cryp_check_aligned(rctx->out_sg, rctx->total_out,
+			rctx->hw_blocksize);
+
+	return ret;
+}
+
+static void sg_copy_buf(void *buf, struct scatterlist *sg,
+		unsigned int start, unsigned int nbytes, int out)
+{
+	struct scatter_walk walk;
+
+	if (!nbytes)
+		return;
+
+	scatterwalk_start(&walk, sg);
+	scatterwalk_advance(&walk, start);
+	scatterwalk_copychunks(buf, &walk, nbytes, out);
+	scatterwalk_done(&walk, out, 0);
+}
+
+static int jh7110_cryp_copy_sgs(struct jh7110_sec_request_ctx *rctx)
+{
+	void *buf_in, *buf_out;
+	int pages, total_in, total_out;
+
+	if (!jh7110_cryp_check_io_aligned(rctx)) {
+		rctx->sgs_copied = 0;
+		return 0;
+	}
+
+	total_in = ALIGN(rctx->total_in, rctx->hw_blocksize);
+	pages = total_in ? get_order(total_in) : 1;
+	buf_in = (void *)__get_free_pages(GFP_ATOMIC, pages);
+
+	total_out = ALIGN(rctx->total_out, rctx->hw_blocksize);
+	pages = total_out ? get_order(total_out) : 1;
+	buf_out = (void *)__get_free_pages(GFP_ATOMIC, pages);
+
+	if (!buf_in || !buf_out) {
+		dev_err(rctx->sdev->dev, "Can't allocate pages when unaligned\n");
+		rctx->sgs_copied = 0;
+		return -EFAULT;
+	}
+
+	sg_copy_buf(buf_in, rctx->in_sg, 0, rctx->total_in, 0);
+
+	sg_init_one(&rctx->in_sgl, buf_in, total_in);
+	rctx->in_sg = &rctx->in_sgl;
+	rctx->in_sg_len = 1;
+
+	sg_init_one(&rctx->out_sgl, buf_out, total_out);
+	rctx->out_sg_save = rctx->out_sg;
+	rctx->out_sg = &rctx->out_sgl;
+	rctx->out_sg_len = 1;
+
+	rctx->sgs_copied = 1;
+
+	return 0;
+}
+
+static inline int is_ecb(struct jh7110_sec_request_ctx *rctx)
+{
+	return (rctx->flags & FLG_MODE_MASK) == JH7110_AES_MODE_ECB;
+}
+
+static inline int is_cbc(struct jh7110_sec_request_ctx *rctx)
+{
+	return (rctx->flags & FLG_MODE_MASK) == JH7110_AES_MODE_CBC;
+}
+
+static inline int is_ofb(struct jh7110_sec_request_ctx *rctx)
+{
+	return (rctx->flags & FLG_MODE_MASK) == JH7110_AES_MODE_OFB;
+}
+
+static inline int is_cfb(struct jh7110_sec_request_ctx *rctx)
+{
+	return (rctx->flags & FLG_MODE_MASK) == JH7110_AES_MODE_CFB;
+}
+
+static inline int is_ctr(struct jh7110_sec_request_ctx *rctx)
+{
+	return (rctx->flags & FLG_MODE_MASK) == JH7110_AES_MODE_CTR;
+}
+
+static inline int is_gcm(struct jh7110_sec_request_ctx *rctx)
+{
+	return (rctx->flags & FLG_MODE_MASK) == JH7110_AES_MODE_GCM;
+}
+
+static inline int is_ccm(struct jh7110_sec_request_ctx *rctx)
+{
+	return (rctx->flags & FLG_MODE_MASK) == JH7110_AES_MODE_CCM;
+}
+
+static inline int get_aes_mode(struct jh7110_sec_request_ctx *rctx)
+{
+	return rctx->flags & FLG_MODE_MASK;
+}
+
+static inline int is_encrypt(struct jh7110_sec_request_ctx *rctx)
+{
+	return !!(rctx->flags & FLG_ENCRYPT);
+}
+
+static inline int is_decrypt(struct jh7110_sec_request_ctx *rctx)
+{
+	return !is_encrypt(rctx);
+}
+
+static int jh7110_cryp_read_auth_tag(struct jh7110_sec_ctx *ctx);
+
+static inline void jh7110_aes_reset(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+
+	rctx->csr.aes_csr.v = 0;
+	rctx->csr.aes_csr.aesrst = 1;
+	jh7110_sec_write(ctx->sdev, JH7110_AES_CSR, rctx->csr.aes_csr.v);
+
+}
+
+static inline void jh7110_aes_xcm_start(struct jh7110_sec_ctx *ctx, u32 hw_mode)
+{
+	unsigned int value;
+
+	switch (hw_mode) {
+	case JH7110_AES_MODE_GCM:
+		value = jh7110_sec_read(ctx->sdev, JH7110_AES_CSR);
+		value |= JH7110_AES_GCM_START;
+		jh7110_sec_write(ctx->sdev, JH7110_AES_CSR, value);
+		break;
+	case JH7110_AES_MODE_CCM:
+		value = jh7110_sec_read(ctx->sdev, JH7110_AES_CSR);
+		value |= JH7110_AES_CCM_START;
+		jh7110_sec_write(ctx->sdev, JH7110_AES_CSR, value);
+		break;
+	}
+}
+
+static inline void jh7110_aes_csr_setup(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+
+	rctx->csr.aes_csr.v = 0;
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_128:
+		rctx->csr.aes_csr.keymode = JH7110_AES_KEYMODE_128;
+		break;
+	case AES_KEYSIZE_192:
+		rctx->csr.aes_csr.keymode = JH7110_AES_KEYMODE_192;
+		break;
+	case AES_KEYSIZE_256:
+		rctx->csr.aes_csr.keymode = JH7110_AES_KEYMODE_256;
+		break;
+	default:
+		return;
+	}
+	rctx->csr.aes_csr.mode  = rctx->flags & FLG_MODE_MASK;
+	rctx->csr.aes_csr.cmode = is_decrypt(rctx);
+	rctx->csr.aes_csr.stream_mode = rctx->stmode;
+
+	if (ctx->sdev->use_side_channel_mitigation) {
+		rctx->csr.aes_csr.delay_aes = 1;
+		rctx->csr.aes_csr.vaes_start = 1;
+	}
+
+	if (jh7110_aes_wait_busy(ctx)) {
+		dev_err(ctx->sdev->dev, "reset error\n");
+		return;
+	}
+
+	jh7110_sec_write(ctx->sdev, JH7110_AES_CSR, rctx->csr.aes_csr.v);
+}
+
+static inline void jh7110_aes_set_ivlen(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+
+	if (is_gcm(rctx))
+		jh7110_sec_write(sdev, JH7110_AES_IVLEN, GCM_AES_IV_SIZE);
+	else
+		jh7110_sec_write(sdev, JH7110_AES_IVLEN, AES_BLOCK_SIZE);
+}
+
+static inline void jh7110_aes_set_alen(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+
+	jh7110_sec_write(sdev, JH7110_AES_ALEN0, (ctx->rctx->assoclen >> 32) & 0xffffffff);
+	jh7110_sec_write(sdev, JH7110_AES_ALEN1, ctx->rctx->assoclen & 0xffffffff);
+}
+
+static unsigned int jh7110_cryp_get_input_text_len(struct jh7110_sec_ctx *ctx);
+
+static inline void jh7110_aes_set_mlen(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	size_t data_len;
+
+	data_len = jh7110_cryp_get_input_text_len(ctx);
+
+	jh7110_sec_write(sdev, JH7110_AES_MLEN0, (data_len >> 32) & 0xffffffff);
+	jh7110_sec_write(sdev, JH7110_AES_MLEN1, data_len & 0xffffffff);
+}
+
+static inline int crypto_ccm_check_iv(const u8 *iv)
+{
+	/* 2 <= L <= 8, so 1 <= L' <= 7. */
+	if (iv[0] < 1 || iv[0] > 7)
+		return -EINVAL;
+
+	return 0;
+}
+
+
+static int jh7110_cryp_hw_write_iv(struct jh7110_sec_ctx *ctx, u32 *iv)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+
+	if (!iv)
+		return -EINVAL;
+
+	jh7110_sec_write(sdev, JH7110_AES_IV0, iv[0]);
+	jh7110_sec_write(sdev, JH7110_AES_IV1, iv[1]);
+	jh7110_sec_write(sdev, JH7110_AES_IV2, iv[2]);
+
+	if (!is_gcm(rctx))
+		jh7110_sec_write(sdev, JH7110_AES_IV3, iv[3]);
+	else
+		if (jh7110_aes_wait_gcmdone(ctx))
+			return -ETIMEDOUT;
+
+	return 0;
+}
+
+static void jh7110_cryp_hw_get_iv(struct jh7110_sec_ctx *ctx, u32 *iv)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+
+	if (!iv)
+		return;
+
+	iv[0] = jh7110_sec_read(sdev, JH7110_AES_IV0);
+	iv[1] = jh7110_sec_read(sdev, JH7110_AES_IV1);
+	iv[2] = jh7110_sec_read(sdev, JH7110_AES_IV2);
+	iv[3] = jh7110_sec_read(sdev, JH7110_AES_IV3);
+}
+
+static void jh7110_cryp_hw_write_ctr(struct jh7110_sec_ctx *ctx, u32 *ctr)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+
+	jh7110_sec_write(sdev, JH7110_AES_NONCE0, ctr[0]);
+	jh7110_sec_write(sdev, JH7110_AES_NONCE1, ctr[1]);
+	jh7110_sec_write(sdev, JH7110_AES_NONCE2, ctr[2]);
+	jh7110_sec_write(sdev, JH7110_AES_NONCE3, ctr[3]);
+}
+
+static int jh7110_cryp_hw_write_key(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	u32 *key = (u32 *)ctx->key;
+
+	switch (ctx->keylen) {
+	case AES_KEYSIZE_256:
+	case AES_KEYSIZE_192:
+	case AES_KEYSIZE_128:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (ctx->keylen >= AES_KEYSIZE_128) {
+		jh7110_sec_write(sdev, JH7110_AES_KEY0, key[0]);
+		jh7110_sec_write(sdev, JH7110_AES_KEY1, key[1]);
+		jh7110_sec_write(sdev, JH7110_AES_KEY2, key[2]);
+		jh7110_sec_write(sdev, JH7110_AES_KEY3, key[3]);
+	}
+
+	if (ctx->keylen >= AES_KEYSIZE_192) {
+		jh7110_sec_write(sdev, JH7110_AES_KEY4, key[4]);
+		jh7110_sec_write(sdev, JH7110_AES_KEY5, key[5]);
+	}
+
+	if (ctx->keylen >= AES_KEYSIZE_256) {
+		jh7110_sec_write(sdev, JH7110_AES_KEY6, key[6]);
+		jh7110_sec_write(sdev, JH7110_AES_KEY7, key[7]);
+	}
+
+	if (jh7110_aes_wait_keydone(ctx))
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static unsigned int jh7110_cryp_get_input_text_len(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+
+	return is_encrypt(rctx) ? rctx->req.areq->cryptlen :
+				  rctx->req.areq->cryptlen - rctx->authsize;
+}
+
+static int jh7110_cryp_gcm_init(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	int ret;
+	/* Phase 1 : init */
+	memcpy(rctx->last_ctr, rctx->req.areq->iv, 12);
+
+	ret = jh7110_cryp_hw_write_iv(ctx, (u32 *)rctx->last_ctr);
+
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int jh7110_cryp_ccm_init(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	u8 iv[AES_BLOCK_SIZE], *b0;
+	unsigned int textlen;
+
+	/* Phase 1 : init. Firstly set the CTR value to 1 (not 0) */
+	memcpy(iv, rctx->req.areq->iv, AES_BLOCK_SIZE);
+	memset(iv + AES_BLOCK_SIZE - 1 - iv[0], 0, iv[0] + 1);
+
+	/* Build B0 */
+	b0 = (u8 *)sdev->aes_data;
+	memcpy(b0, iv, AES_BLOCK_SIZE);
+
+	b0[0] |= (8 * ((rctx->authsize - 2) / 2));
+
+	if (rctx->req.areq->assoclen)
+		b0[0] |= 0x40;
+
+	textlen = jh7110_cryp_get_input_text_len(ctx);
+
+	b0[AES_BLOCK_SIZE - 2] = textlen >> 8;
+	b0[AES_BLOCK_SIZE - 1] = textlen & 0xFF;
+
+	memcpy((void *)rctx->last_ctr, sdev->aes_data, AES_BLOCK_SIZE);
+	jh7110_cryp_hw_write_ctr(ctx, (u32 *)b0);
+
+	return 0;
+}
+
+static int jh7110_cryp_hw_init(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	int ret;
+	u32 hw_mode;
+
+	pm_runtime_resume_and_get(ctx->sdev->dev);
+
+	jh7110_aes_reset(ctx);
+
+	hw_mode = get_aes_mode(ctx->rctx);
+	if (hw_mode == JH7110_AES_MODE_CFB ||
+	   hw_mode == JH7110_AES_MODE_OFB)
+		rctx->stmode = JH7110_AES_MODE_XFB_128;
+	else
+		rctx->stmode = JH7110_AES_MODE_XFB_1;
+
+	jh7110_aes_csr_setup(ctx);
+
+	ret = jh7110_cryp_hw_write_key(ctx);
+
+	switch (hw_mode) {
+	case JH7110_AES_MODE_GCM:
+		memset(ctx->sdev->aes_data, 0, JH7110_MSG_BUFFER_SIZE);
+		jh7110_aes_set_alen(ctx);
+		jh7110_aes_set_mlen(ctx);
+		jh7110_aes_set_ivlen(ctx);
+		jh7110_aes_xcm_start(ctx, hw_mode);
+
+		if (jh7110_aes_wait_gcmdone(ctx))
+			return -ETIMEDOUT;
+
+		memset((void *)rctx->last_ctr, 0, sizeof(rctx->last_ctr));
+		jh7110_cryp_gcm_init(ctx);
+
+		break;
+	case JH7110_AES_MODE_CCM:
+		memset(ctx->sdev->aes_data, 0, JH7110_MSG_BUFFER_SIZE);
+		memset((void *)rctx->last_ctr, 0, sizeof(rctx->last_ctr));
+		jh7110_aes_set_alen(ctx);
+		jh7110_aes_set_mlen(ctx);
+
+		/* Phase 1 : init */
+		jh7110_cryp_ccm_init(ctx);
+
+		jh7110_aes_xcm_start(ctx, hw_mode);
+
+		break;
+	case JH7110_AES_MODE_OFB:
+	case JH7110_AES_MODE_CFB:
+	case JH7110_AES_MODE_CBC:
+	case JH7110_AES_MODE_CTR:
+		ret = jh7110_cryp_hw_write_iv(ctx, (void *)rctx->req.sreq->iv);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int jh7110_cryp_get_from_sg(struct jh7110_sec_request_ctx *rctx, size_t offset,
+			     size_t count, size_t data_offset)
+{
+	size_t of, ct, index;
+	struct scatterlist	*sg = rctx->in_sg;
+
+	of = offset;
+	ct = count;
+	while (sg->length <= of) {
+		of -= sg->length;
+
+		if (!sg_is_last(sg)) {
+			sg = sg_next(sg);
+			continue;
+		} else {
+			return -EBADE;
+		}
+	}
+
+	index = data_offset;
+	while (ct > 0) {
+		if (sg->length - of >= ct) {
+			scatterwalk_map_and_copy(rctx->sdev->aes_data + index, sg,
+					of, ct, 0);
+			index = index + ct;
+			return index - data_offset;
+		}
+		scatterwalk_map_and_copy(rctx->sdev->aes_data + index, sg,
+					of, sg->length - of, 0);
+		index += sg->length - of;
+		ct = ct - (sg->length - of);
+
+		of = 0;
+
+		if (!sg_is_last(sg))
+			sg = sg_next(sg);
+		else
+			return -EBADE;
+	}
+	return index - data_offset;
+}
+
+static int jh7110_cryp_read_auth_tag(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	int loop, total_len, start_addr;
+
+	total_len = AES_BLOCK_SIZE / sizeof(u32);
+	start_addr = JH7110_AES_NONCE0;
+
+	if (jh7110_aes_wait_busy(ctx))
+		return -EBUSY;
+
+	if (is_gcm(rctx))
+		for (loop = 0; loop < total_len; loop++, start_addr += 4)
+			rctx->tag_out[loop] = jh7110_sec_read(sdev, start_addr);
+	else
+		for (loop = 0; loop < total_len; loop++)
+			rctx->tag_out[loop] = jh7110_sec_read(sdev, JH7110_AES_AESDIO0R);
+
+	if (is_encrypt(rctx))
+		sg_copy_buffer(rctx->out_sg, sg_nents(rctx->out_sg), rctx->tag_out,
+				rctx->authsize, rctx->offset, 0);
+	else {
+		scatterwalk_map_and_copy(rctx->tag_in, rctx->in_sg,
+				rctx->total_in_save - rctx->authsize,
+				rctx->authsize, 0);
+
+		if (crypto_memneq(rctx->tag_in, rctx->tag_out, rctx->authsize))
+			return -EBADMSG;
+	}
+
+	return 0;
+}
+
+static int jh7110_gcm_zero_message_data(struct jh7110_sec_ctx *ctx);
+
+static void jh7110_cryp_finish_req(struct jh7110_sec_ctx *ctx, int err)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+
+	if (!err && (is_gcm(rctx) || is_ccm(rctx))) {
+		/* Phase 4 : output tag */
+		err = jh7110_cryp_read_auth_tag(ctx);
+	}
+
+	if (!err && (is_cbc(rctx) || is_ctr(rctx)))
+		jh7110_cryp_hw_get_iv(ctx, (void *)rctx->req.sreq->iv);
+
+	if (rctx->sgs_copied) {
+		void *buf_in, *buf_out;
+		int pages, len;
+
+		buf_in = sg_virt(&rctx->in_sgl);
+		buf_out = sg_virt(&rctx->out_sgl);
+
+		sg_copy_buf(buf_out, rctx->out_sg_save, 0,
+				rctx->total_out_save, 1);
+
+		len = ALIGN(rctx->total_in_save, rctx->hw_blocksize);
+		pages = len ? get_order(len) : 1;
+		free_pages((unsigned long)buf_in, pages);
+
+		len = ALIGN(rctx->total_out_save, rctx->hw_blocksize);
+		pages = len ? get_order(len) : 1;
+		free_pages((unsigned long)buf_out, pages);
+	}
+
+	pm_runtime_mark_last_busy(ctx->sdev->dev);
+	pm_runtime_put_autosuspend(ctx->sdev->dev);
+
+	if (is_gcm(rctx) || is_ccm(rctx))
+		crypto_finalize_aead_request(ctx->sdev->engine, rctx->req.areq, err);
+	else
+		crypto_finalize_skcipher_request(ctx->sdev->engine, rctx->req.sreq,
+				err);
+}
+
+static bool jh7110_check_counter_overflow(struct jh7110_sec_ctx *ctx, size_t count)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	bool ret = false;
+	u32 start, end, ctr, blocks;
+
+	if (count) {
+		blocks = DIV_ROUND_UP(count, AES_BLOCK_SIZE);
+		rctx->last_ctr[3] = cpu_to_be32(be32_to_cpu(rctx->last_ctr[3]) + blocks);
+
+		if (rctx->last_ctr[3] == 0) {
+			rctx->last_ctr[2] = cpu_to_be32(be32_to_cpu(rctx->last_ctr[2]) + 1);
+			if (rctx->last_ctr[2] == 0) {
+				rctx->last_ctr[1] = cpu_to_be32(be32_to_cpu(rctx->last_ctr[1]) + 1);
+				if (rctx->last_ctr[1] == 0) {
+					rctx->last_ctr[0] = cpu_to_be32(be32_to_cpu(rctx->last_ctr[0]) + 1);
+					if (rctx->last_ctr[1] == 0)
+						jh7110_cryp_hw_write_ctr(ctx, (u32 *)rctx->last_ctr);
+				}
+			}
+		}
+	}
+
+	/* ctr counter overflow. */
+	ctr = rctx->total_in - rctx->assoclen - rctx->authsize;
+	blocks = DIV_ROUND_UP(ctr, AES_BLOCK_SIZE);
+	start = be32_to_cpu(rctx->last_ctr[3]);
+
+	end = start + blocks - 1;
+	if (end < start) {
+		rctx->ctr_over_count = AES_BLOCK_SIZE * -start;
+		ret = true;
+	}
+
+	return ret;
+}
+
+static void jh7110_aes_dma_callback(void *param)
+{
+	struct jh7110_sec_dev *sdev = param;
+
+	complete(&sdev->sec_comp_p);
+}
+
+static void vic_debug_dma_info(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	int loop;
+
+	for (loop = 0; loop <= 0x34; loop += 4)
+		dev_dbg(sdev->dev, "dma[%x] = %x\n", loop, readl_relaxed(sdev->dma_base + loop));
+	for (loop = 0x100; loop <= 0x110; loop += 4)
+		dev_dbg(sdev->dev, "dma[%x] = %x\n", loop, readl_relaxed(sdev->dma_base + loop));
+	for (loop = 0x120; loop <= 0x130; loop += 4)
+		dev_dbg(sdev->dev, "dma[%x] = %x\n", loop, readl_relaxed(sdev->dma_base + loop));
+}
+
+static int jh7110_cryp_write_out_dma(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct dma_async_tx_descriptor	*in_desc, *out_desc;
+	union  jh7110_alg_cr		alg_cr;
+	dma_cookie_t cookie;
+	unsigned int  *out;
+	int total_len;
+	int err;
+	int loop;
+
+	total_len = rctx->bufcnt;
+
+	alg_cr.v = 0;
+	alg_cr.start = 1;
+	alg_cr.aes_dma_en = 1;
+	jh7110_sec_write(sdev, JH7110_ALG_CR_OFFSET, alg_cr.v);
+
+	total_len = (total_len & 0xf) ? (((total_len >> 4) + 1) << 4) : total_len;
+
+	jh7110_sec_write(sdev, JH7110_DMA_IN_LEN_OFFSET, total_len);
+	jh7110_sec_write(sdev, JH7110_DMA_OUT_LEN_OFFSET, total_len);
+
+	sg_init_table(&ctx->sg[0], 1);
+	sg_set_buf(&ctx->sg[0], sdev->aes_data, total_len);
+	sg_dma_address(&ctx->sg[0]) = phys_to_dma(sdev->dev, (unsigned long long)(sdev->aes_data));
+	sg_dma_len(&ctx->sg[0]) = total_len;
+
+	sg_init_table(&ctx->sg[1], 1);
+	sg_set_buf(&ctx->sg[1], sdev->aes_data + (JH7110_MSG_BUFFER_SIZE >> 1), total_len);
+	sg_dma_address(&ctx->sg[1]) = phys_to_dma(sdev->dev, (unsigned long long)(sdev->aes_data + (JH7110_MSG_BUFFER_SIZE >> 1)));
+	sg_dma_len(&ctx->sg[1]) = total_len;
+
+	err = dma_map_sg(sdev->dev, &ctx->sg[0], 1, DMA_TO_DEVICE);
+	if (!err) {
+		dev_err(sdev->dev, "dma_map_sg() error\n");
+		return -EINVAL;
+	}
+
+	err = dma_map_sg(sdev->dev, &ctx->sg[1], 1, DMA_FROM_DEVICE);
+	if (!err) {
+		dev_err(sdev->dev, "dma_map_sg() error\n");
+		return -EINVAL;
+	}
+
+	sdev->cfg_in.direction = DMA_MEM_TO_DEV;
+	sdev->cfg_in.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	sdev->cfg_in.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	sdev->cfg_in.src_maxburst = sdev->dma_maxburst;
+	sdev->cfg_in.dst_maxburst = sdev->dma_maxburst;
+	sdev->cfg_in.dst_addr = sdev->io_phys_base + JH7110_ALG_FIFO_OFFSET;
+
+	dmaengine_slave_config(sdev->sec_xm_m, &sdev->cfg_in);
+
+	sdev->cfg_out.direction = DMA_DEV_TO_MEM;
+	sdev->cfg_out.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	sdev->cfg_out.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	sdev->cfg_out.src_maxburst = 4;
+	sdev->cfg_out.dst_maxburst = 4;
+	sdev->cfg_out.src_addr = sdev->io_phys_base + JH7110_ALG_FIFO_OFFSET;
+
+	dmaengine_slave_config(sdev->sec_xm_p, &sdev->cfg_out);
+
+	in_desc = dmaengine_prep_slave_sg(sdev->sec_xm_m, &ctx->sg[0],
+				1, DMA_MEM_TO_DEV,
+				DMA_PREP_INTERRUPT  |  DMA_CTRL_ACK);
+	if (!in_desc)
+		return -EINVAL;
+
+	cookie = dmaengine_submit(in_desc);
+	dma_async_issue_pending(sdev->sec_xm_m);
+
+	out_desc = dmaengine_prep_slave_sg(sdev->sec_xm_p, &ctx->sg[1],
+				1, DMA_DEV_TO_MEM,
+				DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!out_desc)
+		return -EINVAL;
+
+	reinit_completion(&sdev->sec_comp_p);
+
+	out_desc->callback = jh7110_aes_dma_callback;
+	out_desc->callback_param = sdev;
+
+	dmaengine_submit(out_desc);
+	dma_async_issue_pending(sdev->sec_xm_p);
+
+	err = 0;
+
+	if (!wait_for_completion_timeout(&sdev->sec_comp_p,
+				msecs_to_jiffies(10000))) {
+		alg_cr.v = 0;
+		alg_cr.clear = 1;
+
+		jh7110_sec_write(sdev, JH7110_ALG_CR_OFFSET, alg_cr.v);
+
+		vic_debug_dma_info(ctx);
+		dev_err(sdev->dev, "wait_for_completion_timeout out error cookie = %x\n",
+			dma_async_is_tx_complete(sdev->sec_xm_p, cookie,
+				     NULL, NULL));
+	}
+
+	out = (unsigned int *)(sdev->aes_data + (JH7110_MSG_BUFFER_SIZE >> 1));
+
+	for (loop = 0; loop < total_len / 4; loop++)
+		dev_dbg(sdev->dev, "this is debug [%d] = %x\n", loop, out[loop]);
+
+	sg_copy_buffer(rctx->out_sg, sg_nents(rctx->out_sg), out,
+			total_len, rctx->offset, 0);
+
+	dma_unmap_sg(sdev->dev, &ctx->sg[0], 1, DMA_TO_DEVICE);
+	dma_unmap_sg(sdev->dev, &ctx->sg[1], 1, DMA_FROM_DEVICE);
+
+	alg_cr.v = 0;
+	alg_cr.clear = 1;
+
+	jh7110_sec_write(sdev, JH7110_ALG_CR_OFFSET, alg_cr.v);
+
+	return 0;
+}
+
+static int jh7110_cryp_write_out_cpu(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	unsigned int  *buffer, *out;
+	int total_len, loop, count;
+
+	total_len = rctx->bufcnt;
+	buffer = (unsigned int *)sdev->aes_data;
+	out = (unsigned int *)(sdev->aes_data + (JH7110_MSG_BUFFER_SIZE >> 1));
+
+	while (total_len > 0) {
+		for (loop = 0; loop < 4; loop++, buffer++)
+			jh7110_sec_write(sdev, JH7110_AES_AESDIO0R, *buffer);
+
+		if (jh7110_aes_wait_busy(ctx)) {
+			dev_err(sdev->dev, "jh7110_aes_wait_busy error\n");
+			return -ETIMEDOUT;
+		}
+
+		for (loop = 0; loop < 4; loop++, out++)
+			*out = jh7110_sec_read(sdev, JH7110_AES_AESDIO0R);
+
+		total_len -= 16;
+	}
+
+	if (rctx->bufcnt >= rctx->total_out)
+		count = rctx->total_out;
+	else
+		count = rctx->bufcnt;
+
+	out = (unsigned int *)(sdev->aes_data + (JH7110_MSG_BUFFER_SIZE >> 1));
+
+	sg_copy_buffer(rctx->out_sg, sg_nents(rctx->out_sg), out,
+			count, rctx->offset, 0);
+
+	return 0;
+}
+
+static int jh7110_cryp_write_data(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	size_t data_len, total, count, data_buf_len, data_offset;
+	int ret;
+	bool fragmented = false;
+
+	sdev->cry_type = JH7110_AES_TYPE;
+
+	/* ctr counter overflow. */
+	fragmented = jh7110_check_counter_overflow(ctx, 0);
+
+	total = 0;
+	rctx->offset = 0;
+	rctx->data_offset = 0;
+
+	data_offset = rctx->data_offset;
+	while (total < rctx->total_in) {
+		data_buf_len = sdev->data_buf_len - (sdev->data_buf_len % ctx->keylen) - data_offset;
+		count = min(rctx->total_in - rctx->offset, data_buf_len);
+
+		/* ctr counter overflow. */
+		if (fragmented && rctx->ctr_over_count != 0) {
+			if (count >= rctx->ctr_over_count)
+				count = rctx->ctr_over_count;
+		}
+		data_len = jh7110_cryp_get_from_sg(rctx, rctx->offset, count, data_offset);
+
+		if (data_len < 0)
+			return data_len;
+		if (data_len != count)
+			return -EINVAL;
+
+		rctx->bufcnt = data_len + data_offset;
+		total += data_len;
+
+		if (!is_encrypt(rctx) && (total + rctx->assoclen >= rctx->total_in))
+			rctx->bufcnt = rctx->bufcnt - rctx->authsize;
+
+		if (rctx->bufcnt) {
+			if (sdev->use_dma)
+				ret = jh7110_cryp_write_out_dma(ctx);
+			else
+				ret = jh7110_cryp_write_out_cpu(ctx);
+
+			if (ret)
+				return ret;
+		}
+		data_offset = 0;
+		rctx->offset += data_len;
+		fragmented = jh7110_check_counter_overflow(ctx, data_len);
+	}
+
+	return ret;
+}
+
+static int jh7110_cryp_gcm_write_aad(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	unsigned int *buffer;
+	int total_len, loop;
+
+	if (rctx->assoclen) {
+		total_len = rctx->assoclen;
+		total_len = (total_len & 0xf) ? (((total_len >> 4) + 1) << 2) : (total_len >> 2);
+	}
+
+	buffer = (unsigned int *)sdev->aes_data;
+
+	for (loop = 0; loop < total_len; loop += 4) {
+		jh7110_sec_write(sdev, JH7110_AES_NONCE0, *buffer);
+		buffer++;
+		jh7110_sec_write(sdev, JH7110_AES_NONCE1, *buffer);
+		buffer++;
+		jh7110_sec_write(sdev, JH7110_AES_NONCE2, *buffer);
+		buffer++;
+		jh7110_sec_write(sdev, JH7110_AES_NONCE3, *buffer);
+		buffer++;
+		udelay(2);
+	}
+
+	if (jh7110_aes_wait_gcmdone(ctx))
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static int jh7110_cryp_ccm_write_aad(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	unsigned int  *buffer, *out;
+	unsigned char *ci;
+	int total_len, mlen, loop;
+
+	total_len = rctx->bufcnt;
+	buffer = (unsigned int *)sdev->aes_data;
+	out = (unsigned int *)(sdev->aes_data + (JH7110_MSG_BUFFER_SIZE >> 1));
+
+	ci = (unsigned char *)buffer;
+	jh7110_sec_writeb(sdev, JH7110_AES_AESDIO0R, *ci);
+	ci++;
+	jh7110_sec_writeb(sdev, JH7110_AES_AESDIO0R, *ci);
+	ci++;
+	total_len -= 2;
+	buffer = (unsigned int *)ci;
+	for (loop = 0; loop < 3; loop++, buffer++)
+		jh7110_sec_write(sdev, JH7110_AES_AESDIO0R, *buffer);
+
+	if (jh7110_aes_wait_busy(ctx)) {
+		dev_err(sdev->dev, "jh7110_aes_wait_busy error\n");
+		return -ETIMEDOUT;
+	}
+	total_len -= 12;
+
+	while (total_len >= 16) {
+		for (loop = 0; loop < 4; loop++, buffer++)
+			jh7110_sec_write(sdev, JH7110_AES_AESDIO0R, *buffer);
+
+		if (jh7110_aes_wait_busy(ctx)) {
+			dev_err(sdev->dev, "jh7110_aes_wait_busy error\n");
+			return -ETIMEDOUT;
+		}
+		total_len -= 16;
+	}
+
+	if (total_len > 0) {
+		mlen = total_len;
+		for (; total_len >= 4; total_len -= 4, buffer++)
+			jh7110_sec_write(sdev, JH7110_AES_AESDIO0R, *buffer);
+
+		ci = (unsigned char *)buffer;
+		for (; total_len > 0; total_len--, ci++)
+			jh7110_sec_writeb(sdev, JH7110_AES_AESDIO0R, *ci);
+
+		if (jh7110_aes_wait_busy(ctx)) {
+			dev_err(sdev->dev, "jh7110_aes_wait_busy error\n");
+			return -ETIMEDOUT;
+		}
+	}
+
+	if (jh7110_aes_wait_busy(ctx)) {
+		dev_err(sdev->dev, "jh7110_aes_wait_busy error\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int jh7110_cryp_xcm_write_data(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	size_t data_len, total, count, data_buf_len, offset, auths;
+	int ret;
+	bool fragmented = false;
+
+	sdev->cry_type = JH7110_AES_TYPE;
+
+	/* ctr counter overflow. */
+	fragmented = jh7110_check_counter_overflow(ctx, 0);
+
+	total = 0;
+	rctx->offset = 0;
+	rctx->data_offset = 0;
+	offset = 0;
+
+	while (total < rctx->assoclen) {
+		data_buf_len = sdev->data_buf_len - (sdev->data_buf_len % ctx->keylen);
+		count = min(rctx->assoclen - offset, data_buf_len);
+		count = min(count, rctx->assoclen - total);
+		data_len = jh7110_cryp_get_from_sg(rctx, offset, count, 0);
+		if (data_len < 0)
+			return data_len;
+		if (data_len != count)
+			return -EINVAL;
+
+		offset += data_len;
+		rctx->offset += data_len;
+		if ((data_len + 2) & 0xF) {
+			memset(sdev->aes_data + data_len, 0, 16 - ((data_len + 2) & 0xf));
+			data_len += 16 - ((data_len + 2) & 0xf);
+		}
+
+		rctx->bufcnt = data_len;
+		total += data_len;
+
+		if (is_ccm(rctx))
+			ret = jh7110_cryp_ccm_write_aad(ctx);
+		else
+			ret = jh7110_cryp_gcm_write_aad(ctx);
+
+		if (ret)
+			return ret;
+	}
+
+	total = 0;
+	auths = 0;
+
+	while (total + auths < rctx->total_in - rctx->assoclen) {
+		data_buf_len = sdev->data_buf_len - (sdev->data_buf_len % ctx->keylen);
+		count = min(rctx->total_in - rctx->offset, data_buf_len);
+
+		if (is_encrypt(rctx))
+			count = min(count, rctx->total_in - rctx->assoclen - total);
+		else {
+			count = min(count, rctx->total_in - rctx->assoclen - total - rctx->authsize);
+			auths = rctx->authsize;
+		}
+
+		/* ctr counter overflow. */
+		if (fragmented && rctx->ctr_over_count != 0) {
+			if (count >= rctx->ctr_over_count)
+				count = rctx->ctr_over_count;
+		}
+
+		data_len = jh7110_cryp_get_from_sg(rctx, rctx->offset, count, 0);
+
+		if (data_len < 0)
+			return data_len;
+		if (data_len != count)
+			return -EINVAL;
+
+		if (data_len % JH7110_AES_IV_LEN) {
+			memset(sdev->aes_data + data_len, 0, JH7110_AES_IV_LEN - (data_len % JH7110_AES_IV_LEN));
+			data_len = data_len + (JH7110_AES_IV_LEN - (data_len % JH7110_AES_IV_LEN));
+		}
+
+		rctx->bufcnt = data_len;
+		total += data_len;
+
+		if (rctx->bufcnt) {
+			if (sdev->use_dma)
+				ret = jh7110_cryp_write_out_dma(ctx);
+			else
+				ret = jh7110_cryp_write_out_cpu(ctx);
+		}
+
+		rctx->offset += count;
+		offset += count;
+
+		fragmented = jh7110_check_counter_overflow(ctx, data_len);
+	}
+
+	return ret;
+}
+
+static int jh7110_gcm_zero_message_data(struct jh7110_sec_ctx *ctx)
+{
+	int ret;
+
+	ctx->rctx->bufcnt = 0;
+	ctx->rctx->offset = 0;
+	if (ctx->sdev->use_dma)
+		ret = jh7110_cryp_write_out_dma(ctx);
+	else
+		ret = jh7110_cryp_write_out_cpu(ctx);
+
+	return ret;
+}
+
+static int jh7110_cryp_cpu_start(struct jh7110_sec_ctx *ctx, struct jh7110_sec_request_ctx *rctx)
+{
+	int ret;
+
+	ret = jh7110_cryp_write_data(ctx);
+	if (ret)
+		return ret;
+
+	jh7110_cryp_finish_req(ctx, ret);
+
+	return 0;
+}
+
+static int jh7110_cryp_xcm_start(struct jh7110_sec_ctx *ctx, struct jh7110_sec_request_ctx *rctx)
+{
+	int ret;
+
+	ret = jh7110_cryp_xcm_write_data(ctx);
+	if (ret)
+		return ret;
+
+	jh7110_cryp_finish_req(ctx, ret);
+
+	mutex_unlock(&ctx->sdev->lock);
+
+	return 0;
+}
+
+static int jh7110_cryp_cipher_one_req(struct crypto_engine *engine, void *areq);
+static int jh7110_cryp_prepare_cipher_req(struct crypto_engine *engine,
+					 void *areq);
+
+static int jh7110_cryp_cra_init(struct crypto_skcipher *tfm)
+{
+	struct jh7110_sec_ctx *ctx = crypto_skcipher_ctx(tfm);
+
+	ctx->sdev = jh7110_sec_find_dev(ctx);
+	if (!ctx->sdev)
+		return -ENODEV;
+
+	crypto_skcipher_set_reqsize(tfm, sizeof(struct jh7110_sec_request_ctx));
+
+	ctx->enginectx.op.do_one_request = jh7110_cryp_cipher_one_req;
+	ctx->enginectx.op.prepare_request = jh7110_cryp_prepare_cipher_req;
+	ctx->enginectx.op.unprepare_request = NULL;
+
+	return 0;
+}
+
+static void jh7110_cryp_cra_exit(struct crypto_skcipher *tfm)
+{
+	struct jh7110_sec_ctx *ctx = crypto_skcipher_ctx(tfm);
+
+	ctx->enginectx.op.do_one_request = NULL;
+	ctx->enginectx.op.prepare_request = NULL;
+	ctx->enginectx.op.unprepare_request = NULL;
+}
+
+static int jh7110_cryp_aead_one_req(struct crypto_engine *engine, void *areq);
+static int jh7110_cryp_prepare_aead_req(struct crypto_engine *engine,
+				       void *areq);
+
+static int jh7110_cryp_aes_aead_init(struct crypto_aead *tfm)
+{
+	struct jh7110_sec_ctx *ctx = crypto_aead_ctx(tfm);
+	struct crypto_tfm *aead = crypto_aead_tfm(tfm);
+	struct crypto_alg *alg = aead->__crt_alg;
+
+	ctx->sdev = jh7110_sec_find_dev(ctx);
+
+	if (!ctx->sdev)
+		return -ENODEV;
+
+	crypto_aead_set_reqsize(tfm, sizeof(struct jh7110_sec_request_ctx));
+
+	if (alg->cra_flags & CRYPTO_ALG_NEED_FALLBACK) {
+		ctx->fallback.aead =
+			crypto_alloc_aead(alg->cra_name, 0,
+					CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_NEED_FALLBACK);
+		if (IS_ERR(ctx->fallback.aead)) {
+			pr_err("%s() failed to allocate fallback for %s\n",
+					__func__, alg->cra_name);
+			return PTR_ERR(ctx->fallback.aead);
+		}
+	}
+
+	ctx->enginectx.op.do_one_request = jh7110_cryp_aead_one_req;
+	ctx->enginectx.op.prepare_request = jh7110_cryp_prepare_aead_req;
+	ctx->enginectx.op.unprepare_request = NULL;
+
+	return 0;
+}
+
+static void jh7110_cryp_aes_aead_exit(struct crypto_aead *tfm)
+{
+	struct jh7110_sec_ctx *ctx = crypto_aead_ctx(tfm);
+
+	if (ctx->fallback.aead) {
+		crypto_free_aead(ctx->fallback.aead);
+		ctx->fallback.aead = NULL;
+	}
+
+	ctx->enginectx.op.do_one_request = NULL;
+	ctx->enginectx.op.prepare_request = NULL;
+	ctx->enginectx.op.unprepare_request = NULL;
+}
+
+static int jh7110_cryp_crypt(struct skcipher_request *req, unsigned long flags)
+{
+	struct jh7110_sec_ctx *ctx = crypto_skcipher_ctx(
+			crypto_skcipher_reqtfm(req));
+	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
+	struct jh7110_sec_request_ctx *rctx = skcipher_request_ctx(req);
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	unsigned int blocksize_align = crypto_skcipher_blocksize(tfm) - 1;
+
+	if (!sdev)
+		return -ENODEV;
+
+	rctx->flags = flags;
+	rctx->req_type = JH7110_ABLK_REQ;
+
+	if (is_ecb(rctx) || is_cbc(rctx))
+		if (req->cryptlen & (blocksize_align))
+			return -EINVAL;
+
+	return crypto_transfer_skcipher_request_to_engine(sdev->engine, req);
+}
+
+static int aead_do_fallback(struct aead_request *req)
+{
+	struct aead_request *subreq = aead_request_ctx(req);
+	struct crypto_aead *aead = crypto_aead_reqtfm(req);
+	struct jh7110_sec_ctx *ctx = crypto_aead_ctx(aead);
+
+	aead_request_set_tfm(subreq, ctx->fallback.aead);
+	aead_request_set_callback(subreq, req->base.flags,
+			req->base.complete, req->base.data);
+	aead_request_set_crypt(subreq, req->src,
+			req->dst, req->cryptlen, req->iv);
+	aead_request_set_ad(subreq, req->assoclen);
+
+	return crypto_aead_decrypt(subreq);
+}
+
+static int jh7110_cryp_aead_crypt(struct aead_request *req, unsigned long flags)
+{
+	struct jh7110_sec_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
+	struct jh7110_sec_request_ctx *rctx = aead_request_ctx(req);
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+
+	if (!sdev)
+		return -ENODEV;
+
+	rctx->flags = flags;
+	rctx->req_type = JH7110_AEAD_REQ;
+
+	/* HW engine could not perform tag verification on
+	 * non-blocksize aligned ciphertext, use fallback algo instead
+	 */
+	if (ctx->fallback.aead && is_decrypt(rctx))
+		return aead_do_fallback(req);
+
+	return crypto_transfer_aead_request_to_engine(sdev->engine, req);
+}
+
+static int jh7110_cryp_setkey(struct crypto_skcipher *tfm, const u8 *key,
+			     unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = crypto_skcipher_ctx(tfm);
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+	{
+		int loop;
+
+		for (loop = 0; loop < keylen; loop++)
+			pr_debug("key[%d] = %x ctx->key[%d] = %x\n", loop, key[loop], loop, ctx->key[loop]);
+	}
+	return 0;
+}
+
+static int jh7110_cryp_aes_setkey(struct crypto_skcipher *tfm, const u8 *key,
+				 unsigned int keylen)
+{
+	if (!key || !keylen)
+		return -EINVAL;
+
+	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
+		keylen != AES_KEYSIZE_256)
+		return -EINVAL;
+	else
+		return jh7110_cryp_setkey(tfm, key, keylen);
+}
+
+static int jh7110_cryp_aes_aead_setkey(struct crypto_aead *tfm, const u8 *key,
+				      unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = crypto_aead_ctx(tfm);
+	int ret = 0;
+
+	if (!key || !keylen)
+		return -EINVAL;
+
+	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
+	    keylen != AES_KEYSIZE_256) {
+		return -EINVAL;
+	}
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+
+	if (ctx->fallback.aead)
+		ret = crypto_aead_setkey(ctx->fallback.aead, key, keylen);
+
+	return ret;
+}
+
+static int jh7110_cryp_aes_gcm_setauthsize(struct crypto_aead *tfm,
+					  unsigned int authsize)
+{
+	struct jh7110_sec_ctx *ctx = crypto_aead_ctx(tfm);
+
+	tfm->authsize = authsize;
+
+	if (ctx->fallback.aead)
+		ctx->fallback.aead->authsize = authsize;
+
+	return crypto_gcm_check_authsize(authsize);
+}
+
+static int jh7110_cryp_aes_ccm_setauthsize(struct crypto_aead *tfm,
+					  unsigned int authsize)
+{
+	struct jh7110_sec_ctx *ctx = crypto_aead_ctx(tfm);
+	int ret = 0;
+
+	switch (authsize) {
+	case 4:
+	case 6:
+	case 8:
+	case 10:
+	case 12:
+	case 14:
+	case 16:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	tfm->authsize = authsize;
+
+	if (ctx->fallback.aead)
+		ctx->fallback.aead->authsize = authsize;
+
+	return ret;
+}
+
+static int jh7110_cryp_aes_ecb_encrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_ECB | FLG_ENCRYPT);
+}
+
+static int jh7110_cryp_aes_ecb_decrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_ECB);
+}
+
+static int jh7110_cryp_aes_cbc_encrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_CBC | FLG_ENCRYPT);
+}
+
+static int jh7110_cryp_aes_cbc_decrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_CBC);
+}
+
+static int jh7110_cryp_aes_cfb_encrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_CFB | FLG_ENCRYPT);
+}
+
+static int jh7110_cryp_aes_cfb_decrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_CFB);
+}
+
+static int jh7110_cryp_aes_ofb_encrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_OFB | FLG_ENCRYPT);
+}
+
+static int jh7110_cryp_aes_ofb_decrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_OFB);
+}
+
+static int jh7110_cryp_aes_ctr_encrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_CTR | FLG_ENCRYPT);
+}
+
+static int jh7110_cryp_aes_ctr_decrypt(struct skcipher_request *req)
+{
+	return jh7110_cryp_crypt(req,  JH7110_AES_MODE_CTR);
+}
+
+static int jh7110_cryp_aes_gcm_encrypt(struct aead_request *req)
+{
+	return jh7110_cryp_aead_crypt(req,  JH7110_AES_MODE_GCM | FLG_ENCRYPT);
+}
+
+static int jh7110_cryp_aes_gcm_decrypt(struct aead_request *req)
+{
+	return jh7110_cryp_aead_crypt(req,  JH7110_AES_MODE_GCM);
+}
+
+static int jh7110_cryp_aes_ccm_encrypt(struct aead_request *req)
+{
+	int ret;
+
+	ret = crypto_ccm_check_iv(req->iv);
+	if (ret)
+		return ret;
+
+	return jh7110_cryp_aead_crypt(req,  JH7110_AES_MODE_CCM | FLG_ENCRYPT);
+}
+
+static int jh7110_cryp_aes_ccm_decrypt(struct aead_request *req)
+{
+	int ret;
+
+	ret = crypto_ccm_check_iv(req->iv);
+	if (ret)
+		return ret;
+
+	return jh7110_cryp_aead_crypt(req, JH7110_AES_MODE_CCM);
+}
+
+static int jh7110_cryp_prepare_req(struct skcipher_request *req,
+				  struct aead_request *areq)
+{
+	struct jh7110_sec_ctx *ctx;
+	struct jh7110_sec_dev *sdev;
+	struct jh7110_sec_request_ctx *rctx;
+	int ret;
+
+	if (!req && !areq)
+		return -EINVAL;
+
+	ctx = req ? crypto_skcipher_ctx(crypto_skcipher_reqtfm(req)) :
+		    crypto_aead_ctx(crypto_aead_reqtfm(areq));
+
+	sdev = ctx->sdev;
+
+	if (!sdev)
+		return -ENODEV;
+
+	rctx = req ? skcipher_request_ctx(req) : aead_request_ctx(areq);
+
+	mutex_lock(&ctx->sdev->lock);
+
+	rctx->sdev = sdev;
+	ctx->rctx = rctx;
+	rctx->hw_blocksize = AES_BLOCK_SIZE;
+
+	if (req) {
+		rctx->req.sreq = req;
+		rctx->req_type = JH7110_ABLK_REQ;
+		rctx->total_in = req->cryptlen;
+		rctx->total_out = rctx->total_in;
+		rctx->authsize = 0;
+		rctx->assoclen = 0;
+	} else {
+		/*
+		 * Length of input and output data:
+		 * Encryption case:
+		 *  INPUT  =   AssocData  ||   PlainText
+		 *          <- assoclen ->  <- cryptlen ->
+		 *          <------- total_in ----------->
+		 *
+		 *  OUTPUT =   AssocData  ||  CipherText  ||   AuthTag
+		 *          <- assoclen ->  <- cryptlen ->  <- authsize ->
+		 *          <---------------- total_out ----------------->
+		 *
+		 * Decryption case:
+		 *  INPUT  =   AssocData  ||  CipherText  ||  AuthTag
+		 *          <- assoclen ->  <--------- cryptlen --------->
+		 *                                          <- authsize ->
+		 *          <---------------- total_in ------------------>
+		 *
+		 *  OUTPUT =   AssocData  ||   PlainText
+		 *          <- assoclen ->  <- crypten - authsize ->
+		 *          <---------- total_out ----------------->
+		 */
+		rctx->req.areq = areq;
+		rctx->req_type = JH7110_AEAD_REQ;
+		rctx->authsize = crypto_aead_authsize(crypto_aead_reqtfm(areq));
+		rctx->total_in = areq->assoclen + areq->cryptlen;
+		rctx->assoclen = areq->assoclen;
+		if (is_encrypt(rctx))
+			/* Append auth tag to output */
+			rctx->total_out = rctx->total_in + rctx->authsize;
+		else
+			/* No auth tag in output */
+			rctx->total_out = rctx->total_in - rctx->authsize;
+	}
+
+	rctx->total_in_save = rctx->total_in;
+	rctx->total_out_save = rctx->total_out;
+
+	rctx->in_sg = req ? req->src : areq->src;
+	rctx->out_sg = req ? req->dst : areq->dst;
+	rctx->out_sg_save = rctx->out_sg;
+
+	rctx->in_sg_len = sg_nents_for_len(rctx->in_sg, rctx->total_in);
+	if (rctx->in_sg_len < 0) {
+		dev_err(sdev->dev, "Cannot get in_sg_len\n");
+		ret = rctx->in_sg_len;
+		goto out;
+	}
+
+	rctx->out_sg_len = sg_nents_for_len(rctx->out_sg, rctx->total_out);
+	if (rctx->out_sg_len < 0) {
+		dev_err(sdev->dev, "Cannot get out_sg_len\n");
+		ret = rctx->out_sg_len;
+		goto out;
+	}
+
+	ret = jh7110_cryp_copy_sgs(rctx);
+	if (ret)
+		return ret;
+
+	ret = jh7110_cryp_hw_init(ctx);
+	if (ret)
+		goto out;
+
+	return ret;
+out:
+	mutex_unlock(&sdev->doing);
+
+	return ret;
+}
+
+static int jh7110_cryp_prepare_cipher_req(struct crypto_engine *engine,
+					 void *areq)
+{
+	struct skcipher_request *req = container_of(areq,
+						      struct skcipher_request,
+						      base);
+	return jh7110_cryp_prepare_req(req, NULL);
+}
+
+static int jh7110_cryp_cipher_one_req(struct crypto_engine *engine, void *areq)
+{
+	struct skcipher_request *req = container_of(areq,
+			struct skcipher_request,
+			base);
+	struct jh7110_sec_request_ctx *rctx = skcipher_request_ctx(req);
+	struct jh7110_sec_ctx *ctx = crypto_skcipher_ctx(
+			crypto_skcipher_reqtfm(req));
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	int ret;
+
+	if (!sdev)
+		return -ENODEV;
+
+	ret = jh7110_cryp_cpu_start(ctx, rctx);
+
+	mutex_unlock(&sdev->lock);
+
+	return ret;
+}
+
+static int jh7110_cryp_prepare_aead_req(struct crypto_engine *engine, void *areq)
+{
+	struct aead_request *req = container_of(areq, struct aead_request,
+						base);
+	return jh7110_cryp_prepare_req(NULL, req);
+}
+
+static int jh7110_cryp_aead_one_req(struct crypto_engine *engine, void *areq)
+{
+	struct aead_request *req = container_of(areq, struct aead_request,
+						base);
+	struct jh7110_sec_request_ctx *rctx = aead_request_ctx(req);
+	struct jh7110_sec_ctx *ctx = crypto_aead_ctx(crypto_aead_reqtfm(req));
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+
+	if (!sdev)
+		return -ENODEV;
+
+	if (unlikely(!rctx->req.areq->assoclen &&
+		     !jh7110_cryp_get_input_text_len(ctx))) {
+		/* No input data to process: get tag and finish */
+		jh7110_gcm_zero_message_data(ctx);
+		jh7110_cryp_finish_req(ctx, 0);
+		mutex_unlock(&ctx->sdev->lock);
+		return 0;
+	}
+
+	return jh7110_cryp_xcm_start(ctx, rctx);
+}
+
+static struct skcipher_alg crypto_algs[] = {
+{
+	.base.cra_name		        = "ecb(aes)",
+	.base.cra_driver_name	        = "jh7110-ecb-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		        = CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= AES_BLOCK_SIZE,
+	.base.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		                = jh7110_cryp_cra_init,
+	.exit                           = jh7110_cryp_cra_exit,
+	.min_keysize	                = AES_MIN_KEY_SIZE,
+	.max_keysize	                = AES_MAX_KEY_SIZE,
+	.setkey		                = jh7110_cryp_aes_setkey,
+	.encrypt	                = jh7110_cryp_aes_ecb_encrypt,
+	.decrypt	                = jh7110_cryp_aes_ecb_decrypt,
+}, {
+	.base.cra_name		        = "cbc(aes)",
+	.base.cra_driver_name	        = "jh7110-cbc-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		        = CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= AES_BLOCK_SIZE,
+	.base.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		                = jh7110_cryp_cra_init,
+	.exit                           = jh7110_cryp_cra_exit,
+	.min_keysize	                = AES_MIN_KEY_SIZE,
+	.max_keysize	                = AES_MAX_KEY_SIZE,
+	.ivsize		                = AES_BLOCK_SIZE,
+	.setkey		                = jh7110_cryp_aes_setkey,
+	.encrypt	                = jh7110_cryp_aes_cbc_encrypt,
+	.decrypt	                = jh7110_cryp_aes_cbc_decrypt,
+}, {
+	.base.cra_name		        = "ctr(aes)",
+	.base.cra_driver_name	        = "jh7110-ctr-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		        = CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= 1,
+	.base.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		                = jh7110_cryp_cra_init,
+	.exit                           = jh7110_cryp_cra_exit,
+	.min_keysize	                = AES_MIN_KEY_SIZE,
+	.max_keysize	                = AES_MAX_KEY_SIZE,
+	.ivsize		                = AES_BLOCK_SIZE,
+	.setkey		                = jh7110_cryp_aes_setkey,
+	.encrypt	                = jh7110_cryp_aes_ctr_encrypt,
+	.decrypt	                = jh7110_cryp_aes_ctr_decrypt,
+}, {
+	.base.cra_name		        = "cfb(aes)",
+	.base.cra_driver_name	        = "jh7110-cfb-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		        = CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= AES_BLOCK_SIZE,
+	.base.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		                = jh7110_cryp_cra_init,
+	.exit                           = jh7110_cryp_cra_exit,
+	.min_keysize	                = AES_MIN_KEY_SIZE,
+	.max_keysize	                = AES_MAX_KEY_SIZE,
+	.ivsize		                = AES_BLOCK_SIZE,
+	.setkey		                = jh7110_cryp_aes_setkey,
+	.encrypt	                = jh7110_cryp_aes_cfb_encrypt,
+	.decrypt	                = jh7110_cryp_aes_cfb_decrypt,
+}, {
+	.base.cra_name		        = "ofb(aes)",
+	.base.cra_driver_name	        = "jh7110-ofb-aes",
+	.base.cra_priority		= 200,
+	.base.cra_flags		        = CRYPTO_ALG_ASYNC,
+	.base.cra_blocksize		= AES_BLOCK_SIZE,
+	.base.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+	.base.cra_alignmask		= 0xf,
+	.base.cra_module		= THIS_MODULE,
+	.init		                = jh7110_cryp_cra_init,
+	.exit                           = jh7110_cryp_cra_exit,
+	.min_keysize	                = AES_MIN_KEY_SIZE,
+	.max_keysize	                = AES_MAX_KEY_SIZE,
+	.ivsize		                = AES_BLOCK_SIZE,
+	.setkey		                = jh7110_cryp_aes_setkey,
+	.encrypt	                = jh7110_cryp_aes_ofb_encrypt,
+	.decrypt	                = jh7110_cryp_aes_ofb_decrypt,
+},
+};
+
+static struct aead_alg aead_algs[] = {
+{
+	.setkey                         = jh7110_cryp_aes_aead_setkey,
+	.setauthsize                    = jh7110_cryp_aes_gcm_setauthsize,
+	.encrypt                        = jh7110_cryp_aes_gcm_encrypt,
+	.decrypt                        = jh7110_cryp_aes_gcm_decrypt,
+	.init                           = jh7110_cryp_aes_aead_init,
+	.exit                           = jh7110_cryp_aes_aead_exit,
+	.ivsize                         = GCM_AES_IV_SIZE,
+	.maxauthsize                    = AES_BLOCK_SIZE,
+
+	.base = {
+		.cra_name               = "gcm(aes)",
+		.cra_driver_name        = "jh7110-gcm-aes",
+		.cra_priority           = 200,
+		.cra_flags              = CRYPTO_ALG_ASYNC,
+		.cra_blocksize          = 1,
+		.cra_ctxsize            = sizeof(struct jh7110_sec_ctx),
+		.cra_alignmask          = 0xf,
+		.cra_module             = THIS_MODULE,
+	},
+}, {
+	.setkey		                = jh7110_cryp_aes_aead_setkey,
+	.setauthsize	                = jh7110_cryp_aes_ccm_setauthsize,
+	.encrypt	                = jh7110_cryp_aes_ccm_encrypt,
+	.decrypt	                = jh7110_cryp_aes_ccm_decrypt,
+	.init		                = jh7110_cryp_aes_aead_init,
+	.exit		                = jh7110_cryp_aes_aead_exit,
+	.ivsize		                = AES_BLOCK_SIZE,
+	.maxauthsize	                = AES_BLOCK_SIZE,
+
+	.base = {
+		.cra_name		= "ccm(aes)",
+		.cra_driver_name	= "jh7110-ccm-aes",
+		.cra_priority		= 200,
+		.cra_flags		= CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= 1,
+		.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+		.cra_alignmask		= 0xf,
+		.cra_module		= THIS_MODULE,
+	},
+},
+};
+
+int jh7110_aes_register_algs(void)
+{
+	int ret;
+
+	ret = crypto_register_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));
+
+	if (ret) {
+		pr_err("Could not register algs\n");
+		goto err_algs;
+	}
+
+	ret = crypto_register_aeads(aead_algs, ARRAY_SIZE(aead_algs));
+	if (ret)
+		goto err_aead_algs;
+
+	return 0;
+
+err_aead_algs:
+	crypto_unregister_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));
+err_algs:
+	return ret;
+}
+
+void jh7110_aes_unregister_algs(void)
+{
+	crypto_unregister_aeads(aead_algs, ARRAY_SIZE(aead_algs));
+	crypto_unregister_skciphers(crypto_algs, ARRAY_SIZE(crypto_algs));
+}
diff --git a/drivers/crypto/starfive/jh7110/jh7110-pka.c b/drivers/crypto/starfive/jh7110/jh7110-pka.c
new file mode 100644
index 000000000000..2cada3ac51f7
--- /dev/null
+++ b/drivers/crypto/starfive/jh7110/jh7110-pka.c
@@ -0,0 +1,733 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2021 StarFive, Inc <huan.feng@starfivetech.com>
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING
+ * CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER
+ * FOR THEM TO SAVE TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE
+ * FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+ * CLAIMS ARISING FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE
+ * BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION
+ * WITH THEIR PRODUCTS.
+ */
+#include <linux/mod_devicetable.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/crypto.h>
+#include <linux/io.h>
+
+#include <linux/delay.h>
+#include <linux/dma-direct.h>
+#include <crypto/scatterwalk.h>
+
+#include "jh7110-str.h"
+
+#define JH7110_RSA_KEYSZ_LEN			(2048 >> 2)
+#define JH7110_RSA_KEY_SIZE			(JH7110_RSA_KEYSZ_LEN * 3)
+#define JH7110_RSA_MAX_KEYSZ			256
+#define swap32(val) (						\
+		     (((u32)(val) << 24) & (u32)0xFF000000) |	\
+		     (((u32)(val) <<  8) & (u32)0x00FF0000) |	\
+		     (((u32)(val) >>  8) & (u32)0x0000FF00) |	\
+		     (((u32)(val) >> 24) & (u32)0x000000FF))
+
+static inline int jh7110_pka_wait_pre(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	u32 status;
+
+	return readl_relaxed_poll_timeout(sdev->io_base + JH7110_CRYPTO_CASR_OFFSET, status,
+				   (status & JH7110_PKA_DONE_FLAGS), 10, 100000);
+}
+
+static int jh7110_pka_wait_done(struct jh7110_sec_dev *sdev)
+{
+	int ret = -1;
+
+	wait_for_completion(&sdev->rsa_comp);
+	reinit_completion(&sdev->rsa_comp);
+	mutex_unlock(&sdev->doing);
+	mutex_lock(&sdev->doing);
+	if (sdev->done_flags & JH7110_PKA_DONE)
+		ret = 0;
+	mutex_unlock(&sdev->doing);
+
+	return ret;
+}
+
+static void jh7110_rsa_free_key(struct jh7110_rsa_key *key)
+{
+	if (key->d)
+		kfree_sensitive(key->d);
+	if (key->e)
+		kfree_sensitive(key->e);
+	if (key->n)
+		kfree_sensitive(key->n);
+	memset(key, 0, sizeof(*key));
+}
+
+static unsigned int jh7110_rsa_get_nbit(u8 *pa, u32 snum, int key_sz)
+{
+	u32 i;
+	u8 value;
+
+	i = snum >> 3;
+
+	value = pa[key_sz - i - 1];
+	value >>= snum & 0x7;
+	value &= 0x1;
+
+	return value;
+}
+
+static int jh7110_rsa_domain_transfer(struct jh7110_sec_ctx *ctx, u32 *result, u32 *opa, u8 domain, u32 *mod, int bit_len)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	unsigned int *info;
+	int loop;
+	u8 opsize;
+	u32 temp;
+
+	mutex_lock(&sdev->doing);
+
+	opsize = (bit_len - 1) >> 5;
+	rctx->csr.pka_csr.v = 0;
+	jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+	info = (unsigned int *)mod;
+	for (loop = 0; loop <= opsize; loop++)
+		jh7110_sec_write(sdev, JH7110_CRYPTO_CANR_OFFSET + loop * 4, info[opsize - loop]);
+
+
+	if (domain != 0) {
+		rctx->csr.pka_csr.v = 0;
+		rctx->csr.pka_csr.cln_done = 1;
+		rctx->csr.pka_csr.opsize = opsize;
+		rctx->csr.pka_csr.exposize = opsize;
+		rctx->csr.pka_csr.cmd = CRYPTO_CMD_PRE;
+		rctx->csr.pka_csr.ie = 1;
+		rctx->csr.pka_csr.start = 0x1;
+		rctx->csr.pka_csr.not_r2 = 0x1;
+		jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+		jh7110_pka_wait_done(sdev);
+
+		mutex_lock(&sdev->doing);
+
+		info = (unsigned int *)opa;
+		for (loop = 0; loop <= opsize; loop++)
+			jh7110_sec_write(sdev, JH7110_CRYPTO_CAAR_OFFSET + loop * 4, info[opsize - loop]);
+
+		for (loop = 0; loop <= opsize; loop++) {
+			if (loop == 0)
+				jh7110_sec_write(sdev, JH7110_CRYPTO_CAER_OFFSET + loop * 4, 0x1000000);
+			else
+				jh7110_sec_write(sdev, JH7110_CRYPTO_CAER_OFFSET + loop * 4, 0);
+		}
+
+		rctx->csr.pka_csr.v = 0;
+		rctx->csr.pka_csr.cln_done = 1;
+		rctx->csr.pka_csr.ie = 1;
+		rctx->csr.pka_csr.opsize = opsize;
+		rctx->csr.pka_csr.exposize = opsize;
+		rctx->csr.pka_csr.cmd = CRYPTO_CMD_AERN;
+		rctx->csr.pka_csr.start = 0x1;
+		jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+		jh7110_pka_wait_done(sdev);
+	} else {
+		rctx->csr.pka_csr.v = 0;
+		rctx->csr.pka_csr.cln_done = 1;
+		rctx->csr.pka_csr.opsize = opsize;
+		rctx->csr.pka_csr.exposize = opsize;
+		rctx->csr.pka_csr.cmd = CRYPTO_CMD_PRE;
+		rctx->csr.pka_csr.ie = 1;
+		rctx->csr.pka_csr.start = 0x1;
+		rctx->csr.pka_csr.pre_expf = 0x1;
+		jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+		jh7110_pka_wait_done(sdev);
+
+		mutex_lock(&sdev->doing);
+
+		info = (unsigned int *)opa;
+		for (loop = 0; loop <= opsize; loop++)
+			jh7110_sec_write(sdev, JH7110_CRYPTO_CAER_OFFSET + loop * 4, info[opsize - loop]);
+
+		rctx->csr.pka_csr.v = 0;
+		rctx->csr.pka_csr.cln_done = 1;
+		rctx->csr.pka_csr.opsize = opsize;
+		rctx->csr.pka_csr.exposize = opsize;
+		rctx->csr.pka_csr.cmd = CRYPTO_CMD_ARN;
+		rctx->csr.pka_csr.ie = 1;
+		rctx->csr.pka_csr.start = 0x1;
+		jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+		jh7110_pka_wait_done(sdev);
+	}
+
+	mutex_lock(&sdev->doing);
+	for (loop = 0; loop <= opsize; loop++) {
+		temp = jh7110_sec_read(sdev, JH7110_CRYPTO_CAAR_OFFSET + 0x4 * loop);
+		result[opsize - loop] = temp;
+	}
+	mutex_unlock(&sdev->doing);
+
+	return 0;
+}
+
+static int jh7110_rsa_cpu_powm(struct jh7110_sec_ctx *ctx, u32 *result, u8 *de, u32 *n, int key_sz)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	struct jh7110_rsa_key *key = &ctx->rsa_key;
+	u32 initial;
+	int opsize, mlen, bs, loop;
+	unsigned int *mta;
+
+	opsize = (key_sz - 1) >> 2;
+	initial = 1;
+
+	mta = kmalloc(key_sz, GFP_KERNEL);
+	if (!mta)
+		return -ENOMEM;
+
+	jh7110_rsa_domain_transfer(ctx, mta, sdev->pka_data, 0, n, key_sz << 3);
+
+	for (loop = 0; loop <= opsize; loop++)
+		jh7110_sec_write(sdev, JH7110_CRYPTO_CANR_OFFSET + loop * 4, n[opsize - loop]);
+
+	mutex_lock(&sdev->doing);
+
+	rctx->csr.pka_csr.v = 0;
+	rctx->csr.pka_csr.cln_done = 1;
+	rctx->csr.pka_csr.opsize = opsize;
+	rctx->csr.pka_csr.exposize = opsize;
+	rctx->csr.pka_csr.cmd = CRYPTO_CMD_PRE;
+	rctx->csr.pka_csr.ie = 1;
+	rctx->csr.pka_csr.not_r2 = 0x1;
+	rctx->csr.pka_csr.start = 0x1;
+
+	jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+	jh7110_pka_wait_done(sdev);
+
+	for (loop = 0; loop <= opsize; loop++)
+		jh7110_sec_write(sdev, JH7110_CRYPTO_CAER_OFFSET + loop * 4, mta[opsize - loop]);
+
+	for (loop = key->bitlen; loop > 0; loop--) {
+		if (initial) {
+			for (bs = 0; bs <= opsize; bs++)
+				result[bs] = mta[bs];
+
+			initial = 0;
+		} else {
+			mlen = jh7110_rsa_get_nbit(de, loop - 1, key_sz);
+
+			mutex_lock(&sdev->doing);
+
+			rctx->csr.pka_csr.v = 0;
+			rctx->csr.pka_csr.cln_done = 1;
+			rctx->csr.pka_csr.opsize = opsize;
+			rctx->csr.pka_csr.exposize = opsize;
+			rctx->csr.pka_csr.cmd = CRYPTO_CMD_AARN;
+			rctx->csr.pka_csr.ie = 1;
+			rctx->csr.pka_csr.start = 0x1;
+
+			jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+			jh7110_pka_wait_done(sdev);
+
+			if (mlen) {
+				mutex_lock(&sdev->doing);
+
+				rctx->csr.pka_csr.v = 0;
+				rctx->csr.pka_csr.cln_done = 1;
+				rctx->csr.pka_csr.opsize = opsize;
+				rctx->csr.pka_csr.exposize = opsize;
+				rctx->csr.pka_csr.cmd = CRYPTO_CMD_AERN;
+				rctx->csr.pka_csr.ie = 1;
+				rctx->csr.pka_csr.start = 0x1;
+
+				jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+				jh7110_pka_wait_done(sdev);
+			}
+		}
+	}
+
+	mutex_lock(&sdev->doing);
+	for (loop = 0; loop <= opsize; loop++) {
+		unsigned int temp;
+
+		temp = jh7110_sec_read(sdev, JH7110_CRYPTO_CAAR_OFFSET + 0x4 * loop);
+		result[opsize - loop] = temp;
+	}
+	mutex_unlock(&sdev->doing);
+
+	jh7110_rsa_domain_transfer(ctx, result, result, 1, n, key_sz << 3);
+
+	return 0;
+}
+
+static int jh7110_rsa_powm(struct jh7110_sec_ctx *ctx, u8 *result, u8 *de, u8 *n, int key_sz)
+{
+	return jh7110_rsa_cpu_powm(ctx, (u32 *)result, de, (u32 *)n, key_sz);
+}
+
+static int jh7110_rsa_get_from_sg(struct jh7110_sec_request_ctx *rctx, size_t offset,
+				size_t count, size_t data_offset)
+{
+	size_t of, ct, index;
+	struct scatterlist	*sg = rctx->sg;
+
+	of = offset;
+	ct = count;
+
+	while (sg->length <= of) {
+		of -= sg->length;
+
+		if (!sg_is_last(sg)) {
+			sg = sg_next(sg);
+			continue;
+		} else {
+			return -EBADE;
+		}
+	}
+
+	index = data_offset;
+	while (ct > 0) {
+		if (sg->length - of >= ct) {
+			scatterwalk_map_and_copy(rctx->sdev->pka_data + index, sg,
+					of, ct, 0);
+			index = index + ct;
+			return index - data_offset;
+		}
+		scatterwalk_map_and_copy(rctx->sdev->pka_data + index, sg,
+									of, sg->length - of, 0);
+		index += sg->length - of;
+		ct = ct - (sg->length - of);
+
+		of = 0;
+
+		if (!sg_is_last(sg))
+			sg = sg_next(sg);
+		else
+			return -EBADE;
+	}
+	return index - data_offset;
+}
+
+static int jh7110_rsa_enc_core(struct jh7110_sec_ctx *ctx, int enc)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	struct jh7110_rsa_key *key = &ctx->rsa_key;
+	size_t data_len, total, count, data_offset;
+	int ret = 0;
+	unsigned int *info;
+	int loop;
+
+	sdev->cry_type = JH7110_PKA_TYPE;
+
+	rctx->csr.pka_csr.v = 0;
+	rctx->csr.pka_csr.reset = 1;
+	jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, rctx->csr.pka_csr.v);
+
+	if (jh7110_pka_wait_pre(ctx))
+		dev_dbg(sdev->dev, "this is debug for lophyel pka_casr = %x %s %s %d\n",
+			   jh7110_sec_read(sdev, JH7110_CRYPTO_CASR_OFFSET), __FILE__, __func__, __LINE__);
+
+	rctx->offset = 0;
+	total = 0;
+
+	while (total < rctx->total_in) {
+		count = min(sdev->data_buf_len, rctx->total_in);
+		count = min(count, key->key_sz);
+		memset(sdev->pka_data, 0, key->key_sz);
+		data_offset = key->key_sz - count;
+
+		data_len = jh7110_rsa_get_from_sg(rctx, rctx->offset, count, data_offset);
+		if (data_len < 0)
+			return data_len;
+		if (data_len != count)
+			return -EINVAL;
+
+		if (enc) {
+			key->bitlen = key->e_bitlen;
+			ret = jh7110_rsa_powm(ctx, sdev->pka_data + JH7110_RSA_KEYSZ_LEN, key->e, key->n, key->key_sz);
+		} else {
+			key->bitlen = key->d_bitlen;
+			ret = jh7110_rsa_powm(ctx, sdev->pka_data + JH7110_RSA_KEYSZ_LEN, key->d, key->n, key->key_sz);
+		}
+
+
+		if (ret)
+			return ret;
+
+		info = (unsigned int *)(sdev->pka_data + JH7110_RSA_KEYSZ_LEN);
+		for (loop = 0; loop < key->key_sz >> 2; loop++)
+			dev_dbg(sdev->dev, "result[%d] = %x\n", loop, info[loop]);
+
+		sg_copy_buffer(rctx->out_sg, sg_nents(rctx->out_sg), sdev->pka_data + JH7110_RSA_KEYSZ_LEN,
+			       key->key_sz, rctx->offset, 0);
+
+		rctx->offset += data_len;
+		total += data_len;
+	}
+
+	return ret;
+}
+
+static int jh7110_rsa_enc(struct akcipher_request *req)
+{
+	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
+	struct jh7110_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	struct jh7110_rsa_key *key = &ctx->rsa_key;
+	struct jh7110_sec_request_ctx *rctx = akcipher_request_ctx(req);
+	int ret = 0;
+
+	if (key->key_sz > JH7110_RSA_MAX_KEYSZ) {
+		akcipher_request_set_tfm(req, ctx->fallback.akcipher);
+		ret = crypto_akcipher_encrypt(req);
+		akcipher_request_set_tfm(req, tfm);
+		return ret;
+	}
+
+	if (unlikely(!key->n || !key->e))
+		return -EINVAL;
+
+	if (req->dst_len < key->key_sz) {
+		req->dst_len = key->key_sz;
+		dev_err(ctx->sdev->dev, "Output buffer length less than parameter n\n");
+		return -EOVERFLOW;
+	}
+
+	mutex_lock(&ctx->sdev->rsa_lock);
+
+	rctx->sg = req->src;
+	rctx->out_sg = req->dst;
+	rctx->sdev = ctx->sdev;
+	ctx->rctx = rctx;
+	rctx->total_in = req->src_len;
+	rctx->total_out = req->dst_len;
+
+	ret = jh7110_rsa_enc_core(ctx, 1);
+
+	mutex_unlock(&ctx->sdev->rsa_lock);
+
+	return ret;
+}
+
+static int jh7110_rsa_dec(struct akcipher_request *req)
+{
+	struct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);
+	struct jh7110_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	struct jh7110_rsa_key *key = &ctx->rsa_key;
+	struct jh7110_sec_request_ctx *rctx = akcipher_request_ctx(req);
+	int ret = 0;
+
+	if (key->key_sz > JH7110_RSA_MAX_KEYSZ) {
+		akcipher_request_set_tfm(req, ctx->fallback.akcipher);
+		ret = crypto_akcipher_decrypt(req);
+		akcipher_request_set_tfm(req, tfm);
+		return ret;
+	}
+
+	if (unlikely(!key->n || !key->d))
+		return -EINVAL;
+
+	if (req->dst_len < key->key_sz) {
+		req->dst_len = key->key_sz;
+		dev_err(ctx->sdev->dev, "Output buffer length less than parameter n\n");
+		return -EOVERFLOW;
+	}
+
+	mutex_lock(&ctx->sdev->rsa_lock);
+
+	rctx->sg = req->src;
+	rctx->out_sg = req->dst;
+	rctx->sdev = ctx->sdev;
+	ctx->rctx = rctx;
+	rctx->total_in = req->src_len;
+	rctx->total_out = req->dst_len;
+
+	ret = jh7110_rsa_enc_core(ctx, 0);
+
+	mutex_unlock(&ctx->sdev->rsa_lock);
+
+	return ret;
+}
+
+static unsigned long jh7110_rsa_enc_fn_id(unsigned int len)
+{
+	unsigned int bitslen = len << 3;
+
+	if (bitslen & 0x1f)
+		return -EINVAL;
+
+	if (bitslen > 2048)
+		return false;
+
+	return true;
+}
+
+static int jh7110_rsa_set_n(struct jh7110_rsa_key *rsa_key, const char *value,
+			 size_t vlen)
+{
+	const char *ptr = value;
+	int ret;
+
+	while (!*ptr && vlen) {
+		ptr++;
+		vlen--;
+	}
+	rsa_key->key_sz = vlen;
+	ret = -EINVAL;
+	/* invalid key size provided */
+	if (!jh7110_rsa_enc_fn_id(rsa_key->key_sz))
+		return 0;
+
+	ret = -ENOMEM;
+	rsa_key->n = kmemdup(ptr, rsa_key->key_sz, GFP_KERNEL);
+	if (!rsa_key->n)
+		goto err;
+
+	return 1;
+ err:
+	rsa_key->key_sz = 0;
+	rsa_key->n = NULL;
+	return ret;
+}
+
+static int jh7110_rsa_set_e(struct jh7110_rsa_key *rsa_key, const char *value,
+			 size_t vlen)
+{
+	const char *ptr = value;
+	unsigned char pt;
+	int loop;
+
+	while (!*ptr && vlen) {
+		ptr++;
+		vlen--;
+	}
+	pt = *ptr;
+
+	if (!rsa_key->key_sz || !vlen || vlen > rsa_key->key_sz) {
+		rsa_key->e = NULL;
+		return -EINVAL;
+	}
+
+	rsa_key->e = kzalloc(rsa_key->key_sz, GFP_KERNEL);
+	if (!rsa_key->e)
+		return -ENOMEM;
+
+	for (loop = 8; loop > 0; loop--) {
+		if (pt >> (loop - 1))
+			break;
+	}
+
+	rsa_key->e_bitlen = (vlen - 1) * 8 + loop;
+
+	memcpy(rsa_key->e + (rsa_key->key_sz - vlen), ptr, vlen);
+
+	return 0;
+}
+
+static int jh7110_rsa_set_d(struct jh7110_rsa_key *rsa_key, const char *value,
+			 size_t vlen)
+{
+	const char *ptr = value;
+	unsigned char pt;
+	int loop;
+	int ret;
+
+	while (!*ptr && vlen) {
+		ptr++;
+		vlen--;
+	}
+	pt = *ptr;
+
+	ret = -EINVAL;
+	if (!rsa_key->key_sz || !vlen || vlen > rsa_key->key_sz)
+		goto err;
+
+	ret = -ENOMEM;
+	rsa_key->d = kzalloc(rsa_key->key_sz, GFP_KERNEL);
+	if (!rsa_key->d)
+		goto err;
+
+	for (loop = 8; loop > 0; loop--) {
+		pr_debug("this is debug for lophyel loop = %d pt >> (loop - 1) = %x value[%d] = %x %s %s %d\n",
+			   loop, pt >> (loop - 1), loop, value[loop], __FILE__, __func__, __LINE__);
+		if (pt >> (loop - 1))
+			break;
+	}
+
+	rsa_key->d_bitlen = (vlen - 1) * 8 + loop;
+
+	memcpy(rsa_key->d + (rsa_key->key_sz - vlen), ptr, vlen);
+
+	return 0;
+ err:
+	rsa_key->d = NULL;
+	return ret;
+}
+
+static int jh7110_rsa_setkey(struct crypto_akcipher *tfm, const void *key,
+			unsigned int keylen, bool private)
+{
+	struct jh7110_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	struct rsa_key raw_key = {NULL};
+	struct jh7110_rsa_key *rsa_key = &ctx->rsa_key;
+	int ret;
+
+	jh7110_rsa_free_key(rsa_key);
+
+	if (private)
+		ret = rsa_parse_priv_key(&raw_key, key, keylen);
+	else
+		ret = rsa_parse_pub_key(&raw_key, key, keylen);
+	if (ret < 0)
+		goto err;
+
+	ret = jh7110_rsa_set_n(rsa_key, raw_key.n, raw_key.n_sz);
+	if (ret <= 0)
+		return ret;
+
+	ret = jh7110_rsa_set_e(rsa_key, raw_key.e, raw_key.e_sz);
+	if (ret < 0)
+		goto err;
+
+	if (private) {
+		ret = jh7110_rsa_set_d(rsa_key, raw_key.d, raw_key.d_sz);
+		if (ret < 0)
+			goto err;
+	}
+
+	if (!rsa_key->n || !rsa_key->e) {
+		/* invalid key provided */
+		ret = -EINVAL;
+		goto err;
+	}
+	if (private && !rsa_key->d) {
+		/* invalid private key provided */
+		ret = -EINVAL;
+		goto err;
+	}
+
+	return 0;
+ err:
+	jh7110_rsa_free_key(rsa_key);
+	return ret;
+}
+
+static int jh7110_rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,
+			       unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	int ret;
+
+	ret = crypto_akcipher_set_pub_key(ctx->fallback.akcipher, key, keylen);
+	if (ret)
+		return ret;
+
+	return jh7110_rsa_setkey(tfm, key, keylen, false);
+}
+
+static int jh7110_rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,
+				unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	int ret;
+
+	ret = crypto_akcipher_set_priv_key(ctx->fallback.akcipher, key, keylen);
+	if (ret)
+		return ret;
+
+	return jh7110_rsa_setkey(tfm, key, keylen, true);
+}
+
+static unsigned int jh7110_rsa_max_size(struct crypto_akcipher *tfm)
+{
+	struct jh7110_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+
+	/* For key sizes > 2Kb, use software tfm */
+	if (ctx->rsa_key.key_sz > JH7110_RSA_MAX_KEYSZ)
+		return crypto_akcipher_maxsize(ctx->fallback.akcipher);
+
+	return ctx->rsa_key.key_sz;
+}
+
+/* Per session pkc's driver context creation function */
+static int jh7110_rsa_init_tfm(struct crypto_akcipher *tfm)
+{
+	struct jh7110_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+
+	ctx->fallback.akcipher = crypto_alloc_akcipher("rsa-generic", 0, 0);
+	if (IS_ERR(ctx->fallback.akcipher)) {
+		pr_err("Can not alloc_akcipher!\n");
+		return PTR_ERR(ctx->fallback.akcipher);
+	}
+
+	ctx->sdev = jh7110_sec_find_dev(ctx);
+	if (!ctx->sdev) {
+		crypto_free_akcipher(ctx->fallback.akcipher);
+		return -ENODEV;
+	}
+
+	akcipher_set_reqsize(tfm, sizeof(struct jh7110_sec_request_ctx));
+
+	return 0;
+}
+
+/* Per session pkc's driver context cleanup function */
+static void jh7110_rsa_exit_tfm(struct crypto_akcipher *tfm)
+{
+	struct jh7110_sec_ctx *ctx = akcipher_tfm_ctx(tfm);
+	struct jh7110_rsa_key *key = (struct jh7110_rsa_key *)&ctx->rsa_key;
+
+	crypto_free_akcipher(ctx->fallback.akcipher);
+	jh7110_rsa_free_key(key);
+}
+
+static struct akcipher_alg jh7110_rsa = {
+	.encrypt = jh7110_rsa_enc,
+	.decrypt = jh7110_rsa_dec,
+	.sign = jh7110_rsa_dec,
+	.verify = jh7110_rsa_enc,
+	.set_pub_key = jh7110_rsa_set_pub_key,
+	.set_priv_key = jh7110_rsa_set_priv_key,
+	.max_size = jh7110_rsa_max_size,
+	.init = jh7110_rsa_init_tfm,
+	.exit = jh7110_rsa_exit_tfm,
+	.reqsize = sizeof(struct jh7110_sec_request_ctx),
+	.base = {
+		.cra_name = "rsa",
+		.cra_driver_name = "rsa-jh7110",
+		.cra_flags = CRYPTO_ALG_TYPE_AKCIPHER |
+			     CRYPTO_ALG_ASYNC |
+			     CRYPTO_ALG_NEED_FALLBACK,
+		.cra_priority = 3000,
+		.cra_module = THIS_MODULE,
+		.cra_ctxsize = sizeof(struct jh7110_sec_ctx),
+	},
+};
+
+int jh7110_pka_register_algs(void)
+{
+	int ret = 0;
+
+	ret = crypto_register_akcipher(&jh7110_rsa);
+	if (ret)
+		pr_err("JH7110 RSA registration failed\n");
+
+	return ret;
+}
+
+void jh7110_pka_unregister_algs(void)
+{
+	crypto_unregister_akcipher(&jh7110_rsa);
+}
diff --git a/drivers/crypto/starfive/jh7110/jh7110-regs.h b/drivers/crypto/starfive/jh7110/jh7110-regs.h
new file mode 100644
index 000000000000..f484b04bb7a8
--- /dev/null
+++ b/drivers/crypto/starfive/jh7110/jh7110-regs.h
@@ -0,0 +1,237 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright 2021 StarFive, Inc <huan.feng@starfivetech.com>
+ */
+#ifndef __JH7110_REGS_H__
+#define __JH7110_REGS_H__
+
+#include <crypto/aes.h>
+#include <crypto/sha.h>
+
+#define JH7110_ALG_CR_OFFSET					0x0
+#define JH7110_ALG_FIFO_OFFSET					0x4
+#define JH7110_IE_MASK_OFFSET					0x8
+#define JH7110_IE_FLAG_OFFSET					0xc
+#define JH7110_DMA_IN_LEN_OFFSET				0x10
+#define JH7110_DMA_OUT_LEN_OFFSET				0x14
+
+#define JH7110_AES_REGS_OFFSET					0x100
+#define JH7110_SHA_REGS_OFFSET					0x300
+#define JH7110_CRYPTO_REGS_OFFSET				0x400
+
+union jh7110_alg_cr {
+	u32 v;
+	struct {
+		u32 start				:1;
+		u32 aes_dma_en			:1;
+		u32 des_dma_en			:1;
+		u32 sha_dma_en			:1;
+		u32 alg_done			:1;
+		u32 rsvd_0				:3;
+		u32 clear				:1;
+		u32 rsvd_1				:23;
+	};
+};
+
+union jh7110_ie_mask {
+	u32 v;
+	struct {
+		u32 aes_ie_mask			:1;
+		u32 des_ie_mask			:1;
+		u32 sha_ie_mask			:1;
+		u32 crypto_ie_mask		:1;
+		u32 rsvd_0				:28;
+	};
+};
+
+union jh7110_ie_flag {
+	u32 v;
+	struct {
+		u32 aes_ie_done			:1;
+		u32 des_ie_done			:1;
+		u32 sha_ie_done			:1;
+		u32 crypto_ie_done		:1;
+		u32 rsvd_0				:28;
+	};
+};
+
+#define JH7110_CRYPTO_CACR_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x0)
+#define JH7110_CRYPTO_CASR_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x4)
+#define JH7110_CRYPTO_CAAR_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x8)
+#define JH7110_CRYPTO_CAER_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x108)
+#define JH7110_CRYPTO_CANR_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x208)
+#define JH7110_CRYPTO_CAAFR_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x308)
+#define JH7110_CRYPTO_CAEFR_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x30c)
+#define JH7110_CRYPTO_CANFR_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x310)
+#define JH7110_FIFO_COUNTER_OFFSET				(JH7110_CRYPTO_REGS_OFFSET + 0x314)
+
+// R^2 mod N and N0'
+#define CRYPTO_CMD_PRE						0x0
+// (A + A) mod N, ==> A
+#define CRYPTO_CMD_AAN						0x1
+// A ^ E mod N   ==> A
+#define CRYPTO_CMD_AMEN						0x2
+// A + E mod N   ==> A
+#define CRYPTO_CMD_AAEN						0x3
+// A - E mod N   ==> A
+#define CRYPTO_CMD_ADEN						0x4
+// A * R mod N   ==> A
+#define CRYPTO_CMD_ARN						0x5
+// A * E * R mod N ==> A
+#define CRYPTO_CMD_AERN						0x6
+// A * A * R mod N ==> A
+#define CRYPTO_CMD_AARN						0x7
+// ECC2P      ==> A
+#define CRYPTO_CMD_ECC2P					0x8
+// ECCPQ      ==> A
+#define CRYPTO_CMD_ECCPQ					0x9
+
+union jh7110_crypto_cacr {
+	u32 v;
+	struct {
+		u32 start			:1;
+		u32 reset			:1;
+		u32 ie				:1;
+		u32 rsvd_0			:1;
+		u32 fifo_mode			:1;
+		u32 not_r2			:1;
+		u32 ecc_sub			:1;
+		u32 pre_expf			:1;
+
+		u32 cmd				:4;
+		u32 rsvd_1			:1;
+		u32 ctrl_dummy			:1;
+		u32 ctrl_false			:1;
+		u32 cln_done			:1;
+
+		u32 opsize			:6;
+		u32 rsvd_2			:2;
+
+		u32 exposize			:6;
+		u32 rsvd_3			:1;
+		u32 bigendian			:1;
+	};
+};
+
+union jh7110_crypto_casr {
+	u32 v;
+	struct {
+#define JH7110_PKA_DONE_FLAGS					BIT(0)
+		u32 done			:1;
+		u32 rsvd_0			:31;
+	};
+};
+
+#define JH7110_AES_AESDIO0R					(JH7110_AES_REGS_OFFSET + 0x0)
+#define JH7110_AES_KEY0						(JH7110_AES_REGS_OFFSET + 0x4)
+#define JH7110_AES_KEY1						(JH7110_AES_REGS_OFFSET + 0x8)
+#define JH7110_AES_KEY2						(JH7110_AES_REGS_OFFSET + 0xC)
+#define JH7110_AES_KEY3						(JH7110_AES_REGS_OFFSET + 0x10)
+#define JH7110_AES_KEY4						(JH7110_AES_REGS_OFFSET + 0x14)
+#define JH7110_AES_KEY5						(JH7110_AES_REGS_OFFSET + 0x18)
+#define JH7110_AES_KEY6						(JH7110_AES_REGS_OFFSET + 0x1C)
+#define JH7110_AES_KEY7						(JH7110_AES_REGS_OFFSET + 0x20)
+#define JH7110_AES_CSR						(JH7110_AES_REGS_OFFSET + 0x24)
+#define JH7110_AES_IV0						(JH7110_AES_REGS_OFFSET + 0x28)
+#define JH7110_AES_IV1						(JH7110_AES_REGS_OFFSET + 0x2C)
+#define JH7110_AES_IV2						(JH7110_AES_REGS_OFFSET + 0x30)
+#define JH7110_AES_IV3						(JH7110_AES_REGS_OFFSET + 0x34)
+#define JH7110_AES_NONCE0					(JH7110_AES_REGS_OFFSET + 0x3C)
+#define JH7110_AES_NONCE1					(JH7110_AES_REGS_OFFSET + 0x40)
+#define JH7110_AES_NONCE2					(JH7110_AES_REGS_OFFSET + 0x44)
+#define JH7110_AES_NONCE3					(JH7110_AES_REGS_OFFSET + 0x48)
+#define JH7110_AES_ALEN0					(JH7110_AES_REGS_OFFSET + 0x4C)
+#define JH7110_AES_ALEN1					(JH7110_AES_REGS_OFFSET + 0x50)
+#define JH7110_AES_MLEN0					(JH7110_AES_REGS_OFFSET + 0x54)
+#define JH7110_AES_MLEN1					(JH7110_AES_REGS_OFFSET + 0x58)
+#define JH7110_AES_IVLEN					(JH7110_AES_REGS_OFFSET + 0x5C)
+
+union jh7110_aes_csr {
+	u32 v;
+	struct {
+		u32 cmode			:1;
+#define JH7110_AES_KEYMODE_128					0x0
+#define JH7110_AES_KEYMODE_192					0x1
+#define JH7110_AES_KEYMODE_256					0x2
+		u32 keymode			:2;
+#define JH7110_AES_BUSY						BIT(3)
+		u32 busy			:1;
+		u32 done			:1;
+#define JH7110_AES_KEY_DONE					BIT(5)
+		u32 krdy			:1;
+		u32 aesrst			:1;
+		u32 aesie			:1;
+
+#define JH7110_AES_CCM_START					BIT(8)
+		u32 ccm_start			:1;
+#define JH7110_AES_MODE_ECB					0x0
+#define JH7110_AES_MODE_CBC					0x1
+#define JH7110_AES_MODE_CFB					0x2
+#define JH7110_AES_MODE_OFB					0x3
+#define JH7110_AES_MODE_CTR					0x4
+#define JH7110_AES_MODE_CCM					0x5
+#define JH7110_AES_MODE_GCM					0x6
+		u32 mode			:3;
+#define JH7110_AES_GCM_START					BIT(12)
+		u32 gcm_start			:1;
+#define JH7110_AES_GCM_DONE					BIT(13)
+		u32 gcm_done			:1;
+		u32 delay_aes			:1;
+		u32 vaes_start			:1;
+
+		u32 rsvd_0			:8;
+
+#define JH7110_AES_MODE_XFB_1					0x0
+#define JH7110_AES_MODE_XFB_128					0x5
+		u32 stream_mode			:3;
+		u32 rsvd_1			:5;
+	};
+};
+
+#define JH7110_SHA_SHACSR					(JH7110_SHA_REGS_OFFSET + 0x0)
+#define JH7110_SHA_SHAWDR					(JH7110_SHA_REGS_OFFSET + 0x4)
+#define JH7110_SHA_SHARDR					(JH7110_SHA_REGS_OFFSET + 0x8)
+#define JH7110_SHA_SHAWSR					(JH7110_SHA_REGS_OFFSET + 0xC)
+#define JH7110_SHA_SHAWLEN3					(JH7110_SHA_REGS_OFFSET + 0x10)
+#define JH7110_SHA_SHAWLEN2					(JH7110_SHA_REGS_OFFSET + 0x14)
+#define JH7110_SHA_SHAWLEN1					(JH7110_SHA_REGS_OFFSET + 0x18)
+#define JH7110_SHA_SHAWLEN0					(JH7110_SHA_REGS_OFFSET + 0x1C)
+#define JH7110_SHA_SHAWKR					(JH7110_SHA_REGS_OFFSET + 0x20)
+#define JH7110_SHA_SHAWKLEN					(JH7110_SHA_REGS_OFFSET + 0x24)
+
+union jh7110_sha_shacsr {
+	u32 v;
+	struct {
+		u32 start			:1;
+		u32 reset			:1;
+		u32 ie				:1;
+		u32 firstb			:1;
+#define JH7110_SHA_SM3						0x0
+#define JH7110_SHA_SHA0						0x1
+#define JH7110_SHA_SHA1						0x2
+#define JH7110_SHA_SHA224					0x3
+#define JH7110_SHA_SHA256					0x4
+#define JH7110_SHA_SHA384					0x5
+#define JH7110_SHA_SHA512					0x6
+#define JH7110_SHA_MODE_MASK					0x7
+		u32 mode			:3;
+		u32 rsvd_0			:1;
+
+		u32 final			:1;
+		u32 rsvd_1			:2;
+#define JH7110_SHA_HMAC_FLAGS					0x800
+		u32 hmac			:1;
+		u32 rsvd_2			:1;
+#define JH7110_SHA_KEY_DONE					BIT(13)
+		u32 key_done			:1;
+		u32 key_flag			:1;
+#define JH7110_SHA_HMAC_DONE					BIT(15)
+		u32 hmac_done			:1;
+#define JH7110_SHA_BUSY						BIT(16)
+		u32 busy			:1;
+		u32 shadone			:1;
+		u32 rsvd_3			:14;
+	};
+};
+
+#endif
diff --git a/drivers/crypto/starfive/jh7110/jh7110-sec.c b/drivers/crypto/starfive/jh7110/jh7110-sec.c
new file mode 100644
index 000000000000..b328a0c83a28
--- /dev/null
+++ b/drivers/crypto/starfive/jh7110/jh7110-sec.c
@@ -0,0 +1,432 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2021 StarFive, Inc <william.qiu@starfivetech.com>
+ * Copyright 2021 StarFive, Inc <huan.feng@starfivetech.com>
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING
+ * CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER
+ * FOR THEM TO SAVE TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE
+ * FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+ * CLAIMS ARISING FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE
+ * BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION
+ * WITH THEIR PRODUCTS.
+ */
+
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+
+#include "jh7110-str.h"
+
+#define DRIVER_NAME             "jh7110-sec"
+
+struct jh7110_dev_list {
+	struct list_head        dev_list;
+	spinlock_t              lock; /* protect dev_list */
+};
+
+static struct jh7110_dev_list dev_list = {
+	.dev_list = LIST_HEAD_INIT(dev_list.dev_list),
+	.lock     = __SPIN_LOCK_UNLOCKED(dev_list.lock),
+};
+
+struct jh7110_sec_dev *jh7110_sec_find_dev(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = NULL, *tmp;
+
+	spin_lock_bh(&dev_list.lock);
+	if (!ctx->sdev) {
+		list_for_each_entry(tmp, &dev_list.dev_list, list) {
+			sdev = tmp;
+			break;
+		}
+		ctx->sdev = sdev;
+	} else {
+		sdev = ctx->sdev;
+	}
+
+	spin_unlock_bh(&dev_list.lock);
+
+	return sdev;
+}
+
+static irqreturn_t jh7110_cryp_irq_thread(int irq, void *arg)
+{
+	struct jh7110_sec_dev *sdev = (struct jh7110_sec_dev *) arg;
+
+	if (sdev->use_dma)
+		if (sdev->cry_type != JH7110_PKA_TYPE)
+			return IRQ_HANDLED;
+
+
+	complete(&sdev->rsa_comp);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t jh7110_cryp_irq(int irq, void *arg)
+{
+	struct jh7110_sec_dev *sdev = (struct jh7110_sec_dev *) arg;
+	union jh7110_sha_shacsr sha_csr;
+	union jh7110_aes_csr   aes_csr;
+	union jh7110_crypto_cacr  cry_cacr;
+	union jh7110_crypto_casr  cry_casr;
+	irqreturn_t ret = IRQ_WAKE_THREAD;
+
+	switch (sdev->cry_type) {
+	case JH7110_SHA_TYPE:
+		sha_csr.v = jh7110_sec_read(sdev, JH7110_SHA_SHACSR);
+		if (sha_csr.hmac_done)
+			sdev->done_flags |= JH7110_SHA_HMAC_DONE;
+		if (sha_csr.shadone)
+			sdev->done_flags |= JH7110_SHA_SHA_DONE;
+
+		jh7110_sec_write(sdev, JH7110_SHA_SHACSR, sha_csr.v | BIT(15) | BIT(17));
+		break;
+	case JH7110_AES_TYPE:
+		aes_csr.v = jh7110_sec_read(sdev, JH7110_AES_CSR);
+		if (aes_csr.done) {
+			sdev->done_flags |= JH7110_AES_DONE;
+			jh7110_sec_write(sdev, JH7110_AES_CSR, aes_csr.v);
+		}
+
+		break;
+	case JH7110_PKA_TYPE:
+		cry_casr.v = jh7110_sec_read(sdev, JH7110_CRYPTO_CASR_OFFSET);
+		if (cry_casr.done)
+			sdev->done_flags |= JH7110_PKA_DONE_FLAGS;
+		cry_cacr.v = jh7110_sec_read(sdev, JH7110_CRYPTO_CACR_OFFSET);
+		cry_cacr.cln_done = 1;
+		jh7110_sec_write(sdev, JH7110_CRYPTO_CACR_OFFSET, cry_cacr.v);
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+static const struct of_device_id jh7110_dt_ids[] = {
+	{ .compatible = "starfive,jh7110-sec", .data = NULL},
+	{},
+};
+MODULE_DEVICE_TABLE(of, jh7110_dt_ids);
+
+static int jh7110_dma_init(struct jh7110_sec_dev *sdev)
+{
+	dma_cap_mask_t mask;
+	int err;
+
+	sdev->sec_xm_m = NULL;
+	sdev->sec_xm_p = NULL;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	sdev->sec_xm_m = dma_request_chan(sdev->dev, "sec_m");
+	if (IS_ERR(sdev->sec_xm_m)) {
+		dev_err(sdev->dev, "Unable to request sec_m dma channel in DMA channel\n");
+		return PTR_ERR(sdev->sec_xm_m);
+	}
+
+	sdev->sec_xm_p = dma_request_chan(sdev->dev, "sec_p");
+	if (IS_ERR(sdev->sec_xm_p)) {
+		dev_err(sdev->dev, "Unable to request sec_p dma channel in DMA channel\n");
+		goto err_sha_out;
+	}
+
+	init_completion(&sdev->sec_comp_m);
+	init_completion(&sdev->sec_comp_p);
+
+	return 0;
+
+err_sha_out:
+	dma_release_channel(sdev->sec_xm_m);
+
+	return err;
+}
+
+static void jh7110_dma_cleanup(struct jh7110_sec_dev *sdev)
+{
+	dma_release_channel(sdev->sec_xm_p);
+	dma_release_channel(sdev->sec_xm_m);
+}
+struct gpio_desc *gpio;
+
+static int jh7110_cryp_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct jh7110_sec_dev *sdev;
+	struct resource *res;
+	int pages = 0;
+	int ret;
+
+	sdev = devm_kzalloc(dev, sizeof(*sdev), GFP_KERNEL);
+	if (!sdev)
+		return -ENOMEM;
+
+	sdev->dev = dev;
+
+	mutex_init(&sdev->lock);
+	mutex_init(&sdev->doing);
+	mutex_init(&sdev->pl080_doing);
+	mutex_init(&sdev->sha_lock);
+	mutex_init(&sdev->aes_lock);
+	mutex_init(&sdev->rsa_lock);
+	init_completion(&sdev->rsa_comp);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "secreg");
+	sdev->io_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(sdev->io_base))
+		return PTR_ERR(sdev->io_base);
+
+	sdev->io_phys_base = res->start;
+
+	sdev->dma_base = ioremap(0x16008000, 0x4000);
+	if (IS_ERR(sdev->dma_base))
+		return PTR_ERR(sdev->dma_base);
+
+	sdev->use_side_channel_mitigation = device_property_read_bool(dev, "enable-side-channel-mitigation");
+	sdev->use_dma = device_property_read_bool(dev, "enable-dma");
+	sdev->dma_maxburst = 32;
+
+	sdev->secirq = platform_get_irq_byname(pdev, "secirq");
+	sdev->secirq = platform_get_irq(pdev, 0);
+	if (sdev->secirq < 0) {
+		dev_err(dev, "Cannot get IRQ resource\n");
+		return sdev->secirq;
+	}
+
+	ret = devm_request_threaded_irq(dev, sdev->secirq, jh7110_cryp_irq,
+					jh7110_cryp_irq_thread, IRQF_SHARED,
+					dev_name(dev), sdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't get interrupt working.\n");
+		return ret;
+	}
+
+	sdev->sec_hclk = devm_clk_get(dev, "sec_hclk");
+	if (IS_ERR(sdev->sec_hclk)) {
+		dev_err(dev, "failed to get sec clock\n");
+		return PTR_ERR(sdev->sec_hclk);
+	}
+
+	sdev->sec_ahb = devm_clk_get(dev, "sec_ahb");
+	if (IS_ERR(sdev->sec_ahb)) {
+		dev_err(dev, "failed to get sec clock\n");
+		return PTR_ERR(sdev->sec_ahb);
+	}
+
+	pm_runtime_set_autosuspend_delay(dev, 50);
+	pm_runtime_use_autosuspend(dev);
+
+	pm_runtime_get_noresume(dev);
+	pm_runtime_set_active(dev);
+
+	if (!pm_runtime_enabled(dev))
+		pm_runtime_enable(dev);
+
+	sdev->rst_hresetn = devm_reset_control_get_shared(sdev->dev, "sec_hre");
+	if (IS_ERR(sdev->rst_hresetn)) {
+		dev_err(sdev->dev, "failed to get sec reset\n");
+		return PTR_ERR(sdev->rst_hresetn);
+	}
+
+	clk_prepare_enable(sdev->sec_hclk);
+	clk_prepare_enable(sdev->sec_ahb);
+	reset_control_deassert(sdev->rst_hresetn);
+
+	platform_set_drvdata(pdev, sdev);
+
+	spin_lock(&dev_list.lock);
+	list_add(&sdev->list, &dev_list.dev_list);
+	spin_unlock(&dev_list.lock);
+
+	if (sdev->use_dma) {
+		ret = jh7110_dma_init(sdev);
+		if (ret) {
+			dev_err(dev, "Cannot initial dma chan\n");
+			goto err_dma_init;
+		}
+	}
+
+	pages = get_order(JH7110_MSG_BUFFER_SIZE);
+
+	sdev->sha_data = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA32, pages);
+	if (!sdev->sha_data) {
+		dev_err(sdev->dev, "Can't allocate aes buffer pages when unaligned\n");
+		goto err_sha_data;
+	}
+
+	sdev->aes_data = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA32, pages);
+	if (!sdev->aes_data) {
+		dev_err(sdev->dev, "Can't allocate aes buffer pages when unaligned\n");
+		goto err_aes_data;
+	}
+
+	sdev->pka_data = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA32, pages);
+	if (!sdev->pka_data) {
+		dev_err(sdev->dev, "Can't allocate pka buffer pages when unaligned\n");
+		goto err_pka_data;
+	}
+
+	sdev->pages_count = pages >> 1;
+	sdev->data_buf_len = JH7110_MSG_BUFFER_SIZE >> 1;
+
+	/* Initialize crypto engine */
+	sdev->engine = crypto_engine_alloc_init(dev, 1);
+	if (!sdev->engine) {
+		ret = -ENOMEM;
+		goto err_engine;
+	}
+
+	ret = crypto_engine_start(sdev->engine);
+	if (ret)
+		goto err_engine_start;
+
+	ret = jh7110_hash_register_algs();
+	if (ret)
+		goto err_algs_sha;
+
+	ret = jh7110_aes_register_algs();
+	if (ret)
+		goto err_algs_aes;
+
+	ret = jh7110_pka_register_algs();
+	if (ret)
+		goto err_algs_pka;
+
+	dev_info(dev, "Initialized\n");
+
+	pm_runtime_put_sync(dev);
+
+	return 0;
+ err_algs_pka:
+	jh7110_aes_unregister_algs();
+ err_algs_aes:
+	jh7110_hash_unregister_algs();
+ err_algs_sha:
+	crypto_engine_stop(sdev->engine);
+ err_engine_start:
+	crypto_engine_exit(sdev->engine);
+ err_engine:
+	free_pages((unsigned long)sdev->pka_data, pages);
+ err_pka_data:
+	free_pages((unsigned long)sdev->aes_data, pages);
+ err_aes_data:
+	free_pages((unsigned long)sdev->sha_data, pages);
+ err_sha_data:
+	jh7110_dma_cleanup(sdev);
+ err_dma_init:
+	spin_lock(&dev_list.lock);
+	list_del(&sdev->list);
+	spin_unlock(&dev_list.lock);
+
+	return ret;
+}
+
+static int jh7110_cryp_remove(struct platform_device *pdev)
+{
+	struct jh7110_sec_dev *sdev = platform_get_drvdata(pdev);
+	int ret;
+
+	if (!sdev)
+		return -ENODEV;
+
+	ret = pm_runtime_resume_and_get(sdev->dev);
+	if (ret < 0)
+		return ret;
+
+	jh7110_pka_unregister_algs();
+	jh7110_aes_unregister_algs();
+	jh7110_hash_unregister_algs();
+
+	crypto_engine_stop(sdev->engine);
+	crypto_engine_exit(sdev->engine);
+
+	jh7110_dma_cleanup(sdev);
+
+	free_pages((unsigned long)sdev->pka_data, sdev->pages_count);
+	free_pages((unsigned long)sdev->aes_data, sdev->pages_count);
+	free_pages((unsigned long)sdev->sha_data, sdev->pages_count);
+	sdev->pka_data = NULL;
+	sdev->aes_data = NULL;
+	sdev->sha_data = NULL;
+
+	spin_lock(&dev_list.lock);
+	list_del(&sdev->list);
+	spin_unlock(&dev_list.lock);
+
+	pm_runtime_disable(sdev->dev);
+	pm_runtime_put_noidle(sdev->dev);
+
+	clk_disable_unprepare(sdev->sec_hclk);
+	clk_disable_unprepare(sdev->sec_ahb);
+	reset_control_assert(sdev->rst_hresetn);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int jh7110_cryp_runtime_suspend(struct device *dev)
+{
+	struct jh7110_sec_dev *sdev = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(sdev->sec_ahb);
+	clk_disable_unprepare(sdev->sec_hclk);
+
+	return 0;
+}
+
+static int jh7110_cryp_runtime_resume(struct device *dev)
+{
+	struct jh7110_sec_dev *sdev = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(sdev->sec_ahb);
+	if (ret) {
+		dev_err(sdev->dev, "Failed to prepare_enable sec_ahb clock\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(sdev->sec_hclk);
+	if (ret) {
+		dev_err(sdev->dev, "Failed to prepare_enable sec_hclk clock\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops jh7110_cryp_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(jh7110_cryp_runtime_suspend,
+			   jh7110_cryp_runtime_resume, NULL)
+};
+
+
+
+static struct platform_driver jh7110_cryp_driver = {
+	.probe  = jh7110_cryp_probe,
+	.remove = jh7110_cryp_remove,
+	.driver = {
+		.name           = DRIVER_NAME,
+		.pm		= &jh7110_cryp_pm_ops,
+		.of_match_table = jh7110_dt_ids,
+	},
+};
+
+module_platform_driver(jh7110_cryp_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Huan Feng <huan.feng@starfivetech.com>");
+MODULE_DESCRIPTION("Starfive JH7110 CRYP SHA and AES driver");
diff --git a/drivers/crypto/starfive/jh7110/jh7110-sha.c b/drivers/crypto/starfive/jh7110/jh7110-sha.c
new file mode 100644
index 000000000000..fc8269ce8845
--- /dev/null
+++ b/drivers/crypto/starfive/jh7110/jh7110-sha.c
@@ -0,0 +1,1260 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2021 StarFive, Inc <huan.feng@starfivetech.com>
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING
+ * CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER
+ * FOR THEM TO SAVE TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE
+ * FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+ * CLAIMS ARISING FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE
+ * BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION
+ * WITH THEIR PRODUCTS.
+ */
+#include <linux/clk.h>
+#include <linux/crypto.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/reset.h>
+#include <linux/amba/pl080.h>
+
+#include <linux/dma-direct.h>
+#include <crypto/hash.h>
+#include <crypto/sm3.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/internal/hash.h>
+
+#include "jh7110-str.h"
+
+#define HASH_OP_UPDATE			1
+#define HASH_OP_FINAL			2
+
+#define HASH_FLAGS_INIT			BIT(0)
+#define HASH_FLAGS_FINAL		BIT(1)
+#define HASH_FLAGS_FINUP		BIT(2)
+
+#define JH7110_MAX_ALIGN_SIZE	SHA512_BLOCK_SIZE
+
+#define JH7110_HASH_BUFLEN		8192
+#define JH7110_HASH_THRES		2048
+
+static inline int jh7110_hash_wait_hmac_done(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	u32 status;
+
+	return readl_relaxed_poll_timeout(sdev->io_base + JH7110_SHA_SHACSR, status,
+			(status & JH7110_SHA_HMAC_DONE), 10, 100000);
+}
+
+static inline int jh7110_hash_wait_busy(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	u32 status;
+
+	return readl_relaxed_poll_timeout(sdev->io_base + JH7110_SHA_SHACSR, status,
+			!(status & JH7110_SHA_BUSY), 10, 100000);
+}
+
+static inline int jh7110_hash_wait_key_done(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	u32 status;
+
+	return readl_relaxed_poll_timeout(sdev->io_base + JH7110_SHA_SHACSR, status,
+			(status & JH7110_SHA_KEY_DONE), 10, 100000);
+}
+
+static int jh7110_get_hash_size(struct jh7110_sec_ctx *ctx)
+{
+	unsigned int hashsize;
+
+	switch (ctx->sha_mode & JH7110_SHA_MODE_MASK) {
+	case JH7110_SHA_SHA1:
+		hashsize = SHA1_DIGEST_SIZE;
+		break;
+	case JH7110_SHA_SHA224:
+		hashsize = SHA224_DIGEST_SIZE;
+		break;
+	case JH7110_SHA_SHA256:
+		hashsize = SHA256_DIGEST_SIZE;
+		break;
+	case JH7110_SHA_SHA384:
+		hashsize = SHA384_DIGEST_SIZE;
+		break;
+	case JH7110_SHA_SHA512:
+		hashsize = SHA512_DIGEST_SIZE;
+		break;
+	case JH7110_SHA_SM3:
+		hashsize = SM3_DIGEST_SIZE;
+		break;
+	default:
+		return 0;
+	}
+	return hashsize;
+}
+
+static void jh7110_hash_start(struct jh7110_sec_ctx *ctx, int flags)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+
+	rctx->csr.sha_csr.v = jh7110_sec_read(sdev, JH7110_SHA_SHACSR);
+	rctx->csr.sha_csr.firstb = 0;
+
+	if (flags)
+		rctx->csr.sha_csr.final = 1;
+
+	jh7110_sec_write(sdev, JH7110_SHA_SHACSR, rctx->csr.sha_csr.v);
+}
+
+static int jh7110_sha_hmac_key(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	int klen = ctx->keylen, loop;
+	unsigned int *key = (unsigned int *)ctx->key;
+	unsigned char *cl;
+
+	jh7110_sec_write(sdev, JH7110_SHA_SHAWKLEN, ctx->keylen);
+
+	rctx->csr.sha_csr.hmac = !!(ctx->sha_mode & JH7110_SHA_HMAC_FLAGS);
+	rctx->csr.sha_csr.key_flag = 1;
+
+	jh7110_sec_write(sdev, JH7110_SHA_SHACSR, rctx->csr.sha_csr.v);
+
+	for (loop = 0; loop < klen / sizeof(unsigned int); loop++, key++)
+		jh7110_sec_write(sdev, JH7110_SHA_SHAWKR, *key);
+
+	if (klen & 0x3) {
+		cl = (unsigned char *)key;
+		for (loop = 0; loop < (klen & 0x3); loop++, cl++)
+			jh7110_sec_writeb(sdev, JH7110_SHA_SHAWKR, *cl);
+	}
+
+	if (jh7110_hash_wait_key_done(ctx)) {
+		dev_err(sdev->dev, " jh7110_hash_wait_key_done error\n");
+		return -ETIMEDOUT;
+	}
+	return 0;
+}
+
+static void jh7110_sha_dma_callback(void *param)
+{
+	struct jh7110_sec_dev *sdev = param;
+
+	complete(&sdev->sec_comp_m);
+}
+
+static int jh7110_hash_xmit_dma(struct jh7110_sec_ctx *ctx, int flags)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct dma_async_tx_descriptor	*in_desc;
+	dma_cookie_t cookie;
+	union  jh7110_alg_cr alg_cr;
+	int total_len;
+	int ret;
+
+	if (!rctx->bufcnt)
+		return 0;
+
+	ctx->sha_len_total += rctx->bufcnt;
+
+	total_len = rctx->bufcnt;
+
+	jh7110_sec_write(sdev, JH7110_DMA_IN_LEN_OFFSET, rctx->bufcnt);
+
+	total_len = (total_len & 0x3) ? (((total_len >> 2) + 1) << 2) : total_len;
+
+	memset(sdev->sha_data + rctx->bufcnt, 0, total_len - rctx->bufcnt);
+
+	alg_cr.v = 0;
+	alg_cr.start = 1;
+	alg_cr.sha_dma_en = 1;
+	jh7110_sec_write(sdev, JH7110_ALG_CR_OFFSET, alg_cr.v);
+
+	sg_init_table(&ctx->sg[0], 1);
+	sg_set_buf(&ctx->sg[0], sdev->sha_data, total_len);
+	sg_dma_address(&ctx->sg[0]) = phys_to_dma(sdev->dev, (unsigned long long)(sdev->sha_data));
+	sg_dma_len(&ctx->sg[0]) = total_len;
+
+	ret = dma_map_sg(sdev->dev, &ctx->sg[0], 1, DMA_TO_DEVICE);
+	if (!ret) {
+		dev_err(sdev->dev, "dma_map_sg() error\n");
+		return -EINVAL;
+	}
+
+	sdev->cfg_in.direction = DMA_MEM_TO_DEV;
+	sdev->cfg_in.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	sdev->cfg_in.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	sdev->cfg_in.src_maxburst = sdev->dma_maxburst;
+	sdev->cfg_in.dst_maxburst = sdev->dma_maxburst;
+	sdev->cfg_in.dst_addr = sdev->io_phys_base + JH7110_ALG_FIFO_OFFSET;
+
+	dmaengine_slave_config(sdev->sec_xm_m, &sdev->cfg_in);
+
+	in_desc = dmaengine_prep_slave_sg(sdev->sec_xm_m, &ctx->sg[0],
+				1, DMA_MEM_TO_DEV,
+				DMA_PREP_INTERRUPT  |  DMA_CTRL_ACK);
+	if (!in_desc)
+		return -EINVAL;
+
+	reinit_completion(&sdev->sec_comp_m);
+
+	in_desc->callback = jh7110_sha_dma_callback;
+	in_desc->callback_param = sdev;
+
+	cookie = dmaengine_submit(in_desc);
+	dma_async_issue_pending(sdev->sec_xm_m);
+
+	if (!wait_for_completion_timeout(&sdev->sec_comp_m,
+					msecs_to_jiffies(10000))) {
+		dev_dbg(sdev->dev, "this is debug for lophyel status = %x err = %x control0 = %x control1 = %x  %s %s %d\n",
+		       readl_relaxed(sdev->dma_base + PL080_TC_STATUS), readl_relaxed(sdev->dma_base + PL080_ERR_STATUS),
+		       readl_relaxed(sdev->dma_base + 0x10c), readl_relaxed(sdev->dma_base + 0x12c),
+		       __FILE__, __func__, __LINE__);
+		dev_err(sdev->dev, "wait_for_completion_timeout out error cookie = %x\n",
+			dma_async_is_tx_complete(sdev->sec_xm_p, cookie,
+				     NULL, NULL));
+	}
+
+	dma_unmap_sg(sdev->dev, &ctx->sg[0], 1, DMA_TO_DEVICE);
+
+	alg_cr.v = 0;
+	alg_cr.clear = 1;
+	jh7110_sec_write(sdev, JH7110_ALG_CR_OFFSET, alg_cr.v);
+
+	return 0;
+}
+
+static int jh7110_hash_xmit_cpu(struct jh7110_sec_ctx *ctx, int flags)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	int total_len, mlen, loop;
+	unsigned int  *buffer;
+	unsigned char *cl;
+
+	if (!rctx->bufcnt)
+		return 0;
+
+	ctx->sha_len_total += rctx->bufcnt;
+
+	total_len = rctx->bufcnt;
+	mlen = total_len / sizeof(u32);// DIV_ROUND_UP(total_len, sizeof(u32));
+	buffer = (unsigned int *)ctx->buffer;
+
+	for (loop = 0; loop < mlen; loop++, buffer++) {
+		jh7110_sec_write(sdev, JH7110_SHA_SHAWDR, *buffer);
+		udelay(2);
+	}
+
+	if (total_len & 0x3) {
+		cl = (unsigned char *)buffer;
+		for (loop = 0; loop < (total_len & 0x3); loop++, cl++) {
+			jh7110_sec_writeb(sdev, JH7110_SHA_SHAWDR, *cl);
+			udelay(2);
+		}
+	}
+
+	return 0;
+}
+
+static void jh7110_hash_append_sg(struct jh7110_sec_request_ctx *rctx)
+{
+	struct jh7110_sec_ctx *ctx = rctx->ctx;
+	size_t count;
+
+	while ((rctx->bufcnt < rctx->buflen) && rctx->total) {
+		count = min(rctx->in_sg->length - rctx->offset, rctx->total);
+		count = min(count, rctx->buflen - rctx->bufcnt);
+
+		if (count <= 0) {
+			if ((rctx->in_sg->length == 0) && !sg_is_last(rctx->in_sg)) {
+				rctx->in_sg = sg_next(rctx->in_sg);
+				continue;
+			} else {
+				break;
+			}
+		}
+
+		scatterwalk_map_and_copy(ctx->buffer + rctx->bufcnt, rctx->in_sg,
+					rctx->offset, count, 0);
+
+		rctx->bufcnt += count;
+		rctx->offset += count;
+		rctx->total -= count;
+
+		if (rctx->offset == rctx->in_sg->length) {
+			rctx->in_sg = sg_next(rctx->in_sg);
+			if (rctx->in_sg)
+				rctx->offset = 0;
+			else
+				rctx->total = 0;
+		}
+	}
+}
+
+static int jh7110_hash_xmit(struct jh7110_sec_ctx *ctx, int flags)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	int ret;
+
+	sdev->cry_type = JH7110_SHA_TYPE;
+
+	rctx->csr.sha_csr.v = 0;
+	rctx->csr.sha_csr.reset = 1;
+	jh7110_sec_write(sdev, JH7110_SHA_SHACSR, rctx->csr.sha_csr.v);
+
+	if (jh7110_hash_wait_busy(ctx)) {
+		dev_err(sdev->dev, "jh7110_hash_wait_busy error\n");
+		return -ETIMEDOUT;
+	}
+
+	rctx->csr.sha_csr.v = 0;
+	rctx->csr.sha_csr.mode = ctx->sha_mode & JH7110_SHA_MODE_MASK;
+
+	if (ctx->sha_mode & JH7110_SHA_HMAC_FLAGS)
+		ret = jh7110_sha_hmac_key(ctx);
+
+	if (ret)
+		return ret;
+
+	if (!rctx->csr.sha_csr.hmac) {
+		rctx->csr.sha_csr.start = 1;
+		rctx->csr.sha_csr.firstb = 1;
+		jh7110_sec_write(sdev, JH7110_SHA_SHACSR, rctx->csr.sha_csr.v);
+	}
+
+	if (ctx->sdev->use_dma) {
+		ret = jh7110_hash_xmit_dma(ctx, flags);
+		if (flags)
+			rctx->flags |= HASH_FLAGS_FINAL;
+	} else {
+		ret = jh7110_hash_xmit_cpu(ctx, flags);
+		if (flags)
+			rctx->flags |= HASH_FLAGS_FINAL;
+	}
+
+	if (ret)
+		return ret;
+
+	jh7110_hash_start(ctx, flags);
+
+	if (jh7110_hash_wait_busy(ctx)) {
+		dev_err(sdev->dev, "jh7110_hash_wait_busy error\n");
+		return -ETIMEDOUT;
+	}
+
+	if (ctx->sha_mode & JH7110_SHA_HMAC_FLAGS)
+		if (jh7110_hash_wait_hmac_done(ctx)) {
+			dev_err(sdev->dev, "jh7110_hash_wait_hmac_done error\n");
+			return -ETIMEDOUT;
+		}
+	return 0;
+}
+
+static int jh7110_hash_update_req(struct jh7110_sec_ctx *ctx)
+{
+	struct jh7110_sec_request_ctx *rctx = ctx->rctx;
+	int err = 0, final;
+
+	final = (rctx->flags & HASH_FLAGS_FINUP);
+
+	while ((rctx->total >= rctx->buflen) ||
+			(rctx->bufcnt + rctx->total >= rctx->buflen)) {
+		jh7110_hash_append_sg(rctx);
+		err = jh7110_hash_xmit(ctx, 0);
+		rctx->bufcnt = 0;
+	}
+
+	jh7110_hash_append_sg(rctx);
+
+	if (final) {
+		err = jh7110_hash_xmit(ctx,
+				(rctx->flags & HASH_FLAGS_FINUP));
+		rctx->bufcnt = 0;
+	}
+
+	return err;
+}
+
+static int jh7110_hash_final_req(struct jh7110_sec_ctx *ctx)
+{
+	struct ahash_request *req = ctx->rctx->req.hreq;
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+	int err = 0;
+
+	err = jh7110_hash_xmit(ctx, 1);
+	rctx->bufcnt = 0;
+
+	return err;
+}
+
+
+static int jh7110_hash_out_cpu(struct ahash_request *req)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct jh7110_sec_ctx *ctx = rctx->ctx;
+	int count, *data;
+	int mlen;
+
+	if (!req->result)
+		return 0;
+
+	mlen = jh7110_get_hash_size(ctx) / sizeof(u32);
+
+	data = (u32 *)req->result;
+	for (count = 0; count < mlen; count++)
+		data[count] = jh7110_sec_read(ctx->sdev, JH7110_SHA_SHARDR);
+
+	return 0;
+}
+
+static int jh7110_hash_copy_hash(struct ahash_request *req)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct jh7110_sec_ctx *ctx = rctx->ctx;
+	int hashsize;
+	int ret;
+
+	hashsize = jh7110_get_hash_size(ctx);
+
+	ret = jh7110_hash_out_cpu(req);
+
+	if (ret)
+		return ret;
+
+	memcpy(rctx->sha_digest_mid, req->result, hashsize);
+	rctx->sha_digest_len = hashsize;
+
+	return ret;
+}
+
+static void jh7110_hash_finish_req(struct ahash_request *req, int err)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct jh7110_sec_dev *sdev = rctx->sdev;
+
+	if (!err && (HASH_FLAGS_FINAL & rctx->flags)) {
+		err = jh7110_hash_copy_hash(req);
+		rctx->flags &= ~(HASH_FLAGS_FINAL |
+				 HASH_FLAGS_INIT);
+	}
+
+	crypto_finalize_hash_request(sdev->engine, req, err);
+}
+
+static int jh7110_hash_prepare_req(struct crypto_engine *engine, void *areq)
+{
+	struct ahash_request *req = container_of(areq, struct ahash_request,
+						 base);
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx;
+
+	if (!sdev)
+		return -ENODEV;
+
+	mutex_lock(&ctx->sdev->lock);
+
+	rctx = ahash_request_ctx(req);
+
+	rctx->req.hreq = req;
+
+	return 0;
+}
+
+static int jh7110_hash_one_request(struct crypto_engine *engine, void *areq)
+{
+	struct ahash_request *req = container_of(areq, struct ahash_request,
+						 base);
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(req));
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+	struct jh7110_sec_request_ctx *rctx;
+	int err = 0;
+
+	if (!sdev)
+		return -ENODEV;
+
+	rctx = ahash_request_ctx(req);
+
+	if (rctx->op == HASH_OP_UPDATE)
+		err = jh7110_hash_update_req(ctx);
+	else if (rctx->op == HASH_OP_FINAL)
+		err = jh7110_hash_final_req(ctx);
+
+	if (err != -EINPROGRESS)
+	/* done task will not finish it, so do it here */
+		jh7110_hash_finish_req(req, err);
+
+	mutex_unlock(&ctx->sdev->lock);
+
+	return 0;
+}
+
+static int jh7110_hash_handle_queue(struct jh7110_sec_dev *sdev,
+					struct ahash_request *req)
+{
+	return crypto_transfer_hash_request_to_engine(sdev->engine, req);
+}
+
+static int jh7110_hash_enqueue(struct ahash_request *req, unsigned int op)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct jh7110_sec_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+
+	rctx->op = op;
+
+	return jh7110_hash_handle_queue(sdev, req);
+}
+
+static int jh7110_hash_init(struct ahash_request *req)
+{
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct jh7110_sec_dev *sdev = ctx->sdev;
+
+	memset(rctx, 0, sizeof(struct jh7110_sec_request_ctx));
+
+	rctx->sdev = sdev;
+	rctx->ctx = ctx;
+	rctx->req.hreq = req;
+	rctx->bufcnt = 0;
+
+	rctx->total = 0;
+	rctx->offset = 0;
+	rctx->bufcnt = 0;
+	rctx->buflen = JH7110_HASH_BUFLEN;
+
+	memset(ctx->buffer, 0, JH7110_HASH_BUFLEN);
+
+	ctx->rctx = rctx;
+
+	dev_dbg(sdev->dev, "%s Flags %lx\n", __func__, rctx->flags);
+
+	return 0;
+}
+
+static int jh7110_hash_update(struct ahash_request *req)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	if (!req->nbytes)
+		return 0;
+
+	rctx->total = req->nbytes;
+	rctx->in_sg = req->src;
+	rctx->offset = 0;
+
+	if ((rctx->bufcnt + rctx->total < rctx->buflen)) {
+		jh7110_hash_append_sg(rctx);
+		return 0;
+	}
+
+	return jh7110_hash_enqueue(req, HASH_OP_UPDATE);
+}
+
+static int jh7110_hash_final(struct ahash_request *req)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+	struct jh7110_sec_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+
+	rctx->flags |= HASH_FLAGS_FINUP;
+
+	if (ctx->fallback_available && (rctx->bufcnt < JH7110_HASH_THRES)) {
+		if (ctx->sha_mode & JH7110_SHA_HMAC_FLAGS)
+			crypto_shash_setkey(ctx->fallback.shash, ctx->key,
+					ctx->keylen);
+
+		return crypto_shash_tfm_digest(ctx->fallback.shash, ctx->buffer,
+				rctx->bufcnt, req->result);
+	}
+
+	return jh7110_hash_enqueue(req, HASH_OP_FINAL);
+}
+
+static int jh7110_hash_finup(struct ahash_request *req)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+	int err1, err2;
+	int nents;
+
+	nents = sg_nents_for_len(req->src, req->nbytes);
+
+	rctx->flags |= HASH_FLAGS_FINUP;
+
+	err1 = jh7110_hash_update(req);
+
+	if (err1 == -EINPROGRESS || err1 == -EBUSY)
+		return err1;
+
+	/*
+	 * final() has to be always called to cleanup resources
+	 * even if update() failed, except EINPROGRESS
+	 */
+	err2 = jh7110_hash_final(req);
+
+	return err1 ?: err2;
+}
+
+static int jh7110_hash_digest(struct ahash_request *req)
+{
+	return jh7110_hash_init(req) ?: jh7110_hash_finup(req);
+}
+
+static int jh7110_hash_export(struct ahash_request *req, void *out)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	memcpy(out, rctx, sizeof(*rctx));
+
+	return 0;
+}
+
+static int jh7110_hash_import(struct ahash_request *req, const void *in)
+{
+	struct jh7110_sec_request_ctx *rctx = ahash_request_ctx(req);
+
+	memcpy(rctx, in, sizeof(*rctx));
+
+	return 0;
+}
+
+static int jh7110_hash_cra_init_algs(struct crypto_tfm *tfm,
+					const char *algs_hmac_name,
+					unsigned int mode)
+{
+	struct jh7110_sec_ctx *ctx = crypto_tfm_ctx(tfm);
+	const char *alg_name = crypto_tfm_alg_name(tfm);
+
+	ctx->sdev = jh7110_sec_find_dev(ctx);
+	ctx->fallback_available = true;
+
+	if (!ctx->sdev)
+		return -ENODEV;
+
+	ctx->fallback.shash = crypto_alloc_shash(alg_name, 0,
+			CRYPTO_ALG_NEED_FALLBACK);
+
+	if (IS_ERR(ctx->fallback.shash))
+		ctx->fallback_available = false;
+
+	crypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),
+			sizeof(struct jh7110_sec_request_ctx));
+
+	ctx->keylen   = 0;
+	ctx->sha_mode = mode;
+	ctx->sha_len_total = 0;
+	ctx->buffer = ctx->sdev->sha_data;
+
+	if (algs_hmac_name)
+		ctx->sha_mode |= JH7110_SHA_HMAC_FLAGS;
+
+	pm_runtime_resume_and_get(ctx->sdev->dev);
+
+	ctx->enginectx.op.do_one_request = jh7110_hash_one_request;
+	ctx->enginectx.op.prepare_request = jh7110_hash_prepare_req;
+	ctx->enginectx.op.unprepare_request = NULL;
+
+	return 0;
+}
+
+static void jh7110_hash_cra_exit(struct crypto_tfm *tfm)
+{
+	struct jh7110_sec_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	crypto_free_shash(ctx->fallback.shash);
+
+	pm_runtime_put_sync_suspend(ctx->sdev->dev);
+
+	ctx->fallback.shash = NULL;
+	ctx->enginectx.op.do_one_request = NULL;
+	ctx->enginectx.op.prepare_request = NULL;
+	ctx->enginectx.op.unprepare_request = NULL;
+}
+
+static int jh7110_hash_long_setkey(struct jh7110_sec_ctx *ctx,
+					const u8 *key, unsigned int keylen,
+					const char *alg_name)
+{
+	struct crypto_wait wait;
+	struct ahash_request *req;
+	struct scatterlist sg;
+	struct crypto_ahash *ahash_tfm;
+	u8 *buf;
+	int ret;
+
+	ahash_tfm = crypto_alloc_ahash(alg_name, 0, 0);
+	if (IS_ERR(ahash_tfm))
+		return PTR_ERR(ahash_tfm);
+
+	req = ahash_request_alloc(ahash_tfm, GFP_KERNEL);
+	if (!req) {
+		ret = -ENOMEM;
+		goto err_free_ahash;
+	}
+
+	crypto_init_wait(&wait);
+	ahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,
+				   crypto_req_done, &wait);
+	crypto_ahash_clear_flags(ahash_tfm, ~0);
+
+	buf = kzalloc(keylen + JH7110_MAX_ALIGN_SIZE, GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto err_free_req;
+	}
+
+	memcpy(buf, key, keylen);
+	sg_init_one(&sg, buf, keylen);
+	ahash_request_set_crypt(req, &sg, ctx->key, keylen);
+
+	ret = crypto_wait_req(crypto_ahash_digest(req), &wait);
+
+err_free_req:
+	ahash_request_free(req);
+err_free_ahash:
+	crypto_free_ahash(ahash_tfm);
+	return ret;
+}
+
+static int jh7110_hash1_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	unsigned int digestsize = crypto_ahash_digestsize(tfm);
+	unsigned int blocksize;
+	int ret = 0;
+
+	blocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));
+	if (keylen <= blocksize) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		ctx->keylen = digestsize;
+		ret = jh7110_hash_long_setkey(ctx, key, keylen, "jh7110-sha1");
+	}
+
+	return ret;
+}
+
+static int jh7110_hash224_setkey(struct crypto_ahash *tfm,
+				const u8 *key, unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	unsigned int digestsize = crypto_ahash_digestsize(tfm);
+	unsigned int blocksize;
+	int ret = 0;
+
+	blocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));
+
+	if (keylen <= blocksize) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		ctx->keylen = digestsize;
+		ret = jh7110_hash_long_setkey(ctx, key, keylen, "jh7110-sha224");
+	}
+
+	return ret;
+}
+
+static int jh7110_hash256_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	unsigned int digestsize = crypto_ahash_digestsize(tfm);
+	unsigned int blocksize;
+	int ret = 0;
+
+	blocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));
+
+	if (keylen <= blocksize) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		ctx->keylen = digestsize;
+		ret = jh7110_hash_long_setkey(ctx, key, keylen, "jh7110-sha256");
+	}
+
+	return ret;
+}
+
+static int jh7110_hash384_setkey(struct crypto_ahash *tfm,
+				const u8 *key, unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	unsigned int digestsize = crypto_ahash_digestsize(tfm);
+	unsigned int blocksize;
+	int ret = 0;
+
+	blocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));
+
+	if (keylen <= blocksize) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		ctx->keylen = digestsize;
+		ret = jh7110_hash_long_setkey(ctx, key, keylen, "jh7110-sha384");
+	}
+
+	return ret;
+}
+
+static int jh7110_hash512_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	unsigned int digestsize = crypto_ahash_digestsize(tfm);
+	unsigned int blocksize;
+	int ret = 0;
+
+	blocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));
+
+	if (keylen <= blocksize) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		ctx->keylen = digestsize;
+		ret = jh7110_hash_long_setkey(ctx, key, keylen, "jh7110-sha512");
+	}
+
+	return ret;
+}
+
+static int jh7110_sm3_setkey(struct crypto_ahash *tfm,
+			     const u8 *key, unsigned int keylen)
+{
+	struct jh7110_sec_ctx *ctx = crypto_ahash_ctx(tfm);
+	unsigned int digestsize = crypto_ahash_digestsize(tfm);
+	unsigned int blocksize;
+	int ret = 0;
+
+	blocksize = crypto_tfm_alg_blocksize(crypto_ahash_tfm(tfm));
+
+	if (keylen <= blocksize) {
+		memcpy(ctx->key, key, keylen);
+		ctx->keylen = keylen;
+	} else {
+		ctx->keylen = digestsize;
+		ret = jh7110_hash_long_setkey(ctx, key, keylen, "jh7110-sm3");
+	}
+
+	return ret;
+}
+
+static int jh7110_hash_cra_sha1_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, NULL, JH7110_SHA_SHA1);
+}
+
+static int jh7110_hash_cra_sha224_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, NULL, JH7110_SHA_SHA224);
+}
+
+static int jh7110_hash_cra_sha256_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, NULL, JH7110_SHA_SHA256);
+}
+
+static int jh7110_hash_cra_sha384_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, NULL, JH7110_SHA_SHA384);
+}
+
+static int jh7110_hash_cra_sha512_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, NULL, JH7110_SHA_SHA512);
+}
+
+static int jh7110_hash_cra_sm3_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, NULL, JH7110_SHA_SM3);
+}
+
+static int jh7110_hash_cra_hmac_sha1_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, "sha1", JH7110_SHA_SHA1);
+}
+
+static int jh7110_hash_cra_hmac_sha224_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, "sha224", JH7110_SHA_SHA224);
+}
+
+static int jh7110_hash_cra_hmac_sha256_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, "sha256", JH7110_SHA_SHA256);
+}
+
+static int jh7110_hash_cra_hmac_sha384_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, "sha384", JH7110_SHA_SHA384);
+}
+
+static int jh7110_hash_cra_hmac_sha512_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, "sha512", JH7110_SHA_SHA512);
+}
+
+static int jh7110_hash_cra_hmac_sm3_init(struct crypto_tfm *tfm)
+{
+	return jh7110_hash_cra_init_algs(tfm, "sm3", JH7110_SHA_SM3);
+}
+
+static struct ahash_alg algs_sha0_sha512_sm3[] = {
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.halg = {
+		.digestsize = SHA1_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "sha1",
+			.cra_driver_name	= "jh7110-sha1",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SHA1_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_sha1_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.setkey   = jh7110_hash1_setkey,
+	.halg = {
+		.digestsize = SHA1_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "hmac(sha1)",
+			.cra_driver_name	= "jh7110-hmac-sha1",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SHA1_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_hmac_sha1_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.halg = {
+		.digestsize = SHA224_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "sha224",
+			.cra_driver_name	= "jh7110-sha224",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SHA224_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_sha224_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.setkey   = jh7110_hash224_setkey,
+	.halg = {
+		.digestsize = SHA224_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "hmac(sha224)",
+			.cra_driver_name	= "jh7110-hmac-sha224",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SHA224_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_hmac_sha224_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.halg = {
+		.digestsize = SHA256_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "sha256",
+			.cra_driver_name	= "jh7110-sha256",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SHA256_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_sha256_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.setkey   = jh7110_hash256_setkey,
+	.halg = {
+		.digestsize = SHA256_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "hmac(sha256)",
+			.cra_driver_name	= "jh7110-hmac-sha256",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SHA256_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_hmac_sha256_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.halg = {
+		.digestsize = SHA384_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "sha384",
+			.cra_driver_name	= "jh7110-sha384",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SHA384_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_sha384_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+		.init     = jh7110_hash_init,
+		.update   = jh7110_hash_update,
+		.final    = jh7110_hash_final,
+		.finup    = jh7110_hash_finup,
+		.digest   = jh7110_hash_digest,
+		.setkey   = jh7110_hash384_setkey,
+		.export   = jh7110_hash_export,
+		.import   = jh7110_hash_import,
+		.halg = {
+			.digestsize = SHA384_DIGEST_SIZE,
+			.statesize  = sizeof(struct jh7110_sec_request_ctx),
+			.base = {
+				.cra_name			= "hmac(sha384)",
+				.cra_driver_name	= "jh7110-hmac-sha384",
+				.cra_priority		= 200,
+				.cra_flags		= CRYPTO_ALG_ASYNC |
+							  CRYPTO_ALG_TYPE_AHASH |
+							  CRYPTO_ALG_NEED_FALLBACK,
+				.cra_blocksize		= SHA384_BLOCK_SIZE,
+				.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+				.cra_alignmask		= 3,
+				.cra_init		= jh7110_hash_cra_hmac_sha384_init,
+				.cra_exit		= jh7110_hash_cra_exit,
+				.cra_module		= THIS_MODULE,
+			}
+		}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.halg = {
+		.digestsize = SHA512_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name			= "sha512",
+			.cra_driver_name	= "jh7110-sha512",
+			.cra_priority		= 200,
+			.cra_flags			= CRYPTO_ALG_ASYNC |
+				CRYPTO_ALG_TYPE_AHASH,
+			.cra_blocksize		= SHA512_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init			= jh7110_hash_cra_sha512_init,
+			.cra_exit			= jh7110_hash_cra_exit,
+			.cra_module			= THIS_MODULE,
+		}
+	}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.setkey   = jh7110_hash512_setkey,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.halg = {
+		.digestsize = SHA512_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "hmac(sha512)",
+			.cra_driver_name	= "jh7110-hmac-sha512",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SHA512_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_hmac_sha512_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+	.init     = jh7110_hash_init,
+	.update   = jh7110_hash_update,
+	.final    = jh7110_hash_final,
+	.finup    = jh7110_hash_finup,
+	.digest   = jh7110_hash_digest,
+	.export   = jh7110_hash_export,
+	.import   = jh7110_hash_import,
+	.halg = {
+		.digestsize = SM3_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "sm3",
+			.cra_driver_name	= "jh7110-sm3",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SM3_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_sm3_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+{
+	.init		= jh7110_hash_init,
+	.update		= jh7110_hash_update,
+	.final		= jh7110_hash_final,
+	.finup		= jh7110_hash_finup,
+	.digest		= jh7110_hash_digest,
+	.setkey		= jh7110_sm3_setkey,
+	.export		= jh7110_hash_export,
+	.import		= jh7110_hash_import,
+	.halg = {
+		.digestsize = SM3_DIGEST_SIZE,
+		.statesize  = sizeof(struct jh7110_sec_request_ctx),
+		.base = {
+			.cra_name		= "hmac(sm3)",
+			.cra_driver_name	= "jh7110-hmac-sm3",
+			.cra_priority		= 200,
+			.cra_flags		= CRYPTO_ALG_ASYNC |
+						  CRYPTO_ALG_TYPE_AHASH |
+						  CRYPTO_ALG_NEED_FALLBACK,
+			.cra_blocksize		= SM3_BLOCK_SIZE,
+			.cra_ctxsize		= sizeof(struct jh7110_sec_ctx),
+			.cra_alignmask		= 3,
+			.cra_init		= jh7110_hash_cra_hmac_sm3_init,
+			.cra_exit		= jh7110_hash_cra_exit,
+			.cra_module		= THIS_MODULE,
+		}
+	}
+},
+};
+
+int jh7110_hash_register_algs(void)
+{
+	int ret = 0;
+
+	ret = crypto_register_ahashes(algs_sha0_sha512_sm3, ARRAY_SIZE(algs_sha0_sha512_sm3));
+
+	return ret;
+}
+
+void jh7110_hash_unregister_algs(void)
+{
+	crypto_unregister_ahashes(algs_sha0_sha512_sm3, ARRAY_SIZE(algs_sha0_sha512_sm3));
+}
diff --git a/drivers/crypto/starfive/jh7110/jh7110-str.h b/drivers/crypto/starfive/jh7110/jh7110-str.h
new file mode 100644
index 000000000000..9113805cd83e
--- /dev/null
+++ b/drivers/crypto/starfive/jh7110/jh7110-str.h
@@ -0,0 +1,276 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright 2021 StarFive, Inc <huan.feng@starfivetech.com>
+ */
+#ifndef __JH7110_STR_H__
+#define __JH7110_STR_H__
+
+#include <crypto/internal/akcipher.h>
+#include <crypto/internal/rsa.h>
+#include <crypto/engine.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/delay.h>
+
+#include "jh7110-regs.h"
+
+#define JH7110_MSG_BUFFER_SIZE			(16 * 1024)
+#define MAX_KEY_SIZE				SHA512_BLOCK_SIZE
+
+#define JH7110_AES_IV_LEN			AES_BLOCK_SIZE
+#define JH7110_AES_CTR_LEN			AES_BLOCK_SIZE
+
+struct jh7110_rsa_key {
+	u8					*n;
+	u8					*e;
+	u8					*d;
+	u8					*p;
+	u8					*q;
+	u8					*dp;
+	u8					*dq;
+	u8					*qinv;
+	u8					*rinv;
+	u8					*rinv_p;
+	u8					*rinv_q;
+	u8					*mp;
+	u8					*rsqr;
+	u8					*rsqr_p;
+	u8					*rsqr_q;
+	u8					*pmp;
+	u8					*qmp;
+	int					e_bitlen;
+	int					d_bitlen;
+	int					bitlen;
+	size_t					key_sz;
+	bool					crt_mode;
+};
+
+struct jh7110_sec_ctx {
+	struct crypto_engine_ctx		enginectx;
+
+	struct jh7110_sec_request_ctx		*rctx;
+	struct jh7110_sec_dev			*sdev;
+
+	unsigned int				sha_mode;
+
+	u8					key[MAX_KEY_SIZE];
+	int					keylen;
+	int					sec_init;
+	struct scatterlist			sg[2];
+	struct jh7110_rsa_key			rsa_key;
+	size_t					sha_len_total;
+	u8					*buffer;
+	union {
+		struct crypto_akcipher			*akcipher;
+		struct crypto_aead			*aead;
+		struct crypto_shash			*shash;
+	} fallback;
+	bool					fallback_available;
+};
+
+struct jh7110_sec_dev {
+	struct list_head			list;
+	struct device				*dev;
+
+	struct clk				*sec_hclk;
+	struct clk				*sec_ahb;
+	struct reset_control			*rst_hresetn;
+
+	struct jh7110_pl08x_device		*pl080;
+
+	void __iomem				*io_base;
+	void __iomem				*dma_base;
+	phys_addr_t				io_phys_base;
+	void					*sha_data;
+	void					*aes_data;
+	void					*pka_data;
+	unsigned int				secirq;
+	unsigned int				irq;
+
+	size_t					data_buf_len;
+	int					pages_count;
+	u32					use_side_channel_mitigation;
+	u32					use_dma;
+	u32					dma_maxburst;
+	struct dma_chan				*sec_xm_m;
+	struct dma_chan				*sec_xm_p;
+	struct dma_slave_config			cfg_in;
+	struct dma_slave_config			cfg_out;
+	struct completion			sec_comp_m;
+	struct completion			sec_comp_p;
+	struct scatterlist			in_sg;
+	struct scatterlist			out_sg;
+	unsigned long				in_sg_len;
+	unsigned long				out_sg_len;
+
+	struct mutex				doing;
+	struct mutex				pl080_doing;
+	struct mutex				lock; /* protects req / areq */
+	struct mutex				sha_lock;
+	struct mutex				aes_lock;
+	struct mutex				rsa_lock;
+	struct completion			rsa_comp;
+
+#define JH7110_SHA_SHA_DONE			BIT(2)
+#define JH7110_AES_DONE				BIT(3)
+#define JH7110_PKA_DONE				BIT(5)
+	u32					done_flags;
+#define JH7110_SHA_TYPE				0x1
+#define JH7110_AES_TYPE				0x2
+#define JH7110_PKA_TYPE				0x4
+	u32					cry_type;
+
+	struct crypto_engine			*engine;
+
+	union jh7110_alg_cr			alg_cr;
+	union jh7110_ie_mask			ie_mask;
+	union jh7110_ie_flag			ie_flag;
+};
+
+struct jh7110_sec_request_ctx {
+	struct jh7110_sec_ctx			*ctx;
+	struct jh7110_sec_dev			*sdev;
+
+	union {
+		struct ahash_request		*hreq;
+		struct skcipher_request		*sreq;
+		struct aead_request		*areq;
+	} req;
+#define JH7110_AHASH_REQ			0
+#define JH7110_ABLK_REQ				1
+#define JH7110_AEAD_REQ				2
+	unsigned int				req_type;
+
+	union {
+		union jh7110_crypto_cacr	pka_csr;
+		union jh7110_aes_csr		aes_csr;
+		union jh7110_sha_shacsr		sha_csr;
+	} csr;
+
+	struct scatterlist			*sg;
+	struct scatterlist			*in_sg;
+	struct scatterlist			*out_sg;
+	struct scatterlist			*out_sg_save;
+	struct scatterlist			in_sgl;
+	struct scatterlist			out_sgl;
+	bool					sgs_copied;
+
+	unsigned long				sg_len;
+	unsigned long				in_sg_len;
+	unsigned long				out_sg_len;
+
+	unsigned long				flags;
+	unsigned long				op;
+	unsigned long				stmode;
+	unsigned long long			jiffies_hw;
+	unsigned long long			jiffies_cp;
+
+	size_t					bufcnt;
+	size_t					buflen;
+	size_t					total;
+	size_t					offset;
+	size_t					data_offset;
+	size_t					authsize;
+	size_t					hw_blocksize;
+	size_t					total_in;
+	size_t					total_in_save;
+	size_t					total_out;
+	size_t					total_out_save;
+	size_t					assoclen;
+	size_t					ctr_over_count;
+
+	u32					last_ctr[4];
+	u32                                     aes_iv[4];
+	u32					tag_out[4];
+	u32					tag_in[4];
+	u8					sha_digest_mid[SHA512_DIGEST_SIZE]__aligned(sizeof(u32));
+	unsigned int				sha_digest_len;
+};
+
+struct jh7110_sec_dma {
+	struct dma_slave_config			cfg;
+	union  jh7110_alg_cr			alg_cr;
+	struct dma_chan				*chan;
+	struct completion			*dma_comp;
+	struct scatterlist			*sg;
+	struct jh7110_sec_ctx			*ctx;
+	void					*data;
+	size_t					total;
+};
+
+static inline u64 jh7110_sec_readq(struct jh7110_sec_dev *sdev, u32 offset)
+{
+#ifdef CONFIG_64BIT
+	return __raw_readq(sdev->io_base + offset);
+#else
+	return ((u64)__raw_readl(sdev->io_base + offset) << 32) | (u64)__raw_readl(sdev->io_base + offset + 4);
+#endif
+}
+
+static inline u32 jh7110_sec_read(struct jh7110_sec_dev *sdev, u32 offset)
+{
+	return __raw_readl(sdev->io_base + offset);
+}
+
+static inline u16 jh7110_sec_readw(struct jh7110_sec_dev *sdev, u32 offset)
+{
+	return __raw_readw(sdev->io_base + offset);
+}
+
+static inline u8 jh7110_sec_readb(struct jh7110_sec_dev *sdev, u32 offset)
+{
+	return __raw_readb(sdev->io_base + offset);
+}
+
+static inline void jh7110_sec_writeq(struct jh7110_sec_dev *sdev,
+					u32 offset, u64 value)
+{
+#ifdef CONFIG_64BIT
+	__raw_writeq(value, sdev->io_base + offset);
+#else
+	__raw_writel((value >> 32), sdev->io_base + offset);
+	__raw_writel(value & 0xffffffff, sdev->io_base + offset + 4);
+#endif
+}
+
+static inline void jh7110_sec_write(struct jh7110_sec_dev *sdev,
+					u32 offset, u32 value)
+{
+	__raw_writel(value, sdev->io_base + offset);
+}
+
+static inline void jh7110_sec_writew(struct jh7110_sec_dev *sdev,
+					u32 offset, u16 value)
+{
+	__raw_writew(value, sdev->io_base + offset);
+}
+
+static inline void jh7110_sec_writeb(struct jh7110_sec_dev *sdev,
+					u32 offset, u8 value)
+{
+	__raw_writeb(value, sdev->io_base + offset);
+}
+
+extern struct jh7110_sec_dev *jh7110_sec_find_dev(struct jh7110_sec_ctx *ctx);
+
+extern int jh7110_hash_register_algs(void);
+extern void jh7110_hash_unregister_algs(void);
+
+extern int jh7110_aes_register_algs(void);
+extern void jh7110_aes_unregister_algs(void);
+
+extern int jh7110_pka_register_algs(void);
+extern void jh7110_pka_unregister_algs(void);
+
+extern int jh7110_dma_sg_to_device(struct jh7110_sec_dma *sdma);
+extern int jh7110_dma_mem_to_device(struct jh7110_sec_dma *sdma);
+extern int jh7110_dma_sg_from_device(struct jh7110_sec_dma *sdma);
+extern int jh7110_dma_mem_from_device(struct jh7110_sec_dma *sdma);
+extern int jh7110_mem_to_mem_test(struct jh7110_sec_ctx *ctx);
+
+extern int jh7110_dmac_init(struct jh7110_sec_dev *sdev, int irq);
+extern int jh7110_dmac_secdata_out(struct jh7110_sec_dev *sdev, u8 chan, u32 src, u32 dst, u32 size);
+extern int jh7110_dmac_secdata_in(struct jh7110_sec_dev *sdev, u8 chan, u32 src, u32 dst, u32 size);
+extern int jh7110_dmac_wait_done(struct jh7110_sec_dev *sdev, u8 chan);
+
+#endif
diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
index 14c1ac26f866..6e0e54fcd531 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
@@ -27,6 +27,8 @@
 #include "../dmaengine.h"
 #include "../virt-dma.h"
 
+#include <soc/starfive/jh7110.h>
+
 /*
  * The set of bus widths supported by the DMA controller. DW AXI DMAC supports
  * master data bus width up to 512 bits (for both AXI master interfaces), but
@@ -732,6 +734,17 @@ static int axi_dma_resume(struct axi_dma_chip *chip)
 	return 0;
 }
 
+void axi_dma_cyclic_stop(struct dma_chan *dchan)
+{
+	struct axi_dma_chan *chan = dchan_to_axi_dma_chan(dchan);
+	unsigned long flags;
+
+	spin_lock_irqsave(&chan->vc.lock, flags);
+	axi_chan_disable(chan);
+	spin_unlock_irqrestore(&chan->vc.lock, flags);
+
+}
+EXPORT_SYMBOL(axi_dma_cyclic_stop);
 static int __maybe_unused axi_dma_runtime_suspend(struct device *dev)
 {
 	struct axi_dma_chip *chip = dev_get_drvdata(dev);
@@ -983,6 +996,7 @@ static const struct dev_pm_ops dw_axi_dma_pm_ops = {
 
 static const struct of_device_id dw_dma_of_id_table[] = {
 	{ .compatible = "snps,axi-dma-1.01a" },
+	{ .compatible = "starfive,jh7110-dma" },
 	{}
 };
 MODULE_DEVICE_TABLE(of, dw_dma_of_id_table);
diff --git a/drivers/dma/jh7110-pl08x.c b/drivers/dma/jh7110-pl08x.c
new file mode 100755
index 000000000000..76df9cf7b59b
--- /dev/null
+++ b/drivers/dma/jh7110-pl08x.c
@@ -0,0 +1,3200 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2006 ARM Ltd.
+ * Copyright (c) 2010 ST-Ericsson SA
+ * Copyirght (c) 2017 Linaro Ltd.
+ *
+ * Author: Peter Pearse <peter.pearse@arm.com>
+ * Author: Linus Walleij <linus.walleij@linaro.org>
+ *
+ * Documentation: ARM DDI 0196G == PL080
+ * Documentation: ARM DDI 0218E == PL081
+ * Documentation: S3C6410 User's Manual == PL080S
+ *
+ * PL080 & PL081 both have 16 sets of DMA signals that can be routed to any
+ * channel.
+ *
+ * The PL080 has 8 channels available for simultaneous use, and the PL081
+ * has only two channels. So on these DMA controllers the number of channels
+ * and the number of incoming DMA signals are two totally different things.
+ * It is usually not possible to theoretically handle all physical signals,
+ * so a multiplexing scheme with possible denial of use is necessary.
+ *
+ * The PL080 has a dual bus master, PL081 has a single master.
+ *
+ * PL080S is a version modified by Samsung and used in S3C64xx SoCs.
+ * It differs in following aspects:
+ * - CH_CONFIG register at different offset,
+ * - separate CH_CONTROL2 register for transfer size,
+ * - bigger maximum transfer size,
+ * - 8-word aligned LLI, instead of 4-word, due to extra CCTL2 word,
+ * - no support for peripheral flow control.
+ *
+ * Memory to peripheral transfer may be visualized as
+ *	Get data from memory to DMAC
+ *	Until no data left
+ *		On burst request from peripheral
+ *			Destination burst from DMAC to peripheral
+ *			Clear burst request
+ *	Raise terminal count interrupt
+ *
+ * For peripherals with a FIFO:
+ * Source      burst size == half the depth of the peripheral FIFO
+ * Destination burst size == the depth of the peripheral FIFO
+ *
+ * (Bursts are irrelevant for mem to mem transfers - there are no burst
+ * signals, the DMA controller will simply facilitate its AHB master.)
+ *
+ * ASSUMES default (little) endianness for DMA transfers
+ *
+ * The PL08x has two flow control settings:
+ *  - DMAC flow control: the transfer size defines the number of transfers
+ *    which occur for the current LLI entry, and the DMAC raises TC at the
+ *    end of every LLI entry.  Observed behaviour shows the DMAC listening
+ *    to both the BREQ and SREQ signals (contrary to documented),
+ *    transferring data if either is active.  The LBREQ and LSREQ signals
+ *    are ignored.
+ *
+ *  - Peripheral flow control: the transfer size is ignored (and should be
+ *    zero).  The data is transferred from the current LLI entry, until
+ *    after the final transfer signalled by LBREQ or LSREQ.  The DMAC
+ *    will then move to the next LLI entry. Unsupported by PL080S.
+ */
+//#include <linux/amba/bus.h>
+#include <linux/amba/pl08x.h>
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dmaengine.h>
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_dma.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/amba/pl080.h>
+
+#include "dmaengine.h"
+#include "virt-dma.h"
+
+#define DRIVER_NAME	"pl08xdmac"
+
+#define PL80X_DMA_BUSWIDTHS \
+	BIT(DMA_SLAVE_BUSWIDTH_UNDEFINED) | \
+	BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) | \
+	BIT(DMA_SLAVE_BUSWIDTH_2_BYTES) | \
+	BIT(DMA_SLAVE_BUSWIDTH_4_BYTES)
+
+//static struct amba_driver pl08x_amba_driver;
+struct pl08x_driver_data;
+
+/**
+ * struct vendor_data - vendor-specific config parameters for PL08x derivatives
+ * @config_offset: offset to the configuration register
+ * @channels: the number of channels available in this variant
+ * @signals: the number of request signals available from the hardware
+ * @dualmaster: whether this version supports dual AHB masters or not.
+ * @nomadik: whether this variant is a ST Microelectronics Nomadik, where the
+ *	channels have Nomadik security extension bits that need to be checked
+ *	for permission before use and some registers are missing
+ * @pl080s: whether this variant is a Samsung PL080S, which has separate
+ *	register and LLI word for transfer size.
+ * @ftdmac020: whether this variant is a Faraday Technology FTDMAC020
+ * @max_transfer_size: the maximum single element transfer size for this
+ *	PL08x variant.
+ */
+struct vendor_data {
+	u8 config_offset;
+	u8 channels;
+	u8 signals;
+	bool dualmaster;
+	bool nomadik;
+	bool pl080s;
+	bool ftdmac020;
+	u32 max_transfer_size;
+};
+
+/**
+ * struct pl08x_bus_data - information of source or destination
+ * busses for a transfer
+ * @addr: current address
+ * @maxwidth: the maximum width of a transfer on this bus
+ * @buswidth: the width of this bus in bytes: 1, 2 or 4
+ */
+struct pl08x_bus_data {
+	dma_addr_t addr;
+	u8 maxwidth;
+	u8 buswidth;
+};
+
+#define IS_BUS_ALIGNED(bus) IS_ALIGNED((bus)->addr, (bus)->buswidth)
+
+/**
+ * struct pl08x_phy_chan - holder for the physical channels
+ * @id: physical index to this channel
+ * @base: memory base address for this physical channel
+ * @reg_config: configuration address for this physical channel
+ * @reg_control: control address for this physical channel
+ * @reg_src: transfer source address register
+ * @reg_dst: transfer destination address register
+ * @reg_lli: transfer LLI address register
+ * @reg_busy: if the variant has a special per-channel busy register,
+ * this contains a pointer to it
+ * @lock: a lock to use when altering an instance of this struct
+ * @serving: the virtual channel currently being served by this physical
+ * channel
+ * @locked: channel unavailable for the system, e.g. dedicated to secure
+ * world
+ * @ftdmac020: channel is on a FTDMAC020
+ * @pl080s: channel is on a PL08s
+ */
+struct pl08x_phy_chan {
+	unsigned int id;
+	void __iomem *base;
+	void __iomem *reg_config;
+	void __iomem *reg_control;
+	void __iomem *reg_src;
+	void __iomem *reg_dst;
+	void __iomem *reg_lli;
+	void __iomem *reg_busy;
+	spinlock_t lock;
+	struct pl08x_dma_chan *serving;
+	bool locked;
+	bool ftdmac020;
+	bool pl080s;
+};
+
+/**
+ * struct pl08x_sg - structure containing data per sg
+ * @src_addr: src address of sg
+ * @dst_addr: dst address of sg
+ * @len: transfer len in bytes
+ * @node: node for txd's dsg_list
+ */
+struct pl08x_sg {
+	dma_addr_t src_addr;
+	dma_addr_t dst_addr;
+	size_t len;
+	struct list_head node;
+};
+
+/**
+ * struct pl08x_txd - wrapper for struct dma_async_tx_descriptor
+ * @vd: virtual DMA descriptor
+ * @dsg_list: list of children sg's
+ * @llis_bus: DMA memory address (physical) start for the LLIs
+ * @llis_va: virtual memory address start for the LLIs
+ * @cctl: control reg values for current txd
+ * @ccfg: config reg values for current txd
+ * @done: this marks completed descriptors, which should not have their
+ *   mux released.
+ * @cyclic: indicate cyclic transfers
+ */
+struct pl08x_txd {
+	struct virt_dma_desc vd;
+	struct list_head dsg_list;
+	dma_addr_t llis_bus;
+	u32 *llis_va;
+	/* Default cctl value for LLIs */
+	u32 cctl;
+	/*
+	 * Settings to be put into the physical channel when we
+	 * trigger this txd.  Other registers are in llis_va[0].
+	 */
+	u32 ccfg;
+	bool done;
+	bool cyclic;
+};
+
+/**
+ * enum pl08x_dma_chan_state - holds the PL08x specific virtual channel
+ * states
+ * @PL08X_CHAN_IDLE: the channel is idle
+ * @PL08X_CHAN_RUNNING: the channel has allocated a physical transport
+ * channel and is running a transfer on it
+ * @PL08X_CHAN_PAUSED: the channel has allocated a physical transport
+ * channel, but the transfer is currently paused
+ * @PL08X_CHAN_WAITING: the channel is waiting for a physical transport
+ * channel to become available (only pertains to memcpy channels)
+ */
+enum pl08x_dma_chan_state {
+	PL08X_CHAN_IDLE,
+	PL08X_CHAN_RUNNING,
+	PL08X_CHAN_PAUSED,
+	PL08X_CHAN_WAITING,
+};
+
+/**
+ * struct pl08x_dma_chan - this structure wraps a DMA ENGINE channel
+ * @vc: wrappped virtual channel
+ * @phychan: the physical channel utilized by this channel, if there is one
+ * @name: name of channel
+ * @cd: channel platform data
+ * @cfg: slave configuration
+ * @at: active transaction on this channel
+ * @host: a pointer to the host (internal use)
+ * @state: whether the channel is idle, paused, running etc
+ * @slave: whether this channel is a device (slave) or for memcpy
+ * @signal: the physical DMA request signal which this channel is using
+ * @mux_use: count of descriptors using this DMA request signal setting
+ * @waiting_at: time in jiffies when this channel moved to waiting state
+ */
+struct pl08x_dma_chan {
+	struct virt_dma_chan vc;
+	struct pl08x_phy_chan *phychan;
+	const char *name;
+	struct pl08x_channel_data *cd;
+	struct dma_slave_config cfg;
+	struct pl08x_txd *at;
+	struct pl08x_driver_data *host;
+	enum pl08x_dma_chan_state state;
+	int chan_id;
+	bool slave;
+	int signal;
+	unsigned mux_use;
+	unsigned long waiting_at;
+};
+
+/**
+ * struct pl08x_driver_data - the local state holder for the PL08x
+ * @slave: optional slave engine for this instance
+ * @memcpy: memcpy engine for this instance
+ * @has_slave: the PL08x has a slave engine (routed signals)
+ * @base: virtual memory base (remapped) for the PL08x
+ * @adev: the corresponding AMBA (PrimeCell) bus entry
+ * @vd: vendor data for this PL08x variant
+ * @pd: platform data passed in from the platform/machine
+ * @phy_chans: array of data for the physical channels
+ * @pool: a pool for the LLI descriptors
+ * @lli_buses: bitmask to or in to LLI pointer selecting AHB port for LLI
+ * fetches
+ * @mem_buses: set to indicate memory transfers on AHB2.
+ * @lli_words: how many words are used in each LLI item for this variant
+ */
+struct pl08x_driver_data {
+	struct dma_device slave;
+	struct dma_device memcpy;
+	bool has_slave;
+	void __iomem *base;
+	struct platform_device *adev;
+	const struct vendor_data *vd;
+	struct pl08x_platform_data *pd;
+	struct pl08x_phy_chan *phy_chans;
+	struct dma_pool *pool;
+	u8 lli_buses;
+	u8 mem_buses;
+	u8 lli_words;
+};
+
+/*
+ * PL08X specific defines
+ */
+
+/* The order of words in an LLI. */
+#define PL080_LLI_SRC		0
+#define PL080_LLI_DST		1
+#define PL080_LLI_LLI		2
+#define PL080_LLI_CCTL		3
+#define PL080S_LLI_CCTL2	4
+
+/* Total words in an LLI. */
+#define PL080_LLI_WORDS		4
+#define PL080S_LLI_WORDS	8
+
+/*
+ * Number of LLIs in each LLI buffer allocated for one transfer
+ * (maximum times we call dma_pool_alloc on this pool without freeing)
+ */
+#define MAX_NUM_TSFR_LLIS	512
+#define PL08X_ALIGN		8
+
+static inline struct pl08x_dma_chan *to_pl08x_chan(struct dma_chan *chan)
+{
+	return container_of(chan, struct pl08x_dma_chan, vc.chan);
+}
+
+static inline struct pl08x_txd *to_pl08x_txd(struct dma_async_tx_descriptor *tx)
+{
+	return container_of(tx, struct pl08x_txd, vd.tx);
+}
+
+/*
+ * Mux handling.
+ *
+ * This gives us the DMA request input to the PL08x primecell which the
+ * peripheral described by the channel data will be routed to, possibly
+ * via a board/SoC specific external MUX.  One important point to note
+ * here is that this does not depend on the physical channel.
+ */
+static int pl08x_request_mux(struct pl08x_dma_chan *plchan)
+{
+	const struct pl08x_platform_data *pd = plchan->host->pd;
+	int ret;
+
+	if (plchan->mux_use++ == 0 && pd->get_xfer_signal) {
+		ret = pd->get_xfer_signal(plchan->cd);
+		if (ret < 0) {
+			plchan->mux_use = 0;
+			return ret;
+		}
+
+		plchan->signal = ret;
+	}
+	return 0;
+}
+
+static void pl08x_release_mux(struct pl08x_dma_chan *plchan)
+{
+	const struct pl08x_platform_data *pd = plchan->host->pd;
+
+	if (plchan->signal >= 0) {
+		WARN_ON(plchan->mux_use == 0);
+
+		if (--plchan->mux_use == 0 && pd->put_xfer_signal) {
+			pd->put_xfer_signal(plchan->cd, plchan->signal);
+			plchan->signal = -1;
+		}
+	}
+}
+
+/*
+ * Physical channel handling
+ */
+
+/* Whether a certain channel is busy or not */
+static int pl08x_phy_channel_busy(struct pl08x_phy_chan *ch)
+{
+	unsigned int val;
+
+	/* If we have a special busy register, take a shortcut */
+	if (ch->reg_busy) {
+		val = readl(ch->reg_busy);
+		return !!(val & BIT(ch->id));
+	}
+	val = readl(ch->reg_config);
+	return val & PL080_CONFIG_ACTIVE;
+}
+
+/*
+ * pl08x_write_lli() - Write an LLI into the DMA controller.
+ *
+ * The PL08x derivatives support linked lists, but the first item of the
+ * list containing the source, destination, control word and next LLI is
+ * ignored. Instead the driver has to write those values directly into the
+ * SRC, DST, LLI and control registers. On FTDMAC020 also the SIZE
+ * register need to be set up for the first transfer.
+ */
+static void pl08x_write_lli(struct pl08x_driver_data *pl08x,
+		struct pl08x_phy_chan *phychan, const u32 *lli, u32 ccfg)
+{
+	if (pl08x->vd->pl080s)
+		dev_vdbg(&pl08x->adev->dev,
+			"WRITE channel %d: csrc=0x%08x, cdst=0x%08x, "
+			"clli=0x%08x, cctl=0x%08x, cctl2=0x%08x, ccfg=0x%08x\n",
+			phychan->id, lli[PL080_LLI_SRC], lli[PL080_LLI_DST],
+			lli[PL080_LLI_LLI], lli[PL080_LLI_CCTL],
+			lli[PL080S_LLI_CCTL2], ccfg);
+	else
+		//dev_vdbg(&pl08x->adev->dev,
+		dev_info(&pl08x->adev->dev,
+			"WRITE channel %d: csrc=0x%08x, cdst=0x%08x, "
+			"clli=0x%08x, cctl=0x%08x, ccfg=0x%08x\n",
+			phychan->id, lli[PL080_LLI_SRC], lli[PL080_LLI_DST],
+			lli[PL080_LLI_LLI], lli[PL080_LLI_CCTL], ccfg);
+
+	writel_relaxed(lli[PL080_LLI_SRC], phychan->reg_src);
+	writel_relaxed(lli[PL080_LLI_DST], phychan->reg_dst);
+	writel_relaxed(lli[PL080_LLI_LLI], phychan->reg_lli);
+
+	/*
+	 * The FTMAC020 has a different layout in the CCTL word of the LLI
+	 * and the CCTL register which is split in CSR and SIZE registers.
+	 * Convert the LLI item CCTL into the proper values to write into
+	 * the CSR and SIZE registers.
+	 */
+	if (phychan->ftdmac020) {
+		u32 llictl = lli[PL080_LLI_CCTL];
+		u32 val = 0;
+
+		/* Write the transfer size (12 bits) to the size register */
+		writel_relaxed(llictl & FTDMAC020_LLI_TRANSFER_SIZE_MASK,
+			       phychan->base + FTDMAC020_CH_SIZE);
+		/*
+		 * Then write the control bits 28..16 to the control register
+		 * by shuffleing the bits around to where they are in the
+		 * main register. The mapping is as follows:
+		 * Bit 28: TC_MSK - mask on all except last LLI
+		 * Bit 27..25: SRC_WIDTH
+		 * Bit 24..22: DST_WIDTH
+		 * Bit 21..20: SRCAD_CTRL
+		 * Bit 19..17: DSTAD_CTRL
+		 * Bit 17: SRC_SEL
+		 * Bit 16: DST_SEL
+		 */
+		if (llictl & FTDMAC020_LLI_TC_MSK)
+			val |= FTDMAC020_CH_CSR_TC_MSK;
+		val |= ((llictl  & FTDMAC020_LLI_SRC_WIDTH_MSK) >>
+			(FTDMAC020_LLI_SRC_WIDTH_SHIFT -
+			 FTDMAC020_CH_CSR_SRC_WIDTH_SHIFT));
+		val |= ((llictl  & FTDMAC020_LLI_DST_WIDTH_MSK) >>
+			(FTDMAC020_LLI_DST_WIDTH_SHIFT -
+			 FTDMAC020_CH_CSR_DST_WIDTH_SHIFT));
+		val |= ((llictl  & FTDMAC020_LLI_SRCAD_CTL_MSK) >>
+			(FTDMAC020_LLI_SRCAD_CTL_SHIFT -
+			 FTDMAC020_CH_CSR_SRCAD_CTL_SHIFT));
+		val |= ((llictl  & FTDMAC020_LLI_DSTAD_CTL_MSK) >>
+			(FTDMAC020_LLI_DSTAD_CTL_SHIFT -
+			 FTDMAC020_CH_CSR_DSTAD_CTL_SHIFT));
+		if (llictl & FTDMAC020_LLI_SRC_SEL)
+			val |= FTDMAC020_CH_CSR_SRC_SEL;
+		if (llictl & FTDMAC020_LLI_DST_SEL)
+			val |= FTDMAC020_CH_CSR_DST_SEL;
+
+		/*
+		 * Set up the bits that exist in the CSR but are not
+		 * part the LLI, i.e. only gets written to the control
+		 * register right here.
+		 *
+		 * FIXME: do not just handle memcpy, also handle slave DMA.
+		 */
+		switch (pl08x->pd->memcpy_burst_size) {
+		default:
+		case PL08X_BURST_SZ_1:
+			val |= PL080_BSIZE_1 <<
+				FTDMAC020_CH_CSR_SRC_SIZE_SHIFT;
+			break;
+		case PL08X_BURST_SZ_4:
+			val |= PL080_BSIZE_4 <<
+				FTDMAC020_CH_CSR_SRC_SIZE_SHIFT;
+			break;
+		case PL08X_BURST_SZ_8:
+			val |= PL080_BSIZE_8 <<
+				FTDMAC020_CH_CSR_SRC_SIZE_SHIFT;
+			break;
+		case PL08X_BURST_SZ_16:
+			val |= PL080_BSIZE_16 <<
+				FTDMAC020_CH_CSR_SRC_SIZE_SHIFT;
+			break;
+		case PL08X_BURST_SZ_32:
+			val |= PL080_BSIZE_32 <<
+				FTDMAC020_CH_CSR_SRC_SIZE_SHIFT;
+			break;
+		case PL08X_BURST_SZ_64:
+			val |= PL080_BSIZE_64 <<
+				FTDMAC020_CH_CSR_SRC_SIZE_SHIFT;
+			break;
+		case PL08X_BURST_SZ_128:
+			val |= PL080_BSIZE_128 <<
+				FTDMAC020_CH_CSR_SRC_SIZE_SHIFT;
+			break;
+		case PL08X_BURST_SZ_256:
+			val |= PL080_BSIZE_256 <<
+				FTDMAC020_CH_CSR_SRC_SIZE_SHIFT;
+			break;
+		}
+
+		/* Protection flags */
+		if (pl08x->pd->memcpy_prot_buff)
+			val |= FTDMAC020_CH_CSR_PROT2;
+		if (pl08x->pd->memcpy_prot_cache)
+			val |= FTDMAC020_CH_CSR_PROT3;
+		/* We are the kernel, so we are in privileged mode */
+		val |= FTDMAC020_CH_CSR_PROT1;
+
+		writel_relaxed(val, phychan->reg_control);
+	} else {
+		/*		printk("this is debug lli[PL080_LLI_CCTL] = %x reg_control = %x  %s %s %d\n",
+		       lli[PL080_LLI_CCTL],phychan->reg_control,__FILE__,__func__,__LINE__);
+		*/
+		/* Bits are just identical */
+		writel_relaxed(lli[PL080_LLI_CCTL], phychan->reg_control);
+	}
+
+	/* Second control word on the PL080s */
+	if (pl08x->vd->pl080s)
+		writel_relaxed(lli[PL080S_LLI_CCTL2],
+				phychan->base + PL080S_CH_CONTROL2);
+
+	/*
+	printk("this is debug ccfg = %x reg_config = %x  %s %s %d\n",
+	       ccfg,phychan->reg_config,__FILE__,__func__,__LINE__);
+	*/
+	writel(ccfg, phychan->reg_config);
+}
+
+/*
+ * Set the initial DMA register values i.e. those for the first LLI
+ * The next LLI pointer and the configuration interrupt bit have
+ * been set when the LLIs were constructed.  Poke them into the hardware
+ * and start the transfer.
+ */
+static void pl08x_start_next_txd(struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_phy_chan *phychan = plchan->phychan;
+	struct virt_dma_desc *vd = vchan_next_desc(&plchan->vc);
+	struct pl08x_txd *txd = to_pl08x_txd(&vd->tx);
+	u32 val;
+
+	list_del(&txd->vd.node);
+
+	plchan->at = txd;
+
+	/* Wait for channel inactive */
+	while (pl08x_phy_channel_busy(phychan))
+		cpu_relax();
+	//printk("this is debug txd->ccfg = %x  %s %s %d\n",txd->ccfg,__FILE__,__func__,__LINE__);
+	pl08x_write_lli(pl08x, phychan, &txd->llis_va[0], txd->ccfg);
+
+	/* Enable the DMA channel */
+	/* Do not access config register until channel shows as disabled */
+	//printk("this is debug en_chan = %x id = %d %s %s %d\n",readl(pl08x->base + PL080_EN_CHAN),phychan->id,__FILE__,__func__,__LINE__);
+	while (readl(pl08x->base + PL080_EN_CHAN) & BIT(phychan->id))
+		cpu_relax();
+
+	//printk("this is debug en_chan = %x id = %d %s %s %d\n",readl(pl08x->base + PL080_EN_CHAN),phychan->id,__FILE__,__func__,__LINE__);
+	/* Do not access config register until channel shows as inactive */
+	if (phychan->ftdmac020) {
+		val = readl(phychan->reg_config);
+		while (val & FTDMAC020_CH_CFG_BUSY)
+			val = readl(phychan->reg_config);
+
+		val = readl(phychan->reg_control);
+		while (val & FTDMAC020_CH_CSR_EN)
+			val = readl(phychan->reg_control);
+
+		writel(val | FTDMAC020_CH_CSR_EN,
+		       phychan->reg_control);
+	} else {
+		val = readl(phychan->reg_config);
+		while ((val & PL080_CONFIG_ACTIVE) ||
+		       (val & PL080_CONFIG_ENABLE))
+			val = readl(phychan->reg_config);
+		//printk("this is debug val = %x  phychan->reg_config = %x  %s %s %d\n",val, phychan->reg_config,__FILE__,__func__,__LINE__);
+		writel(val | PL080_CONFIG_ENABLE, phychan->reg_config);
+#if 0
+		while(!(readl(pl08x->base + PL080_EN_CHAN) & BIT(phychan->id))){
+			printk("this is debug val = %x  phychan->reg_config = %x  %s %s %d\n",val, phychan->reg_config,__FILE__,__func__,__LINE__);
+			writel(val | PL080_CONFIG_ENABLE, phychan->reg_config);
+		}
+#endif			
+	}
+	//printk("this is debug reg_config = %x  en_chan = %x id = %d %s %s %d\n",readl(phychan->reg_config),
+	//       readl(pl08x->base + PL080_EN_CHAN),phychan->id,__FILE__,__func__,__LINE__);
+}
+
+/*
+ * Pause the channel by setting the HALT bit.
+ *
+ * For M->P transfers, pause the DMAC first and then stop the peripheral -
+ * the FIFO can only drain if the peripheral is still requesting data.
+ * (note: this can still timeout if the DMAC FIFO never drains of data.)
+ *
+ * For P->M transfers, disable the peripheral first to stop it filling
+ * the DMAC FIFO, and then pause the DMAC.
+ */
+static void pl08x_pause_phy_chan(struct pl08x_phy_chan *ch)
+{
+	u32 val;
+	int timeout;
+
+	if (ch->ftdmac020) {
+		/* Use the enable bit on the FTDMAC020 */
+		val = readl(ch->reg_control);
+		val &= ~FTDMAC020_CH_CSR_EN;
+		writel(val, ch->reg_control);
+		return;
+	}
+
+	/* Set the HALT bit and wait for the FIFO to drain */
+	val = readl(ch->reg_config);
+	val |= PL080_CONFIG_HALT;
+	writel(val, ch->reg_config);
+
+	/* Wait for channel inactive */
+	for (timeout = 1000; timeout; timeout--) {
+		if (!pl08x_phy_channel_busy(ch))
+			break;
+		udelay(1);
+	}
+	if (pl08x_phy_channel_busy(ch))
+		pr_err("pl08x: channel%u timeout waiting for pause\n", ch->id);
+}
+
+static void pl08x_resume_phy_chan(struct pl08x_phy_chan *ch)
+{
+	u32 val;
+
+	/* Use the enable bit on the FTDMAC020 */
+	if (ch->ftdmac020) {
+		val = readl(ch->reg_control);
+		val |= FTDMAC020_CH_CSR_EN;
+		writel(val, ch->reg_control);
+		return;
+	}
+
+	/* Clear the HALT bit */
+	val = readl(ch->reg_config);
+	val &= ~PL080_CONFIG_HALT;
+	writel(val, ch->reg_config);
+}
+
+/*
+ * pl08x_terminate_phy_chan() stops the channel, clears the FIFO and
+ * clears any pending interrupt status.  This should not be used for
+ * an on-going transfer, but as a method of shutting down a channel
+ * (eg, when it's no longer used) or terminating a transfer.
+ */
+static void pl08x_terminate_phy_chan(struct pl08x_driver_data *pl08x,
+	struct pl08x_phy_chan *ch)
+{
+	u32 val;
+
+	/* The layout for the FTDMAC020 is different */
+	if (ch->ftdmac020) {
+		/* Disable all interrupts */
+		val = readl(ch->reg_config);
+		val |= (FTDMAC020_CH_CFG_INT_ABT_MASK |
+			FTDMAC020_CH_CFG_INT_ERR_MASK |
+			FTDMAC020_CH_CFG_INT_TC_MASK);
+		writel(val, ch->reg_config);
+
+		/* Abort and disable channel */
+		val = readl(ch->reg_control);
+		val &= ~FTDMAC020_CH_CSR_EN;
+		val |= FTDMAC020_CH_CSR_ABT;
+		writel(val, ch->reg_control);
+
+		/* Clear ABT and ERR interrupt flags */
+		writel(BIT(ch->id) | BIT(ch->id + 16),
+		       pl08x->base + PL080_ERR_CLEAR);
+		writel(BIT(ch->id), pl08x->base + PL080_TC_CLEAR);
+
+		return;
+	}
+
+	val = readl(ch->reg_config);
+	val &= ~(PL080_CONFIG_ENABLE | PL080_CONFIG_ERR_IRQ_MASK |
+		 PL080_CONFIG_TC_IRQ_MASK);
+	writel(val, ch->reg_config);
+
+	writel(BIT(ch->id), pl08x->base + PL080_ERR_CLEAR);
+	writel(BIT(ch->id), pl08x->base + PL080_TC_CLEAR);
+}
+
+static u32 get_bytes_in_phy_channel(struct pl08x_phy_chan *ch)
+{
+	u32 val;
+	u32 bytes;
+
+	if (ch->ftdmac020) {
+		bytes = readl(ch->base + FTDMAC020_CH_SIZE);
+
+		val = readl(ch->reg_control);
+		val &= FTDMAC020_CH_CSR_SRC_WIDTH_MSK;
+		val >>= FTDMAC020_CH_CSR_SRC_WIDTH_SHIFT;
+	} else if (ch->pl080s) {
+		val = readl(ch->base + PL080S_CH_CONTROL2);
+		bytes = val & PL080S_CONTROL_TRANSFER_SIZE_MASK;
+
+		val = readl(ch->reg_control);
+		val &= PL080_CONTROL_SWIDTH_MASK;
+		val >>= PL080_CONTROL_SWIDTH_SHIFT;
+	} else {
+		/* Plain PL08x */
+		val = readl(ch->reg_control);
+		bytes = val & PL080_CONTROL_TRANSFER_SIZE_MASK;
+
+		val &= PL080_CONTROL_SWIDTH_MASK;
+		val >>= PL080_CONTROL_SWIDTH_SHIFT;
+	}
+
+	switch (val) {
+	case PL080_WIDTH_8BIT:
+		break;
+	case PL080_WIDTH_16BIT:
+		bytes *= 2;
+		break;
+	case PL080_WIDTH_32BIT:
+		bytes *= 4;
+		break;
+	}
+	return bytes;
+}
+
+static u32 get_bytes_in_lli(struct pl08x_phy_chan *ch, const u32 *llis_va)
+{
+	u32 val;
+	u32 bytes;
+
+	if (ch->ftdmac020) {
+		val = llis_va[PL080_LLI_CCTL];
+		bytes = val & FTDMAC020_LLI_TRANSFER_SIZE_MASK;
+
+		val = llis_va[PL080_LLI_CCTL];
+		val &= FTDMAC020_LLI_SRC_WIDTH_MSK;
+		val >>= FTDMAC020_LLI_SRC_WIDTH_SHIFT;
+	} else if (ch->pl080s) {
+		val = llis_va[PL080S_LLI_CCTL2];
+		bytes = val & PL080S_CONTROL_TRANSFER_SIZE_MASK;
+
+		val = llis_va[PL080_LLI_CCTL];
+		val &= PL080_CONTROL_SWIDTH_MASK;
+		val >>= PL080_CONTROL_SWIDTH_SHIFT;
+	} else {
+		/* Plain PL08x */
+		val = llis_va[PL080_LLI_CCTL];
+		bytes = val & PL080_CONTROL_TRANSFER_SIZE_MASK;
+
+		val &= PL080_CONTROL_SWIDTH_MASK;
+		val >>= PL080_CONTROL_SWIDTH_SHIFT;
+	}
+
+	switch (val) {
+	case PL080_WIDTH_8BIT:
+		break;
+	case PL080_WIDTH_16BIT:
+		bytes *= 2;
+		break;
+	case PL080_WIDTH_32BIT:
+		bytes *= 4;
+		break;
+	}
+	return bytes;
+}
+
+/* The channel should be paused when calling this */
+static u32 pl08x_getbytes_chan(struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_driver_data *pl08x = plchan->host;
+	const u32 *llis_va, *llis_va_limit;
+	struct pl08x_phy_chan *ch;
+	dma_addr_t llis_bus;
+	struct pl08x_txd *txd;
+	u32 llis_max_words;
+	size_t bytes;
+	u32 clli;
+
+	ch = plchan->phychan;
+	txd = plchan->at;
+
+	if (!ch || !txd)
+		return 0;
+
+	/*
+	 * Follow the LLIs to get the number of remaining
+	 * bytes in the currently active transaction.
+	 */
+	clli = readl(ch->reg_lli) & ~PL080_LLI_LM_AHB2;
+
+	/* First get the remaining bytes in the active transfer */
+	bytes = get_bytes_in_phy_channel(ch);
+
+	if (!clli)
+		return bytes;
+
+	llis_va = txd->llis_va;
+	llis_bus = txd->llis_bus;
+
+	llis_max_words = pl08x->lli_words * MAX_NUM_TSFR_LLIS;
+	BUG_ON(clli < llis_bus || clli >= llis_bus +
+						sizeof(u32) * llis_max_words);
+
+	/*
+	 * Locate the next LLI - as this is an array,
+	 * it's simple maths to find.
+	 */
+	llis_va += (clli - llis_bus) / sizeof(u32);
+
+	llis_va_limit = llis_va + llis_max_words;
+
+	for (; llis_va < llis_va_limit; llis_va += pl08x->lli_words) {
+		bytes += get_bytes_in_lli(ch, llis_va);
+
+		/*
+		 * A LLI pointer going backward terminates the LLI list
+		 */
+		if (llis_va[PL080_LLI_LLI] <= clli)
+			break;
+	}
+
+	return bytes;
+}
+
+/*
+ * Allocate a physical channel for a virtual channel
+ *
+ * Try to locate a physical channel to be used for this transfer. If all
+ * are taken return NULL and the requester will have to cope by using
+ * some fallback PIO mode or retrying later.
+ */
+static struct pl08x_phy_chan *
+pl08x_get_phy_channel(struct pl08x_driver_data *pl08x,
+		      struct pl08x_dma_chan *virt_chan)
+{
+	struct pl08x_phy_chan *ch = NULL;
+	unsigned long flags;
+	int i;
+
+	//printk("this is debug virt_chan->id = %d %s %s %d\n",virt_chan->chan_id,__FILE__,__func__,__LINE__);
+#if 1
+	ch = &pl08x->phy_chans[virt_chan->chan_id];
+
+	spin_lock_irqsave(&ch->lock, flags);
+
+	if (!ch->locked && !ch->serving) {
+		ch->serving = virt_chan;
+		spin_unlock_irqrestore(&ch->lock, flags);
+		return ch;
+	}
+
+	spin_unlock_irqrestore(&ch->lock, flags);
+#endif
+	for (i = 0; i < pl08x->vd->channels; i++) {
+		ch = &pl08x->phy_chans[i];
+
+		spin_lock_irqsave(&ch->lock, flags);
+
+		if (!ch->locked && !ch->serving) {
+			ch->serving = virt_chan;
+			spin_unlock_irqrestore(&ch->lock, flags);
+			break;
+		}
+
+		spin_unlock_irqrestore(&ch->lock, flags);
+	}
+
+	if (i == pl08x->vd->channels) {
+		/* No physical channel available, cope with it */
+		return NULL;
+	}
+
+	return ch;
+}
+
+/* Mark the physical channel as free.  Note, this write is atomic. */
+static inline void pl08x_put_phy_channel(struct pl08x_driver_data *pl08x,
+					 struct pl08x_phy_chan *ch)
+{
+	ch->serving = NULL;
+}
+
+/*
+ * Try to allocate a physical channel.  When successful, assign it to
+ * this virtual channel, and initiate the next descriptor.  The
+ * virtual channel lock must be held at this point.
+ */
+static void pl08x_phy_alloc_and_start(struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_phy_chan *ch;
+
+	ch = pl08x_get_phy_channel(pl08x, plchan);
+	if (!ch) {
+		dev_dbg(&pl08x->adev->dev, "no physical channel available for xfer on %s\n", plchan->name);
+		plchan->state = PL08X_CHAN_WAITING;
+		plchan->waiting_at = jiffies;
+		return;
+	}
+
+	dev_dbg(&pl08x->adev->dev, "allocated physical channel %d for xfer on %s\n",
+		ch->id, plchan->name);
+
+	plchan->phychan = ch;
+	plchan->state = PL08X_CHAN_RUNNING;
+	pl08x_start_next_txd(plchan);
+}
+
+static void pl08x_phy_reassign_start(struct pl08x_phy_chan *ch,
+	struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_driver_data *pl08x = plchan->host;
+
+	dev_dbg(&pl08x->adev->dev, "reassigned physical channel %d for xfer on %s\n",
+		ch->id, plchan->name);
+
+	/*
+	 * We do this without taking the lock; we're really only concerned
+	 * about whether this pointer is NULL or not, and we're guaranteed
+	 * that this will only be called when it _already_ is non-NULL.
+	 */
+	ch->serving = plchan;
+	plchan->phychan = ch;
+	plchan->state = PL08X_CHAN_RUNNING;
+	pl08x_start_next_txd(plchan);
+}
+
+/*
+ * Free a physical DMA channel, potentially reallocating it to another
+ * virtual channel if we have any pending.
+ */
+static void pl08x_phy_free(struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_dma_chan *p, *next;
+	unsigned long waiting_at;
+ retry:
+	next = NULL;
+	waiting_at = jiffies;
+
+	/*
+	 * Find a waiting virtual channel for the next transfer.
+	 * To be fair, time when each channel reached waiting state is compared
+	 * to select channel that is waiting for the longest time.
+	 */
+	list_for_each_entry(p, &pl08x->memcpy.channels, vc.chan.device_node)
+		if (p->state == PL08X_CHAN_WAITING &&
+		    p->waiting_at <= waiting_at) {
+			next = p;
+			waiting_at = p->waiting_at;
+		}
+
+	if (!next && pl08x->has_slave) {
+		list_for_each_entry(p, &pl08x->slave.channels, vc.chan.device_node)
+			if (p->state == PL08X_CHAN_WAITING &&
+			    p->waiting_at <= waiting_at) {
+				next = p;
+				waiting_at = p->waiting_at;
+			}
+	}
+
+	/* Ensure that the physical channel is stopped */
+	pl08x_terminate_phy_chan(pl08x, plchan->phychan);
+
+	if (next) {
+		bool success;
+
+		/*
+		 * Eww.  We know this isn't going to deadlock
+		 * but lockdep probably doesn't.
+		 */
+		spin_lock(&next->vc.lock);
+		/* Re-check the state now that we have the lock */
+		success = next->state == PL08X_CHAN_WAITING;
+		if (success)
+			pl08x_phy_reassign_start(plchan->phychan, next);
+		spin_unlock(&next->vc.lock);
+
+		/* If the state changed, try to find another channel */
+		if (!success)
+			goto retry;
+	} else {
+		/* No more jobs, so free up the physical channel */
+		pl08x_put_phy_channel(pl08x, plchan->phychan);
+	}
+
+	plchan->phychan = NULL;
+	plchan->state = PL08X_CHAN_IDLE;
+}
+
+/*
+ * LLI handling
+ */
+
+static inline unsigned int
+pl08x_get_bytes_for_lli(struct pl08x_driver_data *pl08x,
+			u32 cctl,
+			bool source)
+{
+	u32 val;
+
+	if (pl08x->vd->ftdmac020) {
+		if (source)
+			val = (cctl & FTDMAC020_LLI_SRC_WIDTH_MSK) >>
+				FTDMAC020_LLI_SRC_WIDTH_SHIFT;
+		else
+			val = (cctl & FTDMAC020_LLI_DST_WIDTH_MSK) >>
+				FTDMAC020_LLI_DST_WIDTH_SHIFT;
+	} else {
+		if (source)
+			val = (cctl & PL080_CONTROL_SWIDTH_MASK) >>
+				PL080_CONTROL_SWIDTH_SHIFT;
+		else
+			val = (cctl & PL080_CONTROL_DWIDTH_MASK) >>
+				PL080_CONTROL_DWIDTH_SHIFT;
+	}
+
+	switch (val) {
+	case PL080_WIDTH_8BIT:
+		return 1;
+	case PL080_WIDTH_16BIT:
+		return 2;
+	case PL080_WIDTH_32BIT:
+		return 4;
+	default:
+		break;
+	}
+	BUG();
+	return 0;
+}
+
+static inline u32 pl08x_lli_control_bits(struct pl08x_driver_data *pl08x,
+					 u32 cctl,
+					 u8 srcwidth, u8 dstwidth,
+					 size_t tsize)
+{
+	u32 retbits = cctl;
+
+	/*
+	 * Remove all src, dst and transfer size bits, then set the
+	 * width and size according to the parameters. The bit offsets
+	 * are different in the FTDMAC020 so we need to accound for this.
+	 */
+	if (pl08x->vd->ftdmac020) {
+		retbits &= ~FTDMAC020_LLI_DST_WIDTH_MSK;
+		retbits &= ~FTDMAC020_LLI_SRC_WIDTH_MSK;
+		retbits &= ~FTDMAC020_LLI_TRANSFER_SIZE_MASK;
+
+		switch (srcwidth) {
+		case 1:
+			retbits |= PL080_WIDTH_8BIT <<
+				FTDMAC020_LLI_SRC_WIDTH_SHIFT;
+			break;
+		case 2:
+			retbits |= PL080_WIDTH_16BIT <<
+				FTDMAC020_LLI_SRC_WIDTH_SHIFT;
+			break;
+		case 4:
+			retbits |= PL080_WIDTH_32BIT <<
+				FTDMAC020_LLI_SRC_WIDTH_SHIFT;
+			break;
+		default:
+			BUG();
+			break;
+		}
+
+		switch (dstwidth) {
+		case 1:
+			retbits |= PL080_WIDTH_8BIT <<
+				FTDMAC020_LLI_DST_WIDTH_SHIFT;
+			break;
+		case 2:
+			retbits |= PL080_WIDTH_16BIT <<
+				FTDMAC020_LLI_DST_WIDTH_SHIFT;
+			break;
+		case 4:
+			retbits |= PL080_WIDTH_32BIT <<
+				FTDMAC020_LLI_DST_WIDTH_SHIFT;
+			break;
+		default:
+			BUG();
+			break;
+		}
+
+		tsize &= FTDMAC020_LLI_TRANSFER_SIZE_MASK;
+		retbits |= tsize << FTDMAC020_LLI_TRANSFER_SIZE_SHIFT;
+	} else {
+		retbits &= ~PL080_CONTROL_DWIDTH_MASK;
+		retbits &= ~PL080_CONTROL_SWIDTH_MASK;
+		retbits &= ~PL080_CONTROL_TRANSFER_SIZE_MASK;
+
+		switch (srcwidth) {
+		case 1:
+			retbits |= PL080_WIDTH_8BIT <<
+				PL080_CONTROL_SWIDTH_SHIFT;
+			break;
+		case 2:
+			retbits |= PL080_WIDTH_16BIT <<
+				PL080_CONTROL_SWIDTH_SHIFT;
+			break;
+		case 4:
+			retbits |= PL080_WIDTH_32BIT <<
+				PL080_CONTROL_SWIDTH_SHIFT;
+			break;
+		default:
+			BUG();
+			break;
+		}
+
+		switch (dstwidth) {
+		case 1:
+			retbits |= PL080_WIDTH_8BIT <<
+				PL080_CONTROL_DWIDTH_SHIFT;
+			break;
+		case 2:
+			retbits |= PL080_WIDTH_16BIT <<
+				PL080_CONTROL_DWIDTH_SHIFT;
+			break;
+		case 4:
+			retbits |= PL080_WIDTH_32BIT <<
+				PL080_CONTROL_DWIDTH_SHIFT;
+			break;
+		default:
+			BUG();
+			break;
+		}
+
+		tsize &= PL080_CONTROL_TRANSFER_SIZE_MASK;
+		retbits |= tsize << PL080_CONTROL_TRANSFER_SIZE_SHIFT;
+	}
+
+	return retbits;
+}
+
+struct pl08x_lli_build_data {
+	struct pl08x_txd *txd;
+	struct pl08x_bus_data srcbus;
+	struct pl08x_bus_data dstbus;
+	size_t remainder;
+	u32 lli_bus;
+};
+
+/*
+ * Autoselect a master bus to use for the transfer. Slave will be the chosen as
+ * victim in case src & dest are not similarly aligned. i.e. If after aligning
+ * masters address with width requirements of transfer (by sending few byte by
+ * byte data), slave is still not aligned, then its width will be reduced to
+ * BYTE.
+ * - prefers the destination bus if both available
+ * - prefers bus with fixed address (i.e. peripheral)
+ */
+static void pl08x_choose_master_bus(struct pl08x_driver_data *pl08x,
+				    struct pl08x_lli_build_data *bd,
+				    struct pl08x_bus_data **mbus,
+				    struct pl08x_bus_data **sbus,
+				    u32 cctl)
+{
+	bool dst_incr;
+	bool src_incr;
+
+	/*
+	 * The FTDMAC020 only supports memory-to-memory transfer, so
+	 * source and destination always increase.
+	 */
+	if (pl08x->vd->ftdmac020) {
+		dst_incr = true;
+		src_incr = true;
+	} else {
+		dst_incr = !!(cctl & PL080_CONTROL_DST_INCR);
+		src_incr = !!(cctl & PL080_CONTROL_SRC_INCR);
+	}
+
+	/*
+	 * If either bus is not advancing, i.e. it is a peripheral, that
+	 * one becomes master
+	 */
+	if (!dst_incr) {
+		*mbus = &bd->dstbus;
+		*sbus = &bd->srcbus;
+	} else if (!src_incr) {
+		*mbus = &bd->srcbus;
+		*sbus = &bd->dstbus;
+	} else {
+		if (bd->dstbus.buswidth >= bd->srcbus.buswidth) {
+			*mbus = &bd->dstbus;
+			*sbus = &bd->srcbus;
+		} else {
+			*mbus = &bd->srcbus;
+			*sbus = &bd->dstbus;
+		}
+	}
+}
+
+/*
+ * Fills in one LLI for a certain transfer descriptor and advance the counter
+ */
+static void pl08x_fill_lli_for_desc(struct pl08x_driver_data *pl08x,
+				    struct pl08x_lli_build_data *bd,
+				    int num_llis, int len, u32 cctl, u32 cctl2)
+{
+	u32 offset = num_llis * pl08x->lli_words;
+	u32 *llis_va = bd->txd->llis_va + offset;
+	dma_addr_t llis_bus = bd->txd->llis_bus;
+
+	BUG_ON(num_llis >= MAX_NUM_TSFR_LLIS);
+
+	/*
+	printk("this is debug num_llis = %x lli_words = %x %s %s %d\n",
+		num_llis,pl08x->lli_words,__FILE__,__func__,__LINE__);
+	*/
+	/* Advance the offset to next LLI. */
+	offset += pl08x->lli_words;
+
+	llis_va[PL080_LLI_SRC] = bd->srcbus.addr;
+	llis_va[PL080_LLI_DST] = bd->dstbus.addr;
+	llis_va[PL080_LLI_LLI] = (llis_bus + sizeof(u32) * offset);
+	llis_va[PL080_LLI_LLI] |= bd->lli_bus;
+	llis_va[PL080_LLI_CCTL] = cctl;
+	if (pl08x->vd->pl080s)
+		llis_va[PL080S_LLI_CCTL2] = cctl2;
+
+	if (pl08x->vd->ftdmac020) {
+		/* FIXME: only memcpy so far so both increase */
+		bd->srcbus.addr += len;
+		bd->dstbus.addr += len;
+	} else {
+		if (cctl & PL080_CONTROL_SRC_INCR)
+			bd->srcbus.addr += len;
+		if (cctl & PL080_CONTROL_DST_INCR)
+			bd->dstbus.addr += len;
+	}
+
+	BUG_ON(bd->remainder < len);
+
+	bd->remainder -= len;
+}
+
+static inline void prep_byte_width_lli(struct pl08x_driver_data *pl08x,
+			struct pl08x_lli_build_data *bd, u32 *cctl, u32 len,
+			int num_llis, size_t *total_bytes)
+{
+	*cctl = pl08x_lli_control_bits(pl08x, *cctl, 1, 1, len);
+	pl08x_fill_lli_for_desc(pl08x, bd, num_llis, len, *cctl, len);
+	(*total_bytes) += len;
+}
+
+#if 1
+static void pl08x_dump_lli(struct pl08x_driver_data *pl08x,
+			   const u32 *llis_va, int num_llis)
+{
+	int i;
+
+	if (pl08x->vd->pl080s) {
+		dev_vdbg(&pl08x->adev->dev,
+			"%-3s %-9s  %-10s %-10s %-10s %-10s %s\n",
+			"lli", "", "csrc", "cdst", "clli", "cctl", "cctl2");
+		for (i = 0; i < num_llis; i++) {
+			dev_vdbg(&pl08x->adev->dev,
+				"%3d @%p: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",
+				i, llis_va, llis_va[PL080_LLI_SRC],
+				llis_va[PL080_LLI_DST], llis_va[PL080_LLI_LLI],
+				llis_va[PL080_LLI_CCTL],
+				llis_va[PL080S_LLI_CCTL2]);
+			llis_va += pl08x->lli_words;
+		}
+	} else {
+		//dev_vdbg(&pl08x->adev->dev,
+		dev_info(&pl08x->adev->dev,
+			"%-3s %-9s  %-10s %-10s %-10s %s\n",
+			"lli", "", "csrc", "cdst", "clli", "cctl");
+		for (i = 0; i < num_llis; i++) {
+			//dev_vdbg(&pl08x->adev->dev,
+			dev_info(&pl08x->adev->dev,
+				"%3d @%p: 0x%08x 0x%08x 0x%08x 0x%08x\n",
+				i, llis_va, llis_va[PL080_LLI_SRC],
+				llis_va[PL080_LLI_DST], llis_va[PL080_LLI_LLI],
+				llis_va[PL080_LLI_CCTL]);
+			llis_va += pl08x->lli_words;
+		}
+	}
+}
+#else
+static inline void pl08x_dump_lli(struct pl08x_driver_data *pl08x,
+				  const u32 *llis_va, int num_llis) {}
+#endif
+
+extern u64 dw_virt_to_phys(void *vaddr);
+/*
+ * This fills in the table of LLIs for the transfer descriptor
+ * Note that we assume we never have to change the burst sizes
+ * Return 0 for error
+ */
+static int pl08x_fill_llis_for_desc(struct pl08x_driver_data *pl08x,
+			      struct pl08x_txd *txd)
+{
+	struct pl08x_bus_data *mbus, *sbus;
+	struct pl08x_lli_build_data bd;
+	int num_llis = 0;
+	u32 cctl, early_bytes = 0;
+	size_t max_bytes_per_lli, total_bytes;
+	u32 *llis_va, *last_lli;
+	struct pl08x_sg *dsg;
+
+	txd->llis_va = dma_pool_alloc(pl08x->pool, GFP_NOWAIT, &txd->llis_bus);
+	if (!txd->llis_va) {
+		dev_err(&pl08x->adev->dev, "%s no memory for llis\n", __func__);
+		return 0;
+	}
+
+	/*
+	printk("this is debug txd->llis_bus = %llx pl08x->lli_buses = %x llis_va = %llx %s %s %d\n",
+	       txd->llis_bus,pl08x->lli_buses,dw_virt_to_phys(txd->llis_va),__FILE__,__func__,__LINE__);
+	*/
+	bd.txd = txd;
+	bd.lli_bus = (pl08x->lli_buses & PL08X_AHB2) ? PL080_LLI_LM_AHB2 : 0;
+	cctl = txd->cctl;
+
+	/* Find maximum width of the source bus */
+	bd.srcbus.maxwidth = pl08x_get_bytes_for_lli(pl08x, cctl, true);
+
+	/* Find maximum width of the destination bus */
+	bd.dstbus.maxwidth = pl08x_get_bytes_for_lli(pl08x, cctl, false);
+
+	list_for_each_entry(dsg, &txd->dsg_list, node) {
+		total_bytes = 0;
+		cctl = txd->cctl;
+
+		bd.srcbus.addr = dsg->src_addr;
+		bd.dstbus.addr = dsg->dst_addr;
+		bd.remainder = dsg->len;
+		bd.srcbus.buswidth = bd.srcbus.maxwidth;
+		bd.dstbus.buswidth = bd.dstbus.maxwidth;
+
+		pl08x_choose_master_bus(pl08x, &bd, &mbus, &sbus, cctl);
+
+		dev_vdbg(&pl08x->adev->dev,
+			"src=0x%08llx%s/%u dst=0x%08llx%s/%u len=%zu\n",
+			(u64)bd.srcbus.addr,
+			cctl & PL080_CONTROL_SRC_INCR ? "+" : "",
+			bd.srcbus.buswidth,
+			(u64)bd.dstbus.addr,
+			cctl & PL080_CONTROL_DST_INCR ? "+" : "",
+			bd.dstbus.buswidth,
+			bd.remainder);
+		dev_vdbg(&pl08x->adev->dev, "mbus=%s sbus=%s\n",
+			mbus == &bd.srcbus ? "src" : "dst",
+			sbus == &bd.srcbus ? "src" : "dst");
+
+		/*
+		 * Zero length is only allowed if all these requirements are
+		 * met:
+		 * - flow controller is peripheral.
+		 * - src.addr is aligned to src.width
+		 * - dst.addr is aligned to dst.width
+		 *
+		 * sg_len == 1 should be true, as there can be two cases here:
+		 *
+		 * - Memory addresses are contiguous and are not scattered.
+		 *   Here, Only one sg will be passed by user driver, with
+		 *   memory address and zero length. We pass this to controller
+		 *   and after the transfer it will receive the last burst
+		 *   request from peripheral and so transfer finishes.
+		 *
+		 * - Memory addresses are scattered and are not contiguous.
+		 *   Here, Obviously as DMA controller doesn't know when a lli's
+		 *   transfer gets over, it can't load next lli. So in this
+		 *   case, there has to be an assumption that only one lli is
+		 *   supported. Thus, we can't have scattered addresses.
+		 */
+		if (!bd.remainder) {
+			u32 fc;
+
+			/* FTDMAC020 only does memory-to-memory */
+			if (pl08x->vd->ftdmac020)
+				fc = PL080_FLOW_MEM2MEM;
+			else
+				fc = (txd->ccfg & PL080_CONFIG_FLOW_CONTROL_MASK) >>
+					PL080_CONFIG_FLOW_CONTROL_SHIFT;
+			if (!((fc >= PL080_FLOW_SRC2DST_DST) &&
+					(fc <= PL080_FLOW_SRC2DST_SRC))) {
+				dev_err(&pl08x->adev->dev, "%s sg len can't be zero",
+					__func__);
+				return 0;
+			}
+
+			if (!IS_BUS_ALIGNED(&bd.srcbus) ||
+				!IS_BUS_ALIGNED(&bd.dstbus)) {
+				dev_err(&pl08x->adev->dev,
+					"%s src & dst address must be aligned to src"
+					" & dst width if peripheral is flow controller",
+					__func__);
+				return 0;
+			}
+
+			cctl = pl08x_lli_control_bits(pl08x, cctl,
+					bd.srcbus.buswidth, bd.dstbus.buswidth,
+					0);
+			pl08x_fill_lli_for_desc(pl08x, &bd, num_llis++,
+					0, cctl, 0);
+			break;
+		}
+
+		/*
+		 * Send byte by byte for following cases
+		 * - Less than a bus width available
+		 * - until master bus is aligned
+		 */
+		if (bd.remainder < mbus->buswidth)
+			early_bytes = bd.remainder;
+		else if (!IS_BUS_ALIGNED(mbus)) {
+			early_bytes = mbus->buswidth -
+				(mbus->addr & (mbus->buswidth - 1));
+			if ((bd.remainder - early_bytes) < mbus->buswidth)
+				early_bytes = bd.remainder;
+		}
+
+		if (early_bytes) {
+			dev_vdbg(&pl08x->adev->dev,
+				"%s byte width LLIs (remain 0x%08zx)\n",
+				__func__, bd.remainder);
+			prep_byte_width_lli(pl08x, &bd, &cctl, early_bytes,
+				num_llis++, &total_bytes);
+		}
+
+		if (bd.remainder) {
+			/*
+			 * Master now aligned
+			 * - if slave is not then we must set its width down
+			 */
+			if (!IS_BUS_ALIGNED(sbus)) {
+				dev_dbg(&pl08x->adev->dev,
+					"%s set down bus width to one byte\n",
+					__func__);
+
+				sbus->buswidth = 1;
+			}
+
+			/*
+			 * Bytes transferred = tsize * src width, not
+			 * MIN(buswidths)
+			 */
+			max_bytes_per_lli = bd.srcbus.buswidth *
+						pl08x->vd->max_transfer_size;
+			dev_vdbg(&pl08x->adev->dev,
+				"%s max bytes per lli = %zu\n",
+				__func__, max_bytes_per_lli);
+
+			/*
+			 * Make largest possible LLIs until less than one bus
+			 * width left
+			 */
+			while (bd.remainder > (mbus->buswidth - 1)) {
+				size_t lli_len, tsize, width;
+
+				/*
+				 * If enough left try to send max possible,
+				 * otherwise try to send the remainder
+				 */
+				lli_len = min(bd.remainder, max_bytes_per_lli);
+
+				/*
+				 * Check against maximum bus alignment:
+				 * Calculate actual transfer size in relation to
+				 * bus width an get a maximum remainder of the
+				 * highest bus width - 1
+				 */
+				width = max(mbus->buswidth, sbus->buswidth);
+				lli_len = (lli_len / width) * width;
+				tsize = lli_len / bd.srcbus.buswidth;
+
+				dev_vdbg(&pl08x->adev->dev,
+					"%s fill lli with single lli chunk of "
+					"size 0x%08zx (remainder 0x%08zx)\n",
+					__func__, lli_len, bd.remainder);
+
+				cctl = pl08x_lli_control_bits(pl08x, cctl,
+					bd.srcbus.buswidth, bd.dstbus.buswidth,
+					tsize);
+				pl08x_fill_lli_for_desc(pl08x, &bd, num_llis++,
+						lli_len, cctl, tsize);
+				total_bytes += lli_len;
+			}
+
+			/*
+			 * Send any odd bytes
+			 */
+			if (bd.remainder) {
+				dev_vdbg(&pl08x->adev->dev,
+					"%s align with boundary, send odd bytes (remain %zu)\n",
+					__func__, bd.remainder);
+				prep_byte_width_lli(pl08x, &bd, &cctl,
+					bd.remainder, num_llis++, &total_bytes);
+			}
+		}
+
+		if (total_bytes != dsg->len) {
+			dev_err(&pl08x->adev->dev,
+				"%s size of encoded lli:s don't match total txd, transferred 0x%08zx from size 0x%08zx\n",
+				__func__, total_bytes, dsg->len);
+			return 0;
+		}
+
+		if (num_llis >= MAX_NUM_TSFR_LLIS) {
+			dev_err(&pl08x->adev->dev,
+				"%s need to increase MAX_NUM_TSFR_LLIS from 0x%08x\n",
+				__func__, MAX_NUM_TSFR_LLIS);
+			return 0;
+		}
+	}
+
+	llis_va = txd->llis_va;
+	last_lli = llis_va + (num_llis - 1) * pl08x->lli_words;
+
+	if (txd->cyclic) {
+		/* Link back to the first LLI. */
+		last_lli[PL080_LLI_LLI] = txd->llis_bus | bd.lli_bus;
+	} else {
+		/* The final LLI terminates the LLI. */
+		last_lli[PL080_LLI_LLI] = 0;
+		/* The final LLI element shall also fire an interrupt. */
+		if (pl08x->vd->ftdmac020)
+			last_lli[PL080_LLI_CCTL] &= ~FTDMAC020_LLI_TC_MSK;
+		else
+			last_lli[PL080_LLI_CCTL] |= PL080_CONTROL_TC_IRQ_EN;
+	}
+
+	pl08x_dump_lli(pl08x, llis_va, num_llis);
+
+	return num_llis;
+}
+
+static void pl08x_free_txd(struct pl08x_driver_data *pl08x,
+			   struct pl08x_txd *txd)
+{
+	struct pl08x_sg *dsg, *_dsg;
+
+	if (txd->llis_va)
+		dma_pool_free(pl08x->pool, txd->llis_va, txd->llis_bus);
+
+	list_for_each_entry_safe(dsg, _dsg, &txd->dsg_list, node) {
+		list_del(&dsg->node);
+		kfree(dsg);
+	}
+
+	kfree(txd);
+}
+
+static void pl08x_desc_free(struct virt_dma_desc *vd)
+{
+	struct pl08x_txd *txd = to_pl08x_txd(&vd->tx);
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(vd->tx.chan);
+
+	dma_descriptor_unmap(&vd->tx);
+	if (!txd->done)
+		pl08x_release_mux(plchan);
+
+	pl08x_free_txd(plchan->host, txd);
+}
+
+static void pl08x_free_txd_list(struct pl08x_driver_data *pl08x,
+				struct pl08x_dma_chan *plchan)
+{
+	LIST_HEAD(head);
+
+	vchan_get_all_descriptors(&plchan->vc, &head);
+	vchan_dma_desc_free_list(&plchan->vc, &head);
+}
+
+/*
+ * The DMA ENGINE API
+ */
+static void pl08x_free_chan_resources(struct dma_chan *chan)
+{
+	/* Ensure all queued descriptors are freed */
+	vchan_free_chan_resources(to_virt_chan(chan));
+}
+
+static struct dma_async_tx_descriptor *pl08x_prep_dma_interrupt(
+		struct dma_chan *chan, unsigned long flags)
+{
+	struct dma_async_tx_descriptor *retval = NULL;
+
+	return retval;
+}
+
+/*
+ * Code accessing dma_async_is_complete() in a tight loop may give problems.
+ * If slaves are relying on interrupts to signal completion this function
+ * must not be called with interrupts disabled.
+ */
+static enum dma_status pl08x_dma_tx_status(struct dma_chan *chan,
+		dma_cookie_t cookie, struct dma_tx_state *txstate)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct virt_dma_desc *vd;
+	unsigned long flags;
+	enum dma_status ret;
+	size_t bytes = 0;
+
+	ret = dma_cookie_status(chan, cookie, txstate);
+	if (ret == DMA_COMPLETE)
+		return ret;
+
+	/*
+	 * There's no point calculating the residue if there's
+	 * no txstate to store the value.
+	 */
+	if (!txstate) {
+		if (plchan->state == PL08X_CHAN_PAUSED)
+			ret = DMA_PAUSED;
+		return ret;
+	}
+
+	spin_lock_irqsave(&plchan->vc.lock, flags);
+	ret = dma_cookie_status(chan, cookie, txstate);
+	if (ret != DMA_COMPLETE) {
+		vd = vchan_find_desc(&plchan->vc, cookie);
+		if (vd) {
+			/* On the issued list, so hasn't been processed yet */
+			struct pl08x_txd *txd = to_pl08x_txd(&vd->tx);
+			struct pl08x_sg *dsg;
+
+			list_for_each_entry(dsg, &txd->dsg_list, node)
+				bytes += dsg->len;
+		} else {
+			bytes = pl08x_getbytes_chan(plchan);
+		}
+	}
+	spin_unlock_irqrestore(&plchan->vc.lock, flags);
+
+	/*
+	 * This cookie not complete yet
+	 * Get number of bytes left in the active transactions and queue
+	 */
+	dma_set_residue(txstate, bytes);
+
+	if (plchan->state == PL08X_CHAN_PAUSED && ret == DMA_IN_PROGRESS)
+		ret = DMA_PAUSED;
+
+	/* Whether waiting or running, we're in progress */
+	return ret;
+}
+
+/* PrimeCell DMA extension */
+struct burst_table {
+	u32 burstwords;
+	u32 reg;
+};
+
+static const struct burst_table burst_sizes[] = {
+	{
+		.burstwords = 256,
+		.reg = PL080_BSIZE_256,
+	},
+	{
+		.burstwords = 128,
+		.reg = PL080_BSIZE_128,
+	},
+	{
+		.burstwords = 64,
+		.reg = PL080_BSIZE_64,
+	},
+	{
+		.burstwords = 32,
+		.reg = PL080_BSIZE_32,
+	},
+	{
+		.burstwords = 16,
+		.reg = PL080_BSIZE_16,
+	},
+	{
+		.burstwords = 8,
+		.reg = PL080_BSIZE_8,
+	},
+	{
+		.burstwords = 4,
+		.reg = PL080_BSIZE_4,
+	},
+	{
+		.burstwords = 0,
+		.reg = PL080_BSIZE_1,
+	},
+};
+
+/*
+ * Given the source and destination available bus masks, select which
+ * will be routed to each port.  We try to have source and destination
+ * on separate ports, but always respect the allowable settings.
+ */
+static u32 pl08x_select_bus(bool ftdmac020, u8 src, u8 dst)
+{
+	u32 cctl = 0;
+	u32 dst_ahb2;
+	u32 src_ahb2;
+
+	/* The FTDMAC020 use different bits to indicate src/dst bus */
+	if (ftdmac020) {
+		dst_ahb2 = FTDMAC020_LLI_DST_SEL;
+		src_ahb2 = FTDMAC020_LLI_SRC_SEL;
+	} else {
+		dst_ahb2 = PL080_CONTROL_DST_AHB2;
+		src_ahb2 = PL080_CONTROL_SRC_AHB2;
+	}
+
+	if (!(dst & PL08X_AHB1) || ((dst & PL08X_AHB2) && (src & PL08X_AHB1)))
+		cctl |= dst_ahb2;
+	if (!(src & PL08X_AHB1) || ((src & PL08X_AHB2) && !(dst & PL08X_AHB2)))
+		cctl |= src_ahb2;
+
+	//printk("this is debug dst = %x src = %x cctl = %x %s %s %d\n",dst,src,cctl,__FILE__,__func__,__LINE__);
+
+	return cctl;
+}
+
+static u32 pl08x_cctl(u32 cctl)
+{
+	cctl &= ~(PL080_CONTROL_SRC_AHB2 | PL080_CONTROL_DST_AHB2 |
+		  PL080_CONTROL_SRC_INCR | PL080_CONTROL_DST_INCR |
+		  PL080_CONTROL_PROT_MASK);
+
+	/* Access the cell in privileged mode, non-bufferable, non-cacheable */
+	return cctl | PL080_CONTROL_PROT_SYS;
+}
+
+static u32 pl08x_width(enum dma_slave_buswidth width)
+{
+	switch (width) {
+	case DMA_SLAVE_BUSWIDTH_1_BYTE:
+		return PL080_WIDTH_8BIT;
+	case DMA_SLAVE_BUSWIDTH_2_BYTES:
+		return PL080_WIDTH_16BIT;
+	case DMA_SLAVE_BUSWIDTH_4_BYTES:
+		return PL080_WIDTH_32BIT;
+	default:
+		return ~0;
+	}
+}
+
+static u32 pl08x_burst(u32 maxburst)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(burst_sizes); i++)
+		if (burst_sizes[i].burstwords <= maxburst)
+			break;
+
+	return burst_sizes[i].reg;
+}
+
+static u32 pl08x_get_cctl(struct pl08x_dma_chan *plchan,
+	enum dma_slave_buswidth addr_width, u32 maxburst)
+{
+	u32 width, burst, cctl = 0;
+
+	width = pl08x_width(addr_width);
+	if (width == ~0)
+		return ~0;
+
+	cctl |= width << PL080_CONTROL_SWIDTH_SHIFT;
+	cctl |= width << PL080_CONTROL_DWIDTH_SHIFT;
+
+	/*
+	 * If this channel will only request single transfers, set this
+	 * down to ONE element.  Also select one element if no maxburst
+	 * is specified.
+	 */
+	if (plchan->cd->single)
+		maxburst = 1;
+
+	burst = pl08x_burst(maxburst);
+	cctl |= burst << PL080_CONTROL_SB_SIZE_SHIFT;
+	cctl |= burst << PL080_CONTROL_DB_SIZE_SHIFT;
+
+	return pl08x_cctl(cctl);
+}
+
+/*
+ * Slave transactions callback to the slave device to allow
+ * synchronization of slave DMA signals with the DMAC enable
+ */
+static void pl08x_issue_pending(struct dma_chan *chan)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	unsigned long flags;
+
+	plchan->chan_id = chan->chan_id;
+
+	spin_lock_irqsave(&plchan->vc.lock, flags);
+	if (vchan_issue_pending(&plchan->vc)) {
+		if (!plchan->phychan && plchan->state != PL08X_CHAN_WAITING)
+			pl08x_phy_alloc_and_start(plchan);
+	}
+	spin_unlock_irqrestore(&plchan->vc.lock, flags);
+}
+
+static struct pl08x_txd *pl08x_get_txd(struct pl08x_dma_chan *plchan)
+{
+	struct pl08x_txd *txd = kzalloc(sizeof(*txd), GFP_NOWAIT);
+
+	if (txd)
+		INIT_LIST_HEAD(&txd->dsg_list);
+	return txd;
+}
+
+static u32 pl08x_memcpy_cctl(struct pl08x_driver_data *pl08x)
+{
+	u32 cctl = 0;
+
+	/* Conjure cctl */
+	switch (pl08x->pd->memcpy_burst_size) {
+	default:
+		dev_err(&pl08x->adev->dev,
+			"illegal burst size for memcpy, set to 1\n");
+		fallthrough;
+	case PL08X_BURST_SZ_1:
+		cctl |= PL080_BSIZE_1 << PL080_CONTROL_SB_SIZE_SHIFT |
+			PL080_BSIZE_1 << PL080_CONTROL_DB_SIZE_SHIFT;
+		break;
+	case PL08X_BURST_SZ_4:
+		cctl |= PL080_BSIZE_4 << PL080_CONTROL_SB_SIZE_SHIFT |
+			PL080_BSIZE_4 << PL080_CONTROL_DB_SIZE_SHIFT;
+		break;
+	case PL08X_BURST_SZ_8:
+		cctl |= PL080_BSIZE_8 << PL080_CONTROL_SB_SIZE_SHIFT |
+			PL080_BSIZE_8 << PL080_CONTROL_DB_SIZE_SHIFT;
+		break;
+	case PL08X_BURST_SZ_16:
+		cctl |= PL080_BSIZE_16 << PL080_CONTROL_SB_SIZE_SHIFT |
+			PL080_BSIZE_16 << PL080_CONTROL_DB_SIZE_SHIFT;
+		break;
+	case PL08X_BURST_SZ_32:
+		cctl |= PL080_BSIZE_32 << PL080_CONTROL_SB_SIZE_SHIFT |
+			PL080_BSIZE_32 << PL080_CONTROL_DB_SIZE_SHIFT;
+		break;
+	case PL08X_BURST_SZ_64:
+		cctl |= PL080_BSIZE_64 << PL080_CONTROL_SB_SIZE_SHIFT |
+			PL080_BSIZE_64 << PL080_CONTROL_DB_SIZE_SHIFT;
+		break;
+	case PL08X_BURST_SZ_128:
+		cctl |= PL080_BSIZE_128 << PL080_CONTROL_SB_SIZE_SHIFT |
+			PL080_BSIZE_128 << PL080_CONTROL_DB_SIZE_SHIFT;
+		break;
+	case PL08X_BURST_SZ_256:
+		cctl |= PL080_BSIZE_256 << PL080_CONTROL_SB_SIZE_SHIFT |
+			PL080_BSIZE_256 << PL080_CONTROL_DB_SIZE_SHIFT;
+		break;
+	}
+
+	switch (pl08x->pd->memcpy_bus_width) {
+	default:
+		dev_err(&pl08x->adev->dev,
+			"illegal bus width for memcpy, set to 8 bits\n");
+		fallthrough;
+	case PL08X_BUS_WIDTH_8_BITS:
+		cctl |= PL080_WIDTH_8BIT << PL080_CONTROL_SWIDTH_SHIFT |
+			PL080_WIDTH_8BIT << PL080_CONTROL_DWIDTH_SHIFT;
+		break;
+	case PL08X_BUS_WIDTH_16_BITS:
+		cctl |= PL080_WIDTH_16BIT << PL080_CONTROL_SWIDTH_SHIFT |
+			PL080_WIDTH_16BIT << PL080_CONTROL_DWIDTH_SHIFT;
+		break;
+	case PL08X_BUS_WIDTH_32_BITS:
+		cctl |= PL080_WIDTH_32BIT << PL080_CONTROL_SWIDTH_SHIFT |
+			PL080_WIDTH_32BIT << PL080_CONTROL_DWIDTH_SHIFT;
+		break;
+	}
+
+	/* Protection flags */
+	if (pl08x->pd->memcpy_prot_buff)
+		cctl |= PL080_CONTROL_PROT_BUFF;
+	if (pl08x->pd->memcpy_prot_cache)
+		cctl |= PL080_CONTROL_PROT_CACHE;
+
+	/* We are the kernel, so we are in privileged mode */
+	cctl |= PL080_CONTROL_PROT_SYS;
+
+	/* Both to be incremented or the code will break */
+	cctl |= PL080_CONTROL_SRC_INCR | PL080_CONTROL_DST_INCR;
+
+	if (pl08x->vd->dualmaster)
+		cctl |= pl08x_select_bus(false,
+					 pl08x->mem_buses,
+					 pl08x->mem_buses);
+
+	return cctl;
+}
+
+static u32 pl08x_ftdmac020_memcpy_cctl(struct pl08x_driver_data *pl08x)
+{
+	u32 cctl = 0;
+
+	/* Conjure cctl */
+	switch (pl08x->pd->memcpy_bus_width) {
+	default:
+		dev_err(&pl08x->adev->dev,
+			"illegal bus width for memcpy, set to 8 bits\n");
+		fallthrough;
+	case PL08X_BUS_WIDTH_8_BITS:
+		cctl |= PL080_WIDTH_8BIT << FTDMAC020_LLI_SRC_WIDTH_SHIFT |
+			PL080_WIDTH_8BIT << FTDMAC020_LLI_DST_WIDTH_SHIFT;
+		break;
+	case PL08X_BUS_WIDTH_16_BITS:
+		cctl |= PL080_WIDTH_16BIT << FTDMAC020_LLI_SRC_WIDTH_SHIFT |
+			PL080_WIDTH_16BIT << FTDMAC020_LLI_DST_WIDTH_SHIFT;
+		break;
+	case PL08X_BUS_WIDTH_32_BITS:
+		cctl |= PL080_WIDTH_32BIT << FTDMAC020_LLI_SRC_WIDTH_SHIFT |
+			PL080_WIDTH_32BIT << FTDMAC020_LLI_DST_WIDTH_SHIFT;
+		break;
+	}
+
+	/*
+	 * By default mask the TC IRQ on all LLIs, it will be unmasked on
+	 * the last LLI item by other code.
+	 */
+	cctl |= FTDMAC020_LLI_TC_MSK;
+
+	/*
+	 * Both to be incremented so leave bits FTDMAC020_LLI_SRCAD_CTL
+	 * and FTDMAC020_LLI_DSTAD_CTL as zero
+	 */
+	if (pl08x->vd->dualmaster)
+		cctl |= pl08x_select_bus(true,
+					 pl08x->mem_buses,
+					 pl08x->mem_buses);
+
+	return cctl;
+}
+
+/*
+ * Initialize a descriptor to be used by memcpy submit
+ */
+static struct dma_async_tx_descriptor *pl08x_prep_dma_memcpy(
+		struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
+		size_t len, unsigned long flags)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_txd *txd;
+	struct pl08x_sg *dsg;
+	int ret;
+	//printk("this is debug for lophyel %s %s %d\n",__FILE__,__func__,__LINE__);
+	txd = pl08x_get_txd(plchan);
+	if (!txd) {
+		dev_err(&pl08x->adev->dev,
+			"%s no memory for descriptor\n", __func__);
+		return NULL;
+	}
+	//printk("this is debug for lophyel %s %s %d\n",__FILE__,__func__,__LINE__);
+	dsg = kzalloc(sizeof(struct pl08x_sg), GFP_NOWAIT);
+	if (!dsg) {
+		pl08x_free_txd(pl08x, txd);
+		return NULL;
+	}
+	list_add_tail(&dsg->node, &txd->dsg_list);
+	//printk("this is debug for lophyel %s %s %d\n",__FILE__,__func__,__LINE__);
+	dsg->src_addr = src;
+	dsg->dst_addr = dest;
+	dsg->len = len;
+	if (pl08x->vd->ftdmac020) {
+		/* Writing CCFG zero ENABLES all interrupts */
+		txd->ccfg = 0;
+		txd->cctl = pl08x_ftdmac020_memcpy_cctl(pl08x);
+	} else {
+		txd->ccfg = PL080_CONFIG_ERR_IRQ_MASK |
+			PL080_CONFIG_TC_IRQ_MASK |
+			PL080_FLOW_MEM2MEM << PL080_CONFIG_FLOW_CONTROL_SHIFT;
+		txd->cctl = pl08x_memcpy_cctl(pl08x);
+	}
+	//printk("this is debug for lophyel %s %s %d\n",__FILE__,__func__,__LINE__);
+	ret = pl08x_fill_llis_for_desc(plchan->host, txd);
+	if (!ret) {
+		pl08x_free_txd(pl08x, txd);
+		return NULL;
+	}
+	//printk("this is debug for lophyel %s %s %d\n",__FILE__,__func__,__LINE__);
+	return vchan_tx_prep(&plchan->vc, &txd->vd, flags);
+}
+
+static struct pl08x_txd *pl08x_init_txd(
+		struct dma_chan *chan,
+		enum dma_transfer_direction direction,
+		dma_addr_t *slave_addr)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_txd *txd;
+	enum dma_slave_buswidth addr_width;
+	int ret, tmp;
+	u8 src_buses, dst_buses;
+	u32 maxburst, cctl;
+
+	txd = pl08x_get_txd(plchan);
+	if (!txd) {
+		dev_err(&pl08x->adev->dev, "%s no txd\n", __func__);
+		return NULL;
+	}
+
+	/*
+	 * Set up addresses, the PrimeCell configured address
+	 * will take precedence since this may configure the
+	 * channel target address dynamically at runtime.
+	 */
+	if (direction == DMA_MEM_TO_DEV) {
+		//printk("this is debug  %s %s %d\n",__FILE__,__func__,__LINE__);
+		cctl = PL080_CONTROL_SRC_INCR;
+		*slave_addr = plchan->cfg.dst_addr;
+		addr_width = plchan->cfg.dst_addr_width;
+		maxburst = plchan->cfg.dst_maxburst;
+		src_buses = pl08x->mem_buses;
+		dst_buses = plchan->cd->periph_buses;
+	} else if (direction == DMA_DEV_TO_MEM) {
+		//printk("this is debug  %s %s %d\n",__FILE__,__func__,__LINE__);
+		cctl = PL080_CONTROL_DST_INCR;
+		*slave_addr = plchan->cfg.src_addr;
+		addr_width = plchan->cfg.src_addr_width;
+		maxburst = plchan->cfg.src_maxburst;
+		src_buses = plchan->cd->periph_buses;
+		dst_buses = pl08x->mem_buses;
+	} else {
+		pl08x_free_txd(pl08x, txd);
+		dev_err(&pl08x->adev->dev,
+			"%s direction unsupported\n", __func__);
+		return NULL;
+	}
+
+	cctl |= pl08x_get_cctl(plchan, addr_width, maxburst);
+	if (cctl == ~0) {
+		pl08x_free_txd(pl08x, txd);
+		dev_err(&pl08x->adev->dev,
+			"DMA slave configuration botched?\n");
+		return NULL;
+	}
+
+	txd->cctl = cctl | pl08x_select_bus(false, src_buses, dst_buses);
+
+	if (plchan->cfg.device_fc)
+		tmp = (direction == DMA_MEM_TO_DEV) ? PL080_FLOW_MEM2PER_PER :
+			PL080_FLOW_PER2MEM_PER;
+	else
+		tmp = (direction == DMA_MEM_TO_DEV) ? PL080_FLOW_MEM2PER :
+			PL080_FLOW_PER2MEM;
+
+	txd->ccfg = PL080_CONFIG_ERR_IRQ_MASK |
+		PL080_CONFIG_TC_IRQ_MASK |
+		tmp << PL080_CONFIG_FLOW_CONTROL_SHIFT;
+	//printk("this is debug cctl = %x ccfg = %x %s %s %d\n",txd->cctl,txd->ccfg,__FILE__,__func__,__LINE__);
+
+	ret = pl08x_request_mux(plchan);
+	if (ret < 0) {
+		pl08x_free_txd(pl08x, txd);
+		dev_dbg(&pl08x->adev->dev,
+			"unable to mux for transfer on %s due to platform restrictions\n",
+			plchan->name);
+		return NULL;
+	}
+
+	dev_dbg(&pl08x->adev->dev, "allocated DMA request signal %d for xfer on %s\n",
+		 plchan->signal, plchan->name);
+
+	/* Assign the flow control signal to this channel */
+	if (direction == DMA_MEM_TO_DEV)
+		txd->ccfg |= plchan->signal << PL080_CONFIG_DST_SEL_SHIFT;
+	else
+		txd->ccfg |= plchan->signal << PL080_CONFIG_SRC_SEL_SHIFT;
+
+	return txd;
+}
+
+static int pl08x_tx_add_sg(struct pl08x_txd *txd,
+			   enum dma_transfer_direction direction,
+			   dma_addr_t slave_addr,
+			   dma_addr_t buf_addr,
+			   unsigned int len)
+{
+	struct pl08x_sg *dsg;
+
+	dsg = kzalloc(sizeof(struct pl08x_sg), GFP_NOWAIT);
+	if (!dsg)
+		return -ENOMEM;
+
+	list_add_tail(&dsg->node, &txd->dsg_list);
+
+	dsg->len = len;
+	if (direction == DMA_MEM_TO_DEV) {
+		dsg->src_addr = buf_addr;
+		dsg->dst_addr = slave_addr;
+	} else {
+		dsg->src_addr = slave_addr;
+		dsg->dst_addr = buf_addr;
+	}
+
+	return 0;
+}
+
+static struct dma_async_tx_descriptor *pl08x_prep_slave_sg(
+		struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_transfer_direction direction,
+		unsigned long flags, void *context)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_txd *txd;
+	struct scatterlist *sg;
+	int ret, tmp;
+	dma_addr_t slave_addr;
+
+	dev_dbg(&pl08x->adev->dev, "%s prepare transaction of %d bytes from %s\n",
+			__func__, sg_dma_len(sgl), plchan->name);
+
+	txd = pl08x_init_txd(chan, direction, &slave_addr);
+	if (!txd)
+		return NULL;
+
+	for_each_sg(sgl, sg, sg_len, tmp) {
+		ret = pl08x_tx_add_sg(txd, direction, slave_addr,
+				      sg_dma_address(sg),
+				      sg_dma_len(sg));
+		/*
+		printk("this is debug direction = %x slave_addr = %x addr = %x len = %x %s %s %d\n",
+		       direction,slave_addr,sg_dma_address(sg),sg_dma_len(sg),
+		       __FILE__,__func__,__LINE__);
+		*/
+		if (ret) {
+			pl08x_release_mux(plchan);
+			pl08x_free_txd(pl08x, txd);
+			dev_err(&pl08x->adev->dev, "%s no mem for pl080 sg\n",
+					__func__);
+			return NULL;
+		}
+	}
+
+	ret = pl08x_fill_llis_for_desc(plchan->host, txd);
+	if (!ret) {
+		pl08x_release_mux(plchan);
+		pl08x_free_txd(pl08x, txd);
+		return NULL;
+	}
+
+	return vchan_tx_prep(&plchan->vc, &txd->vd, flags);
+}
+
+static struct dma_async_tx_descriptor *pl08x_prep_dma_cyclic(
+		struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,
+		size_t period_len, enum dma_transfer_direction direction,
+		unsigned long flags)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	struct pl08x_txd *txd;
+	int ret, tmp;
+	dma_addr_t slave_addr;
+
+	dev_dbg(&pl08x->adev->dev,
+		"%s prepare cyclic transaction of %zd/%zd bytes %s %s\n",
+		__func__, period_len, buf_len,
+		direction == DMA_MEM_TO_DEV ? "to" : "from",
+		plchan->name);
+
+	txd = pl08x_init_txd(chan, direction, &slave_addr);
+	if (!txd)
+		return NULL;
+
+	txd->cyclic = true;
+	txd->cctl |= PL080_CONTROL_TC_IRQ_EN;
+	for (tmp = 0; tmp < buf_len; tmp += period_len) {
+		ret = pl08x_tx_add_sg(txd, direction, slave_addr,
+				      buf_addr + tmp, period_len);
+		if (ret) {
+			pl08x_release_mux(plchan);
+			pl08x_free_txd(pl08x, txd);
+			return NULL;
+		}
+	}
+
+	ret = pl08x_fill_llis_for_desc(plchan->host, txd);
+	if (!ret) {
+		pl08x_release_mux(plchan);
+		pl08x_free_txd(pl08x, txd);
+		return NULL;
+	}
+
+	return vchan_tx_prep(&plchan->vc, &txd->vd, flags);
+}
+
+static int pl08x_config(struct dma_chan *chan,
+			struct dma_slave_config *config)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+
+	if (!plchan->slave)
+		return -EINVAL;
+
+	/* Reject definitely invalid configurations */
+	if (config->src_addr_width == DMA_SLAVE_BUSWIDTH_8_BYTES ||
+	    config->dst_addr_width == DMA_SLAVE_BUSWIDTH_8_BYTES)
+		return -EINVAL;
+
+	if (config->device_fc && pl08x->vd->pl080s) {
+		dev_err(&pl08x->adev->dev,
+			"%s: PL080S does not support peripheral flow control\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	/*
+	printk("this is debug chan = %x chan-id = %d plchan = %x plchan->signal = %d %s %s %d\n",
+	       chan,chan->chan_id,plchan,plchan->signal,__FILE__,__func__,__LINE__);
+	*/
+	plchan->cfg = *config;
+
+	return 0;
+}
+
+static int pl08x_terminate_all(struct dma_chan *chan)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	struct pl08x_driver_data *pl08x = plchan->host;
+	unsigned long flags;
+
+	spin_lock_irqsave(&plchan->vc.lock, flags);
+	if (!plchan->phychan && !plchan->at) {
+		spin_unlock_irqrestore(&plchan->vc.lock, flags);
+		return 0;
+	}
+
+	plchan->state = PL08X_CHAN_IDLE;
+
+	if (plchan->phychan) {
+		/*
+		 * Mark physical channel as free and free any slave
+		 * signal
+		 */
+		pl08x_phy_free(plchan);
+	}
+	/* Dequeue jobs and free LLIs */
+	if (plchan->at) {
+		vchan_terminate_vdesc(&plchan->at->vd);
+		plchan->at = NULL;
+	}
+	/* Dequeue jobs not yet fired as well */
+	pl08x_free_txd_list(pl08x, plchan);
+
+	spin_unlock_irqrestore(&plchan->vc.lock, flags);
+
+	return 0;
+}
+
+static void pl08x_synchronize(struct dma_chan *chan)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+
+	printk("this is debug %s %s %d \n",__FILE__,__func__,__LINE__);
+	vchan_synchronize(&plchan->vc);
+}
+
+static int pl08x_pause(struct dma_chan *chan)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	unsigned long flags;
+
+	/*
+	 * Anything succeeds on channels with no physical allocation and
+	 * no queued transfers.
+	 */
+	printk("this is debug %s %s %d \n",__FILE__,__func__,__LINE__);
+	spin_lock_irqsave(&plchan->vc.lock, flags);
+	if (!plchan->phychan && !plchan->at) {
+		spin_unlock_irqrestore(&plchan->vc.lock, flags);
+		return 0;
+	}
+
+	pl08x_pause_phy_chan(plchan->phychan);
+	plchan->state = PL08X_CHAN_PAUSED;
+
+	spin_unlock_irqrestore(&plchan->vc.lock, flags);
+
+	return 0;
+}
+
+static int pl08x_resume(struct dma_chan *chan)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+	unsigned long flags;
+
+	/*
+	 * Anything succeeds on channels with no physical allocation and
+	 * no queued transfers.
+	 */
+	printk("this is debug %s %s %d \n",__FILE__,__func__,__LINE__);
+	spin_lock_irqsave(&plchan->vc.lock, flags);
+	if (!plchan->phychan && !plchan->at) {
+		spin_unlock_irqrestore(&plchan->vc.lock, flags);
+		return 0;
+	}
+
+	pl08x_resume_phy_chan(plchan->phychan);
+	plchan->state = PL08X_CHAN_RUNNING;
+
+	spin_unlock_irqrestore(&plchan->vc.lock, flags);
+
+	return 0;
+}
+#if 0
+bool pl08x_filter_id(struct dma_chan *chan, void *chan_id)
+{
+	struct pl08x_dma_chan *plchan;
+	char *name = chan_id;
+
+	/* Reject channels for devices not bound to this driver */
+	if (chan->device->dev->driver != &pl08x_amba_driver.drv)
+		return false;
+
+	plchan = to_pl08x_chan(chan);
+
+	/* Check that the channel is not taken! */
+	if (!strcmp(plchan->name, name))
+		return true;
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(pl08x_filter_id);
+#endif
+static bool pl08x_filter_fn(struct dma_chan *chan, void *chan_id)
+{
+	struct pl08x_dma_chan *plchan = to_pl08x_chan(chan);
+
+	return plchan->cd == chan_id;
+}
+
+/*
+ * Just check that the device is there and active
+ * TODO: turn this bit on/off depending on the number of physical channels
+ * actually used, if it is zero... well shut it off. That will save some
+ * power. Cut the clock at the same time.
+ */
+static void pl08x_ensure_on(struct pl08x_driver_data *pl08x)
+{
+	/* The Nomadik variant does not have the config register */
+	if (pl08x->vd->nomadik)
+		return;
+	/* The FTDMAC020 variant does this in another register */
+	if (pl08x->vd->ftdmac020) {
+		writel(PL080_CONFIG_ENABLE, pl08x->base + FTDMAC020_CSR);
+		return;
+	}
+	writel(PL080_CONFIG_ENABLE, pl08x->base + PL080_CONFIG);
+}
+
+static irqreturn_t pl08x_irq(int irq, void *dev)
+{
+	struct pl08x_driver_data *pl08x = dev;
+	u32 mask = 0, err, tc, i;
+
+	/* check & clear - ERR & TC interrupts */
+	err = readl(pl08x->base + PL080_ERR_STATUS);
+	if (err) {
+		dev_err(&pl08x->adev->dev, "%s error interrupt, register value 0x%08x\n",
+			__func__, err);
+		writel(err, pl08x->base + PL080_ERR_CLEAR);
+	}
+	tc = readl(pl08x->base + PL080_TC_STATUS);
+	if (tc) {
+		writel(tc, pl08x->base + PL080_TC_CLEAR);
+	}
+
+	if (!err && !tc) {
+		return IRQ_NONE;
+	}
+
+	for (i = 0; i < pl08x->vd->channels; i++) {
+		if ((BIT(i) & err) || (BIT(i) & tc)) {
+			/* Locate physical channel */
+			struct pl08x_phy_chan *phychan = &pl08x->phy_chans[i];
+			struct pl08x_dma_chan *plchan = phychan->serving;
+			struct pl08x_txd *tx;
+
+			if (!plchan) {
+				dev_err(&pl08x->adev->dev,
+					"%s Error TC interrupt on unused channel: 0x%08x\n",
+					__func__, i);
+				continue;
+			}
+
+			spin_lock(&plchan->vc.lock);
+			tx = plchan->at;
+			if (tx && tx->cyclic) {
+				vchan_cyclic_callback(&tx->vd);
+			} else if (tx) {
+				plchan->at = NULL;
+				/*
+				 * This descriptor is done, release its mux
+				 * reservation.
+				 */
+				pl08x_release_mux(plchan);
+				tx->done = true;
+				vchan_cookie_complete(&tx->vd);
+
+				/*
+				 * And start the next descriptor (if any),
+				 * otherwise free this channel.
+				 */
+				if (vchan_next_desc(&plchan->vc))
+					pl08x_start_next_txd(plchan);
+				else
+					pl08x_phy_free(plchan);
+			}
+			spin_unlock(&plchan->vc.lock);
+
+			mask |= BIT(i);
+		}
+	}
+
+	return mask ? IRQ_HANDLED : IRQ_NONE;
+}
+
+static void pl08x_dma_slave_init(struct pl08x_dma_chan *chan)
+{
+	chan->slave = true;
+	chan->name = chan->cd->bus_id;
+	chan->cfg.src_addr = chan->cd->addr;
+	chan->cfg.dst_addr = chan->cd->addr;
+}
+
+/*
+ * Initialise the DMAC memcpy/slave channels.
+ * Make a local wrapper to hold required data
+ */
+static int pl08x_dma_init_virtual_channels(struct pl08x_driver_data *pl08x,
+		struct dma_device *dmadev, unsigned int channels, bool slave)
+{
+	struct pl08x_dma_chan *chan;
+	int i;
+
+	INIT_LIST_HEAD(&dmadev->channels);
+
+	/*
+	 * Register as many many memcpy as we have physical channels,
+	 * we won't always be able to use all but the code will have
+	 * to cope with that situation.
+	 */
+	for (i = 0; i < channels; i++) {
+		chan = kzalloc(sizeof(*chan), GFP_KERNEL);
+		if (!chan)
+			return -ENOMEM;
+
+		chan->host = pl08x;
+		chan->state = PL08X_CHAN_IDLE;
+		chan->signal = -1;
+
+		if (slave) {
+			chan->cd = &pl08x->pd->slave_channels[i];
+			/*
+			 * Some implementations have muxed signals, whereas some
+			 * use a mux in front of the signals and need dynamic
+			 * assignment of signals.
+			 */
+			chan->signal = i;
+			pl08x_dma_slave_init(chan);
+		} else {
+			chan->cd = kzalloc(sizeof(*chan->cd), GFP_KERNEL);
+			if (!chan->cd) {
+				kfree(chan);
+				return -ENOMEM;
+			}
+			chan->cd->bus_id = "memcpy";
+			chan->cd->periph_buses = pl08x->pd->mem_buses;
+			chan->name = kasprintf(GFP_KERNEL, "memcpy%d", i);
+			if (!chan->name) {
+				kfree(chan->cd);
+				kfree(chan);
+				return -ENOMEM;
+			}
+		}
+		dev_dbg(&pl08x->adev->dev,
+			 "initialize virtual channel \"%s\"\n",
+			 chan->name);
+
+		chan->vc.desc_free = pl08x_desc_free;
+		vchan_init(&chan->vc, dmadev);
+	}
+	dev_info(&pl08x->adev->dev, "initialized %d virtual %s channels\n",
+		 i, slave ? "slave" : "memcpy");
+	return i;
+}
+
+static void pl08x_free_virtual_channels(struct dma_device *dmadev)
+{
+	struct pl08x_dma_chan *chan = NULL;
+	struct pl08x_dma_chan *next;
+
+	list_for_each_entry_safe(chan,
+				 next, &dmadev->channels, vc.chan.device_node) {
+		list_del(&chan->vc.chan.device_node);
+		kfree(chan);
+	}
+}
+
+#ifdef CONFIG_DEBUG_FS
+static const char *pl08x_state_str(enum pl08x_dma_chan_state state)
+{
+	switch (state) {
+	case PL08X_CHAN_IDLE:
+		return "idle";
+	case PL08X_CHAN_RUNNING:
+		return "running";
+	case PL08X_CHAN_PAUSED:
+		return "paused";
+	case PL08X_CHAN_WAITING:
+		return "waiting";
+	default:
+		break;
+	}
+	return "UNKNOWN STATE";
+}
+
+static int pl08x_debugfs_show(struct seq_file *s, void *data)
+{
+	struct pl08x_driver_data *pl08x = s->private;
+	struct pl08x_dma_chan *chan;
+	struct pl08x_phy_chan *ch;
+	unsigned long flags;
+	int i;
+
+	seq_printf(s, "PL08x physical channels:\n");
+	seq_printf(s, "CHANNEL:\tUSER:\n");
+	seq_printf(s, "--------\t-----\n");
+	for (i = 0; i < pl08x->vd->channels; i++) {
+		struct pl08x_dma_chan *virt_chan;
+
+		ch = &pl08x->phy_chans[i];
+
+		spin_lock_irqsave(&ch->lock, flags);
+		virt_chan = ch->serving;
+
+		seq_printf(s, "%d\t\t%s%s\n",
+			   ch->id,
+			   virt_chan ? virt_chan->name : "(none)",
+			   ch->locked ? " LOCKED" : "");
+
+		spin_unlock_irqrestore(&ch->lock, flags);
+	}
+
+	seq_printf(s, "\nPL08x virtual memcpy channels:\n");
+	seq_printf(s, "CHANNEL:\tSTATE:\n");
+	seq_printf(s, "--------\t------\n");
+	list_for_each_entry(chan, &pl08x->memcpy.channels, vc.chan.device_node) {
+		seq_printf(s, "%s\t\t%s\n", chan->name,
+			   pl08x_state_str(chan->state));
+	}
+
+	if (pl08x->has_slave) {
+		seq_printf(s, "\nPL08x virtual slave channels:\n");
+		seq_printf(s, "CHANNEL:\tSTATE:\n");
+		seq_printf(s, "--------\t------\n");
+		list_for_each_entry(chan, &pl08x->slave.channels,
+				    vc.chan.device_node) {
+			seq_printf(s, "%s\t\t%s\n", chan->name,
+				   pl08x_state_str(chan->state));
+		}
+	}
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(pl08x_debugfs);
+
+static void init_pl08x_debugfs(struct pl08x_driver_data *pl08x)
+{
+	/* Expose a simple debugfs interface to view all clocks */
+	debugfs_create_file(dev_name(&pl08x->adev->dev), S_IFREG | S_IRUGO,
+			    NULL, pl08x, &pl08x_debugfs_fops);
+}
+
+#else
+static inline void init_pl08x_debugfs(struct pl08x_driver_data *pl08x)
+{
+}
+#endif
+
+#ifdef CONFIG_OF
+static struct dma_chan *pl08x_find_chan_id(struct pl08x_driver_data *pl08x,
+					 u32 id)
+{
+	struct pl08x_dma_chan *chan;
+
+	/* Trying to get a slave channel from something with no slave support */
+	if (!pl08x->has_slave)
+		return NULL;
+
+	list_for_each_entry(chan, &pl08x->slave.channels, vc.chan.device_node) {
+		if (chan->signal == id)
+			return &chan->vc.chan;
+	}
+
+	return NULL;
+}
+
+static struct dma_chan *pl08x_of_xlate(struct of_phandle_args *dma_spec,
+				       struct of_dma *ofdma)
+{
+	struct pl08x_driver_data *pl08x = ofdma->of_dma_data;
+	struct dma_chan *dma_chan;
+	struct pl08x_dma_chan *plchan;
+
+	if (!pl08x)
+		return NULL;
+
+	if (dma_spec->args_count != 2) {
+		dev_err(&pl08x->adev->dev,
+			"DMA channel translation requires two cells\n");
+		return NULL;
+	}
+
+	dma_chan = pl08x_find_chan_id(pl08x, dma_spec->args[0]);
+	if (!dma_chan) {
+		dev_err(&pl08x->adev->dev,
+			"DMA slave channel not found\n");
+		return NULL;
+	}
+
+	plchan = to_pl08x_chan(dma_chan);
+	dev_dbg(&pl08x->adev->dev,
+		"translated channel for signal %d\n",
+		dma_spec->args[0]);
+
+	/* Augment channel data for applicable AHB buses */
+	plchan->cd->periph_buses = dma_spec->args[1];
+	return dma_get_slave_channel(dma_chan);
+}
+
+static int pl08x_of_probe(struct platform_device *adev,
+			  struct pl08x_driver_data *pl08x,
+			  struct device_node *np)
+{
+	struct pl08x_platform_data *pd;
+	struct pl08x_channel_data *chanp = NULL;
+	u32 val;
+	int ret;
+	int i;
+
+	pd = devm_kzalloc(&adev->dev, sizeof(*pd), GFP_KERNEL);
+	if (!pd)
+		return -ENOMEM;
+
+	/* Eligible bus masters for fetching LLIs */
+	if (of_property_read_bool(np, "lli-bus-interface-ahb1"))
+		pd->lli_buses |= PL08X_AHB1;
+	if (of_property_read_bool(np, "lli-bus-interface-ahb2"))
+		pd->lli_buses |= PL08X_AHB2;
+	if (!pd->lli_buses) {
+		dev_info(&adev->dev, "no bus masters for LLIs stated, assume all\n");
+		pd->lli_buses |= PL08X_AHB1 | PL08X_AHB2;
+	}
+
+	/* Eligible bus masters for memory access */
+	if (of_property_read_bool(np, "mem-bus-interface-ahb1"))
+		pd->mem_buses |= PL08X_AHB1;
+	if (of_property_read_bool(np, "mem-bus-interface-ahb2"))
+		pd->mem_buses |= PL08X_AHB2;
+	if (!pd->mem_buses) {
+		dev_info(&adev->dev, "no bus masters for memory stated, assume all\n");
+		pd->mem_buses |= PL08X_AHB1 | PL08X_AHB2;
+	}
+
+	/* Parse the memcpy channel properties */
+	ret = of_property_read_u32(np, "memcpy-burst-size", &val);
+	if (ret) {
+		dev_info(&adev->dev, "no memcpy burst size specified, using 1 byte\n");
+		val = 1;
+	}
+	switch (val) {
+	default:
+		dev_err(&adev->dev, "illegal burst size for memcpy, set to 1\n");
+		fallthrough;
+	case 1:
+		pd->memcpy_burst_size = PL08X_BURST_SZ_1;
+		break;
+	case 4:
+		pd->memcpy_burst_size = PL08X_BURST_SZ_4;
+		break;
+	case 8:
+		pd->memcpy_burst_size = PL08X_BURST_SZ_8;
+		break;
+	case 16:
+		pd->memcpy_burst_size = PL08X_BURST_SZ_16;
+		break;
+	case 32:
+		pd->memcpy_burst_size = PL08X_BURST_SZ_32;
+		break;
+	case 64:
+		pd->memcpy_burst_size = PL08X_BURST_SZ_64;
+		break;
+	case 128:
+		pd->memcpy_burst_size = PL08X_BURST_SZ_128;
+		break;
+	case 256:
+		pd->memcpy_burst_size = PL08X_BURST_SZ_256;
+		break;
+	}
+
+	ret = of_property_read_u32(np, "memcpy-bus-width", &val);
+	if (ret) {
+		dev_info(&adev->dev, "no memcpy bus width specified, using 8 bits\n");
+		val = 8;
+	}
+	switch (val) {
+	default:
+		dev_err(&adev->dev, "illegal bus width for memcpy, set to 8 bits\n");
+		fallthrough;
+	case 8:
+		pd->memcpy_bus_width = PL08X_BUS_WIDTH_8_BITS;
+		break;
+	case 16:
+		pd->memcpy_bus_width = PL08X_BUS_WIDTH_16_BITS;
+		break;
+	case 32:
+		pd->memcpy_bus_width = PL08X_BUS_WIDTH_32_BITS;
+		break;
+	}
+
+	/*
+	 * Allocate channel data for all possible slave channels (one
+	 * for each possible signal), channels will then be allocated
+	 * for a device and have it's AHB interfaces set up at
+	 * translation time.
+	 */
+	if (pl08x->vd->signals) {
+		chanp = devm_kcalloc(&adev->dev,
+				     pl08x->vd->signals,
+				     sizeof(struct pl08x_channel_data),
+				     GFP_KERNEL);
+		if (!chanp)
+			return -ENOMEM;
+
+		pd->slave_channels = chanp;
+		for (i = 0; i < pl08x->vd->signals; i++) {
+			/*
+			 * chanp->periph_buses will be assigned at translation
+			 */
+			chanp->bus_id = kasprintf(GFP_KERNEL, "slave%d", i);
+			chanp++;
+		}
+		pd->num_slave_channels = pl08x->vd->signals;
+	}
+
+	pl08x->pd = pd;
+
+	return of_dma_controller_register(adev->dev.of_node, pl08x_of_xlate,
+					  pl08x);
+}
+#else
+static inline int pl08x_of_probe(struct platform_device *adev,
+				 struct pl08x_driver_data *pl08x,
+				 struct device_node *np)
+{
+	return -EINVAL;
+}
+#endif
+
+static int pl08x_probe(struct platform_device *adev) //, const struct amba_id *id)
+{
+	struct pl08x_driver_data *pl08x;
+	struct vendor_data *vd;
+	struct device_node *np = adev->dev.of_node;
+	struct resource *res;
+	u32 tsfr_size;
+	int irq, ret = 0;
+	int i;
+
+	//printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+#if 0
+	ret = amba_request_regions(adev, NULL);
+	if (ret){
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		return ret;
+	}
+#endif
+	/* Ensure that we can do DMA */
+	ret = dma_set_mask_and_coherent(&adev->dev, DMA_BIT_MASK(32));
+	if (ret){
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		return ret;
+	}
+
+	/* Create the driver state holder */
+	pl08x = kzalloc(sizeof(*pl08x), GFP_KERNEL);
+	if (!pl08x) {
+		ret = -ENOMEM;
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		return ret;
+	}
+
+	/* Assign useful pointers to the driver state */
+	pl08x->adev = adev;
+	vd = of_device_get_match_data(&adev->dev);
+	if(!vd)
+		return -ENODEV;
+	pl08x->vd = vd;
+
+	res = platform_get_resource_byname(adev, IORESOURCE_MEM, "sec_dma");
+	pl08x->base = devm_ioremap_resource(&adev->dev, res);
+	if (!pl08x->base) {
+		ret = -ENOMEM;
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		goto out_no_ioremap;
+	}
+
+	if (vd->ftdmac020) {
+		u32 val;
+
+		val = readl(pl08x->base + FTDMAC020_REVISION);
+		dev_dbg(&pl08x->adev->dev, "FTDMAC020 %d.%d rel %d\n",
+			 (val >> 16) & 0xff, (val >> 8) & 0xff, val & 0xff);
+		val = readl(pl08x->base + FTDMAC020_FEATURE);
+		dev_dbg(&pl08x->adev->dev, "FTDMAC020 %d channels, "
+			 "%s built-in bridge, %s, %s linked lists\n",
+			 (val >> 12) & 0x0f,
+			 (val & BIT(10)) ? "no" : "has",
+			 (val & BIT(9)) ? "AHB0 and AHB1" : "AHB0",
+			 (val & BIT(8)) ? "supports" : "does not support");
+
+		/* Vendor data from feature register */
+		if (!(val & BIT(8)))
+			dev_warn(&pl08x->adev->dev,
+				 "linked lists not supported, required\n");
+		vd->channels = (val >> 12) & 0x0f;
+		vd->dualmaster = !!(val & BIT(9));
+	}
+
+	/* Initialize memcpy engine */
+	dma_cap_set(DMA_MEMCPY, pl08x->memcpy.cap_mask);
+	pl08x->memcpy.dev = &adev->dev;
+	pl08x->memcpy.device_free_chan_resources = pl08x_free_chan_resources;
+	pl08x->memcpy.device_prep_dma_memcpy = pl08x_prep_dma_memcpy;
+	pl08x->memcpy.device_prep_dma_interrupt = pl08x_prep_dma_interrupt;
+	pl08x->memcpy.device_tx_status = pl08x_dma_tx_status;
+	pl08x->memcpy.device_issue_pending = pl08x_issue_pending;
+	pl08x->memcpy.device_config = pl08x_config;
+	pl08x->memcpy.device_pause = pl08x_pause;
+	pl08x->memcpy.device_resume = pl08x_resume;
+	pl08x->memcpy.device_terminate_all = pl08x_terminate_all;
+	pl08x->memcpy.device_synchronize = pl08x_synchronize;
+	pl08x->memcpy.src_addr_widths = PL80X_DMA_BUSWIDTHS;
+	pl08x->memcpy.dst_addr_widths = PL80X_DMA_BUSWIDTHS;
+	pl08x->memcpy.directions = BIT(DMA_MEM_TO_MEM);
+	pl08x->memcpy.residue_granularity = DMA_RESIDUE_GRANULARITY_SEGMENT;
+	if (vd->ftdmac020)
+		pl08x->memcpy.copy_align = DMAENGINE_ALIGN_4_BYTES;
+
+
+	/*
+	 * Initialize slave engine, if the block has no signals, that means
+	 * we have no slave support.
+	 */
+	if (vd->signals) {
+		pl08x->has_slave = true;
+		dma_cap_set(DMA_SLAVE, pl08x->slave.cap_mask);
+		dma_cap_set(DMA_CYCLIC, pl08x->slave.cap_mask);
+		pl08x->slave.dev = &adev->dev;
+		pl08x->slave.device_free_chan_resources =
+			pl08x_free_chan_resources;
+		pl08x->slave.device_prep_dma_interrupt =
+			pl08x_prep_dma_interrupt;
+		pl08x->slave.device_tx_status = pl08x_dma_tx_status;
+		pl08x->slave.device_issue_pending = pl08x_issue_pending;
+		pl08x->slave.device_prep_slave_sg = pl08x_prep_slave_sg;
+		pl08x->slave.device_prep_dma_cyclic = pl08x_prep_dma_cyclic;
+		pl08x->slave.device_config = pl08x_config;
+		pl08x->slave.device_pause = pl08x_pause;
+		pl08x->slave.device_resume = pl08x_resume;
+		pl08x->slave.device_terminate_all = pl08x_terminate_all;
+		pl08x->slave.device_synchronize = pl08x_synchronize;
+		pl08x->slave.src_addr_widths = PL80X_DMA_BUSWIDTHS;
+		pl08x->slave.dst_addr_widths = PL80X_DMA_BUSWIDTHS;
+		pl08x->slave.directions =
+			BIT(DMA_DEV_TO_MEM) | BIT(DMA_MEM_TO_DEV);
+		pl08x->slave.residue_granularity =
+			DMA_RESIDUE_GRANULARITY_SEGMENT;
+	}
+
+	/* Get the platform data */
+	pl08x->pd = dev_get_platdata(&adev->dev);
+	if (!pl08x->pd) {
+		if (np) {
+			ret = pl08x_of_probe(adev, pl08x, np);
+			if (ret) {
+				printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+				goto out_no_platdata;
+			}
+		} else {
+			printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+			dev_err(&adev->dev, "no platform data supplied\n");
+			ret = -EINVAL;
+			goto out_no_platdata;
+		}
+	} else {
+		pl08x->slave.filter.map = pl08x->pd->slave_map;
+		pl08x->slave.filter.mapcnt = pl08x->pd->slave_map_len;
+		pl08x->slave.filter.fn = pl08x_filter_fn;
+	}
+
+	/* By default, AHB1 only.  If dualmaster, from platform */
+	pl08x->lli_buses = PL08X_AHB1;
+	pl08x->mem_buses = PL08X_AHB1;
+	if (pl08x->vd->dualmaster) {
+		pl08x->lli_buses = pl08x->pd->lli_buses;
+		pl08x->mem_buses = pl08x->pd->mem_buses;
+	}
+
+	if (vd->pl080s)
+		pl08x->lli_words = PL080S_LLI_WORDS;
+	else
+		pl08x->lli_words = PL080_LLI_WORDS;
+	tsfr_size = MAX_NUM_TSFR_LLIS * pl08x->lli_words * sizeof(u32);
+
+	/* A DMA memory pool for LLIs, align on 1-byte boundary */
+	pl08x->pool = dma_pool_create(DRIVER_NAME, &pl08x->adev->dev,
+						tsfr_size, PL08X_ALIGN, 0);
+	if (!pl08x->pool) {
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		ret = -ENOMEM;
+		goto out_no_lli_pool;
+	}
+
+	/* Turn on the PL08x */
+	pl08x_ensure_on(pl08x);
+
+	/* Clear any pending interrupts */
+	if (vd->ftdmac020)
+		/* This variant has error IRQs in bits 16-19 */
+		writel(0x0000FFFF, pl08x->base + PL080_ERR_CLEAR);
+	else
+		writel(0x000000FF, pl08x->base + PL080_ERR_CLEAR);
+	writel(0x000000FF, pl08x->base + PL080_TC_CLEAR);
+
+	/* Attach the interrupt handler */
+	irq = platform_get_irq(adev, 0);
+	if (irq < 0) {
+		dev_err(&adev->dev, "Cannot get IRQ resource\n");
+		return irq;
+	}
+
+	ret = request_irq(irq, pl08x_irq, 0, DRIVER_NAME, pl08x);
+	if (ret) {
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		dev_err(&adev->dev, "%s failed to request interrupt %d\n",
+			__func__, irq);
+		goto out_no_irq;
+	}
+
+	/* Initialize physical channels */
+	pl08x->phy_chans = kzalloc((vd->channels * sizeof(*pl08x->phy_chans)),
+			GFP_KERNEL);
+	if (!pl08x->phy_chans) {
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		ret = -ENOMEM;
+		goto out_no_phychans;
+	}
+
+	for (i = 0; i < vd->channels; i++) {
+		struct pl08x_phy_chan *ch = &pl08x->phy_chans[i];
+
+		ch->id = i;
+		ch->base = pl08x->base + PL080_Cx_BASE(i);
+		if (vd->ftdmac020) {
+			/* FTDMA020 has a special channel busy register */
+			ch->reg_busy = ch->base + FTDMAC020_CH_BUSY;
+			ch->reg_config = ch->base + FTDMAC020_CH_CFG;
+			ch->reg_control = ch->base + FTDMAC020_CH_CSR;
+			ch->reg_src = ch->base + FTDMAC020_CH_SRC_ADDR;
+			ch->reg_dst = ch->base + FTDMAC020_CH_DST_ADDR;
+			ch->reg_lli = ch->base + FTDMAC020_CH_LLP;
+			ch->ftdmac020 = true;
+		} else {
+			printk("this is debug i = %d  ch->base = %x  %s %s %d\n",i,ch->base,__FILE__,__func__,__LINE__);
+			ch->reg_config = ch->base + vd->config_offset;
+			ch->reg_control = ch->base + PL080_CH_CONTROL;
+			ch->reg_src = ch->base + PL080_CH_SRC_ADDR;
+			ch->reg_dst = ch->base + PL080_CH_DST_ADDR;
+			ch->reg_lli = ch->base + PL080_CH_LLI;
+		}
+		if (vd->pl080s)
+			ch->pl080s = true;
+
+		spin_lock_init(&ch->lock);
+
+		/*
+		 * Nomadik variants can have channels that are locked
+		 * down for the secure world only. Lock up these channels
+		 * by perpetually serving a dummy virtual channel.
+		 */
+		if (vd->nomadik) {
+			u32 val;
+
+			val = readl(ch->reg_config);
+			if (val & (PL080N_CONFIG_ITPROT | PL080N_CONFIG_SECPROT)) {
+				dev_dbg(&adev->dev, "physical channel %d reserved for secure access only\n", i);
+				ch->locked = true;
+			}
+		}
+
+		//dev_dbg(&adev->dev, "physical channel %d is %s\n",
+		dev_dbg(&adev->dev, "physical channel %d is %s\n",
+			i, pl08x_phy_channel_busy(ch) ? "BUSY" : "FREE");
+	}
+
+	/* Register as many memcpy channels as there are physical channels */
+	ret = pl08x_dma_init_virtual_channels(pl08x, &pl08x->memcpy,
+					      pl08x->vd->channels, false);
+	if (ret <= 0) {
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		dev_warn(&pl08x->adev->dev,
+			 "%s failed to enumerate memcpy channels - %d\n",
+			 __func__, ret);
+		goto out_no_memcpy;
+	}
+
+	/* Register slave channels */
+	if (pl08x->has_slave) {
+		ret = pl08x_dma_init_virtual_channels(pl08x, &pl08x->slave,
+					pl08x->pd->num_slave_channels, true);
+		if (ret < 0) {
+			printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+			dev_warn(&pl08x->adev->dev,
+				 "%s failed to enumerate slave channels - %d\n",
+				 __func__, ret);
+			goto out_no_slave;
+		}
+	}
+
+	ret = dma_async_device_register(&pl08x->memcpy);
+	if (ret) {
+		printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+		dev_warn(&pl08x->adev->dev,
+			"%s failed to register memcpy as an async device - %d\n",
+			__func__, ret);
+		goto out_no_memcpy_reg;
+	}
+
+	if (pl08x->has_slave) {
+		ret = dma_async_device_register(&pl08x->slave);
+		if (ret) {
+			printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+			dev_warn(&pl08x->adev->dev,
+			"%s failed to register slave as an async device - %d\n",
+			__func__, ret);
+			goto out_no_slave_reg;
+		}
+	}
+
+	platform_set_drvdata(adev, pl08x);
+	init_pl08x_debugfs(pl08x);
+	printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+	{
+		int loop;
+
+		for (loop = 0xfe0;loop <= 0xffc; loop += 4) {
+			dev_dbg(&pl08x->adev->dev, "periphid[0x%x] = %x ",
+				 loop,readl(pl08x->base + loop));
+		}
+	}
+	printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+	dev_dbg(&pl08x->adev->dev, "DMA: PL080  at 0x%08llx irq %d\n",
+		 (unsigned long long)res->start, irq);
+
+	return 0;
+
+out_no_slave_reg:
+	dma_async_device_unregister(&pl08x->memcpy);
+out_no_memcpy_reg:
+	if (pl08x->has_slave)
+		pl08x_free_virtual_channels(&pl08x->slave);
+out_no_slave:
+	pl08x_free_virtual_channels(&pl08x->memcpy);
+out_no_memcpy:
+	kfree(pl08x->phy_chans);
+out_no_phychans:
+	free_irq(irq, pl08x);
+out_no_irq:
+	dma_pool_destroy(pl08x->pool);
+out_no_lli_pool:
+out_no_platdata:
+	iounmap(pl08x->base);
+out_no_ioremap:
+	kfree(pl08x);
+	//out_no_pl08x:
+	//amba_release_regions(adev);
+	printk("this is debug %s %s %d\n",__FILE__,__func__,__LINE__);
+	return ret;
+}
+
+/* PL080 has 8 channels and the PL080 have just 2 */
+static struct vendor_data vendor_pl080 = {
+	.config_offset = PL080_CH_CONFIG,
+	.channels = 8,
+	.signals = 16,
+	.dualmaster = true,
+	.max_transfer_size = PL080_CONTROL_TRANSFER_SIZE_MASK,
+};
+#if 0
+static struct vendor_data vendor_nomadik = {
+	.config_offset = PL080_CH_CONFIG,
+	.channels = 8,
+	.signals = 32,
+	.dualmaster = true,
+	.nomadik = true,
+	.max_transfer_size = PL080_CONTROL_TRANSFER_SIZE_MASK,
+};
+
+static struct vendor_data vendor_pl080s = {
+	.config_offset = PL080S_CH_CONFIG,
+	.channels = 8,
+	.signals = 32,
+	.pl080s = true,
+	.max_transfer_size = PL080S_CONTROL_TRANSFER_SIZE_MASK,
+};
+
+static struct vendor_data vendor_pl081 = {
+	.config_offset = PL080_CH_CONFIG,
+	.channels = 2,
+	.signals = 16,
+	.dualmaster = false,
+	.max_transfer_size = PL080_CONTROL_TRANSFER_SIZE_MASK,
+};
+
+static struct vendor_data vendor_ftdmac020 = {
+	.config_offset = PL080_CH_CONFIG,
+	.ftdmac020 = true,
+	.max_transfer_size = PL080_CONTROL_TRANSFER_SIZE_MASK,
+};
+
+static const struct amba_id pl08x_ids[] = {
+	/* Samsung PL080S variant */
+	{
+		.id	= 0x0a141080,
+		.mask	= 0xffffffff,
+		.data	= &vendor_pl080s,
+	},
+	/* PL080 */
+	{
+		.id	= 0x00041080,
+		.mask	= 0x000fffff,
+		.data	= &vendor_pl080,
+	},
+	/* PL081 */
+	{
+		.id	= 0x00041081,
+		.mask	= 0x000fffff,
+		.data	= &vendor_pl081,
+	},
+	/* Nomadik 8815 PL080 variant */
+	{
+		.id	= 0x00280080,
+		.mask	= 0x00ffffff,
+		.data	= &vendor_nomadik,
+	},
+	/* Faraday Technology FTDMAC020 */
+	{
+		.id	= 0x0003b080,
+		.mask	= 0x000fffff,
+		.data	= &vendor_ftdmac020,
+	},
+	{ 0, 0 },
+};
+
+MODULE_DEVICE_TABLE(amba, pl08x_ids);
+
+static struct amba_driver pl08x_amba_driver = {
+	.drv.name	= DRIVER_NAME,
+	.id_table	= pl08x_ids,
+	.probe		= pl08x_probe,
+};
+#endif
+static const struct of_device_id vic7110_dma_ids[] = {
+	{ .compatible = "starfive,pl080", .data = &vendor_pl080},
+	{},
+};
+MODULE_DEVICE_TABLE(of, vic7110_dma_ids);
+
+static struct platform_driver vic7110_pl08x_driver = {
+	.probe  = pl08x_probe,
+	.driver = {
+		.name           = DRIVER_NAME,
+		.of_match_table = vic7110_dma_ids,
+	},
+};
+
+module_platform_driver(vic7110_pl08x_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Huan Feng <huan.feng@starfivetech.com>");
+MODULE_DESCRIPTION("Starfive VIC7110 CRYP DMA driver");
diff --git a/drivers/gpu/drm/i2c/tda998x_pin.c b/drivers/gpu/drm/i2c/tda998x_pin.c
new file mode 100644
index 000000000000..995efc8e55ed
--- /dev/null
+++ b/drivers/gpu/drm/i2c/tda998x_pin.c
@@ -0,0 +1,47 @@
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/iommu.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_of.h>
+
+#define DRIVER_NAME	"starfive"
+#define DRIVER_DESC	"StarFive Soc DRM"
+#define DRIVER_DATE	"20220624"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+#define DRIVER_VERSION	"v1.0.0"
+
+static struct drm_driver starfive_drm_driver = {
+	.name	= DRIVER_NAME,
+	.desc	= DRIVER_DESC,
+	.date	= DRIVER_DATE,
+	.major	= DRIVER_MAJOR,
+	.minor	= DRIVER_MINOR,
+};
+
+static int starfive_drm_platform_probe(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "%s, ok\n", __func__);
+
+	return 0;
+}
+
+static const struct of_device_id tda998x_rgb_dt_ids[] = {
+	{ .compatible = "starfive,tda998x_rgb_pin", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, starfive_drm_dt_ids);
+
+static struct platform_driver starfive_drm_platform_driver = {
+	.probe = starfive_drm_platform_probe,
+	.driver = {
+		.name = "tda998x_rgb_dt_ids",
+		.of_match_table = tda998x_rgb_dt_ids,
+	},
+};
+
+module_platform_driver(starfive_drm_platform_driver);
+
+MODULE_AUTHOR("David Li <david.li@starfivetech.com>");
+MODULE_DESCRIPTION("starfive DRM Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-jadard-jd9365da-h3.c b/drivers/gpu/drm/panel/panel-jadard-jd9365da-h3.c
new file mode 100755
index 000000000000..0b7341cecc45
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-jadard-jd9365da-h3.c
@@ -0,0 +1,704 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2019 Radxa Limited
+ * Copyright (c) 2022 Edgeble AI Technologies Pvt. Ltd.
+ *
+ * Author:
+ * - Jagan Teki <jagan@amarulasolutions.com>
+ * - Stephen Chen <stephen@radxa.com>
+ */
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <drm/drm_crtc.h>
+#include <drm/drm_device.h>
+#include <video/display_timing.h>
+#include <video/videomode.h>
+
+#define DSI_DRIVER_NAME "starfive-dri"
+
+enum cmd_type {
+	CMD_TYPE_DCS,
+	CMD_TYPE_DELAY,
+};
+
+struct jadard_init_cmd {
+	enum cmd_type type;
+	const char *data;
+	size_t len;
+};
+
+#define _INIT_CMD_DCS(...)					\
+	{							\
+		.type	= CMD_TYPE_DCS,				\
+		.data	= (char[]){__VA_ARGS__},		\
+		.len	= sizeof((char[]){__VA_ARGS__})		\
+	}							\
+
+#define _INIT_CMD_DELAY(...)					\
+	{							\
+		.type	= CMD_TYPE_DELAY,			\
+		.data	= (char[]){__VA_ARGS__},		\
+		.len	= sizeof((char[]){__VA_ARGS__})		\
+	}							\
+
+struct jadard_panel_desc {
+	const struct drm_display_mode mode;
+	unsigned int lanes;
+	enum mipi_dsi_pixel_format format;
+	const struct jadard_init_cmd *init_cmds;
+	u32 num_init_cmds;
+	const struct display_timing *timings;
+	unsigned int num_timings;
+};
+
+struct jadard {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	const struct jadard_panel_desc *desc;
+	struct i2c_client *client;
+
+	struct device   *dev;
+
+	struct regulator *vdd;
+	struct regulator *vccio;
+	struct gpio_desc *reset;
+	struct gpio_desc *enable;
+	bool enable_initialized;
+};
+
+static inline struct jadard *panel_to_jadard(struct drm_panel *panel)
+{
+	return container_of(panel, struct jadard, panel);
+}
+
+static int jadard_i2c_write(struct i2c_client *client, u8 reg, u8 val)
+{
+	struct i2c_msg msg;
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg;
+	buf[1] = val;
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.buf = buf;
+	msg.len = 2;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0)
+		return 0;
+
+	return ret;
+}
+
+static int jadard_i2c_read(struct i2c_client *client, u8 reg, u8 *val)
+{
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg;
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].buf = buf;
+	msg[0].len = 1;
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = val;
+	msg[1].len = 1;
+	ret = i2c_transfer(client->adapter, msg, 2);
+
+	if (ret >= 0)
+		return 0;
+
+	return ret;
+}
+
+static int jadard_enable(struct drm_panel *panel)
+{
+	struct device *dev = panel->dev;
+	struct jadard *jadard = panel_to_jadard(panel);
+	const struct jadard_panel_desc *desc = jadard->desc;
+	struct mipi_dsi_device *dsi = jadard->dsi;
+	unsigned int i;
+	int err;
+	if (jadard->enable_initialized == true)
+		return 0;
+
+	for (i = 0; i < desc->num_init_cmds; i++) {
+		const struct jadard_init_cmd *cmd = &desc->init_cmds[i];
+
+		switch (cmd->type) {
+		case CMD_TYPE_DELAY:
+			msleep(cmd->data[0]);
+			err = 0;
+			break;
+		case CMD_TYPE_DCS:
+			err = mipi_dsi_dcs_write(dsi, cmd->data[0],
+						 cmd->len <= 1 ? NULL : &cmd->data[1],
+						 cmd->len - 1);
+			break;
+		default:
+			err = -EINVAL;
+		}
+
+		if (err < 0) {
+			DRM_DEV_ERROR(dev, "failed to write CMD#0x%x\n", cmd->data[0]);
+			return err;
+		}
+
+	}
+
+	err = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (err < 0)
+		DRM_DEV_ERROR(dev, "failed to exit sleep mode ret = %d\n", err);
+	msleep(120);
+
+	err =  mipi_dsi_dcs_set_display_on(dsi);
+	if (err < 0)
+		DRM_DEV_ERROR(dev, "failed to set display on ret = %d\n", err);
+	jadard->enable_initialized = true ;
+
+	return 0;
+}
+
+static int jadard_disable(struct drm_panel *panel)
+{
+	struct device *dev = panel->dev;
+	struct jadard *jadard = panel_to_jadard(panel);
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(jadard->dsi);
+	if (ret < 0)
+		DRM_DEV_ERROR(dev, "failed to set display off: %d\n", ret);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(jadard->dsi);
+	if (ret < 0)
+		DRM_DEV_ERROR(dev, "failed to enter sleep mode: %d\n", ret);
+
+	jadard->enable_initialized = false;
+
+	return 0;
+}
+
+static int jadard_prepare(struct drm_panel *panel)
+{
+	struct device *dev = panel->dev;
+	struct jadard *jadard = panel_to_jadard(panel);
+	const struct jadard_panel_desc *desc = jadard->desc;
+	struct mipi_dsi_device *dsi = jadard->dsi;
+	unsigned int i;
+	int err;
+
+	if (jadard->enable_initialized == true)
+		return 0;
+
+	gpiod_direction_output(jadard->enable, 0);
+	gpiod_set_value(jadard->enable, 1);
+	mdelay(100);
+
+	gpiod_direction_output(jadard->reset, 0);
+	mdelay(100);
+	gpiod_set_value(jadard->reset, 1);
+	mdelay(100);
+	gpiod_set_value(jadard->reset, 0);
+	mdelay(100);
+	gpiod_set_value(jadard->reset, 1);
+	mdelay(150);
+
+	return 0;
+}
+
+static int jadard_unprepare(struct drm_panel *panel)
+{
+	struct jadard *jadard = panel_to_jadard(panel);
+
+	gpiod_set_value(jadard->reset, 1);
+	msleep(120);
+#if 0
+	regulator_disable(jadard->vdd);
+	regulator_disable(jadard->vccio);
+#endif
+	return 0;
+}
+
+static int jadard_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct jadard *jadard = panel_to_jadard(panel);
+	const struct drm_display_mode *desc_mode = &jadard->desc->mode;
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, desc_mode);
+	if (!mode) {
+		DRM_DEV_ERROR(&jadard->dsi->dev, "failed to add mode %ux%ux@%u\n",
+			      desc_mode->hdisplay, desc_mode->vdisplay,
+			      drm_mode_vrefresh(desc_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static int seiko_panel_get_timings(struct drm_panel *panel,
+					unsigned int num_timings,
+					struct display_timing *timings)
+{
+	struct jadard *jadard = panel_to_jadard(panel);
+	unsigned int i;
+
+	if (jadard->desc->num_timings < num_timings)
+		num_timings = jadard->desc->num_timings;
+
+	if (timings)
+		for (i = 0; i < num_timings; i++)
+			timings[i] = jadard->desc->timings[i];
+
+	return jadard->desc->num_timings;
+}
+
+static const struct drm_panel_funcs jadard_funcs = {
+	.disable = jadard_disable,
+	.unprepare = jadard_unprepare,
+	.prepare = jadard_prepare,
+	.enable = jadard_enable,
+	.get_modes = jadard_get_modes,
+	.get_timings = seiko_panel_get_timings,
+};
+
+static const struct jadard_init_cmd cz101b4001_init_cmds[] = {
+	_INIT_CMD_DCS(0x01),
+	_INIT_CMD_DELAY(100),
+	_INIT_CMD_DCS(0xE0, 0x00),
+	_INIT_CMD_DCS(0xE1, 0x93),
+	_INIT_CMD_DCS(0xE2, 0x65),
+	_INIT_CMD_DCS(0xE3, 0xF8),
+	_INIT_CMD_DCS(0x80, 0x03),
+	_INIT_CMD_DCS(0xE0, 0x01),
+	_INIT_CMD_DCS(0x00, 0x00),
+	_INIT_CMD_DCS(0x01, 0x7E),
+	_INIT_CMD_DCS(0x03, 0x00),
+	_INIT_CMD_DCS(0x04, 0x65),
+	_INIT_CMD_DCS(0x0C, 0x74),
+	_INIT_CMD_DCS(0x17, 0x00),
+	_INIT_CMD_DCS(0x18, 0xB7),
+	_INIT_CMD_DCS(0x19, 0x00),
+	_INIT_CMD_DCS(0x1A, 0x00),
+	_INIT_CMD_DCS(0x1B, 0xB7),
+	_INIT_CMD_DCS(0x1C, 0x00),
+	_INIT_CMD_DCS(0x24, 0xFE),
+	_INIT_CMD_DCS(0x37, 0x19),
+	_INIT_CMD_DCS(0x38, 0x05),
+	_INIT_CMD_DCS(0x39, 0x00),
+	_INIT_CMD_DCS(0x3A, 0x01),
+	_INIT_CMD_DCS(0x3B, 0x01),
+	_INIT_CMD_DCS(0x3C, 0x70),
+	_INIT_CMD_DCS(0x3D, 0xFF),
+	_INIT_CMD_DCS(0x3E, 0xFF),
+	_INIT_CMD_DCS(0x3F, 0xFF),
+	_INIT_CMD_DCS(0x40, 0x06),
+	_INIT_CMD_DCS(0x41, 0xA0),
+	_INIT_CMD_DCS(0x43, 0x1E),
+	_INIT_CMD_DCS(0x44, 0x0F),
+	_INIT_CMD_DCS(0x45, 0x28),
+	_INIT_CMD_DCS(0x4B, 0x04),
+	_INIT_CMD_DCS(0x55, 0x02),
+	_INIT_CMD_DCS(0x56, 0x01),
+	_INIT_CMD_DCS(0x57, 0xA9),
+	_INIT_CMD_DCS(0x58, 0x0A),
+	_INIT_CMD_DCS(0x59, 0x0A),
+	_INIT_CMD_DCS(0x5A, 0x37),
+	_INIT_CMD_DCS(0x5B, 0x19),
+	_INIT_CMD_DCS(0x5D, 0x78),
+	_INIT_CMD_DCS(0x5E, 0x63),
+	_INIT_CMD_DCS(0x5F, 0x54),
+	_INIT_CMD_DCS(0x60, 0x49),
+	_INIT_CMD_DCS(0x61, 0x45),
+	_INIT_CMD_DCS(0x62, 0x38),
+	_INIT_CMD_DCS(0x63, 0x3D),
+	_INIT_CMD_DCS(0x64, 0x28),
+	_INIT_CMD_DCS(0x65, 0x43),
+	_INIT_CMD_DCS(0x66, 0x41),
+	_INIT_CMD_DCS(0x67, 0x43),
+	_INIT_CMD_DCS(0x68, 0x62),
+	_INIT_CMD_DCS(0x69, 0x50),
+	_INIT_CMD_DCS(0x6A, 0x57),
+	_INIT_CMD_DCS(0x6B, 0x49),
+	_INIT_CMD_DCS(0x6C, 0x44),
+	_INIT_CMD_DCS(0x6D, 0x37),
+	_INIT_CMD_DCS(0x6E, 0x23),
+	_INIT_CMD_DCS(0x6F, 0x10),
+	_INIT_CMD_DCS(0x70, 0x78),
+	_INIT_CMD_DCS(0x71, 0x63),
+	_INIT_CMD_DCS(0x72, 0x54),
+	_INIT_CMD_DCS(0x73, 0x49),
+	_INIT_CMD_DCS(0x74, 0x45),
+	_INIT_CMD_DCS(0x75, 0x38),
+	_INIT_CMD_DCS(0x76, 0x3D),
+	_INIT_CMD_DCS(0x77, 0x28),
+	_INIT_CMD_DCS(0x78, 0x43),
+	_INIT_CMD_DCS(0x79, 0x41),
+	_INIT_CMD_DCS(0x7A, 0x43),
+	_INIT_CMD_DCS(0x7B, 0x62),
+	_INIT_CMD_DCS(0x7C, 0x50),
+	_INIT_CMD_DCS(0x7D, 0x57),
+	_INIT_CMD_DCS(0x7E, 0x49),
+	_INIT_CMD_DCS(0x7F, 0x44),
+	_INIT_CMD_DCS(0x80, 0x37),
+	_INIT_CMD_DCS(0x81, 0x23),
+	_INIT_CMD_DCS(0x82, 0x10),
+	_INIT_CMD_DCS(0xE0, 0x02),
+	_INIT_CMD_DCS(0x00, 0x47),
+	_INIT_CMD_DCS(0x01, 0x47),
+	_INIT_CMD_DCS(0x02, 0x45),
+	_INIT_CMD_DCS(0x03, 0x45),
+	_INIT_CMD_DCS(0x04, 0x4B),
+	_INIT_CMD_DCS(0x05, 0x4B),
+	_INIT_CMD_DCS(0x06, 0x49),
+	_INIT_CMD_DCS(0x07, 0x49),
+	_INIT_CMD_DCS(0x08, 0x41),
+	_INIT_CMD_DCS(0x09, 0x1F),
+	_INIT_CMD_DCS(0x0A, 0x1F),
+	_INIT_CMD_DCS(0x0B, 0x1F),
+	_INIT_CMD_DCS(0x0C, 0x1F),
+	_INIT_CMD_DCS(0x0D, 0x1F),
+	_INIT_CMD_DCS(0x0E, 0x1F),
+	_INIT_CMD_DCS(0x0F, 0x5F),
+	_INIT_CMD_DCS(0x10, 0x5F),
+	_INIT_CMD_DCS(0x11, 0x57),
+	_INIT_CMD_DCS(0x12, 0x77),
+	_INIT_CMD_DCS(0x13, 0x35),
+	_INIT_CMD_DCS(0x14, 0x1F),
+	_INIT_CMD_DCS(0x15, 0x1F),
+	_INIT_CMD_DCS(0x16, 0x46),
+	_INIT_CMD_DCS(0x17, 0x46),
+	_INIT_CMD_DCS(0x18, 0x44),
+	_INIT_CMD_DCS(0x19, 0x44),
+	_INIT_CMD_DCS(0x1A, 0x4A),
+	_INIT_CMD_DCS(0x1B, 0x4A),
+	_INIT_CMD_DCS(0x1C, 0x48),
+	_INIT_CMD_DCS(0x1D, 0x48),
+	_INIT_CMD_DCS(0x1E, 0x40),
+	_INIT_CMD_DCS(0x1F, 0x1F),
+	_INIT_CMD_DCS(0x20, 0x1F),
+	_INIT_CMD_DCS(0x21, 0x1F),
+	_INIT_CMD_DCS(0x22, 0x1F),
+	_INIT_CMD_DCS(0x23, 0x1F),
+	_INIT_CMD_DCS(0x24, 0x1F),
+	_INIT_CMD_DCS(0x25, 0x5F),
+	_INIT_CMD_DCS(0x26, 0x5F),
+	_INIT_CMD_DCS(0x27, 0x57),
+	_INIT_CMD_DCS(0x28, 0x77),
+	_INIT_CMD_DCS(0x29, 0x35),
+	_INIT_CMD_DCS(0x2A, 0x1F),
+	_INIT_CMD_DCS(0x2B, 0x1F),
+	_INIT_CMD_DCS(0x58, 0x40),
+	_INIT_CMD_DCS(0x59, 0x00),
+	_INIT_CMD_DCS(0x5A, 0x00),
+	_INIT_CMD_DCS(0x5B, 0x10),
+	_INIT_CMD_DCS(0x5C, 0x06),
+	_INIT_CMD_DCS(0x5D, 0x40),
+	_INIT_CMD_DCS(0x5E, 0x01),
+	_INIT_CMD_DCS(0x5F, 0x02),
+	_INIT_CMD_DCS(0x60, 0x30),
+	_INIT_CMD_DCS(0x61, 0x01),
+	_INIT_CMD_DCS(0x62, 0x02),
+	_INIT_CMD_DCS(0x63, 0x03),
+	_INIT_CMD_DCS(0x64, 0x6B),
+	_INIT_CMD_DCS(0x65, 0x05),
+	_INIT_CMD_DCS(0x66, 0x0C),
+	_INIT_CMD_DCS(0x67, 0x73),
+	_INIT_CMD_DCS(0x68, 0x09),
+	_INIT_CMD_DCS(0x69, 0x03),
+	_INIT_CMD_DCS(0x6A, 0x56),
+	_INIT_CMD_DCS(0x6B, 0x08),
+	_INIT_CMD_DCS(0x6C, 0x00),
+	_INIT_CMD_DCS(0x6D, 0x04),
+	_INIT_CMD_DCS(0x6E, 0x04),
+	_INIT_CMD_DCS(0x6F, 0x88),
+	_INIT_CMD_DCS(0x70, 0x00),
+	_INIT_CMD_DCS(0x71, 0x00),
+	_INIT_CMD_DCS(0x72, 0x06),
+	_INIT_CMD_DCS(0x73, 0x7B),
+	_INIT_CMD_DCS(0x74, 0x00),
+	_INIT_CMD_DCS(0x75, 0xF8),
+	_INIT_CMD_DCS(0x76, 0x00),
+	_INIT_CMD_DCS(0x77, 0xD5),
+	_INIT_CMD_DCS(0x78, 0x2E),
+	_INIT_CMD_DCS(0x79, 0x12),
+	_INIT_CMD_DCS(0x7A, 0x03),
+	_INIT_CMD_DCS(0x7B, 0x00),
+	_INIT_CMD_DCS(0x7C, 0x00),
+	_INIT_CMD_DCS(0x7D, 0x03),
+	_INIT_CMD_DCS(0x7E, 0x7B),
+	_INIT_CMD_DCS(0xE0, 0x04),
+	_INIT_CMD_DCS(0x00, 0x0E),
+	_INIT_CMD_DCS(0x02, 0xB3),
+	_INIT_CMD_DCS(0x09, 0x60),
+	_INIT_CMD_DCS(0x0E, 0x2A),
+	_INIT_CMD_DCS(0x36, 0x59),
+	_INIT_CMD_DCS(0xE0, 0x00),
+
+	_INIT_CMD_DELAY(120),
+};
+
+static const struct display_timing jadard_timing = {
+	.pixelclock = { 79200000, 79200000, 79200000 },
+	.hactive = { 800, 800, 800 },
+	.hfront_porch = {  356, 356, 356 },
+	.hback_porch = { 134, 134, 134 },
+	.hsync_len = { 7, 7, 7 },
+	.vactive = { 1280, 1280, 1280 },
+	.vfront_porch = { 84, 84, 84 },
+	.vback_porch = { 20, 20, 20 },
+	.vsync_len = { 9, 9, 9 },
+	.flags = DISPLAY_FLAGS_DE_LOW,
+};
+
+static const struct jadard_panel_desc cz101b4001_desc = {
+	.mode = {
+		.clock		= 79200,
+
+		.hdisplay	= 800,
+		.hsync_start	= 800 + 139,
+		.hsync_end	= 800 + 139 + 5,
+		.htotal		= 800 + 139 + 5 + 5,
+
+		.vdisplay	= 1280,
+		.vsync_start	= 1280 + 84,
+		.vsync_end	= 1280 + 84 + 20,
+		.vtotal		= 1280 + 84+ 20 + 7,
+
+		.width_mm	= 62,
+		.height_mm	= 110,
+		.type		= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+	},
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.init_cmds = cz101b4001_init_cmds,
+	.num_init_cmds = ARRAY_SIZE(cz101b4001_init_cmds),
+	.timings = &jadard_timing,
+	.num_timings = 1,
+};
+
+static int panel_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	u8 reg_value = 0;
+	struct jadard *jd_panel;
+	const struct jadard_panel_desc *desc;
+
+	struct device_node *endpoint, *dsi_host_node;
+	struct mipi_dsi_host *host;
+	struct device *dev = &client->dev;
+	int ret = 0;
+	struct mipi_dsi_device_info info = {
+		.type = DSI_DRIVER_NAME,
+		.channel = 1, //0,
+		.node = NULL,
+	};
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		dev_warn(&client->dev,
+			 "I2C adapter doesn't support I2C_FUNC_SMBUS_BYTE\n");
+		return -EIO;
+	}
+
+	jd_panel = devm_kzalloc(&client->dev, sizeof(struct jadard), GFP_KERNEL);
+	if (!jd_panel )
+		return -ENOMEM;
+	desc = of_device_get_match_data(dev);
+
+	jd_panel ->client = client;
+	i2c_set_clientdata(client, jd_panel);
+
+	jd_panel->enable_initialized = false;
+
+	jd_panel->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(jd_panel->reset)) {
+		DRM_DEV_ERROR(dev, "failed to get our reset GPIO\n");
+		return PTR_ERR(jd_panel->reset);
+	}
+
+	jd_panel->enable = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+	if (IS_ERR(jd_panel->enable)) {
+		DRM_DEV_ERROR(dev, "failed to get our enable GPIO\n");
+		return PTR_ERR(jd_panel->enable);
+	}
+
+	/*use i2c read to detect whether the panel has connected */
+	ret = jadard_i2c_read(client, 0x00, &reg_value);
+	if (ret < 0)
+		return -ENODEV;
+
+	endpoint = of_graph_get_next_endpoint(dev->of_node, NULL);
+	if (!endpoint)
+		return -ENODEV;
+
+	dsi_host_node = of_graph_get_remote_port_parent(endpoint);
+	if (!dsi_host_node)
+		goto error;
+
+	host = of_find_mipi_dsi_host_by_node(dsi_host_node);
+	of_node_put(dsi_host_node);
+	if (!host) {
+		of_node_put(endpoint);
+		return -EPROBE_DEFER;
+	}
+
+	drm_panel_init(&jd_panel->panel, dev, &jadard_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	drm_panel_add(&jd_panel->panel);
+
+	info.node = of_node_get(of_graph_get_remote_port(endpoint));
+	if (!info.node)
+		goto error;
+
+	of_node_put(endpoint);
+	jd_panel->desc = desc;
+
+	jd_panel->dsi = mipi_dsi_device_register_full(host, &info);
+	if (IS_ERR(jd_panel->dsi)) {
+		dev_err(dev, "DSI device registration failed: %ld\n",
+			PTR_ERR(jd_panel->dsi));
+		return PTR_ERR(jd_panel->dsi);
+	}
+
+	mipi_dsi_set_drvdata(jd_panel->dsi, jd_panel);
+
+	return 0;
+error:
+	of_node_put(endpoint);
+	return -ENODEV;
+no_panel:
+	mipi_dsi_device_unregister(jd_panel->dsi);
+	//drm_panel_remove(&jd_panel->panel);
+	//mipi_dsi_detach(jd_panel->dsi);
+
+	return -ENODEV;
+
+
+}
+
+static int panel_remove(struct i2c_client *client)
+{
+	struct jadard *jd_panel = i2c_get_clientdata(client);
+
+	mipi_dsi_detach(jd_panel->dsi);
+	drm_panel_remove(&jd_panel->panel);
+	mipi_dsi_device_unregister(jd_panel->dsi);
+	return 0;
+}
+
+static const struct i2c_device_id panel_id[] = {
+	{ "starfive_jadard", 0 },
+	{ }
+};
+
+static const struct of_device_id panel_dt_ids[] = {
+	{ .compatible = "starfive_jadard", .data = &cz101b4001_desc},
+	{ /* sentinel */ }
+};
+
+static struct i2c_driver panel_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "starfive_jadard",
+		.of_match_table = panel_dt_ids,
+	},
+	.probe		= panel_probe,
+	.remove		= panel_remove,
+	.id_table	= panel_id,
+};
+
+static int jadard_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct jadard *jadard = mipi_dsi_get_drvdata(dsi);
+
+	int ret;
+
+	dsi->mode_flags = MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE ;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->lanes = 4;
+	dsi->channel = 1;
+	dsi->hs_rate = 490000000;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int jadard_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	struct jadard *jadard = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&jadard->panel);
+
+	return 0;
+}
+
+static const struct of_device_id jadard_of_match[] = {
+	{ .compatible = "starfive-dri-panel-1", .data = &cz101b4001_desc },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, jadard_of_match);
+
+static struct mipi_dsi_driver jadard_mipi_driver = {
+	.probe = jadard_dsi_probe,
+	.remove = jadard_dsi_remove,
+	.driver.name = DSI_DRIVER_NAME,
+};
+//module_mipi_dsi_driver(jadard_driver);
+
+
+static int __init init_panel(void)
+{
+	int err;
+
+	mipi_dsi_driver_register(&jadard_mipi_driver);
+	err = i2c_add_driver(&panel_driver);
+
+	return err;
+
+}
+module_init(init_panel);
+
+static void __exit exit_panel(void)
+{
+	i2c_del_driver(&panel_driver);
+	mipi_dsi_driver_unregister(&jadard_mipi_driver);
+}
+module_exit(exit_panel);
+
+
+MODULE_AUTHOR("Jagan Teki <jagan@edgeble.ai>");
+MODULE_AUTHOR("Stephen Chen <stephen@radxa.com>");
+MODULE_DESCRIPTION("Jadard JD9365DA-H3 WUXGA DSI panel");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 8bcffda38cb7..9f0e3d09384c 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -1709,6 +1709,16 @@ config SENSORS_STTS751
 	  This driver can also be built as a module. If so, the module
 	  will be called stts751.
 
+config SENSORS_SFCTEMP
+	tristate "Starfive JH7100 temperature sensor"
+	depends on SOC_STARFIVE || COMPILE_TEST
+	help
+	  If you say yes here you get support for temperature sensor
+	  on the Starfive JH7100 SoC.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called sfctemp.
+
 config SENSORS_SMM665
 	tristate "Summit Microelectronics SMM665"
 	depends on I2C
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 95908c478b94..e722f08193e3 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -161,6 +161,7 @@ obj-$(CONFIG_SENSORS_S3C)	+= s3c-hwmon.o
 obj-$(CONFIG_SENSORS_SCH56XX_COMMON)+= sch56xx-common.o
 obj-$(CONFIG_SENSORS_SCH5627)	+= sch5627.o
 obj-$(CONFIG_SENSORS_SCH5636)	+= sch5636.o
+obj-$(CONFIG_SENSORS_SFCTEMP)	+= sfctemp.o
 obj-$(CONFIG_SENSORS_SL28CPLD)	+= sl28cpld-hwmon.o
 obj-$(CONFIG_SENSORS_SHT15)	+= sht15.o
 obj-$(CONFIG_SENSORS_SHT21)	+= sht21.o
diff --git a/drivers/hwmon/sfctemp.c b/drivers/hwmon/sfctemp.c
new file mode 100644
index 000000000000..5ba934ce2172
--- /dev/null
+++ b/drivers/hwmon/sfctemp.c
@@ -0,0 +1,392 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 Emil Renner Berthing <kernel@esmil.dk>
+ * Copyright (C) 2021 Samin Guo <samin.guo@starfivetech.com>
+ */
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/pm_runtime.h>
+
+/*
+ * TempSensor reset. The RSTN can be de-asserted once the analog core has
+ * powered up. Trst(min 100ns)
+ * 0:reset  1:de-assert
+ */
+#define SFCTEMP_RSTN	BIT(0)
+
+/*
+ * TempSensor analog core power down. The analog core will be powered up
+ * Tpu(min 50us) after PD is de-asserted. RSTN should be held low until the
+ * analog core is powered up.
+ * 0:power up  1:power down
+ */
+#define SFCTEMP_PD	BIT(1)
+
+/*
+ * TempSensor start conversion enable.
+ * 0:disable  1:enable
+ */
+#define SFCTEMP_RUN	BIT(2)
+
+/*
+ * TempSensor conversion value output.
+ * Temp(C)=DOUT*Y/4094 - K
+ */
+#define SFCTEMP_DOUT_POS	16
+#define SFCTEMP_DOUT_MSK	GENMASK(27, 16)
+
+/* DOUT to Celcius conversion constants */
+#define SFCTEMP_Y1000	237500L
+#define SFCTEMP_Z	4094L
+#define SFCTEMP_K1000	81100L
+
+struct sfctemp {
+	/* serialize access to hardware register and enabled below */
+	struct mutex lock;
+	struct completion conversion_done;
+	struct device *dev;
+	void __iomem *regs;
+	struct clk *clk_sense;
+	struct clk *clk_bus;
+	struct reset_control *rst_sense;
+	struct reset_control *rst_bus;
+	bool enabled;
+};
+
+static irqreturn_t sfctemp_isr(int irq, void *data)
+{
+	struct sfctemp *sfctemp = data;
+
+	complete(&sfctemp->conversion_done);
+	return IRQ_HANDLED;
+}
+
+static void sfctemp_power_up(struct sfctemp *sfctemp)
+{
+	/* make sure we're powered down first */
+	writel(SFCTEMP_PD, sfctemp->regs);
+	udelay(1);
+
+	writel(0, sfctemp->regs);
+	/* wait t_pu(50us) + t_rst(100ns) */
+	usleep_range(60, 200);
+
+	/* de-assert reset */
+	writel(SFCTEMP_RSTN, sfctemp->regs);
+	udelay(1); /* wait t_su(500ps) */
+}
+
+static void sfctemp_power_down(struct sfctemp *sfctemp)
+{
+	writel(SFCTEMP_PD, sfctemp->regs);
+}
+
+static void sfctemp_run_single(struct sfctemp *sfctemp)
+{
+	writel(SFCTEMP_RSTN | SFCTEMP_RUN, sfctemp->regs);
+	udelay(1);
+	writel(SFCTEMP_RSTN, sfctemp->regs);
+}
+
+static int sfctemp_clk_enable(struct sfctemp *sfctemp)
+{
+	int ret = 0;
+
+	ret = clk_prepare_enable(sfctemp->clk_bus);
+	if (ret)
+		goto err;
+	ret = reset_control_deassert(sfctemp->rst_bus);
+	if (ret)
+		goto err_disable_bus;
+
+	ret = clk_prepare_enable(sfctemp->clk_sense);
+	if (ret)
+		goto err_assert_bus;
+	ret = reset_control_deassert(sfctemp->rst_sense);
+	if (ret)
+		goto err_disable_sense;
+
+	return ret;
+err_disable_sense:
+	clk_disable_unprepare(sfctemp->clk_sense);
+err_assert_bus:
+	reset_control_assert(sfctemp->rst_bus);
+err_disable_bus:
+	clk_disable_unprepare(sfctemp->clk_bus);
+err:
+	mutex_unlock(&sfctemp->lock);
+	return ret;
+}
+
+static int sfctemp_clk_disable(struct sfctemp *sfctemp)
+{
+	reset_control_assert(sfctemp->rst_sense);
+	clk_disable_unprepare(sfctemp->clk_sense);
+	reset_control_assert(sfctemp->rst_bus);
+	clk_disable_unprepare(sfctemp->clk_bus);
+	return 0;
+}
+
+static int sfctemp_enable(struct sfctemp *sfctemp)
+{
+	int ret = 0;
+
+	mutex_lock(&sfctemp->lock);
+	if (sfctemp->enabled || IS_ENABLED(CONFIG_PM))
+		goto done;
+
+	ret = sfctemp_clk_enable(sfctemp);
+	sfctemp_power_up(sfctemp);
+done:
+	sfctemp->enabled = true;
+	mutex_unlock(&sfctemp->lock);
+	return ret;
+}
+
+static int sfctemp_disable(struct sfctemp *sfctemp)
+{
+	mutex_lock(&sfctemp->lock);
+	if (!sfctemp->enabled || IS_ENABLED(CONFIG_PM))
+		goto done;
+
+	sfctemp_power_down(sfctemp);
+	sfctemp_clk_disable(sfctemp);
+done:
+	sfctemp->enabled = false;
+	mutex_unlock(&sfctemp->lock);
+	return 0;
+}
+
+static void sfctemp_disable_action(void *data)
+{
+	sfctemp_disable(data);
+}
+
+static int sfctemp_convert(struct sfctemp *sfctemp, long *val)
+{
+	int ret;
+
+	mutex_lock(&sfctemp->lock);
+	if (!sfctemp->enabled) {
+		ret = -ENODATA;
+		goto out;
+	}
+
+	pm_runtime_get_sync(sfctemp->dev);
+	sfctemp_run_single(sfctemp);
+
+	ret = wait_for_completion_interruptible_timeout(&sfctemp->conversion_done,
+							msecs_to_jiffies(10));
+	if (ret <= 0) {
+		if (ret == 0)
+			ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	/* calculate temperature in milli Celcius */
+	*val = (long)((readl(sfctemp->regs) & SFCTEMP_DOUT_MSK) >> SFCTEMP_DOUT_POS)
+		* SFCTEMP_Y1000 / SFCTEMP_Z - SFCTEMP_K1000;
+
+	ret = 0;
+	pm_runtime_put(sfctemp->dev);
+out:
+	mutex_unlock(&sfctemp->lock);
+	return ret;
+}
+
+static umode_t sfctemp_is_visible(const void *data, enum hwmon_sensor_types type,
+				  u32 attr, int channel)
+{
+	switch (type) {
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_enable:
+			return 0644;
+		case hwmon_temp_input:
+			return 0444;
+		}
+		return 0;
+	default:
+		return 0;
+	}
+}
+
+static int sfctemp_read(struct device *dev, enum hwmon_sensor_types type,
+			u32 attr, int channel, long *val)
+{
+	struct sfctemp *sfctemp = dev_get_drvdata(dev);
+
+	switch (type) {
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_enable:
+			*val = sfctemp->enabled;
+			return 0;
+		case hwmon_temp_input:
+			return sfctemp_convert(sfctemp, val);
+		}
+		return -EINVAL;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sfctemp_write(struct device *dev, enum hwmon_sensor_types type,
+			 u32 attr, int channel, long val)
+{
+	struct sfctemp *sfctemp = dev_get_drvdata(dev);
+
+	switch (type) {
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_enable:
+			if (val == 0)
+				return sfctemp_disable(sfctemp);
+			if (val == 1)
+				return sfctemp_enable(sfctemp);
+			break;
+		}
+		return -EINVAL;
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct hwmon_channel_info *sfctemp_info[] = {
+	HWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),
+	HWMON_CHANNEL_INFO(temp, HWMON_T_ENABLE | HWMON_T_INPUT),
+	NULL
+};
+
+static const struct hwmon_ops sfctemp_hwmon_ops = {
+	.is_visible = sfctemp_is_visible,
+	.read = sfctemp_read,
+	.write = sfctemp_write,
+};
+
+static const struct hwmon_chip_info sfctemp_chip_info = {
+	.ops = &sfctemp_hwmon_ops,
+	.info = sfctemp_info,
+};
+
+static int sfctemp_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device *hwmon_dev;
+	struct sfctemp *sfctemp;
+	int ret;
+
+	sfctemp = devm_kzalloc(dev, sizeof(*sfctemp), GFP_KERNEL);
+	if (!sfctemp)
+		return -ENOMEM;
+
+	sfctemp->dev = dev;
+	sfctemp->enabled = false;
+	dev_set_drvdata(dev, sfctemp);
+	mutex_init(&sfctemp->lock);
+	init_completion(&sfctemp->conversion_done);
+
+	sfctemp->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(sfctemp->regs))
+		return PTR_ERR(sfctemp->regs);
+
+	sfctemp->clk_sense = devm_clk_get(dev, "sense");
+	if (IS_ERR(sfctemp->clk_sense))
+		return dev_err_probe(dev, PTR_ERR(sfctemp->clk_sense),
+				     "error getting sense clock\n");
+
+	sfctemp->clk_bus = devm_clk_get(dev, "bus");
+	if (IS_ERR(sfctemp->clk_bus))
+		return dev_err_probe(dev, PTR_ERR(sfctemp->clk_bus),
+				     "error getting bus clock\n");
+
+	sfctemp->rst_sense = devm_reset_control_get_exclusive(dev, "sense");
+	if (IS_ERR(sfctemp->rst_sense))
+		return dev_err_probe(dev, PTR_ERR(sfctemp->rst_sense),
+				     "error getting sense reset\n");
+
+	sfctemp->rst_bus = devm_reset_control_get_exclusive(dev, "bus");
+	if (IS_ERR(sfctemp->rst_bus))
+		return dev_err_probe(dev, PTR_ERR(sfctemp->rst_bus),
+				     "error getting busreset\n");
+
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0)
+		return ret;
+
+	ret = devm_request_irq(dev, ret, sfctemp_isr, 0, pdev->name, sfctemp);
+	if (ret)
+		return dev_err_probe(dev, ret, "error requesting irq\n");
+
+	ret = devm_add_action(dev, sfctemp_disable_action, sfctemp);
+	if (ret)
+		return ret;
+
+	ret = sfctemp_enable(sfctemp);
+	if (ret)
+		return dev_err_probe(dev, ret, "error enabling temperature sensor: %d\n", ret);
+
+	hwmon_dev = devm_hwmon_device_register_with_info(dev, pdev->name, sfctemp,
+							 &sfctemp_chip_info, NULL);
+	pm_runtime_enable(dev);
+
+	return PTR_ERR_OR_ZERO(hwmon_dev);
+}
+
+#ifdef CONFIG_PM
+static int starfive_temp_suspend(struct device *dev)
+{
+	struct sfctemp *sfctemp = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "starfive temp runtime suspend\n");
+	sfctemp_power_down(sfctemp);
+	return sfctemp_clk_disable(sfctemp);
+}
+
+static int starfive_temp_resume(struct device *dev)
+{
+	struct sfctemp *sfctemp = dev_get_drvdata(dev);
+	int ret;
+
+	dev_dbg(dev, "starfive temp runtime resume\n");
+
+	ret = sfctemp_clk_enable(sfctemp);
+	sfctemp_power_up(sfctemp);
+	return ret;
+}
+#endif /* CONFIG_PM */
+
+static const struct dev_pm_ops sfctemp_dev_pm_ops = {
+	SET_RUNTIME_PM_OPS(starfive_temp_suspend, starfive_temp_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend, pm_runtime_force_resume)
+};
+
+static const struct of_device_id sfctemp_of_match[] = {
+	{ .compatible = "starfive,jh7100-temp" },
+	{ .compatible = "starfive,jh7110-temp" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sfctemp_of_match);
+
+static struct platform_driver sfctemp_driver = {
+	.probe  = sfctemp_probe,
+	.driver = {
+		.name = "sfctemp",
+		.of_match_table = sfctemp_of_match,
+		.pm   = &sfctemp_dev_pm_ops,
+	},
+};
+module_platform_driver(sfctemp_driver);
+
+MODULE_AUTHOR("Emil Renner Berthing");
+MODULE_DESCRIPTION("StarFive JH7100 temperature sensor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
index 05b1009e2820..507e1a740184 100644
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -254,4 +254,19 @@ config QCOM_IPCC
 	  acts as an interrupt controller for receiving interrupts from clients.
 	  Say Y here if you want to build this driver.
 
+config STARFIVE_MBOX
+	tristate "Platform Starfive Mailbox"
+	depends on OF
+	default m
+	help
+	  Say Y here if you want to build a platform specific variant RISCV
+	  controller driver.
+
+config STARFIVE_MBOX_TEST
+	tristate "Starfive Mailbox Test Client"
+	depends on OF
+	depends on HAS_IOMEM
+	default m
+	help
+	  Test client to help with testing new Controller driver implementations.
 endif
diff --git a/drivers/mailbox/Makefile b/drivers/mailbox/Makefile
index 2e06e02b2e03..6d177275d0d5 100644
--- a/drivers/mailbox/Makefile
+++ b/drivers/mailbox/Makefile
@@ -54,3 +54,7 @@ obj-$(CONFIG_SUN6I_MSGBOX)	+= sun6i-msgbox.o
 obj-$(CONFIG_SPRD_MBOX)		+= sprd-mailbox.o
 
 obj-$(CONFIG_QCOM_IPCC)		+= qcom-ipcc.o
+
+obj-$(CONFIG_STARFIVE_MBOX)    += starfive_mailbox.o
+
+obj-$(CONFIG_STARFIVE_MBOX_TEST)    += starfive_mailbox-test.o
diff --git a/drivers/mailbox/starfive_mailbox-test.c b/drivers/mailbox/starfive_mailbox-test.c
new file mode 100644
index 000000000000..860f18db0be5
--- /dev/null
+++ b/drivers/mailbox/starfive_mailbox-test.c
@@ -0,0 +1,419 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2015 ST Microelectronics
+ *
+ * Author: Lee Jones <lee.jones@linaro.org>
+ */
+
+#include <linux/debugfs.h>
+#include <linux/err.h>
+#include <linux/fs.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/mailbox_client.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/sched/signal.h>
+
+#include <linux/mailbox_controller.h>
+
+#define MBOX_MAX_SIG_LEN	8
+#define MBOX_MAX_MSG_LEN	16
+#define MBOX_BYTES_PER_LINE	16
+#define MBOX_HEXDUMP_LINE_LEN	((MBOX_BYTES_PER_LINE * 4) + 2)
+#define MBOX_HEXDUMP_MAX_LEN	(MBOX_HEXDUMP_LINE_LEN * (MBOX_MAX_MSG_LEN / MBOX_BYTES_PER_LINE))
+
+static bool mbox_data_ready;
+
+struct mbox_test_device {
+	struct device		*dev;
+	void __iomem		*tx_mmio;
+	void __iomem		*rx_mmio;
+	struct mbox_chan	*tx_channel;
+	struct mbox_chan	*rx_channel;
+	char			*rx_buffer;
+	char			*signal;
+	char			*message;
+	spinlock_t		lock;
+	wait_queue_head_t	waitq;
+	struct fasync_struct	*async_queue;
+	struct dentry		*root_debugfs_dir;
+};
+
+static ssize_t mbox_test_signal_write(struct file *filp,
+		const char __user *userbuf,
+		size_t count, loff_t *ppos)
+{
+	struct mbox_test_device *tdev = filp->private_data;
+
+	if (!tdev->tx_channel) {
+		dev_err(tdev->dev, "Channel cannot do Tx\n");
+		return -EINVAL;
+	}
+
+	if (count > MBOX_MAX_SIG_LEN) {
+		dev_err(tdev->dev,
+			"Signal length %zd greater than max allowed %d\n",
+			count, MBOX_MAX_SIG_LEN);
+		return -EINVAL;
+	}
+
+	/* Only allocate memory if we need to */
+	if (!tdev->signal) {
+		tdev->signal = kzalloc(MBOX_MAX_SIG_LEN, GFP_KERNEL);
+		if (!tdev->signal)
+			return -ENOMEM;
+	}
+
+	if (copy_from_user(tdev->signal, userbuf, count)) {
+		kfree(tdev->signal);
+		tdev->signal = NULL;
+		return -EFAULT;
+	}
+
+	return count;
+}
+
+static const struct file_operations mbox_test_signal_ops = {
+	.write = mbox_test_signal_write,
+	.open = simple_open,
+	.llseek = generic_file_llseek,
+};
+
+static int mbox_test_message_fasync(int fd, struct file *filp, int on)
+{
+	struct mbox_test_device *tdev = filp->private_data;
+
+	return fasync_helper(fd, filp, on, &tdev->async_queue);
+}
+
+static ssize_t mbox_test_message_write(struct file *filp,
+		const char __user *userbuf,
+		size_t count, loff_t *ppos)
+{
+	struct mbox_test_device *tdev = filp->private_data;
+	void *data;
+	int ret;
+
+	if (!tdev->tx_channel) {
+		dev_err(tdev->dev, "Channel cannot do Tx\n");
+		return -EINVAL;
+	}
+
+	if (count > MBOX_MAX_MSG_LEN) {
+		dev_err(tdev->dev,
+			"Message length %zd greater than max allowed %d\n",
+			count, MBOX_MAX_MSG_LEN);
+		return -EINVAL;
+	}
+
+	tdev->message = kzalloc(MBOX_MAX_MSG_LEN, GFP_KERNEL);
+	if (!tdev->message)
+		return -ENOMEM;
+
+	ret = copy_from_user(tdev->message, userbuf, count);
+	if (ret) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if (tdev->tx_mmio && tdev->signal) {
+		print_hex_dump_bytes("Client: Sending: Signal: ", DUMP_PREFIX_ADDRESS,
+			tdev->signal, MBOX_MAX_SIG_LEN);
+
+		data = tdev->signal;
+	} else
+		data = tdev->message;
+
+	print_hex_dump_bytes("Client: Sending: Message: ", DUMP_PREFIX_ADDRESS,
+		tdev->message, MBOX_MAX_MSG_LEN);
+
+	ret = mbox_send_message(tdev->tx_channel, data);
+	mbox_chan_txdone(tdev->tx_channel, ret);
+	if (ret < 0)
+		dev_err(tdev->dev, "Failed to send message via mailbox\n");
+
+out:
+	kfree(tdev->signal);
+	kfree(tdev->message);
+	tdev->signal = NULL;
+
+	return ret < 0 ? ret : count;
+}
+
+static bool mbox_test_message_data_ready(struct mbox_test_device *tdev)
+{
+	bool data_ready;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tdev->lock, flags);
+	data_ready = mbox_data_ready;
+	spin_unlock_irqrestore(&tdev->lock, flags);
+
+	return data_ready;
+}
+
+static ssize_t mbox_test_message_read(struct file *filp, char __user *userbuf,
+		size_t count, loff_t *ppos)
+{
+	struct mbox_test_device *tdev = filp->private_data;
+	unsigned long flags;
+	char *touser, *ptr;
+	int ret;
+
+	touser = kzalloc(MBOX_HEXDUMP_MAX_LEN + 1, GFP_KERNEL);
+	if (!touser)
+		return -ENOMEM;
+
+	if (!tdev->rx_channel) {
+		ret = snprintf(touser, 20, "<NO RX CAPABILITY>\n");
+		ret = simple_read_from_buffer(userbuf, count, ppos,
+			touser, ret);
+		goto kfree_err;
+	}
+
+	do {
+		if (mbox_test_message_data_ready(tdev))
+			break;
+
+		if (filp->f_flags & O_NONBLOCK) {
+			ret = -EAGAIN;
+			goto waitq_err;
+		}
+
+		if (signal_pending(current)) {
+			ret = -ERESTARTSYS;
+			goto waitq_err;
+		}
+		schedule();
+
+	} while (1);
+
+	spin_lock_irqsave(&tdev->lock, flags);
+
+	ptr = tdev->rx_buffer;
+
+	mbox_data_ready = false;
+
+	spin_unlock_irqrestore(&tdev->lock, flags);
+	if (copy_to_user((void __user *)userbuf, ptr, 4))
+		ret = -EFAULT;
+
+waitq_err:
+	__set_current_state(TASK_RUNNING);
+kfree_err:
+	kfree(touser);
+	return ret;
+}
+
+static __poll_t
+mbox_test_message_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	struct mbox_test_device *tdev = filp->private_data;
+
+	poll_wait(filp, &tdev->waitq, wait);
+
+	if (mbox_test_message_data_ready(tdev))
+		return EPOLLIN | EPOLLRDNORM;
+	return 0;
+}
+
+static const struct file_operations mbox_test_message_ops = {
+	.write = mbox_test_message_write,
+	.read = mbox_test_message_read,
+	.fasync = mbox_test_message_fasync,
+	.poll = mbox_test_message_poll,
+	.open = simple_open,
+	.llseek = generic_file_llseek,
+};
+
+static int mbox_test_add_debugfs(struct platform_device *pdev,
+		struct mbox_test_device *tdev)
+{
+	if (!debugfs_initialized())
+		return 0;
+
+	tdev->root_debugfs_dir = debugfs_create_dir(dev_name(&pdev->dev), NULL);
+	if (!tdev->root_debugfs_dir) {
+		dev_err(&pdev->dev, "Failed to create Mailbox debugfs\n");
+		return -EINVAL;
+	}
+
+	debugfs_create_file("message", 0600, tdev->root_debugfs_dir,
+		tdev, &mbox_test_message_ops);
+
+	debugfs_create_file("signal", 0200, tdev->root_debugfs_dir,
+		tdev, &mbox_test_signal_ops);
+
+	return 0;
+}
+
+static void mbox_test_receive_message(struct mbox_client *client, void *message)
+{
+	struct mbox_test_device *tdev = dev_get_drvdata(client->dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&tdev->lock, flags);
+	if (tdev->rx_mmio) {
+		memcpy_fromio(tdev->rx_buffer, tdev->rx_mmio, MBOX_MAX_MSG_LEN);
+		print_hex_dump_bytes("Client: Received [MMIO]: ", DUMP_PREFIX_ADDRESS,
+			tdev->rx_buffer, MBOX_MAX_MSG_LEN);
+	} else if (message) {
+		print_hex_dump_bytes("Client: Received [API]: ", DUMP_PREFIX_ADDRESS,
+			message, MBOX_MAX_MSG_LEN);
+		memcpy(tdev->rx_buffer, message, MBOX_MAX_MSG_LEN);
+	}
+	mbox_data_ready = true;
+	spin_unlock_irqrestore(&tdev->lock, flags);
+}
+
+static void mbox_test_prepare_message(struct mbox_client *client, void *message)
+{
+	struct mbox_test_device *tdev = dev_get_drvdata(client->dev);
+
+	if (tdev->tx_mmio) {
+		if (tdev->signal)
+			memcpy_toio(tdev->tx_mmio, tdev->message, MBOX_MAX_MSG_LEN);
+		else
+			memcpy_toio(tdev->tx_mmio, message, MBOX_MAX_MSG_LEN);
+	}
+}
+
+static void mbox_test_message_sent(struct mbox_client *client,
+		void *message, int r)
+{
+	if (r)
+		dev_warn(client->dev,
+			"Client: Message could not be sent: %d\n", r);
+	else
+		dev_info(client->dev,
+			"Client: Message sent\n");
+}
+
+static struct mbox_chan *
+mbox_test_request_channel(struct platform_device *pdev, const char *name)
+{
+	struct mbox_client *client;
+	struct mbox_chan *channel;
+
+	client = devm_kzalloc(&pdev->dev, sizeof(*client), GFP_KERNEL);
+	if (!client)
+		return ERR_PTR(-ENOMEM);
+
+	client->dev        = &pdev->dev;
+	client->rx_callback    = mbox_test_receive_message;
+	client->tx_prepare    = mbox_test_prepare_message;
+	client->tx_done        = mbox_test_message_sent;
+	client->tx_block    = false;
+	client->knows_txdone    = false;
+	client->tx_tout        = 500;
+
+	channel = mbox_request_channel_byname(client, name);
+	if (IS_ERR(channel)) {
+		dev_warn(&pdev->dev, "Failed to request %s channel\n", name);
+		return NULL;
+	}
+
+	return channel;
+}
+
+static int mbox_test_probe(struct platform_device *pdev)
+{
+	struct mbox_test_device *tdev;
+	struct resource *res;
+	resource_size_t size;
+	int ret;
+
+	tdev = devm_kzalloc(&pdev->dev, sizeof(*tdev), GFP_KERNEL);
+	if (!tdev)
+		return -ENOMEM;
+
+	/* It's okay for MMIO to be NULL */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	tdev->tx_mmio = devm_ioremap_resource(&pdev->dev, res);
+	if (PTR_ERR(tdev->tx_mmio) == -EBUSY) {
+		/* if reserved area in SRAM, try just ioremap */
+		size = resource_size(res);
+		tdev->tx_mmio = devm_ioremap(&pdev->dev, res->start, size);
+	} else if (IS_ERR(tdev->tx_mmio)) {
+		tdev->tx_mmio = NULL;
+	}
+
+	/* If specified, second reg entry is Rx MMIO */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	tdev->rx_mmio = devm_ioremap_resource(&pdev->dev, res);
+	if (PTR_ERR(tdev->rx_mmio) == -EBUSY) {
+		size = resource_size(res);
+		tdev->rx_mmio = devm_ioremap(&pdev->dev, res->start, size);
+	} else if (IS_ERR(tdev->rx_mmio)) {
+		tdev->rx_mmio = tdev->tx_mmio;
+	}
+
+	tdev->tx_channel = mbox_test_request_channel(pdev, "tx");
+	tdev->rx_channel = mbox_test_request_channel(pdev, "rx");
+
+	if (!tdev->tx_channel && !tdev->rx_channel)
+		return -EPROBE_DEFER;
+
+	/* If Rx is not specified but has Rx MMIO, then Rx = Tx */
+	if (!tdev->rx_channel && (tdev->rx_mmio != tdev->tx_mmio))
+		tdev->rx_channel = tdev->tx_channel;
+
+	tdev->dev = &pdev->dev;
+	platform_set_drvdata(pdev, tdev);
+
+	spin_lock_init(&tdev->lock);
+
+	if (tdev->rx_channel) {
+		tdev->rx_buffer = devm_kzalloc(&pdev->dev,
+			MBOX_MAX_MSG_LEN, GFP_KERNEL);
+		if (!tdev->rx_buffer)
+			return -ENOMEM;
+	}
+
+	ret = mbox_test_add_debugfs(pdev, tdev);
+	if (ret)
+		return ret;
+
+	dev_info(&pdev->dev, "Successfully registered\n");
+
+	return 0;
+}
+
+static int mbox_test_remove(struct platform_device *pdev)
+{
+	struct mbox_test_device *tdev = platform_get_drvdata(pdev);
+
+	debugfs_remove_recursive(tdev->root_debugfs_dir);
+
+	if (tdev->tx_channel)
+		mbox_free_channel(tdev->tx_channel);
+	if (tdev->rx_channel)
+		mbox_free_channel(tdev->rx_channel);
+
+	return 0;
+}
+
+static const struct of_device_id mbox_test_match[] = {
+	{ .compatible = "starfive,mailbox-test" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mbox_test_match);
+
+static struct platform_driver mbox_test_driver = {
+	.driver = {
+		.name = "mailbox_test",
+		.of_match_table = mbox_test_match,
+	},
+	.probe  = mbox_test_probe,
+	.remove = mbox_test_remove,
+};
+module_platform_driver(mbox_test_driver);
+
+MODULE_DESCRIPTION("mailbox test driver");
+MODULE_AUTHOR("StarFive Technology Co. Ltd.");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mailbox/starfive_mailbox.c b/drivers/mailbox/starfive_mailbox.c
new file mode 100644
index 000000000000..c73ed9c453ed
--- /dev/null
+++ b/drivers/mailbox/starfive_mailbox.c
@@ -0,0 +1,358 @@
+// SPDX-License-Identifier: GPL-2.0
+/*********************************Copyright (c)*********************************************
+ **
+ **-------------------------------file info-------------------------------------------------
+ ** Vrsions:      V1.0
+ ** Filename:     starfive_mailbox.c
+ ** Creator:      shanlong.li
+ ** Date:         2021/06/07
+ ** Description:  starfive mailbox for e24
+ **
+ **-------------------------------history----------------------------------------------
+ ** Name:         shanlong.li
+ ** Versions:     V1.0
+ ** Date:         2021/06/07
+ ** Description:
+ **
+ ** ----------------------------------------------------------------------------------------
+ ******************************************************************************************/
+
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/mailbox_controller.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/pm_runtime.h>
+
+#include "mailbox.h"
+
+#define MBOX_CHAN_MAX		4
+
+#define MBOX_BASE(mbox, ch)	((mbox)->base + ((ch) * 0x10))
+#define MBOX_IRQ_REG		0x00
+#define MBOX_SET_REG		0x04
+#define MBOX_CLR_REG		0x08
+#define MBOX_CMD_REG		0x0c
+#define MBC_PEND_SMRY		0x100
+
+typedef enum {
+	MAILBOX_CORE_U7 = 0,
+	MAILBOX_CORE_HIFI4,
+	MAILBOX_CORE_E2,
+	MAILBOX_CORE_RSVD0,
+	MAILBOX_CORE_NUM,
+} mailbox_core_t;
+
+struct mailbox_irq_name_c{
+	int id;
+	char name[16];
+};
+
+static const struct mailbox_irq_name_c irq_peer_name[MBOX_CHAN_MAX] = {
+	{MAILBOX_CORE_U7,    "u74_core"},
+	{MAILBOX_CORE_HIFI4, "hifi4_core"},
+	{MAILBOX_CORE_E2,    "e24_core"},
+	{MAILBOX_CORE_RSVD0, "" },
+};
+
+/**
+ * starfive mailbox channel information
+ *
+ * A channel can be used for TX or RX, it can trigger remote
+ * processor interrupt to notify remote processor and can receive
+ * interrupt if has incoming message.
+ *
+ * @dst_irq:    Interrupt vector for remote processor
+ * @core_id:    id for remote processor
+ */
+struct starfive_chan_info {
+	unsigned int dst_irq;
+	mailbox_core_t core_id;
+};
+
+/**
+ * starfive mailbox controller data
+ *
+ * Mailbox controller includes 4 channels and can allocate
+ * channel for message transferring.
+ *
+ * @dev:    Device to which it is attached
+ * @base:    Base address of the register mapping region
+ * @chan:    Representation of channels in mailbox controller
+ * @mchan:    Representation of channel info
+ * @controller:    Representation of a communication channel controller
+ */
+struct starfive_mbox {
+	struct device *dev;
+	void __iomem *base;
+	struct mbox_chan chan[MBOX_CHAN_MAX];
+	struct starfive_chan_info mchan[MBOX_CHAN_MAX];
+	struct mbox_controller controller;
+	struct clk *clk;
+	struct reset_control *rst_rresetn;
+};
+
+static struct starfive_mbox *to_starfive_mbox(struct mbox_controller *mbox)
+{
+	return container_of(mbox, struct starfive_mbox, controller);
+}
+
+static struct mbox_chan *
+starfive_of_mbox_index_xlate(struct mbox_controller *mbox,
+			const struct of_phandle_args *sp)
+{
+	struct starfive_mbox *sbox;
+
+	int ind = sp->args[0];
+	int core_id = sp->args[1];
+
+	if (ind >= mbox->num_chans || core_id >= MAILBOX_CORE_NUM)
+		return ERR_PTR(-EINVAL);
+
+	sbox = to_starfive_mbox(mbox);
+
+	sbox->mchan[ind].core_id = core_id;
+
+	return &mbox->chans[ind];
+}
+
+static irqreturn_t starfive_rx_irq_handler(int irq, void *p)
+{
+	struct mbox_chan *chan = p;
+	unsigned long ch = (unsigned long)chan->con_priv;
+	struct starfive_mbox *mbox = to_starfive_mbox(chan->mbox);
+	void __iomem *base = MBOX_BASE(mbox, ch);
+	u32 val;
+
+	val = readl(base + MBOX_CMD_REG);
+	if (!val)
+		return IRQ_NONE;
+
+	mbox_chan_received_data(chan, (void *)&val);
+	writel(val, base + MBOX_CLR_REG);
+	return IRQ_HANDLED;
+}
+
+static int starfive_mbox_check_state(struct mbox_chan *chan)
+{
+	unsigned long ch = (unsigned long)chan->con_priv;
+	struct starfive_mbox *mbox = to_starfive_mbox(chan->mbox);
+	unsigned long irq_flag = IRQF_SHARED;
+	long ret = 0;
+
+	pm_runtime_get_sync(mbox->dev);
+	/* MAILBOX should be with IRQF_NO_SUSPEND set */
+	if (!mbox->dev->pm_domain)
+		irq_flag |= IRQF_NO_SUSPEND;
+
+	/* Mailbox is idle so directly bail out */
+	if (readl(mbox->base + MBC_PEND_SMRY) & BIT(ch))
+		return -EBUSY;
+
+	if (mbox->mchan[ch].dst_irq > 0) {
+		dev_dbg(mbox->dev, "%s: host IRQ = %d, ch:%ld", __func__, mbox->mchan[ch].dst_irq, ch);
+		ret = devm_request_irq(mbox->dev, mbox->mchan[ch].dst_irq, starfive_rx_irq_handler,
+			irq_flag, irq_peer_name[ch].name, chan);
+		if (ret < 0)
+			dev_err(mbox->dev, "request_irq %d failed\n", mbox->mchan[ch].dst_irq);
+	}
+
+	return ret;
+}
+
+static int starfive_mbox_startup(struct mbox_chan *chan)
+{
+	return starfive_mbox_check_state(chan);
+}
+
+static void starfive_mbox_shutdown(struct mbox_chan *chan)
+{
+	struct starfive_mbox *mbox = to_starfive_mbox(chan->mbox);
+	unsigned long ch = (unsigned long)chan->con_priv;
+	void __iomem *base = MBOX_BASE(mbox, ch);
+
+	writel(0x0, base + MBOX_IRQ_REG);
+	writel(0x0, base + MBOX_CLR_REG);
+
+	if (mbox->mchan[ch].dst_irq > 0)
+		devm_free_irq(mbox->dev, mbox->mchan[ch].dst_irq, chan);
+	pm_runtime_put_sync(mbox->dev);
+}
+
+static int starfive_mbox_send_data(struct mbox_chan *chan, void *msg)
+{
+	unsigned long ch = (unsigned long)chan->con_priv;
+	struct starfive_mbox *mbox = to_starfive_mbox(chan->mbox);
+	struct starfive_chan_info *mchan = &mbox->mchan[ch];
+	void __iomem *base = MBOX_BASE(mbox, ch);
+	u32 *buf = msg;
+
+	/* Ensure channel is released */
+	if (readl(mbox->base + MBC_PEND_SMRY) & BIT(ch)) {
+		pr_debug("%s:%d. busy\n", __func__, __LINE__);
+		return -EBUSY;
+	}
+
+	/* Clear mask for destination interrupt */
+	writel(BIT(mchan->core_id), base + MBOX_IRQ_REG);
+
+	/* Fill message data */
+	writel(*buf, base + MBOX_SET_REG);
+	return 0;
+}
+
+static struct mbox_chan_ops starfive_mbox_ops = {
+	.startup = starfive_mbox_startup,
+	.send_data = starfive_mbox_send_data,
+	.shutdown = starfive_mbox_shutdown,
+};
+
+static const struct of_device_id starfive_mbox_of_match[] = {
+	{ .compatible = "starfive,mail_box",},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, starfive_mbox_of_match);
+
+void starfive_mailbox_init(struct starfive_mbox *mbox)
+{
+	mbox->clk = devm_clk_get_optional(mbox->dev, "clk_apb");
+	if (IS_ERR(mbox->clk)) {
+		dev_err(mbox->dev, "failed to get mailbox\n");
+		return;
+	}
+
+	mbox->rst_rresetn = devm_reset_control_get_exclusive(mbox->dev, "mbx_rre");
+	if (IS_ERR(mbox->rst_rresetn)) {
+		dev_err(mbox->dev, "failed to get mailbox reset\n");
+		return;
+	}
+
+	clk_prepare_enable(mbox->clk);
+	reset_control_deassert(mbox->rst_rresetn);
+}
+
+static int starfive_mbox_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct starfive_mbox *mbox;
+	struct mbox_chan *chan;
+	struct resource *res;
+	unsigned long ch;
+	int err;
+
+	mbox = devm_kzalloc(dev, sizeof(*mbox), GFP_KERNEL);
+	if (!mbox)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mbox->base = devm_ioremap_resource(dev, res);
+	mbox->dev = dev;
+
+	if (IS_ERR(mbox->base))
+		return PTR_ERR(mbox->base);
+
+	starfive_mailbox_init(mbox);
+
+	mbox->controller.dev = dev;
+	mbox->controller.chans = mbox->chan;
+	mbox->controller.num_chans = MBOX_CHAN_MAX;
+	mbox->controller.ops = &starfive_mbox_ops;
+	mbox->controller.of_xlate = starfive_of_mbox_index_xlate;
+	mbox->controller.txdone_irq = true;
+	mbox->controller.txdone_poll = false;
+
+	/* Initialize mailbox channel data */
+	chan = mbox->chan;
+	for (ch = 0; ch < MBOX_CHAN_MAX; ch++) {
+		mbox->mchan[ch].dst_irq = 0;
+		mbox->mchan[ch].core_id = (mailbox_core_t)ch;
+		chan[ch].con_priv = (void *)ch;
+	}
+	mbox->mchan[MAILBOX_CORE_HIFI4].dst_irq = platform_get_irq(pdev, 0);
+	mbox->mchan[MAILBOX_CORE_E2].dst_irq = platform_get_irq(pdev, 1);
+
+	err = mbox_controller_register(&mbox->controller);
+	if (err) {
+		dev_err(dev, "Failed to register mailbox %d\n", err);
+		return err;
+	}
+
+	platform_set_drvdata(pdev, mbox);
+	dev_info(dev, "Mailbox enabled\n");
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	return 0;
+}
+
+static int starfive_mbox_remove(struct platform_device *pdev)
+{
+	struct starfive_mbox *mbox = platform_get_drvdata(pdev);
+
+	mbox_controller_unregister(&mbox->controller);
+	devm_clk_put(mbox->dev, mbox->clk);
+	pm_runtime_disable(mbox->dev);
+
+	return 0;
+}
+
+static int __maybe_unused starfive_mbox_suspend(struct device *dev)
+{
+	struct starfive_mbox *mbox = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(mbox->clk);
+
+	return 0;
+}
+
+static int __maybe_unused starfive_mbox_resume(struct device *dev)
+{
+	struct starfive_mbox *mbox = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(mbox->clk);
+	if (ret)
+		dev_err(dev, "failed to enable clock\n");
+
+	return ret;
+}
+
+static const struct dev_pm_ops starfive_mbox_pm_ops = {
+	.suspend = starfive_mbox_suspend,
+	.resume = starfive_mbox_resume,
+	SET_RUNTIME_PM_OPS(starfive_mbox_suspend, starfive_mbox_resume, NULL)
+};
+static struct platform_driver starfive_mbox_driver = {
+	.probe  = starfive_mbox_probe,
+	.remove = starfive_mbox_remove,
+	.driver = {
+	.name = "mailbox",
+		.of_match_table = starfive_mbox_of_match,
+		.pm = &starfive_mbox_pm_ops,
+	},
+};
+
+static int __init starfive_mbox_init(void)
+{
+	return platform_driver_register(&starfive_mbox_driver);
+}
+core_initcall(starfive_mbox_init);
+
+static void __exit starfive_mbox_exit(void)
+{
+	platform_driver_unregister(&starfive_mbox_driver);
+}
+module_exit(starfive_mbox_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("StarFive Mailbox Controller");
+MODULE_AUTHOR("StarFive Technology Co. Ltd.");
diff --git a/drivers/media/platform/Kconfig b/drivers/media/platform/Kconfig
index 7e152bbb4fa6..30bf0d4c2ce9 100644
--- a/drivers/media/platform/Kconfig
+++ b/drivers/media/platform/Kconfig
@@ -138,6 +138,17 @@ config VIDEO_STM32_DCMI
 	  To compile this driver as a module, choose M here: the module
 	  will be called stm32-dcmi.
 
+config VIDEO_STF_VIN
+	tristate "starfive VIC video in support"
+	depends on VIDEO_V4L2 && OF
+	select MEDIA_CONTROLLER
+	select VIDEOBUF2_DMA_CONTIG
+	select VIDEO_V4L2_SUBDEV_API
+	select V4L2_FWNODE
+	help
+	  To compile this driver as a module, choose M here: the module
+	  will be called stf-vin.
+
 config VIDEO_RENESAS_CEU
 	tristate "Renesas Capture Engine Unit (CEU) driver"
 	depends on VIDEO_DEV && VIDEO_V4L2
@@ -153,6 +164,7 @@ source "drivers/media/platform/xilinx/Kconfig"
 source "drivers/media/platform/rcar-vin/Kconfig"
 source "drivers/media/platform/atmel/Kconfig"
 source "drivers/media/platform/sunxi/Kconfig"
+source "drivers/media/platform/starfive/Kconfig"
 
 config VIDEO_TI_CAL
 	tristate "TI CAL (Camera Adaptation Layer) driver"
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index 62b6cdc8c730..ecc171bc24ed 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -41,6 +41,8 @@ obj-$(CONFIG_VIDEO_STI_DELTA)		+= sti/delta/
 
 obj-y					+= stm32/
 
+obj-y					+= starfive/
+
 obj-y					+= davinci/
 
 obj-$(CONFIG_VIDEO_SH_VOU)		+= sh_vou.o
diff --git a/drivers/media/platform/starfive/Kconfig b/drivers/media/platform/starfive/Kconfig
new file mode 100644
index 000000000000..53ab79ae5232
--- /dev/null
+++ b/drivers/media/platform/starfive/Kconfig
@@ -0,0 +1,43 @@
+#
+# VIN sensor driver configuration
+#
+
+config VIN_SENSOR_OV5640
+	tristate "VIN SENSOR support OV5640"
+	depends on VIDEO_STF_VIN
+	select V4L2_FWNODE
+	default n
+	help
+	  Say Y here if you want to have support for VIN sensor OV5640
+
+config VIN_SENSOR_SC2235
+	tristate "VIN SENSOR support SC2235"
+	depends on VIDEO_STF_VIN
+	select V4L2_FWNODE
+	default n
+	help
+	  Say Y here if you want to have support for VIN sensor SC2235
+
+config VIN_SENSOR_OV4689
+	tristate "VIN SENSOR support OV4689"
+	depends on VIDEO_STF_VIN
+	select V4L2_FWNODE
+	default n
+	help
+	  Say Y here if you want to have support for VIN sensor OV4689
+
+config VIN_SENSOR_OV13850
+	bool "VIN SENSOR support OV13850"
+	depends on VIDEO_STF_VIN
+	select V4L2_FWNODE
+	default n
+	help
+	  Say Y here if you want to have support for VIN sensor OV13850
+
+config VIN_SENSOR_IMX219
+	tristate "VIN SENSOR support IMX219"
+	depends on VIDEO_STF_VIN
+	select V4L2_FWNODE
+	default n
+	help
+	  Say Y here if you want to have support for VIN sensor IMX219
diff --git a/drivers/media/platform/starfive/Makefile b/drivers/media/platform/starfive/Makefile
new file mode 100644
index 000000000000..a1d46ed198bc
--- /dev/null
+++ b/drivers/media/platform/starfive/Makefile
@@ -0,0 +1,33 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for RTC class/drivers.
+#
+
+#obj-$(CONFIG_VIN_SENSOR_OV5640) += ov5640_dvp.o
+#obj-$(CONFIG_VIN_SENSOR_SC2235) += sc2235.o
+#obj-$(CONFIG_VIN_SENSOR_OV4689) += ov4689_mipi.o
+#obj-$(CONFIG_VIDEO_STF_VIN) += stf_vin.o stf_event.o stf_isp.o stf_csi.o
+
+obj-$(CONFIG_VIN_SENSOR_OV5640) += v4l2_driver/ov5640.o
+obj-$(CONFIG_VIN_SENSOR_SC2235) += v4l2_driver/sc2235.o
+obj-$(CONFIG_VIN_SENSOR_OV4689) += v4l2_driver/ov4689_mipi.o
+obj-$(CONFIG_VIN_SENSOR_OV13850) += v4l2_driver/ov13850_mipi.o
+obj-$(CONFIG_VIN_SENSOR_IMX219) += v4l2_driver/imx219_mipi.o
+
+starfivecamss-objs += 	v4l2_driver/stfcamss.o \
+	                       	v4l2_driver/stf_event.o \
+				v4l2_driver/stf_dvp.o   \
+				v4l2_driver/stf_csi.o   \
+				v4l2_driver/stf_csiphy.o   \
+				v4l2_driver/stf_isp.o   \
+                                v4l2_driver/stf_video.o \
+				v4l2_driver/stf_vin.o \
+				v4l2_driver/stf_vin_hw_ops.o \
+				v4l2_driver/stf_csi_hw_ops.o \
+				v4l2_driver/stf_csiphy_hw_ops.o \
+				v4l2_driver/stf_isp_hw_ops.o \
+				v4l2_driver/stf_dvp_hw_ops.o \
+				v4l2_driver/stf_dmabuf.o
+
+
+obj-$(CONFIG_VIDEO_STF_VIN) += starfivecamss.o \
diff --git a/drivers/media/platform/starfive/v4l2_driver/Readme.txt b/drivers/media/platform/starfive/v4l2_driver/Readme.txt
new file mode 100644
index 000000000000..b291f1cb3a7b
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/Readme.txt
@@ -0,0 +1,10 @@
+
+/dev/video0: Output the camera data directly.
+/dev/video1: Output the data of the camera converted by isp.
+
+ensure linux/arch/riscv/configs/starfive_jh7110_defconfig:
+CONFIG_VIDEO_STF_VIN=y
+CONFIG_VIN_SENSOR_IMX219=y
+
+Only support the lane4/lane5 of dphy as clock lane, lane0/lane1/lane2/lane3
+as data lane.
diff --git a/drivers/media/platform/starfive/v4l2_driver/imx219_mipi.c b/drivers/media/platform/starfive/v4l2_driver/imx219_mipi.c
new file mode 100644
index 000000000000..5ed8a3d19795
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/imx219_mipi.c
@@ -0,0 +1,1583 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * A V4L2 driver for Sony IMX219 cameras.
+ * Copyright (C) 2019, Raspberry Pi (Trading) Ltd
+ *
+ * Based on Sony imx258 camera driver
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * DT / fwnode changes, and regulator / GPIO control taken from imx214 driver
+ * Copyright 2018 Qtechnology A/S
+ *
+ * Flip handling taken from the Sony IMX319 driver.
+ * Copyright (C) 2018 Intel Corporation
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-mediabus.h>
+#include <asm/unaligned.h>
+
+#define IMX219_REG_VALUE_08BIT		1
+#define IMX219_REG_VALUE_16BIT		2
+
+#define IMX219_REG_MODE_SELECT		0x0100
+#define IMX219_MODE_STANDBY		0x00
+#define IMX219_MODE_STREAMING		0x01
+
+/* Chip ID */
+#define IMX219_REG_CHIP_ID		0x0000
+#define IMX219_CHIP_ID			0x0219
+
+/* External clock frequency is 24.0M */
+#define IMX219_XCLK_FREQ		24000000
+
+/* Pixel rate is fixed at 182.4M for all the modes */
+#define IMX219_PIXEL_RATE		182400000
+
+#define IMX219_DEFAULT_LINK_FREQ	456000000
+
+/* V_TIMING internal */
+#define IMX219_REG_VTS			0x0160
+#define IMX219_VTS_15FPS		0x0dc6
+#define IMX219_VTS_30FPS_1080P		0x06e3
+#define IMX219_VTS_30FPS_BINNED		0x06e3
+#define IMX219_VTS_30FPS_1280x720	0x06e3
+#define IMX219_VTS_30FPS_640x480	0x06e3
+#define IMX219_VTS_MAX			0xffff
+
+#define IMX219_VBLANK_MIN		4
+
+/*Frame Length Line*/
+#define IMX219_FLL_MIN			0x08a6
+#define IMX219_FLL_MAX			0xffff
+#define IMX219_FLL_STEP			1
+#define IMX219_FLL_DEFAULT		0x0c98
+
+/* HBLANK control - read only */
+#define IMX219_PPL_DEFAULT		3448
+
+/* Exposure control */
+#define IMX219_REG_EXPOSURE		0x015a
+#define IMX219_EXPOSURE_MIN		4
+#define IMX219_EXPOSURE_STEP		1
+#define IMX219_EXPOSURE_DEFAULT		0x640
+#define IMX219_EXPOSURE_MAX		65535
+
+/* Analog gain control */
+#define IMX219_REG_ANALOG_GAIN		0x0157
+#define IMX219_ANA_GAIN_MIN		0
+#define IMX219_ANA_GAIN_MAX		232
+#define IMX219_ANA_GAIN_STEP		1
+#define IMX219_ANA_GAIN_DEFAULT		0xd0
+
+/* Digital gain control */
+#define IMX219_REG_DIGITAL_GAIN		0x0158
+#define IMX219_DGTL_GAIN_MIN		0x0100
+#define IMX219_DGTL_GAIN_MAX		0x0fff
+#define IMX219_DGTL_GAIN_DEFAULT	0x0100
+#define IMX219_DGTL_GAIN_STEP		1
+
+#define IMX219_REG_ORIENTATION		0x0172
+
+/* Test Pattern Control */
+#define IMX219_REG_TEST_PATTERN		0x0600
+#define IMX219_TEST_PATTERN_DISABLE	0
+#define IMX219_TEST_PATTERN_SOLID_COLOR	1
+#define IMX219_TEST_PATTERN_COLOR_BARS	2
+#define IMX219_TEST_PATTERN_GREY_COLOR	3
+#define IMX219_TEST_PATTERN_PN9		4
+
+/* Test pattern colour components */
+#define IMX219_REG_TESTP_RED		0x0602
+#define IMX219_REG_TESTP_GREENR		0x0604
+#define IMX219_REG_TESTP_BLUE		0x0606
+#define IMX219_REG_TESTP_GREENB		0x0608
+#define IMX219_TESTP_COLOUR_MIN		0
+#define IMX219_TESTP_COLOUR_MAX		0x03ff
+#define IMX219_TESTP_COLOUR_STEP	1
+#define IMX219_TESTP_RED_DEFAULT	IMX219_TESTP_COLOUR_MAX
+#define IMX219_TESTP_GREENR_DEFAULT	0
+#define IMX219_TESTP_BLUE_DEFAULT	0
+#define IMX219_TESTP_GREENB_DEFAULT	0
+
+/* IMX219 native and active pixel array size. */
+#define IMX219_NATIVE_WIDTH		3296U
+#define IMX219_NATIVE_HEIGHT		2480U
+#define IMX219_PIXEL_ARRAY_LEFT		8U
+#define IMX219_PIXEL_ARRAY_TOP		8U
+#define IMX219_PIXEL_ARRAY_WIDTH	3280U
+#define IMX219_PIXEL_ARRAY_HEIGHT	2464U
+
+struct imx219_reg {
+	u16 address;
+	u8 val;
+};
+
+struct imx219_reg_list {
+	unsigned int num_of_regs;
+	const struct imx219_reg *regs;
+};
+
+/* Mode : resolution and related config&values */
+struct imx219_mode {
+	/* Frame width */
+	unsigned int width;
+	/* Frame height */
+	unsigned int height;
+
+	unsigned int fps;
+
+	/* Analog crop rectangle. */
+	struct v4l2_rect crop;
+
+	/* V-timing */
+	unsigned int vts_def;
+
+	/* Default register values */
+	struct imx219_reg_list reg_list;
+};
+
+/*
+ * Register sets lifted off the i2C interface from the Raspberry Pi firmware
+ * driver.
+ * 3280x2464 = mode 2, 1920x1080 = mode 1, 1640x1232 = mode 4, 640x480 = mode 7.
+ */
+
+static const struct imx219_reg mode_1920_1080_regs[] = {
+	{0x0100, 0x00},
+	{0x30eb, 0x05},
+	{0x30eb, 0x0c},
+	{0x300a, 0xff},
+	{0x300b, 0xff},
+	{0x30eb, 0x05},
+	{0x30eb, 0x09},
+	{0x0114, 0x01},
+	{0x0128, 0x00},
+	{0x012a, 0x18},
+	{0x012b, 0x00},
+	{0x0162, 0x0d},
+	{0x0163, 0x78},
+	{0x0164, 0x02},
+	{0x0165, 0xa8},
+	{0x0166, 0x0a},
+	{0x0167, 0x27},
+	{0x0168, 0x02},
+	{0x0169, 0xb4},
+	{0x016a, 0x06},
+	{0x016b, 0xeb},
+	{0x016c, 0x07},
+	{0x016d, 0x80},
+	{0x016e, 0x04},
+	{0x016f, 0x38},
+	{0x0170, 0x01},
+	{0x0171, 0x01},
+	{0x0174, 0x00},
+	{0x0175, 0x00},
+	{0x0301, 0x05},
+	{0x0303, 0x01},
+	{0x0304, 0x03},
+	{0x0305, 0x03},
+	{0x0306, 0x00},
+	{0x0307, 0x39},
+	{0x030b, 0x01},
+	{0x030c, 0x00},
+	{0x030d, 0x72},
+	{0x0624, 0x07},
+	{0x0625, 0x80},
+	{0x0626, 0x04},
+	{0x0627, 0x38},
+	{0x455e, 0x00},
+	{0x471e, 0x4b},
+	{0x4767, 0x0f},
+	{0x4750, 0x14},
+	{0x4540, 0x00},
+	{0x47b4, 0x14},
+	{0x4713, 0x30},
+	{0x478b, 0x10},
+	{0x478f, 0x10},
+	{0x4793, 0x10},
+	{0x4797, 0x0e},
+	{0x479b, 0x0e},
+};
+
+static const struct imx219_reg mode_1280_720_regs[] = {
+	{0x0100, 0x00},
+	{0x30eb, 0x05},
+	{0x30eb, 0x0c},
+	{0x300a, 0xff},
+	{0x300b, 0xff},
+	{0x30eb, 0x05},
+	{0x30eb, 0x09},
+	{0x0114, 0x01},
+	{0x0128, 0x00},
+	{0x012a, 0x18},
+	{0x012b, 0x00},
+	{0x0162, 0x0d},
+	{0x0163, 0x78},
+	{0x0164, 0x01},
+	{0x0165, 0x68},
+	{0x0166, 0x0b},
+	{0x0167, 0x67},
+	{0x0168, 0x02},
+	{0x0169, 0x00},
+	{0x016a, 0x07},
+	{0x016b, 0x9f},
+	{0x016c, 0x05},
+	{0x016d, 0x00},
+	{0x016e, 0x02},
+	{0x016f, 0xd0},
+	{0x0170, 0x01},
+	{0x0171, 0x01},
+	{0x0174, 0x01},
+	{0x0175, 0x01},
+	{0x0301, 0x05},
+	{0x0303, 0x01},
+	{0x0304, 0x03},
+	{0x0305, 0x03},
+	{0x0306, 0x00},
+	{0x0307, 0x39},
+	{0x030b, 0x01},
+	{0x030c, 0x00},
+	{0x030d, 0x72},
+	{0x0624, 0x06},
+	{0x0625, 0x68},
+	{0x0626, 0x04},
+	{0x0627, 0xd0},
+	{0x455e, 0x00},
+	{0x471e, 0x4b},
+	{0x4767, 0x0f},
+	{0x4750, 0x14},
+	{0x4540, 0x00},
+	{0x47b4, 0x14},
+	{0x4713, 0x30},
+	{0x478b, 0x10},
+	{0x478f, 0x10},
+	{0x4793, 0x10},
+	{0x4797, 0x0e},
+	{0x479b, 0x0e},
+};
+
+static const struct imx219_reg mode_640_480_regs[] = {
+	{0x0100, 0x00},
+	{0x30eb, 0x05},
+	{0x30eb, 0x0c},
+	{0x300a, 0xff},
+	{0x300b, 0xff},
+	{0x30eb, 0x05},
+	{0x30eb, 0x09},
+	{0x0114, 0x01},
+	{0x0128, 0x00},
+	{0x012a, 0x18},
+	{0x012b, 0x00},
+	{0x0162, 0x0d},
+	{0x0163, 0x78},
+	{0x0164, 0x03},
+	{0x0165, 0xe8},
+	{0x0166, 0x08},
+	{0x0167, 0xe7},
+	{0x0168, 0x02},
+	{0x0169, 0xf0},
+	{0x016a, 0x06},
+	{0x016b, 0xaf},
+	{0x016c, 0x02},
+	{0x016d, 0x80},
+	{0x016e, 0x01},
+	{0x016f, 0xe0},
+	{0x0170, 0x01},
+	{0x0171, 0x01},
+	{0x0174, 0x03},
+	{0x0175, 0x03},
+	{0x0301, 0x05},
+	{0x0303, 0x01},
+	{0x0304, 0x03},
+	{0x0305, 0x03},
+	{0x0306, 0x00},
+	{0x0307, 0x39},
+	{0x030b, 0x01},
+	{0x030c, 0x00},
+	{0x030d, 0x72},
+	{0x0624, 0x06},
+	{0x0625, 0x68},
+	{0x0626, 0x04},
+	{0x0627, 0xd0},
+	{0x455e, 0x00},
+	{0x471e, 0x4b},
+	{0x4767, 0x0f},
+	{0x4750, 0x14},
+	{0x4540, 0x00},
+	{0x47b4, 0x14},
+	{0x4713, 0x30},
+	{0x478b, 0x10},
+	{0x478f, 0x10},
+	{0x4793, 0x10},
+	{0x4797, 0x0e},
+	{0x479b, 0x0e},
+};
+
+static const struct imx219_reg raw8_framefmt_regs[] = {
+	{0x018c, 0x08},
+	{0x018d, 0x08},
+	{0x0309, 0x08},
+};
+
+static const struct imx219_reg raw10_framefmt_regs[] = {
+	{0x018c, 0x0a},
+	{0x018d, 0x0a},
+	{0x0309, 0x0a},
+};
+
+static const s64 imx219_link_freq_menu[] = {
+	IMX219_DEFAULT_LINK_FREQ,
+};
+
+static const char * const imx219_test_pattern_menu[] = {
+	"Disabled",
+	"Color Bars",
+	"Solid Color",
+	"Grey Color Bars",
+	"PN9"
+};
+
+static const int imx219_test_pattern_val[] = {
+	IMX219_TEST_PATTERN_DISABLE,
+	IMX219_TEST_PATTERN_COLOR_BARS,
+	IMX219_TEST_PATTERN_SOLID_COLOR,
+	IMX219_TEST_PATTERN_GREY_COLOR,
+	IMX219_TEST_PATTERN_PN9,
+};
+
+/* regulator supplies */
+static const char * const imx219_supply_name[] = {
+	/* Supplies can be enabled in any order */
+	"VANA",  /* Analog (2.8V) supply */
+	"VDIG",  /* Digital Core (1.8V) supply */
+	"VDDL",  /* IF (1.2V) supply */
+};
+
+#define IMX219_NUM_SUPPLIES ARRAY_SIZE(imx219_supply_name)
+
+/*
+ * The supported formats.
+ * This table MUST contain 4 entries per format, to cover the various flip
+ * combinations in the order
+ * - no flip
+ * - h flip
+ * - v flip
+ * - h&v flips
+ */
+static const u32 codes[] = {
+	MEDIA_BUS_FMT_SRGGB10_1X10,
+	MEDIA_BUS_FMT_SGRBG10_1X10,
+	MEDIA_BUS_FMT_SGBRG10_1X10,
+	MEDIA_BUS_FMT_SBGGR10_1X10,
+
+	MEDIA_BUS_FMT_SRGGB8_1X8,
+	MEDIA_BUS_FMT_SGRBG8_1X8,
+	MEDIA_BUS_FMT_SGBRG8_1X8,
+	MEDIA_BUS_FMT_SBGGR8_1X8,
+};
+
+/*
+ * Initialisation delay between XCLR low->high and the moment when the sensor
+ * can start capture (i.e. can leave software stanby) must be not less than:
+ *   t4 + max(t5, t6 + <time to initialize the sensor register over I2C>)
+ * where
+ *   t4 is fixed, and is max 200uS,
+ *   t5 is fixed, and is 6000uS,
+ *   t6 depends on the sensor external clock, and is max 32000 clock periods.
+ * As per sensor datasheet, the external clock must be from 6MHz to 27MHz.
+ * So for any acceptable external clock t6 is always within the range of
+ * 1185 to 5333 uS, and is always less than t5.
+ * For this reason this is always safe to wait (t4 + t5) = 6200 uS, then
+ * initialize the sensor over I2C, and then exit the software standby.
+ *
+ * This start-up time can be optimized a bit more, if we start the writes
+ * over I2C after (t4+t6), but before (t4+t5) expires. But then sensor
+ * initialization over I2C may complete before (t4+t5) expires, and we must
+ * ensure that capture is not started before (t4+t5).
+ *
+ * This delay doesn't account for the power supply startup time. If needed,
+ * this should be taken care of via the regulator framework. E.g. in the
+ * case of DT for regulator-fixed one should define the startup-delay-us
+ * property.
+ */
+#define IMX219_XCLR_MIN_DELAY_US	6200
+#define IMX219_XCLR_DELAY_RANGE_US	1000
+
+/* Mode configs */
+static const struct imx219_mode supported_modes[] = {
+	{
+		/* 1080P 30fps cropped */
+		.width = 1920,
+		.height = 1080,
+		.fps = 30,
+		.crop = {
+			.left = 688,
+			.top = 700,
+			.width = 1920,
+			.height = 1080
+		},
+		.vts_def = IMX219_VTS_30FPS_1080P,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1920_1080_regs),
+			.regs = mode_1920_1080_regs,
+		},
+	},
+	{
+		/* 1280x720 30fps mode */
+		.width = 1280,
+		.height = 720,
+		.fps = 30,
+		.crop = {
+			.left = 360,
+			.top = 512,
+			.width = 2560,
+			.height = 1440
+		},
+		.vts_def = IMX219_VTS_30FPS_1280x720,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_1280_720_regs),
+			.regs = mode_1280_720_regs,
+		},
+	},
+	{
+		/* 640x480 30fps mode */
+		.width = 640,
+		.height = 480,
+		.fps = 30,
+		.crop = {
+			.left = 1008,
+			.top = 760,
+			.width = 1280,
+			.height = 960
+		},
+		.vts_def = IMX219_VTS_30FPS_640x480,
+		.reg_list = {
+			.num_of_regs = ARRAY_SIZE(mode_640_480_regs),
+			.regs = mode_640_480_regs,
+		},
+	},
+};
+
+struct imx219 {
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	//struct v4l2_fwnode_endpoint ep; /* the parsed DT endpoint info */
+
+	struct v4l2_mbus_framefmt fmt;
+
+	struct clk *xclk; /* system clock to IMX219 */
+	u32 xclk_freq;
+
+	struct gpio_desc *reset_gpio;
+	struct regulator_bulk_data supplies[IMX219_NUM_SUPPLIES];
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	/* V4L2 Controls */
+	struct v4l2_ctrl *pixel_rate;
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *exposure;
+	struct v4l2_ctrl *vflip;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vblank;
+	struct v4l2_ctrl *hblank;
+
+	/* Current mode */
+	const struct imx219_mode *mode;
+	struct v4l2_fract frame_interval;
+
+	/*
+	 * Mutex for serialized access:
+	 * Protect sensor module set pad format and start/stop streaming safely.
+	 */
+	struct mutex mutex;
+
+	/* Streaming on/off */
+	int streaming;
+};
+
+static inline struct imx219 *to_imx219(struct v4l2_subdev *_sd)
+{
+	return container_of(_sd, struct imx219, sd);
+}
+
+/* Read registers up to 2 at a time */
+static int imx219_read_reg(struct imx219 *imx219, u16 reg, u32 len, u32 *val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	struct i2c_msg msgs[2];
+	u8 addr_buf[2] = { reg >> 8, reg & 0xff };
+	u8 data_buf[4] = { 0, };
+	int ret;
+
+	if (len > 4)
+		return -EINVAL;
+
+	/* Write register address */
+	msgs[0].addr = client->addr;
+	msgs[0].flags = 0;
+	msgs[0].len = ARRAY_SIZE(addr_buf);
+	msgs[0].buf = addr_buf;
+
+	/* Read data from register */
+	msgs[1].addr = client->addr;
+	msgs[1].flags = I2C_M_RD;
+	msgs[1].len = len;
+	msgs[1].buf = &data_buf[4 - len];
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+	if (ret != ARRAY_SIZE(msgs))
+		return -EIO;
+
+	*val = get_unaligned_be32(data_buf);
+
+	return 0;
+}
+
+/* Write registers up to 2 at a time */
+static int imx219_write_reg(struct imx219 *imx219, u16 reg, u32 len, u32 val)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	u8 buf[6];
+
+	if (len > 4)
+		return -EINVAL;
+
+	put_unaligned_be16(reg, buf);
+	put_unaligned_be32(val << (8 * (4 - len)), buf + 2);
+	if (i2c_master_send(client, buf, len + 2) != len + 2)
+		return -EIO;
+
+	return 0;
+}
+
+/* Write a list of registers */
+static int imx219_write_regs(struct imx219 *imx219,
+			     const struct imx219_reg *regs, u32 len)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < len; i++) {
+		ret = imx219_write_reg(imx219, regs[i].address, 1, regs[i].val);
+		if (ret) {
+			dev_err_ratelimited(&client->dev,
+					    "Failed to write reg 0x%4.4x. error = %d\n",
+					    regs[i].address, ret);
+
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/* Get bayer order based on flip setting. */
+static u32 imx219_get_format_code(struct imx219 *imx219, u32 code)
+{
+	unsigned int i;
+
+	lockdep_assert_held(&imx219->mutex);
+
+	for (i = 0; i < ARRAY_SIZE(codes); i++)
+		if (codes[i] == code)
+			break;
+
+	if (i >= ARRAY_SIZE(codes))
+		i = 0;
+
+	i = (i & ~3) | (imx219->vflip->val ? 2 : 0) |
+	    (imx219->hflip->val ? 1 : 0);
+
+	return codes[i];
+}
+
+static void imx219_set_default_format(struct imx219 *imx219)
+{
+	struct v4l2_mbus_framefmt *fmt;
+
+	fmt = &imx219->fmt;
+	fmt->code = MEDIA_BUS_FMT_SRGGB10_1X10;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
+		fmt->colorspace, fmt->ycbcr_enc);
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = supported_modes[0].width;
+	fmt->height = supported_modes[0].height;
+	fmt->field = V4L2_FIELD_NONE;
+}
+
+static int imx219_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+	struct v4l2_mbus_framefmt *try_fmt =
+		v4l2_subdev_get_try_format(sd, fh->pad, 0);
+	struct v4l2_rect *try_crop;
+
+	mutex_lock(&imx219->mutex);
+
+	/* Initialize try_fmt */
+	try_fmt->width = supported_modes[0].width;
+	try_fmt->height = supported_modes[0].height;
+	try_fmt->code = imx219_get_format_code(imx219, MEDIA_BUS_FMT_SRGGB10_1X10);
+	try_fmt->field = V4L2_FIELD_NONE;
+
+	/* Initialize try_crop rectangle. */
+	try_crop = v4l2_subdev_get_try_crop(sd, fh->pad, 0);
+	try_crop->top = IMX219_PIXEL_ARRAY_TOP;
+	try_crop->left = IMX219_PIXEL_ARRAY_LEFT;
+	try_crop->width = IMX219_PIXEL_ARRAY_WIDTH;
+	try_crop->height = IMX219_PIXEL_ARRAY_HEIGHT;
+
+	mutex_unlock(&imx219->mutex);
+
+	return 0;
+}
+
+static int imx219_set_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct imx219 *imx219 =
+		container_of(ctrl->handler, struct imx219, ctrl_handler);
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	int ret;
+
+	if (ctrl->id == V4L2_CID_VBLANK) {
+		int exposure_max, exposure_def;
+
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = imx219->mode->height + ctrl->val - 4;
+		exposure_def = (exposure_max < IMX219_EXPOSURE_DEFAULT) ?
+			exposure_max : IMX219_EXPOSURE_DEFAULT;
+		__v4l2_ctrl_modify_range(imx219->exposure, imx219->exposure->minimum,
+				exposure_max, imx219->exposure->step, exposure_def);
+	}
+
+	/*
+	 * Applying V4L2 control value only happens
+	 * when power is up for streaming
+	 */
+	if (pm_runtime_get_if_in_use(&client->dev) == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = imx219_write_reg(imx219, IMX219_REG_ANALOG_GAIN,
+				IMX219_REG_VALUE_08BIT, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = imx219_write_reg(imx219, IMX219_REG_EXPOSURE,
+				IMX219_REG_VALUE_16BIT, ctrl->val);
+		break;
+	case V4L2_CID_DIGITAL_GAIN:
+		ret = imx219_write_reg(imx219, IMX219_REG_DIGITAL_GAIN,
+				IMX219_REG_VALUE_16BIT, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = imx219_write_reg(imx219, IMX219_REG_TEST_PATTERN,
+				IMX219_REG_VALUE_16BIT, imx219_test_pattern_val[ctrl->val]);
+		break;
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+		ret = imx219_write_reg(imx219, IMX219_REG_ORIENTATION, 1,
+			imx219->hflip->val | imx219->vflip->val << 1);
+		break;
+	case V4L2_CID_VBLANK:
+		ret = imx219_write_reg(imx219, IMX219_REG_VTS, IMX219_REG_VALUE_16BIT,
+				imx219->mode->height + ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN_RED:
+		ret = imx219_write_reg(imx219, IMX219_REG_TESTP_RED,
+				IMX219_REG_VALUE_16BIT, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN_GREENR:
+		ret = imx219_write_reg(imx219, IMX219_REG_TESTP_GREENR,
+				IMX219_REG_VALUE_16BIT, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN_BLUE:
+		ret = imx219_write_reg(imx219, IMX219_REG_TESTP_BLUE,
+				IMX219_REG_VALUE_16BIT, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN_GREENB:
+		ret = imx219_write_reg(imx219, IMX219_REG_TESTP_GREENB,
+				IMX219_REG_VALUE_16BIT, ctrl->val);
+		break;
+	default:
+		dev_info(&client->dev,
+			 "ctrl(id:0x%x,val:0x%x) is not handled\n", ctrl->id, ctrl->val);
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops imx219_ctrl_ops = {
+	.s_ctrl = imx219_set_ctrl,
+};
+
+static int imx219_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+
+	if (code->index >= (ARRAY_SIZE(codes) / 4))
+		return -EINVAL;
+
+	mutex_lock(&imx219->mutex);
+	code->code = imx219_get_format_code(imx219, codes[code->index * 4]);
+	mutex_unlock(&imx219->mutex);
+
+	return 0;
+}
+
+static int imx219_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+	u32 code;
+
+	if (fse->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	mutex_lock(&imx219->mutex);
+	code = imx219_get_format_code(imx219, fse->code);
+	mutex_unlock(&imx219->mutex);
+	if (fse->code != code)
+		return -EINVAL;
+
+	fse->min_width = supported_modes[fse->index].width;
+	fse->max_width = fse->min_width;
+	fse->min_height = supported_modes[fse->index].height;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int imx219_try_frame_interval(struct imx219 *imx219,
+				     struct v4l2_fract *fi,
+				     u32 w, u32 h)
+{
+	const struct imx219_mode *mode;
+
+	mode = v4l2_find_nearest_size(supported_modes, ARRAY_SIZE(supported_modes),
+			width, height, w, h);
+	if (!mode || (mode->width != w || mode->height != h))
+		return -EINVAL;
+
+	fi->numerator = 1;
+	fi->denominator = mode->fps;
+
+	return mode->fps;
+}
+
+static int imx219_enum_frame_interval(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+	struct v4l2_fract tpf;
+	u32 code;
+	int ret;
+
+	if (fie->index >= ARRAY_SIZE(supported_modes))
+		return -EINVAL;
+
+	mutex_lock(&imx219->mutex);
+	code = imx219_get_format_code(imx219, fie->code);
+	if (fie->code != code) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = imx219_try_frame_interval(imx219, &tpf,
+				fie->width, fie->height);
+	if (ret < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	mutex_unlock(&imx219->mutex);
+	fie->interval = tpf;
+
+	return 0;
+
+out:
+	mutex_unlock(&imx219->mutex);
+	return ret;
+}
+
+static int imx219_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+
+	mutex_lock(&imx219->mutex);
+	fi->interval = imx219->frame_interval;
+	mutex_unlock(&imx219->mutex);
+
+	return 0;
+}
+
+static int imx219_s_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+	const struct imx219_mode *mode = imx219->mode;
+	int frame_rate, ret = 0;
+
+	if (fi->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&imx219->mutex);
+
+	if (imx219->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	frame_rate = imx219_try_frame_interval(imx219, &fi->interval,
+					       mode->width, mode->height);
+	if (frame_rate < 0) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	imx219->frame_interval = fi->interval;
+
+out:
+	mutex_unlock(&imx219->mutex);
+	return ret;
+}
+
+static void imx219_reset_colorspace(struct v4l2_mbus_framefmt *fmt)
+{
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_MAP_QUANTIZATION_DEFAULT(true,
+			fmt->colorspace, fmt->ycbcr_enc);
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+}
+
+static void imx219_update_pad_format(struct imx219 *imx219,
+				     const struct imx219_mode *mode,
+				     struct v4l2_subdev_format *fmt)
+{
+	fmt->format.width = mode->width;
+	fmt->format.height = mode->height;
+	fmt->format.field = V4L2_FIELD_NONE;
+	imx219_reset_colorspace(&fmt->format);
+}
+
+static int __imx219_get_pad_format(struct imx219 *imx219,
+				   struct v4l2_subdev_pad_config *cfg,
+				   struct v4l2_subdev_format *fmt)
+{
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		struct v4l2_mbus_framefmt *try_fmt =
+			v4l2_subdev_get_try_format(&imx219->sd, cfg, fmt->pad);
+		/* update the code which could change due to vflip or hflip: */
+		try_fmt->code = imx219_get_format_code(imx219, try_fmt->code);
+		fmt->format = *try_fmt;
+	} else {
+		imx219_update_pad_format(imx219, imx219->mode, fmt);
+		fmt->format.code = imx219_get_format_code(imx219, imx219->fmt.code);
+	}
+
+	return 0;
+}
+
+static int imx219_get_pad_format(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_format *fmt)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+	int ret;
+
+	mutex_lock(&imx219->mutex);
+	ret = __imx219_get_pad_format(imx219, cfg, fmt);
+	mutex_unlock(&imx219->mutex);
+
+	return ret;
+}
+
+static int imx219_set_pad_format(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_format *fmt)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+	const struct imx219_mode *mode;
+	struct v4l2_mbus_framefmt *framefmt;
+	int exposure_max, exposure_def, hblank;
+	unsigned int i;
+
+	mutex_lock(&imx219->mutex);
+
+	for (i = 0; i < ARRAY_SIZE(codes); i++)
+		if (codes[i] == fmt->format.code)
+			break;
+	if (i >= ARRAY_SIZE(codes))
+		i = 0;
+
+	/* Bayer order varies with flips */
+	fmt->format.code = imx219_get_format_code(imx219, codes[i]);
+
+	mode = v4l2_find_nearest_size(supported_modes, ARRAY_SIZE(supported_modes),
+			width, height, fmt->format.width, fmt->format.height);
+	imx219_update_pad_format(imx219, mode, fmt);
+	if (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {
+		framefmt = v4l2_subdev_get_try_format(sd, cfg, fmt->pad);
+		*framefmt = fmt->format;
+	} else if (imx219->mode != mode ||
+		   imx219->fmt.code != fmt->format.code) {
+		imx219->fmt = fmt->format;
+		imx219->mode = mode;
+		/* Update limits and set FPS to default */
+		__v4l2_ctrl_modify_range(imx219->vblank, IMX219_VBLANK_MIN,
+				IMX219_VTS_MAX - mode->height, 1,
+				mode->vts_def - mode->height);
+		__v4l2_ctrl_s_ctrl(imx219->vblank, mode->vts_def - mode->height);
+		/* Update max exposure while meeting expected vblanking */
+		exposure_max = mode->vts_def - 4;
+		exposure_def = (exposure_max < IMX219_EXPOSURE_DEFAULT) ?
+			exposure_max : IMX219_EXPOSURE_DEFAULT;
+		__v4l2_ctrl_modify_range(imx219->exposure, imx219->exposure->minimum,
+				exposure_max, imx219->exposure->step, exposure_def);
+		/*
+		 * Currently PPL is fixed to IMX219_PPL_DEFAULT, so hblank
+		 * depends on mode->width only, and is not changeble in any
+		 * way other than changing the mode.
+		 */
+		hblank = IMX219_PPL_DEFAULT - mode->width;
+		__v4l2_ctrl_modify_range(imx219->hblank, hblank, hblank, 1, hblank);
+	}
+
+	mutex_unlock(&imx219->mutex);
+
+	return 0;
+}
+
+static int imx219_set_framefmt(struct imx219 *imx219)
+{
+	switch (imx219->fmt.code) {
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+		return imx219_write_regs(imx219, raw8_framefmt_regs,
+				ARRAY_SIZE(raw8_framefmt_regs));
+
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+		return imx219_write_regs(imx219, raw10_framefmt_regs,
+				ARRAY_SIZE(raw10_framefmt_regs));
+	}
+
+	return -EINVAL;
+}
+
+static const struct v4l2_rect *
+__imx219_get_pad_crop(struct imx219 *imx219, struct v4l2_subdev_pad_config *cfg,
+				unsigned int pad, enum v4l2_subdev_format_whence which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_crop(&imx219->sd, cfg, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &imx219->mode->crop;
+	}
+
+	return NULL;
+}
+
+static int imx219_get_selection(struct v4l2_subdev *sd,
+					struct v4l2_subdev_pad_config *cfg,
+					struct v4l2_subdev_selection *sel)
+{
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP: {
+		struct imx219 *imx219 = to_imx219(sd);
+
+		mutex_lock(&imx219->mutex);
+		sel->r = *__imx219_get_pad_crop(imx219, cfg, sel->pad, sel->which);
+		mutex_unlock(&imx219->mutex);
+		return 0;
+	}
+
+	case V4L2_SEL_TGT_NATIVE_SIZE:
+		sel->r.top = 0;
+		sel->r.left = 0;
+		sel->r.width = IMX219_NATIVE_WIDTH;
+		sel->r.height = IMX219_NATIVE_HEIGHT;
+		return 0;
+
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.top = IMX219_PIXEL_ARRAY_TOP;
+		sel->r.left = IMX219_PIXEL_ARRAY_LEFT;
+		sel->r.width = IMX219_PIXEL_ARRAY_WIDTH;
+		sel->r.height = IMX219_PIXEL_ARRAY_HEIGHT;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static int imx219_start_streaming(struct imx219 *imx219)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	const struct imx219_reg_list *reg_list;
+	int ret;
+
+	/* Apply default values of current mode */
+	reg_list = &imx219->mode->reg_list;
+	ret = imx219_write_regs(imx219, reg_list->regs, reg_list->num_of_regs);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set mode\n", __func__);
+		goto err;
+	}
+
+	ret = imx219_set_framefmt(imx219);
+	if (ret) {
+		dev_err(&client->dev, "%s failed to set frame format: %d\n",
+			__func__, ret);
+		goto err;
+	}
+
+	/* Apply customized values from user */
+	ret =  __v4l2_ctrl_handler_setup(imx219->sd.ctrl_handler);
+	if (ret)
+		goto err;
+
+	/* set stream on register */
+	ret = imx219_write_reg(imx219, IMX219_REG_MODE_SELECT,
+			       IMX219_REG_VALUE_08BIT, IMX219_MODE_STREAMING);
+	if (ret)
+		goto err;
+
+	/* vflip and hflip cannot change during streaming */
+	__v4l2_ctrl_grab(imx219->vflip, true);
+	__v4l2_ctrl_grab(imx219->hflip, true);
+
+	return 0;
+
+err:
+	return ret;
+}
+
+static void imx219_stop_streaming(struct imx219 *imx219)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	int ret;
+
+	/* set stream off register */
+	ret = imx219_write_reg(imx219, IMX219_REG_MODE_SELECT,
+			IMX219_REG_VALUE_08BIT, IMX219_MODE_STANDBY);
+	if (ret)
+		dev_err(&client->dev, "%s failed to set stream\n", __func__);
+
+	__v4l2_ctrl_grab(imx219->vflip, false);
+	__v4l2_ctrl_grab(imx219->hflip, false);
+}
+
+static int imx219_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct imx219 *imx219 = to_imx219(sd);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret = 0;
+
+	mutex_lock(&imx219->mutex);
+
+	if (enable) {
+		ret = pm_runtime_get_sync(&client->dev);
+		if (ret < 0) {
+			pm_runtime_put_noidle(&client->dev);
+			mutex_unlock(&imx219->mutex);
+			return ret;
+		}
+
+		if (imx219->streaming)
+			goto unlock;
+
+		/*
+		 * Apply default & customized values
+		 * and then start streaming.
+		 */
+		ret = imx219_start_streaming(imx219);
+		if (ret)
+			goto err_unlock;
+	} else {
+		imx219_stop_streaming(imx219);
+		pm_runtime_put(&client->dev);
+	}
+
+unlock:
+	imx219->streaming += enable ? 1 : -1;
+	WARN_ON(imx219->streaming < 0);
+
+	mutex_unlock(&imx219->mutex);
+
+	return ret;
+
+err_unlock:
+	pm_runtime_put(&client->dev);
+	mutex_unlock(&imx219->mutex);
+
+	return ret;
+}
+
+/* Power/clock management functions */
+static int imx219_power_on(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct imx219 *imx219 = to_imx219(sd);
+	int ret;
+
+	ret = regulator_bulk_enable(IMX219_NUM_SUPPLIES, imx219->supplies);
+	if (ret) {
+		dev_err(dev, "%s: failed to enable regulators\n",
+			__func__);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(imx219->xclk);
+	if (ret) {
+		dev_err(dev, "%s: failed to enable clock\n", __func__);
+		goto reg_off;
+	}
+
+	gpiod_set_value_cansleep(imx219->reset_gpio, 1);
+	usleep_range(IMX219_XCLR_MIN_DELAY_US,
+			IMX219_XCLR_MIN_DELAY_US + IMX219_XCLR_DELAY_RANGE_US);
+
+	return 0;
+
+reg_off:
+	regulator_bulk_disable(IMX219_NUM_SUPPLIES, imx219->supplies);
+
+	return ret;
+}
+
+static int imx219_power_off(struct device *dev)
+{
+	struct v4l2_subdev *sd = dev_get_drvdata(dev);
+	struct imx219 *imx219 = to_imx219(sd);
+
+	gpiod_set_value_cansleep(imx219->reset_gpio, 0);
+	regulator_bulk_disable(IMX219_NUM_SUPPLIES, imx219->supplies);
+	clk_disable_unprepare(imx219->xclk);
+
+	return 0;
+}
+
+static int imx219_get_regulators(struct imx219 *imx219)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	unsigned int i;
+
+	for (i = 0; i < IMX219_NUM_SUPPLIES; i++)
+		imx219->supplies[i].supply = imx219_supply_name[i];
+
+	return devm_regulator_bulk_get(&client->dev,
+			IMX219_NUM_SUPPLIES, imx219->supplies);
+}
+
+/* Verify chip ID */
+static int imx219_identify_module(struct imx219 *imx219)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	int ret;
+	u32 val;
+
+	ret = imx219_read_reg(imx219, IMX219_REG_CHIP_ID,
+			      IMX219_REG_VALUE_16BIT, &val);
+	if (ret) {
+		dev_err(&client->dev, "failed to read chip id %x\n",
+			IMX219_CHIP_ID);
+		return ret;
+	}
+
+	if (val != IMX219_CHIP_ID) {
+		dev_err(&client->dev, "chip id mismatch: %x!=%x\n",
+			IMX219_CHIP_ID, val);
+		return -EIO;
+	}
+
+	dev_err(&client->dev, "%s: chip identifier, got 0x%x\n",
+		__func__, IMX219_CHIP_ID);
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops imx219_core_ops = {
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops imx219_video_ops = {
+	.g_frame_interval = imx219_g_frame_interval,
+	.s_frame_interval = imx219_s_frame_interval,
+	.s_stream = imx219_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops imx219_pad_ops = {
+	.enum_mbus_code = imx219_enum_mbus_code,
+	.get_fmt = imx219_get_pad_format,
+	.set_fmt = imx219_set_pad_format,
+	.get_selection = imx219_get_selection,
+	.enum_frame_size = imx219_enum_frame_size,
+	.enum_frame_interval = imx219_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops imx219_subdev_ops = {
+	.core = &imx219_core_ops,
+	.video = &imx219_video_ops,
+	.pad = &imx219_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops imx219_internal_ops = {
+	.open = imx219_open,
+};
+
+/* Initialize control handlers */
+static int imx219_init_controls(struct imx219 *imx219)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&imx219->sd);
+	struct v4l2_ctrl_handler *ctrl_hdlr;
+	unsigned int height = imx219->mode->height;
+	struct v4l2_fwnode_device_properties props;
+	int exposure_max, exposure_def, hblank;
+	int i, ret;
+
+	ctrl_hdlr = &imx219->ctrl_handler;
+	ret = v4l2_ctrl_handler_init(ctrl_hdlr, 12);
+	if (ret)
+		return ret;
+
+	mutex_init(&imx219->mutex);
+	ctrl_hdlr->lock = &imx219->mutex;
+
+	/* By default, PIXEL_RATE is read only */
+	imx219->pixel_rate = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,
+			V4L2_CID_PIXEL_RATE, IMX219_PIXEL_RATE,
+			IMX219_PIXEL_RATE, 1, IMX219_PIXEL_RATE);
+
+	imx219->link_freq =
+		v4l2_ctrl_new_int_menu(ctrl_hdlr, &imx219_ctrl_ops, V4L2_CID_LINK_FREQ,
+			ARRAY_SIZE(imx219_link_freq_menu) - 1, 0, imx219_link_freq_menu);
+	if (imx219->link_freq)
+		imx219->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	/* Initial vblank/hblank/exposure parameters based on current mode */
+	imx219->vblank = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,
+					V4L2_CID_VBLANK, IMX219_VBLANK_MIN,
+					IMX219_VTS_MAX - height, 1,
+					imx219->mode->vts_def - height);
+	hblank = IMX219_PPL_DEFAULT - imx219->mode->width;
+	imx219->hblank = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,
+					V4L2_CID_HBLANK, hblank, hblank, 1, hblank);
+	if (imx219->hblank)
+		imx219->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	exposure_max = imx219->mode->vts_def - 4;
+	exposure_def = (exposure_max < IMX219_EXPOSURE_DEFAULT) ?
+		exposure_max : IMX219_EXPOSURE_DEFAULT;
+	imx219->exposure = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,
+				V4L2_CID_EXPOSURE, IMX219_EXPOSURE_MIN, exposure_max,
+				IMX219_EXPOSURE_STEP, exposure_def);
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops, V4L2_CID_ANALOGUE_GAIN,
+			IMX219_ANA_GAIN_MIN, IMX219_ANA_GAIN_MAX,
+			IMX219_ANA_GAIN_STEP, IMX219_ANA_GAIN_DEFAULT);
+
+	v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops, V4L2_CID_DIGITAL_GAIN,
+			IMX219_DGTL_GAIN_MIN, IMX219_DGTL_GAIN_MAX,
+			IMX219_DGTL_GAIN_STEP, IMX219_DGTL_GAIN_DEFAULT);
+
+	imx219->hflip = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,
+					  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	if (imx219->hflip)
+		imx219->hflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;
+
+	imx219->vflip = v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,
+					  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	if (imx219->vflip)
+		imx219->vflip->flags |= V4L2_CTRL_FLAG_MODIFY_LAYOUT;
+
+	v4l2_ctrl_new_std_menu_items(ctrl_hdlr, &imx219_ctrl_ops, V4L2_CID_TEST_PATTERN,
+			ARRAY_SIZE(imx219_test_pattern_menu) - 1,
+			0, 0, imx219_test_pattern_menu);
+	for (i = 0; i < 4; i++) {
+		/*
+		 * The assumption is that
+		 * V4L2_CID_TEST_PATTERN_GREENR == V4L2_CID_TEST_PATTERN_RED + 1
+		 * V4L2_CID_TEST_PATTERN_BLUE   == V4L2_CID_TEST_PATTERN_RED + 2
+		 * V4L2_CID_TEST_PATTERN_GREENB == V4L2_CID_TEST_PATTERN_RED + 3
+		 */
+		v4l2_ctrl_new_std(ctrl_hdlr, &imx219_ctrl_ops,
+				V4L2_CID_TEST_PATTERN_RED + i,
+				IMX219_TESTP_COLOUR_MIN,
+				IMX219_TESTP_COLOUR_MAX,
+				IMX219_TESTP_COLOUR_STEP,
+				IMX219_TESTP_COLOUR_MAX);
+		/* The "Solid color" pattern is white by default */
+	}
+
+	if (ctrl_hdlr->error) {
+		ret = ctrl_hdlr->error;
+		dev_err(&client->dev, "%s control init failed (%d)\n",
+			__func__, ret);
+		goto error;
+	}
+
+	ret = v4l2_fwnode_device_parse(&client->dev, &props);
+	if (ret)
+		goto error;
+
+	ret = v4l2_ctrl_new_fwnode_properties(ctrl_hdlr, &imx219_ctrl_ops, &props);
+	if (ret)
+		goto error;
+
+	imx219->sd.ctrl_handler = ctrl_hdlr;
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(ctrl_hdlr);
+	mutex_destroy(&imx219->mutex);
+
+	return ret;
+}
+
+static void imx219_free_controls(struct imx219 *imx219)
+{
+	v4l2_ctrl_handler_free(imx219->sd.ctrl_handler);
+	mutex_destroy(&imx219->mutex);
+}
+
+static int imx219_check_hwcfg(struct device *dev)
+{
+	struct fwnode_handle *endpoint;
+	struct v4l2_fwnode_endpoint ep_cfg = {
+		.bus_type = V4L2_MBUS_CSI2_DPHY
+	};
+	int ret = -EINVAL;
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(dev), NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	if (v4l2_fwnode_endpoint_alloc_parse(endpoint, &ep_cfg)) {
+		dev_err(dev, "could not parse endpoint\n");
+		goto error_out;
+	}
+
+	/* Check the number of MIPI CSI2 data lanes */
+	if (ep_cfg.bus.mipi_csi2.num_data_lanes != 2) {
+		dev_err(dev, "only 2 data lanes are currently supported\n");
+		goto error_out;
+	}
+
+	/* Check the link frequency set in device tree */
+	if (!ep_cfg.nr_of_link_frequencies) {
+		dev_err(dev, "link-frequency property not found in DT\n");
+		goto error_out;
+	}
+
+	if (ep_cfg.nr_of_link_frequencies != 1 ||
+	    ep_cfg.link_frequencies[0] != IMX219_DEFAULT_LINK_FREQ) {
+		dev_err(dev, "Link frequency not supported: %lld\n",
+			ep_cfg.link_frequencies[0]);
+		goto error_out;
+	}
+
+	ret = 0;
+
+error_out:
+	v4l2_fwnode_endpoint_free(&ep_cfg);
+	fwnode_handle_put(endpoint);
+
+	return ret;
+}
+
+static int imx219_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct imx219 *imx219;
+	int ret;
+
+	imx219 = devm_kzalloc(&client->dev, sizeof(*imx219), GFP_KERNEL);
+	if (!imx219)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&imx219->sd, client, &imx219_subdev_ops);
+
+	/* Check the hardware configuration in device tree */
+	if (imx219_check_hwcfg(dev))
+		return -EINVAL;
+
+	/* Get system clock (xclk) */
+	imx219->xclk = devm_clk_get(dev, NULL);
+	if (IS_ERR(imx219->xclk)) {
+		dev_err(dev, "failed to get xclk\n");
+		return PTR_ERR(imx219->xclk);
+	}
+
+	imx219->xclk_freq = clk_get_rate(imx219->xclk);
+	if (imx219->xclk_freq != IMX219_XCLK_FREQ) {
+		dev_err(dev, "xclk frequency not supported: %d Hz\n",
+			imx219->xclk_freq);
+		return -EINVAL;
+	}
+
+	ret = imx219_get_regulators(imx219);
+	if (ret) {
+		dev_err(dev, "failed to get regulators\n");
+		return ret;
+	}
+
+	/* Request optional enable pin */
+	imx219->reset_gpio = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+
+	/*
+	 * The sensor must be powered for imx219_identify_module()
+	 * to be able to read the CHIP_ID register
+	 */
+	ret = imx219_power_on(dev);
+	if (ret)
+		return ret;
+
+	ret = imx219_identify_module(imx219);
+	if (ret)
+		goto error_power_off;
+
+	/* Set default mode to max resolution */
+	imx219->mode = &supported_modes[0];
+	imx219->frame_interval.numerator = 1;
+	imx219->frame_interval.denominator = supported_modes[0].fps;
+
+	/* sensor doesn't enter LP-11 state upon power up until and unless
+	 * streaming is started, so upon power up switch the modes to:
+	 * streaming -> standby
+	 */
+	ret = imx219_write_reg(imx219, IMX219_REG_MODE_SELECT,
+			IMX219_REG_VALUE_08BIT, IMX219_MODE_STREAMING);
+	if (ret < 0)
+		goto error_power_off;
+	usleep_range(100, 110);
+
+	/* put sensor back to standby mode */
+	ret = imx219_write_reg(imx219, IMX219_REG_MODE_SELECT,
+			IMX219_REG_VALUE_08BIT, IMX219_MODE_STANDBY);
+	if (ret < 0)
+		goto error_power_off;
+	usleep_range(100, 110);
+
+	ret = imx219_init_controls(imx219);
+	if (ret)
+		goto error_power_off;
+
+	/* Initialize subdev */
+	imx219->sd.internal_ops = &imx219_internal_ops;
+	imx219->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	imx219->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+
+	/* Initialize source pad */
+	imx219->pad.flags = MEDIA_PAD_FL_SOURCE;
+
+	/* Initialize default format */
+	imx219_set_default_format(imx219);
+
+	ret = media_entity_pads_init(&imx219->sd.entity, 1, &imx219->pad);
+	if (ret) {
+		dev_err(dev, "failed to init entity pads: %d\n", ret);
+		goto error_handler_free;
+	}
+
+	ret = v4l2_async_register_subdev_sensor_common(&imx219->sd);
+	if (ret < 0) {
+		dev_err(dev, "failed to register sensor sub-device: %d\n", ret);
+		goto error_media_entity;
+	}
+
+	/* Enable runtime PM and turn off the device */
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	pm_runtime_idle(dev);
+
+	return 0;
+
+error_media_entity:
+	media_entity_cleanup(&imx219->sd.entity);
+
+error_handler_free:
+	imx219_free_controls(imx219);
+
+error_power_off:
+	imx219_power_off(dev);
+
+	return ret;
+}
+
+static int imx219_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct imx219 *imx219 = to_imx219(sd);
+
+	v4l2_async_unregister_subdev(sd);
+	media_entity_cleanup(&sd->entity);
+	imx219_free_controls(imx219);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		imx219_power_off(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	return 0;
+}
+
+static const struct of_device_id imx219_dt_ids[] = {
+	{ .compatible = "sony,imx219" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx219_dt_ids);
+
+static const struct dev_pm_ops imx219_pm_ops = {
+	SET_RUNTIME_PM_OPS(imx219_power_off, imx219_power_on, NULL)
+};
+
+static struct i2c_driver imx219_i2c_driver = {
+	.driver = {
+		.name = "imx219",
+		.of_match_table	= imx219_dt_ids,
+		.pm = &imx219_pm_ops,
+	},
+	.probe_new = imx219_probe,
+	.remove = imx219_remove,
+};
+
+module_i2c_driver(imx219_i2c_driver);
+
+MODULE_AUTHOR("David.li");
+MODULE_DESCRIPTION("Sony IMX219 sensor driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/starfive/v4l2_driver/ov13850_mipi.c b/drivers/media/platform/starfive/v4l2_driver/ov13850_mipi.c
new file mode 100644
index 000000000000..78f49d0fa43f
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/ov13850_mipi.c
@@ -0,0 +1,1930 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2014-2017 Mentor Graphics Inc.
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include "stfcamss.h"
+
+#define OV13850_XCLK_MIN  6000000
+#define OV13850_XCLK_MAX 54000000
+
+#define OV13850_LINK_FREQ_500MHZ         500000000LL
+
+/**
+ *OV13850 PLL
+ *
+ *PLL1:
+ *
+ *REF_CLK -> /PREDIVP[0] -> /PREDIV[2:0] -> *DIVP[9:8,7:0] -> /DIVM[3:0] -> /DIV_MIPI[1:0]  -> PCLK
+ *(6-64M)     0x030A         0x0300          0x0301,0x302      0x0303        0x0304
+ *                                                                      `-> MIPI_PHY_CLK
+ *
+ *
+ *PLL2:
+ *                           000: 1
+ *                           001: 1.5
+ *                           010: 2
+ *                           011: 2.5
+ *                           100: 3
+ *                           101: 4
+ *            0: /1          110: 6
+ *            1: /2          111: 8
+ *REF_CLK -> /PREDIVP[3] -> /PREDIV[2:0] -> /DIVP[9:0] -> /DIVDAC[3:0] -> DAC_CLK =
+ *(6~64M)    0x3611
+ *                                                     -> /DIVSP[3:0] -> /DIVS[2:0] -> SCLK
+ *
+ *                                                     -> /(1+DIVSRAM[3:0]) -> SRAM_CLK
+ */
+
+// PREDIVP
+#define OV13850_REG_PLL1_PREDIVP        0x030a
+#define OV13850_PREDIVP_1   0
+#define OV13850_PREDIVP_2   1
+
+// PREDIV
+#define OV13850_REG_PLL1_PREDIV         0x0300
+#define OV13850_PREDIV_1    0
+#define OV13850_PREDIV_1_5  1
+#define OV13850_PREDIV_2    2
+#define OV13850_PREDIV_2_5  3
+#define OV13850_PREDIV_3    4
+#define OV13850_PREDIV_4    5
+#define OV13850_PREDIV_6    6
+#define OV13850_PREDIV_8    7
+
+// DIVP
+#define OV13850_REG_PLL1_DIVP_H         0x0301
+#define OV13850_REG_PLL1_DIVP_L         0x0302
+#define OV13850_REG_PLL1_DIVP           OV13850_REG_PLL1_DIVP_H
+
+// DIVM
+#define OV13850_REG_PLL1_DIVM           0x0303
+#define OV13850_DIVM(n)     ((n)-1) // n=1~16
+
+// DIV_MIPI
+#define OV13850_REG_PLL1_DIV_MIPI       0x0304
+#define OV13850_DIV_MIPI_4  0
+#define OV13850_DIV_MIPI_5  1
+#define OV13850_DIV_MIPI_6  2
+#define OV13850_DIV_MIPI_8  3
+
+// system control
+#define OV13850_STREAM_CTRL             0x0100
+#define OV13850_REG_MIPI_SC             0x300f
+#define OV13850_MIPI_SC_8_BIT           0x0
+#define OV13850_MIPI_SC_10_BIT          0x1
+#define OV13850_MIPI_SC_12_BIT          0x2
+#define OV13850_GET_MIPI_SC_MIPI_BIT(v)         ((v) & 0x3)
+#define OV13850_REG_MIPI_SC_CTRL0       0x3012
+#define OV13850_GET_MIPI_SC_CTRL0_LANE_NUM(v)   ((v)>>4 & 0xf)
+
+// timing
+#define OV13850_REG_H_CROP_START_H      0x3800
+#define OV13850_REG_H_CROP_START_L      0x3801
+#define OV13850_REG_H_CROP_START        OV13850_REG_H_CROP_START_H
+#define OV13850_REG_V_CROP_START_H      0x3802
+#define OV13850_REG_V_CROP_START_L      0x3803
+#define OV13850_REG_V_CROP_START        OV13850_REG_V_CROP_START_H
+
+#define OV13850_REG_H_CROP_END_H        0x3804
+#define OV13850_REG_H_CROP_END_L        0x3805
+#define OV13850_REG_H_CROP_END          OV13850_REG_H_CROP_END_H
+#define OV13850_REG_V_CROP_END_H        0x3806
+#define OV13850_REG_V_CROP_END_L        0x3807
+#define OV13850_REG_V_CROP_END          OV13850_REG_V_CROP_END_H
+
+#define OV13850_REG_H_OUTPUT_SIZE_H     0x3808
+#define OV13850_REG_H_OUTPUT_SIZE_L     0x3809
+#define OV13850_REG_H_OUTPUT_SIZE       OV13850_REG_H_OUTPUT_SIZE_H
+#define OV13850_REG_V_OUTPUT_SIZE_H     0x380a
+#define OV13850_REG_V_OUTPUT_SIZE_L     0x380b
+#define OV13850_REG_V_OUTPUT_SIZE       OV13850_REG_V_OUTPUT_SIZE_H
+
+#define OV13850_REG_TIMING_HTS_H        0x380c
+#define OV13850_REG_TIMING_HTS_L        0x380d
+#define OV13850_REG_TIMING_HTS          OV13850_REG_TIMING_HTS_H
+#define OV13850_REG_TIMING_VTS_H        0x380e
+#define OV13850_REG_TIMING_VTS_L        0x380f
+#define OV13850_REG_TIMING_VTS          OV13850_REG_TIMING_VTS_H
+
+
+#define OV13850_REG_H_WIN_OFF_H         0x3810
+#define OV13850_REG_H_WIN_OFF_L         0x3811
+#define OV13850_REG_V_WIN_OFF_H         0x3812
+#define OV13850_REG_V_WIN_OFF_L         0x3813
+
+#define OV13850_REG_H_INC               0x3814
+#define OV13850_REG_V_INC               0x3815
+
+enum ov13850_mode_id {
+	OV13850_MODE_1080P_1920_1080 = 0,
+	OV13850_NUM_MODES,
+};
+
+enum ov13850_frame_rate {
+	OV13850_15_FPS = 0,
+	OV13850_30_FPS,
+	OV13850_60_FPS,
+	OV13850_NUM_FRAMERATES,
+};
+
+static const int ov13850_framerates[] = {
+	[OV13850_15_FPS] = 15,
+	[OV13850_30_FPS] = 30,
+	[OV13850_60_FPS] = 60,
+};
+
+struct ov13850_pixfmt {
+	u32 code;
+	u32 colorspace;
+};
+
+static const struct ov13850_pixfmt ov13850_formats[] = {
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_COLORSPACE_SRGB, },
+};
+
+/* regulator supplies */
+static const char * const ov13850_supply_name[] = {
+	"DOVDD", /* Digital I/O (1.8V) supply */
+	"AVDD",  /* Analog (2.8V) supply */
+	"DVDD",  /* Digital Core (1.5V) supply */
+};
+
+#define OV13850_NUM_SUPPLIES ARRAY_SIZE(ov13850_supply_name)
+
+/*
+ * Image size under 1280 * 960 are SUBSAMPLING
+ * Image size upper 1280 * 960 are SCALING
+ */
+enum ov13850_downsize_mode {
+	SUBSAMPLING,
+	SCALING,
+};
+
+struct reg_value {
+	u16 reg_addr;
+	u8 val;
+	u8 mask;
+	u32 delay_ms;
+};
+
+struct ov13850_mode_info {
+	enum ov13850_mode_id id;
+	enum ov13850_downsize_mode dn_mode;
+	u32 hact;
+	u32 htot;
+	u32 vact;
+	u32 vtot;
+	const struct reg_value *reg_data;
+	u32 reg_data_size;
+	u32 max_fps;
+};
+
+struct ov13850_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct {
+		struct v4l2_ctrl *exposure;
+	};
+	struct {
+		struct v4l2_ctrl *auto_wb;
+		struct v4l2_ctrl *blue_balance;
+		struct v4l2_ctrl *red_balance;
+	};
+	struct {
+		struct v4l2_ctrl *anal_gain;
+	};
+	struct v4l2_ctrl *brightness;
+	struct v4l2_ctrl *light_freq;
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *saturation;
+	struct v4l2_ctrl *contrast;
+	struct v4l2_ctrl *hue;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+};
+
+struct ov13850_dev {
+	struct i2c_client *i2c_client;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_fwnode_endpoint ep; /* the parsed DT endpoint info */
+	struct clk *xclk; /* system clock to OV13850 */
+	u32 xclk_freq;
+
+	struct regulator_bulk_data supplies[OV13850_NUM_SUPPLIES];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *pwdn_gpio;
+	bool   upside_down;
+
+	/* lock to protect all members below */
+	struct mutex lock;
+
+	int power_count;
+
+	struct v4l2_mbus_framefmt fmt;
+	bool pending_fmt_change;
+
+	const struct ov13850_mode_info *current_mode;
+	const struct ov13850_mode_info *last_mode;
+	enum ov13850_frame_rate current_fr;
+	struct v4l2_fract frame_interval;
+
+	struct ov13850_ctrls ctrls;
+
+	u32 prev_sysclk, prev_hts;
+	u32 ae_low, ae_high, ae_target;
+
+	bool pending_mode_change;
+	bool streaming;
+};
+
+static inline struct ov13850_dev *to_ov13850_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ov13850_dev, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov13850_dev,
+			ctrls.handler)->sd;
+}
+
+/* ov13850 initial register */
+static const struct reg_value ov13850_init_setting_30fps_1080P[] = {
+
+};
+
+static const struct reg_value ov13850_setting_1080P_1920_1080[] = {
+//;XVCLK=24Mhz, SCLK=4x120Mhz, MIPI 640Mbps, DACCLK=240Mhz
+/*
+ * using quarter size to scale down
+ */
+	{0x0103, 0x01, 0, 0}, // ; software reset
+
+	{0x0300, 0x01, 0, 0}, //; PLL
+	{0x0301, 0x00, 0, 0}, //; PLL1_DIVP_hi
+	{0x0302, 0x28, 0, 0}, //; PLL1_DIVP_lo
+	{0x0303, 0x00, 0, 0}, // ; PLL
+	{0x030a, 0x00, 0, 0}, // ; PLL
+	//{0xffff, 20, 0, 0},
+	{0x300f, 0x11, 0, 0}, // SFC modified, MIPI_SRC, [1:0] 00-8bit, 01-10bit, 10-12bit
+	{0x3010, 0x01, 0, 0}, // ; MIPI PHY
+	{0x3011, 0x76, 0, 0}, // ; MIPI PHY
+	{0x3012, 0x41, 0, 0}, // ; MIPI 4 lane
+	{0x3013, 0x12, 0, 0}, // ; MIPI control
+	{0x3014, 0x11, 0, 0}, // ; MIPI control
+	{0x301f, 0x03, 0, 0}, //
+	{0x3106, 0x00, 0, 0}, //
+	{0x3210, 0x47, 0, 0}, //
+	{0x3500, 0x00, 0, 0}, // ; exposure HH
+	{0x3501, 0x67, 0, 0}, // ; exposure H
+	{0x3502, 0x80, 0, 0}, // ; exposure L
+	{0x3506, 0x00, 0, 0}, // ; short exposure HH
+	{0x3507, 0x02, 0, 0}, // ; short exposure H
+	{0x3508, 0x00, 0, 0}, // ; shour exposure L
+	{0x3509, 0x10, 0, 0},//00},//8},
+	{0x350a, 0x00, 0, 0}, // ; gain H
+	{0x350b, 0x10, 0, 0}, // ; gain L
+	{0x350e, 0x00, 0, 0}, // ; short gain H
+	{0x350f, 0x10, 0, 0}, // ; short gain L
+	{0x3600, 0x40, 0, 0}, // ; analog control
+	{0x3601, 0xfc, 0, 0}, // ; analog control
+	{0x3602, 0x02, 0, 0}, // ; analog control
+	{0x3603, 0x48, 0, 0}, // ; analog control
+	{0x3604, 0xa5, 0, 0}, // ; analog control
+	{0x3605, 0x9f, 0, 0}, // ; analog control
+	{0x3607, 0x00, 0, 0}, // ; analog control
+	{0x360a, 0x40, 0, 0}, // ; analog control
+	{0x360b, 0x91, 0, 0}, // ; analog control
+	{0x360c, 0x49, 0, 0}, // ; analog control
+	{0x360f, 0x8a, 0, 0}, //
+	{0x3611, 0x10, 0, 0}, // ; PLL2
+	//{0x3612, 0x23, 0, 0}, // ; PLL2
+	{0x3612, 0x13, 0, 0}, // ; PLL2
+	//{0x3613, 0x33, 0, 0}, // ; PLL2
+	{0x3613, 0x22, 0, 0}, // ; PLL2
+	//{0xffff, 50, 0, 0},
+	{0x3614, 0x28, 0, 0}, //[7:0] PLL2_DIVP lo
+	{0x3615, 0x08, 0, 0}, //[7:6] Debug mode, [5:4] N_pump clock div, [3:2] P_pump clock div, [1:0] PLL2_DIVP hi
+	{0x3641, 0x02, 0, 0},
+	{0x3660, 0x82, 0, 0},
+	{0x3668, 0x54, 0, 0},
+	{0x3669, 0x40, 0, 0},
+	{0x3667, 0xa0, 0, 0},
+	{0x3702, 0x40, 0, 0},
+	{0x3703, 0x44, 0, 0},
+	{0x3704, 0x2c, 0, 0},
+	{0x3705, 0x24, 0, 0},
+	{0x3706, 0x50, 0, 0},
+	{0x3707, 0x44, 0, 0},
+	{0x3708, 0x3c, 0, 0},
+	{0x3709, 0x1f, 0, 0},
+	{0x370a, 0x26, 0, 0},
+	{0x370b, 0x3c, 0, 0},
+	{0x3720, 0x66, 0, 0},
+	{0x3722, 0x84, 0, 0},
+	{0x3728, 0x40, 0, 0},
+	{0x372a, 0x00, 0, 0},
+	{0x372f, 0x90, 0, 0},
+	{0x3710, 0x28, 0, 0},
+	{0x3716, 0x03, 0, 0},
+	{0x3718, 0x10, 0, 0},
+	{0x3719, 0x08, 0, 0},
+	{0x371c, 0xfc, 0, 0},
+	{0x3760, 0x13, 0, 0},
+	{0x3761, 0x34, 0, 0},
+	{0x3767, 0x24, 0, 0},
+	{0x3768, 0x06, 0, 0},
+	{0x3769, 0x45, 0, 0},
+	{0x376c, 0x23, 0, 0},
+	{0x3d84, 0x00, 0, 0}, // ; OTP program disable
+	{0x3d85, 0x17, 0, 0}, // ; OTP power up load data enable, power load setting enable, software load setting
+	{0x3d8c, 0x73, 0, 0}, // ; OTP start address H
+	{0x3d8d, 0xbf, 0, 0}, // ; OTP start address L
+	{0x3800, 0x00, 0, 0}, // ; H crop start H
+	{0x3801, 0x08, 0, 0}, // ; H crop start L
+	{0x3802, 0x00, 0, 0}, // ; V crop start H
+	{0x3803, 0x04, 0, 0}, // ; V crop start L
+	{0x3804, 0x10, 0, 0}, // ; H crop end H
+	{0x3805, 0x97, 0, 0}, // ; H crop end L
+	{0x3806, 0x0c, 0, 0}, // ; V crop end H
+	{0x3807, 0x4b, 0, 0}, // ; V crop end L
+	{0x3808, 0x08, 0, 0}, // ; H output size H
+	{0x3809, 0x40, 0, 0}, // ; H output size L
+	{0x380a, 0x06, 0, 0}, // ; V output size H
+	{0x380b, 0x20, 0, 0}, // ; V output size L
+	{0x380c, 0x25, 0, 0}, // ; HTS H
+	{0x380d, 0x80, 0, 0}, // ; HTS L
+	{0x380e, 0x06, 0, 0}, // ; VTS H
+	{0x380f, 0x80, 0, 0}, // ; VTS L
+	{0x3810, 0x00, 0, 0}, // ; H win off H
+	{0x3811, 0x04, 0, 0}, // ; H win off L
+	{0x3812, 0x00, 0, 0}, // ; V win off H
+	{0x3813, 0x02, 0, 0}, // ; V win off L
+	{0x3814, 0x31, 0, 0}, // ; H inc
+	{0x3815, 0x31, 0, 0}, // ; V inc
+	{0x3820, 0x02, 0, 0}, // ; V flip off, V bin on
+	{0x3821, 0x05, 0, 0}, // ; H mirror on, H bin on
+	{0x3834, 0x00, 0, 0}, //
+	{0x3835, 0x1c, 0, 0}, // ; cut_en, vts_auto, blk_col_dis
+	{0x3836, 0x08, 0, 0}, //
+	{0x3837, 0x02, 0, 0}, //
+	{0x4000, 0xf1, 0, 0},//c1}, // ; BLC offset trig en, format change trig en, gain trig en, exp trig en, median en
+	{0x4001, 0x00, 0, 0}, // ; BLC
+	{0x400b, 0x0c, 0, 0}, // ; BLC
+	{0x4011, 0x00, 0, 0}, // ; BLC
+	{0x401a, 0x00, 0, 0}, // ; BLC
+	{0x401b, 0x00, 0, 0}, // ; BLC
+	{0x401c, 0x00, 0, 0}, // ; BLC
+	{0x401d, 0x00, 0, 0}, // ; BLC
+	{0x4020, 0x00, 0, 0}, // ; BLC
+	{0x4021, 0xe4, 0, 0}, // ; BLC
+	{0x4022, 0x07, 0, 0}, // ; BLC
+	{0x4023, 0x5f, 0, 0}, // ; BLC
+	{0x4024, 0x08, 0, 0}, // ; BLC
+	{0x4025, 0x44, 0, 0}, // ; BLC
+	{0x4026, 0x08, 0, 0}, // ; BLC
+	{0x4027, 0x47, 0, 0}, // ; BLC
+	{0x4028, 0x00, 0, 0}, // ; BLC
+	{0x4029, 0x02, 0, 0}, // ; BLC
+	{0x402a, 0x04, 0, 0}, // ; BLC
+	{0x402b, 0x08, 0, 0}, // ; BLC
+	{0x402c, 0x02, 0, 0}, // ; BLC
+	{0x402d, 0x02, 0, 0}, // ; BLC
+	{0x402e, 0x0c, 0, 0}, // ; BLC
+	{0x402f, 0x08, 0, 0}, // ; BLC
+	{0x403d, 0x2c, 0, 0}, //
+	{0x403f, 0x7f, 0, 0}, //
+	{0x4500, 0x82, 0, 0}, // ; BLC
+	{0x4501, 0x38, 0, 0}, // ; BLC
+	{0x4601, 0x04, 0, 0}, //
+	{0x4602, 0x22, 0, 0}, //
+	{0x4603, 0x01, 0, 0}, //; VFIFO
+	{0x4837, 0x19, 0, 0}, //; MIPI global timing
+	{0x4d00, 0x04, 0, 0}, // ; temperature monitor
+	{0x4d01, 0x42, 0, 0}, //  ; temperature monitor
+	{0x4d02, 0xd1, 0, 0}, //  ; temperature monitor
+	{0x4d03, 0x90, 0, 0}, //  ; temperature monitor
+	{0x4d04, 0x66, 0, 0}, //  ; temperature monitor
+	{0x4d05, 0x65, 0, 0}, // ; temperature monitor
+	{0x5000, 0x0e, 0, 0}, // ; windowing enable, BPC on, WPC on, Lenc on
+	{0x5001, 0x03, 0, 0}, // ; BLC enable, MWB on
+	{0x5002, 0x07, 0, 0}, //
+	{0x5013, 0x40, 0, 0},
+	{0x501c, 0x00, 0, 0},
+	{0x501d, 0x10, 0, 0},
+	//{0x5057, 0x56, 0, 0},//add
+	{0x5056, 0x08, 0, 0},
+	{0x5058, 0x08, 0, 0},
+	{0x505a, 0x08, 0, 0},
+	{0x5242, 0x00, 0, 0},
+	{0x5243, 0xb8, 0, 0},
+	{0x5244, 0x00, 0, 0},
+	{0x5245, 0xf9, 0, 0},
+	{0x5246, 0x00, 0, 0},
+	{0x5247, 0xf6, 0, 0},
+	{0x5248, 0x00, 0, 0},
+	{0x5249, 0xa6, 0, 0},
+	{0x5300, 0xfc, 0, 0},
+	{0x5301, 0xdf, 0, 0},
+	{0x5302, 0x3f, 0, 0},
+	{0x5303, 0x08, 0, 0},
+	{0x5304, 0x0c, 0, 0},
+	{0x5305, 0x10, 0, 0},
+	{0x5306, 0x20, 0, 0},
+	{0x5307, 0x40, 0, 0},
+	{0x5308, 0x08, 0, 0},
+	{0x5309, 0x08, 0, 0},
+	{0x530a, 0x02, 0, 0},
+	{0x530b, 0x01, 0, 0},
+	{0x530c, 0x01, 0, 0},
+	{0x530d, 0x0c, 0, 0},
+	{0x530e, 0x02, 0, 0},
+	{0x530f, 0x01, 0, 0},
+	{0x5310, 0x01, 0, 0},
+	{0x5400, 0x00, 0, 0},
+	{0x5401, 0x61, 0, 0},
+	{0x5402, 0x00, 0, 0},
+	{0x5403, 0x00, 0, 0},
+	{0x5404, 0x00, 0, 0},
+	{0x5405, 0x40, 0, 0},
+	{0x540c, 0x05, 0, 0},
+	{0x5b00, 0x00, 0, 0},
+	{0x5b01, 0x00, 0, 0},
+	{0x5b02, 0x01, 0, 0},
+	{0x5b03, 0xff, 0, 0},
+	{0x5b04, 0x02, 0, 0},
+	{0x5b05, 0x6c, 0, 0},
+	{0x5b09, 0x02, 0, 0}, //
+	//{0x5e00, 0x00, 0, 0}, // ; test pattern disable
+	//{0x5e00, 0x80, 0, 0}, // ; test pattern enable
+	{0x5e10, 0x1c, 0, 0}, // ; ISP test disable
+
+	//{0x0300, 0x01, 0, 0},// ; PLL
+	//{0x0302, 0x28, 0, 0},// ; PLL
+	//{0xffff,  50, 0, 0},
+	{0x3501, 0x67, 0, 0},// ; Exposure H
+	{0x370a, 0x26, 0, 0},//
+	{0x372a, 0x00, 0, 0},
+	{0x372f, 0x90, 0, 0},
+	{0x3801, 0x08, 0, 0}, //; H crop start L
+	{0x3803, 0x04, 0, 0}, //; V crop start L
+	{0x3805, 0x97, 0, 0}, //; H crop end L
+	{0x3807, 0x4b, 0, 0}, //; V crop end L
+	{0x3808, 0x08, 0, 0}, //; H output size H
+	{0x3809, 0x40, 0, 0}, //; H output size L
+	{0x380a, 0x06, 0, 0}, //; V output size H
+	{0x380b, 0x20, 0, 0}, //; V output size L
+	{0x380c, 0x25, 0, 0}, //; HTS H
+	{0x380d, 0x80, 0, 0}, //; HTS L
+	{0x380e, 0x0a, 0, 0},//6}, //; VTS H
+	{0x380f, 0x80, 0, 0}, //; VTS L
+	{0x3813, 0x02, 0, 0}, //; V win off
+	{0x3814, 0x31, 0, 0}, //; H inc
+	{0x3815, 0x31, 0, 0}, //; V inc
+	{0x3820, 0x02, 0, 0}, //; V flip off, V bin on
+	{0x3821, 0x05, 0, 0}, //; H mirror on, H bin on
+	{0x3836, 0x08, 0, 0}, //
+	{0x3837, 0x02, 0, 0}, //
+	{0x4020, 0x00, 0, 0}, //
+	{0x4021, 0xe4, 0, 0}, //
+	{0x4022, 0x07, 0, 0}, //
+	{0x4023, 0x5f, 0, 0}, //
+	{0x4024, 0x08, 0, 0}, //
+	{0x4025, 0x44, 0, 0}, //
+	{0x4026, 0x08, 0, 0}, //
+	{0x4027, 0x47, 0, 0}, //
+	{0x4603, 0x01, 0, 0}, //; VFIFO
+	{0x4837, 0x19, 0, 0}, //; MIPI global timing
+	{0x4802, 0x42, 0, 0},  //default 0x00
+	{0x481a, 0x00, 0, 0},
+	{0x481b, 0x1c, 0, 0},   //default 0x3c  prepare
+	{0x4826, 0x12, 0, 0},   //default 0x32  trail
+	{0x5401, 0x61, 0, 0}, //
+	{0x5405, 0x40, 0, 0}, //
+
+	//{0xffff, 200, 0, 0},
+	//{0xffff, 200, 0, 0},
+	//{0xffff, 200, 0, 0},
+
+	//{0x0100, 0x01, 0, 0}, //; wake up, streaming
+};
+
+/* power-on sensor init reg table */
+static const struct ov13850_mode_info ov13850_mode_init_data = {
+	OV13850_MODE_1080P_1920_1080, SCALING,
+	1920, 0x6e0, 1080, 0x470,
+	ov13850_init_setting_30fps_1080P,
+	ARRAY_SIZE(ov13850_init_setting_30fps_1080P),
+	OV13850_30_FPS,
+};
+
+static const struct ov13850_mode_info
+ov13850_mode_data[OV13850_NUM_MODES] = {
+	{OV13850_MODE_1080P_1920_1080, SCALING,
+	1920, 0x6e0, 1080, 0x470,
+	ov13850_setting_1080P_1920_1080,
+	ARRAY_SIZE(ov13850_setting_1080P_1920_1080),
+	OV13850_30_FPS},
+};
+
+static int ov13850_write_reg(struct ov13850_dev *sensor, u16 reg, u8 val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg;
+	u8 buf[3];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	buf[2] = val;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.buf = buf;
+	msg.len = sizeof(buf);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x, val=%x\n",
+			__func__, reg, val);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ov13850_read_reg(struct ov13850_dev *sensor, u16 reg, u8 *val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = buf;
+	msg[0].len = sizeof(buf);
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = 1;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x\n",
+			__func__, reg);
+		return ret;
+	}
+
+	*val = buf[0];
+	return 0;
+}
+
+#ifdef UNUSED_CODE
+static int ov13850_read_reg16(struct ov13850_dev *sensor, u16 reg, u16 *val)
+{
+	u8 hi, lo;
+	int ret;
+
+	ret = ov13850_read_reg(sensor, reg, &hi);
+	if (ret)
+		return ret;
+	ret = ov13850_read_reg(sensor, reg + 1, &lo);
+	if (ret)
+		return ret;
+
+	*val = ((u16)hi << 8) | (u16)lo;
+	return 0;
+}
+#endif
+
+static int ov13850_write_reg16(struct ov13850_dev *sensor, u16 reg, u16 val)
+{
+	int ret;
+
+	ret = ov13850_write_reg(sensor, reg, val >> 8);
+	if (ret)
+		return ret;
+
+	return ov13850_write_reg(sensor, reg + 1, val & 0xff);
+}
+
+static int ov13850_mod_reg(struct ov13850_dev *sensor, u16 reg,
+			u8 mask, u8 val)
+{
+	u8 readval;
+	int ret;
+
+	ret = ov13850_read_reg(sensor, reg, &readval);
+	if (ret)
+		return ret;
+
+	readval &= ~mask;
+	val &= mask;
+	val |= readval;
+
+	return ov13850_write_reg(sensor, reg, val);
+}
+
+static int ov13850_set_timings(struct ov13850_dev *sensor,
+			const struct ov13850_mode_info *mode)
+{
+	int ret;
+
+	ret = ov13850_write_reg16(sensor, OV13850_REG_H_OUTPUT_SIZE, mode->hact);
+	if (ret < 0)
+		return ret;
+
+	ret = ov13850_write_reg16(sensor, OV13850_REG_V_OUTPUT_SIZE, mode->vact);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int ov13850_load_regs(struct ov13850_dev *sensor,
+			const struct ov13850_mode_info *mode)
+{
+	const struct reg_value *regs = mode->reg_data;
+	unsigned int i;
+	u32 delay_ms;
+	u16 reg_addr;
+	u8 mask, val;
+	int ret = 0;
+
+	st_info(ST_SENSOR, "%s, mode = 0x%x\n", __func__, mode->id);
+	for (i = 0; i < mode->reg_data_size; ++i, ++regs) {
+		delay_ms = regs->delay_ms;
+		reg_addr = regs->reg_addr;
+		val = regs->val;
+		mask = regs->mask;
+
+		if (mask)
+			ret = ov13850_mod_reg(sensor, reg_addr, mask, val);
+		else
+			ret = ov13850_write_reg(sensor, reg_addr, val);
+		if (ret)
+			break;
+
+		if (delay_ms)
+			usleep_range(1000 * delay_ms, 1000 * delay_ms + 100);
+	}
+
+	return ov13850_set_timings(sensor, mode);
+}
+
+
+
+static int ov13850_get_gain(struct ov13850_dev *sensor)
+{
+	u32 gain = 0;
+	return gain;
+}
+
+static int ov13850_set_gain(struct ov13850_dev *sensor, int gain)
+{
+	return 0;
+}
+
+static int ov13850_set_stream_mipi(struct ov13850_dev *sensor, bool on)
+{
+	return 0;
+}
+
+#ifdef UNUSED_CODE
+static int ov13850_get_sysclk(struct ov13850_dev *sensor)
+{
+	return 0;
+}
+
+static int ov13850_set_night_mode(struct ov13850_dev *sensor)
+{
+	return 0;
+}
+
+static int ov13850_get_hts(struct ov13850_dev *sensor)
+{
+	/* read HTS from register settings */
+	u16 hts;
+	int ret;
+
+	ret = ov13850_read_reg16(sensor, OV13850_REG_TIMING_HTS, &hts);
+	if (ret)
+		return ret;
+	return hts;
+}
+
+static int ov13850_set_hts(struct ov13850_dev *sensor, int hts)
+{
+	return ov13850_write_reg16(sensor, OV13850_REG_TIMING_HTS, hts);
+}
+
+
+static int ov13850_get_vts(struct ov13850_dev *sensor)
+{
+	u16 vts;
+	int ret;
+
+	ret = ov13850_read_reg16(sensor, OV13850_REG_TIMING_VTS, &vts);
+	if (ret)
+		return ret;
+	return vts;
+}
+
+static int ov13850_set_vts(struct ov13850_dev *sensor, int vts)
+{
+	return ov13850_write_reg16(sensor, OV13850_REG_TIMING_VTS, vts);
+}
+
+static int ov13850_get_light_freq(struct ov13850_dev *sensor)
+{
+	return 0;
+}
+
+static int ov13850_set_bandingfilter(struct ov13850_dev *sensor)
+{
+	return 0;
+}
+
+static int ov13850_set_ae_target(struct ov13850_dev *sensor, int target)
+{
+	return 0;
+}
+
+static int ov13850_get_binning(struct ov13850_dev *sensor)
+{
+	return 0;
+}
+
+static int ov13850_set_binning(struct ov13850_dev *sensor, bool enable)
+{
+	return 0;
+}
+#endif
+
+static const struct ov13850_mode_info *
+ov13850_find_mode(struct ov13850_dev *sensor, enum ov13850_frame_rate fr,
+		int width, int height, bool nearest)
+{
+	const struct ov13850_mode_info *mode;
+
+	mode = v4l2_find_nearest_size(ov13850_mode_data,
+				ARRAY_SIZE(ov13850_mode_data),
+				hact, vact,
+				width, height);
+
+	if (!mode ||
+		(!nearest && (mode->hact != width || mode->vact != height)))
+		return NULL;
+
+	/* Check to see if the current mode exceeds the max frame rate */
+	if (ov13850_framerates[fr] > ov13850_framerates[mode->max_fps])
+		return NULL;
+
+	return mode;
+}
+
+static u64 ov13850_calc_pixel_rate(struct ov13850_dev *sensor)
+{
+	u64 rate;
+
+	rate = sensor->current_mode->vact * sensor->current_mode->hact;
+	rate *= ov13850_framerates[sensor->current_fr];
+
+	return rate;
+}
+
+/*
+ * After trying the various combinations, reading various
+ * documentations spread around the net, and from the various
+ * feedback, the clock tree is probably as follows:
+ *
+ *   +--------------+
+ *   |  Ext. Clock  |
+ *   +-+------------+
+ *     |  +----------+
+ *     +->|   PLL1   | - reg 0x030a, bit0 for the pre-dividerp
+ *        +-+--------+ - reg 0x0300, bits 0-2 for the pre-divider
+ *        +-+--------+ - reg 0x0301~0x0302, for the multiplier
+ *          |  +--------------+
+ *          +->| MIPI Divider |  - reg 0x0303, bits 0-3 for the pre-divider
+ *               | +---------> MIPI PHY CLK
+ *               |    +-----+
+ *               | +->| PLL1_DIV_MIPI | - reg 0x0304, bits 0-1 for the divider
+ *                 |    +----------------> PCLK
+ *               |    +-----+
+ *
+ *   +--------------+
+ *   |  Ext. Clock  |
+ *   +-+------------+
+ *     |  +----------+
+ *     +->|   PLL2  | - reg 0x0311, bit0 for the pre-dividerp
+ *        +-+--------+ - reg 0x030b, bits 0-2 for the pre-divider
+ *        +-+--------+ - reg 0x030c~0x030d, for the multiplier
+ *          |  +--------------+
+ *          +->| SCLK Divider |  - reg 0x030F, bits 0-3 for the pre-divider
+ *               +-+--------+    - reg 0x030E, bits 0-2 for the divider
+ *               |    +---------> SCLK
+ *
+ *          |       +-----+
+ *          +->| DAC Divider | - reg 0x0312, bits 0-3 for the divider
+ *                    |    +----------------> DACCLK
+ **
+ */
+
+/*
+ * ov13850_set_mipi_pclk() - Calculate the clock tree configuration values
+ *			for the MIPI CSI-2 output.
+ *
+ * @rate: The requested bandwidth per lane in bytes per second.
+ *	'Bandwidth Per Lane' is calculated as:
+ *	bpl = HTOT * VTOT * FPS * bpp / num_lanes;
+ *
+ * This function use the requested bandwidth to calculate:
+ *
+ * - mipi_pclk   = bpl / 2; ( / 2 is for CSI-2 DDR)
+ * - mipi_phy_clk   = mipi_pclk * PLL1_DIV_MIPI;
+ *
+ * with these fixed parameters:
+ *	PLL1_PREDIVP    = 1;
+ *	PLL1_PREDIV     = 1; (MIPI_BIT_MODE == 8 ? 2 : 2,5);
+ *	PLL1_DIVM       = 1;
+ *	PLL1_DIV_MIPI   = 4;
+ *
+ * FIXME: this have been tested with 10-bit raw and 2 lanes setup only.
+ * MIPI_DIV is fixed to value 2, but it -might- be changed according to the
+ * above formula for setups with 1 lane or image formats with different bpp.
+ *
+ * FIXME: this deviates from the sensor manual documentation which is quite
+ * thin on the MIPI clock tree generation part.
+ */
+
+
+
+static int ov13850_set_mipi_pclk(struct ov13850_dev *sensor,
+				unsigned long rate)
+{
+
+	return 0;
+}
+
+/*
+ * if sensor changes inside scaling or subsampling
+ * change mode directly
+ */
+static int ov13850_set_mode_direct(struct ov13850_dev *sensor,
+				const struct ov13850_mode_info *mode)
+{
+	if (!mode->reg_data)
+		return -EINVAL;
+
+	/* Write capture setting */
+	return ov13850_load_regs(sensor, mode);
+}
+
+static int ov13850_set_mode(struct ov13850_dev *sensor)
+{
+	const struct ov13850_mode_info *mode = sensor->current_mode;
+	int ret = 0;
+
+	ret = ov13850_set_mode_direct(sensor, mode);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * we support have 10 bits raw RGB(mipi)
+	 */
+	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)
+		ret = ov13850_set_mipi_pclk(sensor, 0);
+
+	if (ret < 0)
+		return 0;
+
+	sensor->pending_mode_change = false;
+	sensor->last_mode = mode;
+	return 0;
+}
+
+static int ov13850_set_framefmt(struct ov13850_dev *sensor,
+			       struct v4l2_mbus_framefmt *format);
+
+/* restore the last set video mode after chip power-on */
+static int ov13850_restore_mode(struct ov13850_dev *sensor)
+{
+	int ret;
+
+	/* first load the initial register values */
+	ret = ov13850_load_regs(sensor, &ov13850_mode_init_data);
+	if (ret < 0)
+		return ret;
+	sensor->last_mode = &ov13850_mode_init_data;
+
+	/* now restore the last capture mode */
+	ret = ov13850_set_mode(sensor);
+	if (ret < 0)
+		return ret;
+
+	return ov13850_set_framefmt(sensor, &sensor->fmt);
+}
+
+static void ov13850_power(struct ov13850_dev *sensor, bool enable)
+{
+	if (!sensor->pwdn_gpio)
+		return;
+	if (enable) {
+		gpiod_set_value_cansleep(sensor->pwdn_gpio, 0);
+		gpiod_set_value_cansleep(sensor->pwdn_gpio, 1);
+	} else {
+		gpiod_set_value_cansleep(sensor->pwdn_gpio, 0);
+	}
+
+	mdelay(100);
+}
+
+static void ov13850_reset(struct ov13850_dev *sensor)
+{
+	if (!sensor->reset_gpio)
+		return;
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+	gpiod_set_value_cansleep(sensor->reset_gpio, 1);
+	mdelay(100);
+}
+
+static int ov13850_set_power_on(struct ov13850_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int ret;
+
+	ret = clk_prepare_enable(sensor->xclk);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable clock\n",
+			__func__);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(OV13850_NUM_SUPPLIES,
+				sensor->supplies);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable regulators\n",
+			__func__);
+		goto xclk_off;
+	}
+
+	ov13850_reset(sensor);
+	ov13850_power(sensor, true);
+
+	return 0;
+
+xclk_off:
+	clk_disable_unprepare(sensor->xclk);
+	return ret;
+}
+
+static void ov13850_set_power_off(struct ov13850_dev *sensor)
+{
+	ov13850_power(sensor, false);
+	regulator_bulk_disable(OV13850_NUM_SUPPLIES, sensor->supplies);
+	clk_disable_unprepare(sensor->xclk);
+}
+
+static int ov13850_set_power_mipi(struct ov13850_dev *sensor, bool on)
+{
+	return 0;
+}
+
+static int ov13850_set_power(struct ov13850_dev *sensor, bool on)
+{
+	int ret = 0;
+#ifdef UNUSED_CODE
+	u16 chip_id;
+#endif
+
+	if (on) {
+		ret = ov13850_set_power_on(sensor);
+		if (ret)
+			return ret;
+
+#ifdef UNUSED_CODE
+		ret = ov13850_read_reg16(sensor, OV13850_REG_CHIP_ID, &chip_id);
+		if (ret) {
+			dev_err(&sensor->i2c_client->dev, "%s: failed to read chip identifier\n",
+				__func__);
+			ret = -ENODEV;
+			goto power_off;
+		}
+
+		if (chip_id != OV13850_CHIP_ID) {
+			dev_err(&sensor->i2c_client->dev,
+					"%s: wrong chip identifier, expected 0x%x, got 0x%x\n",
+					__func__, OV13850_CHIP_ID, chip_id);
+			ret = -ENXIO;
+			goto power_off;
+		}
+		dev_err(&sensor->i2c_client->dev, "%s: chip identifier, got 0x%x\n",
+			__func__, chip_id);
+#endif
+
+		ret = ov13850_restore_mode(sensor);
+		if (ret)
+			goto power_off;
+	}
+
+	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)
+		ret = ov13850_set_power_mipi(sensor, on);
+	if (ret)
+		goto power_off;
+
+	if (!on)
+		ov13850_set_power_off(sensor);
+
+	return 0;
+
+power_off:
+	ov13850_set_power_off(sensor);
+	return ret;
+}
+
+static int ov13850_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	int ret = 0;
+
+	mutex_lock(&sensor->lock);
+
+	/*
+	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
+	 * update the power state.
+	 */
+	if (sensor->power_count == !on) {
+		ret = ov13850_set_power(sensor, !!on);
+		if (ret)
+			goto out;
+	}
+
+	/* Update the power count. */
+	sensor->power_count += on ? 1 : -1;
+	WARN_ON(sensor->power_count < 0);
+out:
+	mutex_unlock(&sensor->lock);
+
+	if (on && !ret && sensor->power_count == 1) {
+		/* restore controls */
+		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+	}
+
+	return ret;
+}
+
+static int ov13850_try_frame_interval(struct ov13850_dev *sensor,
+				struct v4l2_fract *fi,
+				u32 width, u32 height)
+{
+	const struct ov13850_mode_info *mode;
+	enum ov13850_frame_rate rate = OV13850_15_FPS;
+	int minfps, maxfps, best_fps, fps;
+	int i;
+
+	minfps = ov13850_framerates[OV13850_15_FPS];
+	maxfps = ov13850_framerates[OV13850_NUM_FRAMERATES - 1];
+
+	if (fi->numerator == 0) {
+		fi->denominator = maxfps;
+		fi->numerator = 1;
+		rate = OV13850_60_FPS;
+		goto find_mode;
+	}
+
+	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
+			minfps, maxfps);
+
+	best_fps = minfps;
+	for (i = 0; i < ARRAY_SIZE(ov13850_framerates); i++) {
+		int curr_fps = ov13850_framerates[i];
+
+		if (abs(curr_fps - fps) < abs(best_fps - fps)) {
+			best_fps = curr_fps;
+			rate = i;
+		}
+	}
+	st_info(ST_SENSOR, "best_fps = %d, fps = %d\n", best_fps, fps);
+
+	fi->numerator = 1;
+	fi->denominator = best_fps;
+
+find_mode:
+	mode = ov13850_find_mode(sensor, rate, width, height, false);
+	return mode ? rate : -EINVAL;
+}
+
+static int ov13850_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad != 0)
+		return -EINVAL;
+
+	if (code->index >= ARRAY_SIZE(ov13850_formats))
+		return -EINVAL;
+
+	code->code = ov13850_formats[code->index].code;
+	return 0;
+}
+
+static int ov13850_get_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *format)
+{
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	struct v4l2_mbus_framefmt *fmt;
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(&sensor->sd, cfg,
+						format->pad);
+	else
+		fmt = &sensor->fmt;
+
+	format->format = *fmt;
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int ov13850_try_fmt_internal(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt,
+				enum ov13850_frame_rate fr,
+				const struct ov13850_mode_info **new_mode)
+{
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	const struct ov13850_mode_info *mode;
+	int i;
+
+	mode = ov13850_find_mode(sensor, fr, fmt->width, fmt->height, true);
+	if (!mode)
+		return -EINVAL;
+	fmt->width = mode->hact;
+	fmt->height = mode->vact;
+
+	if (new_mode)
+		*new_mode = mode;
+
+	for (i = 0; i < ARRAY_SIZE(ov13850_formats); i++)
+		if (ov13850_formats[i].code == fmt->code)
+			break;
+	if (i >= ARRAY_SIZE(ov13850_formats))
+		i = 0;
+
+	fmt->code = ov13850_formats[i].code;
+	fmt->colorspace = ov13850_formats[i].colorspace;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+
+	return 0;
+}
+
+static int ov13850_set_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *format)
+{
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	const struct ov13850_mode_info *new_mode;
+	struct v4l2_mbus_framefmt *mbus_fmt = &format->format;
+	struct v4l2_mbus_framefmt *fmt;
+	int ret;
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = ov13850_try_fmt_internal(sd, mbus_fmt, 0, &new_mode);
+	if (ret)
+		goto out;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(sd, cfg, 0);
+	else
+		fmt = &sensor->fmt;
+
+	if (mbus_fmt->code != sensor->fmt.code)
+		sensor->pending_fmt_change = true;
+
+	*fmt = *mbus_fmt;
+
+	if (new_mode != sensor->current_mode) {
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+
+	if (new_mode->max_fps < sensor->current_fr) {
+		sensor->current_fr = new_mode->max_fps;
+		sensor->frame_interval.numerator = 1;
+		sensor->frame_interval.denominator =
+			ov13850_framerates[sensor->current_fr];
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+
+	__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
+				ov13850_calc_pixel_rate(sensor));
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int ov13850_set_framefmt(struct ov13850_dev *sensor,
+			       struct v4l2_mbus_framefmt *format)
+{
+	u8 fmt;
+
+	switch (format->code) {
+	/* Raw, BGBG... / GRGR... */
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		fmt = 0x0;
+		break;
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+		fmt = 0x1;
+		break;
+	case MEDIA_BUS_FMT_SBGGR12_1X12:
+	case MEDIA_BUS_FMT_SGBRG12_1X12:
+	case MEDIA_BUS_FMT_SGRBG12_1X12:
+	case MEDIA_BUS_FMT_SRGGB12_1X12:
+		fmt = 0x2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ov13850_mod_reg(sensor, OV13850_REG_MIPI_SC,
+			BIT(1) | BIT(0), fmt);
+}
+
+/*
+ * Sensor Controls.
+ */
+
+static int ov13850_set_ctrl_hue(struct ov13850_dev *sensor, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int ov13850_set_ctrl_contrast(struct ov13850_dev *sensor, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int ov13850_set_ctrl_saturation(struct ov13850_dev *sensor, int value)
+{
+	int ret  = 0;
+
+	return ret;
+}
+
+static int ov13850_set_ctrl_white_balance(struct ov13850_dev *sensor, int awb)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int ov13850_set_ctrl_exposure(struct ov13850_dev *sensor,
+				enum v4l2_exposure_auto_type auto_exposure)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static const s64 link_freq_menu_items[] = {
+	OV13850_LINK_FREQ_500MHZ
+};
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Color bars",
+	"Color bars w/ rolling bar",
+	"Color squares",
+	"Color squares w/ rolling bar",
+};
+
+static int ov13850_set_ctrl_test_pattern(struct ov13850_dev *sensor, int value)
+{
+	return 0;
+}
+
+static int ov13850_set_ctrl_light_freq(struct ov13850_dev *sensor, int value)
+{
+	return 0;
+}
+
+static int ov13850_set_ctrl_hflip(struct ov13850_dev *sensor, int value)
+{
+	return 0;
+}
+
+static int ov13850_set_ctrl_vflip(struct ov13850_dev *sensor, int value)
+{
+	return 0;
+}
+
+static int ov13850_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	int val;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		val = ov13850_get_gain(sensor);
+		break;
+	}
+
+	return 0;
+}
+
+static int ov13850_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored right after power-up.
+	 */
+	if (sensor->power_count == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov13850_set_gain(sensor, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = ov13850_set_ctrl_exposure(sensor, V4L2_EXPOSURE_MANUAL);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		ret = ov13850_set_ctrl_white_balance(sensor, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		ret = ov13850_set_ctrl_hue(sensor, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = ov13850_set_ctrl_contrast(sensor, ctrl->val);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = ov13850_set_ctrl_saturation(sensor, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov13850_set_ctrl_test_pattern(sensor, ctrl->val);
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		ret = ov13850_set_ctrl_light_freq(sensor, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = ov13850_set_ctrl_hflip(sensor, ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = ov13850_set_ctrl_vflip(sensor, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov13850_ctrl_ops = {
+	.g_volatile_ctrl = ov13850_g_volatile_ctrl,
+	.s_ctrl = ov13850_s_ctrl,
+};
+
+static int ov13850_init_controls(struct ov13850_dev *sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &ov13850_ctrl_ops;
+	struct ov13850_ctrls *ctrls = &sensor->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	v4l2_ctrl_handler_init(hdl, 32);
+
+	/* we can use our own mutex for the ctrl lock */
+	hdl->lock = &sensor->lock;
+
+	/* Clock related controls */
+	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
+					0, INT_MAX, 1,
+					ov13850_calc_pixel_rate(sensor));
+
+	/* Auto/manual white balance */
+	ctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_AUTO_WHITE_BALANCE,
+					0, 1, 1, 0);
+	ctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,
+						0, 4095, 1, 1024);
+	ctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,
+						0, 4095, 1, 1024);
+
+	ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,
+					4, 0xfff8, 1, 0x4c00);
+	ctrls->anal_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ANALOGUE_GAIN,
+					0x10, 0xfff8, 1, 0x0080);
+	ctrls->test_pattern =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+					ARRAY_SIZE(test_pattern_menu) - 1,
+					0, 0, test_pattern_menu);
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					0, 1, 1, 0);
+	ctrls->light_freq =
+		v4l2_ctrl_new_std_menu(hdl, ops,
+					V4L2_CID_POWER_LINE_FREQUENCY,
+					V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,
+					V4L2_CID_POWER_LINE_FREQUENCY_50HZ);
+	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops, V4L2_CID_LINK_FREQ,
+					0, 0, link_freq_menu_items);
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	// ctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	// ctrls->anal_gain->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	v4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);
+
+	sensor->sd.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+
+static int ov13850_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->pad != 0)
+		return -EINVAL;
+	if (fse->index >= OV13850_NUM_MODES)
+		return -EINVAL;
+
+	fse->min_width =
+		ov13850_mode_data[fse->index].hact;
+	fse->max_width = fse->min_width;
+	fse->min_height =
+		ov13850_mode_data[fse->index].vact;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov13850_enum_frame_interval(
+	struct v4l2_subdev *sd,
+	struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct v4l2_fract tpf;
+#ifdef UNUSED_CODE
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	int ret;
+#endif
+
+	if (fie->pad != 0)
+		return -EINVAL;
+	if (fie->index >= OV13850_NUM_FRAMERATES)
+		return -EINVAL;
+
+	tpf.numerator = 1;
+	tpf.denominator = ov13850_framerates[fie->index];
+
+/*	ret = ov13850_try_frame_interval(sensor, &tpf,
+ *					fie->width, fie->height);
+ *	if (ret < 0)
+ *		return -EINVAL;
+ */
+	fie->interval = tpf;
+
+	return 0;
+}
+
+static int ov13850_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *fi)
+{
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+
+	mutex_lock(&sensor->lock);
+	fi->interval = sensor->frame_interval;
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int ov13850_s_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *fi)
+{
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	const struct ov13850_mode_info *mode;
+	int frame_rate, ret = 0;
+
+	if (fi->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	mode = sensor->current_mode;
+
+	frame_rate = ov13850_try_frame_interval(sensor, &fi->interval,
+					mode->hact, mode->vact);
+	if (frame_rate < 0) {
+		/* Always return a valid frame interval value */
+		fi->interval = sensor->frame_interval;
+		goto out;
+	}
+
+	mode = ov13850_find_mode(sensor, frame_rate, mode->hact,
+				mode->vact, true);
+	if (!mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (mode != sensor->current_mode ||
+		frame_rate != sensor->current_fr) {
+		sensor->current_fr = frame_rate;
+		sensor->frame_interval = fi->interval;
+		sensor->current_mode = mode;
+		sensor->pending_mode_change = true;
+
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
+					ov13850_calc_pixel_rate(sensor));
+	}
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int ov13850_stream_start(struct ov13850_dev *sensor, int enable)
+{
+	int ret;
+
+	if (enable) {		//stream on
+		mdelay(1000);
+		ret = ov13850_write_reg(sensor, OV13850_STREAM_CTRL, enable);
+	} else {			//stream off
+		ret = ov13850_write_reg(sensor, OV13850_STREAM_CTRL, enable);
+		mdelay(100);
+	}
+
+	return ret;
+}
+
+static int ov13850_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+	int ret = 0;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming == !enable) {
+		if (enable && sensor->pending_mode_change) {
+			ret = ov13850_set_mode(sensor);
+			if (ret)
+				goto out;
+		}
+
+		if (enable && sensor->pending_fmt_change) {
+			ret = ov13850_set_framefmt(sensor, &sensor->fmt);
+			if (ret)
+				goto out;
+			sensor->pending_fmt_change = false;
+		}
+
+		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)
+			ret = ov13850_set_stream_mipi(sensor, enable);
+
+		ret = ov13850_stream_start(sensor, enable);
+
+		if (!ret)
+			sensor->streaming = enable;
+	}
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops ov13850_core_ops = {
+	.s_power = ov13850_s_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops ov13850_video_ops = {
+	.g_frame_interval = ov13850_g_frame_interval,
+	.s_frame_interval = ov13850_s_frame_interval,
+	.s_stream = ov13850_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov13850_pad_ops = {
+	.enum_mbus_code = ov13850_enum_mbus_code,
+	.get_fmt = ov13850_get_fmt,
+	.set_fmt = ov13850_set_fmt,
+	.enum_frame_size = ov13850_enum_frame_size,
+	.enum_frame_interval = ov13850_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops ov13850_subdev_ops = {
+	.core = &ov13850_core_ops,
+	.video = &ov13850_video_ops,
+	.pad = &ov13850_pad_ops,
+};
+
+static int ov13850_get_regulators(struct ov13850_dev *sensor)
+{
+	int i;
+
+	for (i = 0; i < OV13850_NUM_SUPPLIES; i++)
+		sensor->supplies[i].supply = ov13850_supply_name[i];
+
+	return devm_regulator_bulk_get(&sensor->i2c_client->dev,
+					OV13850_NUM_SUPPLIES,
+					sensor->supplies);
+}
+
+static int ov13850_check_chip_id(struct ov13850_dev *sensor)
+{
+#ifdef UNUSED_CODE
+	struct i2c_client *client = sensor->i2c_client;
+	u16 chip_id;
+#endif
+	int ret = 0;
+
+	ret = ov13850_set_power_on(sensor);
+	if (ret)
+		return ret;
+
+#ifdef UNUSED_CODE
+	ret = ov13850_read_reg16(sensor, OV13850_REG_CHIP_ID, &chip_id);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to read chip identifier\n",
+			__func__);
+		goto power_off;
+	}
+
+	if (chip_id != OV13850_CHIP_ID) {
+		dev_err(&client->dev, "%s: wrong chip identifier, expected 0x%x,  got 0x%x\n",
+			__func__, OV13850_CHIP_ID, chip_id);
+		ret = -ENXIO;
+	}
+	dev_err(&client->dev, "%s: chip identifier, got 0x%x\n",
+		__func__, chip_id);
+
+power_off:
+#endif
+	ov13850_set_power_off(sensor);
+	return ret;
+}
+
+static int ov13850_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	struct ov13850_dev *sensor;
+	struct v4l2_mbus_framefmt *fmt;
+	u32 rotation;
+	int ret;
+
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	sensor->i2c_client = client;
+
+	fmt = &sensor->fmt;
+	fmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = 1920;
+	fmt->height = 1080;
+	fmt->field = V4L2_FIELD_NONE;
+	sensor->frame_interval.numerator = 1;
+	sensor->frame_interval.denominator = ov13850_framerates[OV13850_30_FPS];
+	sensor->current_fr = OV13850_30_FPS;
+	sensor->current_mode =
+		&ov13850_mode_data[OV13850_MODE_1080P_1920_1080];
+	sensor->last_mode = sensor->current_mode;
+
+	sensor->ae_target = 52;
+
+	/* optional indication of physical rotation of sensor */
+	ret = fwnode_property_read_u32(dev_fwnode(&client->dev), "rotation",
+					&rotation);
+	if (!ret) {
+		switch (rotation) {
+		case 180:
+			sensor->upside_down = true;
+			fallthrough;
+		case 0:
+			break;
+		default:
+			dev_warn(dev, "%u degrees rotation is not supported, ignoring...\n",
+				rotation);
+		}
+	}
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev),
+						NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &sensor->ep);
+	fwnode_handle_put(endpoint);
+	if (ret) {
+		dev_err(dev, "Could not parse endpoint\n");
+		return ret;
+	}
+
+	if (sensor->ep.bus_type != V4L2_MBUS_PARALLEL &&
+		sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY &&
+		sensor->ep.bus_type != V4L2_MBUS_BT656) {
+		dev_err(dev, "Unsupported bus type %d\n", sensor->ep.bus_type);
+		return -EINVAL;
+	}
+
+	/* get system clock (xclk) */
+	sensor->xclk = devm_clk_get(dev, "xclk");
+	if (IS_ERR(sensor->xclk)) {
+		dev_err(dev, "failed to get xclk\n");
+		return PTR_ERR(sensor->xclk);
+	}
+
+	sensor->xclk_freq = clk_get_rate(sensor->xclk);
+	if (sensor->xclk_freq < OV13850_XCLK_MIN ||
+		sensor->xclk_freq > OV13850_XCLK_MAX) {
+		dev_err(dev, "xclk frequency out of range: %d Hz\n",
+			sensor->xclk_freq);
+		return -EINVAL;
+	}
+
+	/* request optional power down pin */
+	sensor->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
+						GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->pwdn_gpio))
+		return PTR_ERR(sensor->pwdn_gpio);
+
+	/* request optional reset pin */
+	sensor->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->reset_gpio))
+		return PTR_ERR(sensor->reset_gpio);
+
+	v4l2_i2c_subdev_init(&sensor->sd, client, &ov13850_subdev_ops);
+
+	sensor->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			V4L2_SUBDEV_FL_HAS_EVENTS;
+	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);
+	if (ret)
+		return ret;
+
+	ret = ov13850_get_regulators(sensor);
+	if (ret)
+		return ret;
+
+	mutex_init(&sensor->lock);
+
+	ret = ov13850_check_chip_id(sensor);
+	if (ret)
+		goto entity_cleanup;
+
+	ret = ov13850_init_controls(sensor);
+	if (ret)
+		goto entity_cleanup;
+
+	ret = v4l2_async_register_subdev_sensor_common(&sensor->sd);
+	if (ret)
+		goto free_ctrls;
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+entity_cleanup:
+	media_entity_cleanup(&sensor->sd.entity);
+	mutex_destroy(&sensor->lock);
+	return ret;
+}
+
+static int ov13850_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13850_dev *sensor = to_ov13850_dev(sd);
+
+	v4l2_async_unregister_subdev(&sensor->sd);
+	media_entity_cleanup(&sensor->sd.entity);
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+	mutex_destroy(&sensor->lock);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov13850_id[] = {
+	{"ov13850", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ov13850_id);
+
+static const struct of_device_id ov13850_dt_ids[] = {
+	{ .compatible = "ovti,ov13850" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ov13850_dt_ids);
+
+static struct i2c_driver ov13850_i2c_driver = {
+	.driver = {
+		.name  = "ov13850",
+		.of_match_table = ov13850_dt_ids,
+	},
+	.id_table = ov13850_id,
+	.probe_new = ov13850_probe,
+	.remove   = ov13850_remove,
+};
+
+module_i2c_driver(ov13850_i2c_driver);
+
+MODULE_DESCRIPTION("OV13850 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/starfive/v4l2_driver/ov4689_mipi.c b/drivers/media/platform/starfive/v4l2_driver/ov4689_mipi.c
new file mode 100644
index 000000000000..1aa390446eb3
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/ov4689_mipi.c
@@ -0,0 +1,2974 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2014-2017 Mentor Graphics Inc.
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include "stfcamss.h"
+
+
+#define OV4689_LANES    4
+
+#define OV4689_LINK_FREQ_500MHZ         500000000LL
+
+/* min/typical/max system clock (xclk) frequencies */
+#define OV4689_XCLK_MIN  6000000
+#define OV4689_XCLK_MAX 64000000
+
+#define OV4689_CHIP_ID	(0x4688)
+
+#define OV4689_CHIP_ID_HIGH_BYTE        0x300a   // max should be 0x46
+#define OV4689_CHIP_ID_LOW_BYTE         0x300b   // max should be 0x88
+#define OV4689_REG_CHIP_ID              0x300a
+
+#define OV4689_REG_H_OUTPUT_SIZE	0x3808
+#define OV4689_REG_V_OUTPUT_SIZE	0x380a
+#define OV4689_REG_TIMING_HTS		0x380c
+#define OV4689_REG_TIMING_VTS		0x380e
+
+#define OV4689_REG_EXPOSURE_HI          0x3500
+#define OV4689_REG_EXPOSURE_MED         0x3501
+#define OV4689_REG_EXPOSURE_LO          0x3502
+#define OV4689_REG_GAIN_H               0x3507
+#define OV4689_REG_GAIN_M               0x3508
+#define OV4689_REG_GAIN_L               0x3509
+#define OV4689_REG_TEST_PATTERN         0x5040
+#define OV4689_REG_TIMING_TC_REG20      0x3820
+#define OV4689_REG_TIMING_TC_REG21      0x3821
+
+#define OV4689_REG_AWB_R_GAIN           0x500C
+#define OV4689_REG_AWB_B_GAIN           0x5010
+#define OV4689_REG_STREAM_ON            0x0100
+
+enum ov4689_mode_id {
+	//OV4689_MODE_720P_1280_720 = 0,
+	OV4689_MODE_1080P_1920_1080 = 0,
+	//OV4689_MODE_4M_2688_1520,
+	OV4689_NUM_MODES,
+};
+
+enum ov4689_frame_rate {
+	OV4689_15_FPS = 0,
+	OV4689_30_FPS,
+	OV4689_45_FPS,
+	OV4689_60_FPS,
+	OV4689_90_FPS,
+	OV4689_120_FPS,
+	OV4689_150_FPS,
+	OV4689_180_FPS,
+	OV4689_330_FPS,
+	OV4689_NUM_FRAMERATES,
+};
+
+enum ov4689_format_mux {
+	OV4689_FMT_MUX_RAW,
+};
+
+static const int ov4689_framerates[] = {
+	[OV4689_15_FPS] = 15,
+	[OV4689_30_FPS] = 30,
+	[OV4689_45_FPS] = 45,
+	[OV4689_60_FPS] = 60,
+	[OV4689_90_FPS] = 90,
+	[OV4689_120_FPS] = 120,
+	[OV4689_150_FPS] = 150,
+	[OV4689_180_FPS] = 180,
+	[OV4689_330_FPS] = 330,
+};
+
+/* regulator supplies */
+static const char * const ov4689_supply_name[] = {
+	"DOVDD", /* Digital I/O (1.8V) supply */
+	"AVDD",  /* Analog (2.8V) supply */
+	"DVDD",  /* Digital Core (1.5V) supply */
+};
+
+#define OV4689_NUM_SUPPLIES ARRAY_SIZE(ov4689_supply_name)
+
+/*
+ * Image size under 1280 * 960 are SUBSAMPLING
+ * Image size upper 1280 * 960 are SCALING
+ */
+enum ov4689_downsize_mode {
+	SUBSAMPLING,
+	SCALING,
+};
+
+struct reg_value {
+	u16 reg_addr;
+	u8 val;
+	u8 mask;
+	u32 delay_ms;
+};
+
+struct ov4689_mode_info {
+	enum ov4689_mode_id id;
+	enum ov4689_downsize_mode dn_mode;
+	u32 hact;
+	u32 htot;
+	u32 vact;
+	u32 vtot;
+	const struct reg_value *reg_data;
+	u32 reg_data_size;
+	u32 max_fps;
+};
+
+struct ov4689_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct {
+		struct v4l2_ctrl *exposure;
+	};
+	struct {
+		struct v4l2_ctrl *auto_wb;
+		struct v4l2_ctrl *blue_balance;
+		struct v4l2_ctrl *red_balance;
+	};
+	struct {
+		struct v4l2_ctrl *anal_gain;
+	};
+	struct v4l2_ctrl *brightness;
+	struct v4l2_ctrl *light_freq;
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *saturation;
+	struct v4l2_ctrl *contrast;
+	struct v4l2_ctrl *hue;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+};
+
+struct ov4689_dev {
+	struct i2c_client *i2c_client;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_fwnode_endpoint ep; /* the parsed DT endpoint info */
+	struct clk *xclk; /* system clock to OV4689 */
+	u32 xclk_freq;
+
+	struct regulator_bulk_data supplies[OV4689_NUM_SUPPLIES];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *pwdn_gpio;
+	bool   upside_down;
+
+	/* lock to protect all members below */
+	struct mutex lock;
+
+	struct v4l2_mbus_framefmt fmt;
+
+	const struct ov4689_mode_info *current_mode;
+	const struct ov4689_mode_info *last_mode;
+	enum ov4689_frame_rate current_fr;
+	struct v4l2_fract frame_interval;
+
+	struct ov4689_ctrls ctrls;
+
+	bool pending_mode_change;
+	int streaming;
+};
+
+static inline struct ov4689_dev *to_ov4689_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ov4689_dev, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov4689_dev,
+			ctrls.handler)->sd;
+}
+
+/* ov4689 initial register */
+static const struct reg_value ov4689_init_setting_30fps_1080P[] = {
+/* ov4689_1080p_30fps_4d */
+	{0x0103, 0x01, 0, 0},
+	{0x3638, 0x00, 0, 0},
+	{0x0300, 0x02, 0, 0},
+	{0x0302, 0x32, 0, 0},
+	{0x0303, 0x00, 0, 0},
+	{0x0304, 0x03, 0, 0},
+	{0x030b, 0x00, 0, 0},
+	{0x030d, 0x1e, 0, 0},
+	{0x030e, 0x04, 0, 0},
+	{0x030f, 0x01, 0, 0},
+	{0x0312, 0x01, 0, 0},
+	{0x031e, 0x00, 0, 0},
+	{0x3000, 0x20, 0, 0},
+	{0x3002, 0x00, 0, 0},
+	{0x3018, 0x72, 0, 0},
+	{0x3020, 0x93, 0, 0},
+	{0x3021, 0x03, 0, 0},
+	{0x3022, 0x01, 0, 0},
+	{0x3031, 0x0a, 0, 0},
+	{0x3305, 0xf1, 0, 0},
+	{0x3307, 0x04, 0, 0},
+	{0x3309, 0x29, 0, 0},
+	{0x3500, 0x00, 0, 0},
+	{0x3501, 0x4c, 0, 0},
+	{0x3502, 0x00, 0, 0},
+	{0x3503, 0x04, 0, 0},
+	{0x3504, 0x00, 0, 0},
+	{0x3505, 0x00, 0, 0},
+	{0x3506, 0x00, 0, 0},
+	{0x3507, 0x00, 0, 0},
+	{0x3508, 0x00, 0, 0},
+	{0x3509, 0x80, 0, 0},
+	{0x350a, 0x00, 0, 0},
+	{0x350b, 0x00, 0, 0},
+	{0x350c, 0x00, 0, 0},
+	{0x350d, 0x00, 0, 0},
+	{0x350e, 0x00, 0, 0},
+	{0x350f, 0x80, 0, 0},
+	{0x3510, 0x00, 0, 0},
+	{0x3511, 0x00, 0, 0},
+	{0x3512, 0x00, 0, 0},
+	{0x3513, 0x00, 0, 0},
+	{0x3514, 0x00, 0, 0},
+	{0x3515, 0x80, 0, 0},
+	{0x3516, 0x00, 0, 0},
+	{0x3517, 0x00, 0, 0},
+	{0x3518, 0x00, 0, 0},
+	{0x3519, 0x00, 0, 0},
+	{0x351a, 0x00, 0, 0},
+	{0x351b, 0x80, 0, 0},
+	{0x351c, 0x00, 0, 0},
+	{0x351d, 0x00, 0, 0},
+	{0x351e, 0x00, 0, 0},
+	{0x351f, 0x00, 0, 0},
+	{0x3520, 0x00, 0, 0},
+	{0x3521, 0x80, 0, 0},
+	{0x3522, 0x08, 0, 0},
+	{0x3524, 0x08, 0, 0},
+	{0x3526, 0x08, 0, 0},
+	{0x3528, 0x08, 0, 0},
+	{0x352a, 0x08, 0, 0},
+	{0x3602, 0x00, 0, 0},
+	{0x3603, 0x40, 0, 0},
+	{0x3604, 0x02, 0, 0},
+	{0x3605, 0x00, 0, 0},
+	{0x3606, 0x00, 0, 0},
+	{0x3607, 0x00, 0, 0},
+	{0x3609, 0x12, 0, 0},
+	{0x360a, 0x40, 0, 0},
+	{0x360c, 0x08, 0, 0},
+	{0x360f, 0xe5, 0, 0},
+	{0x3608, 0x8f, 0, 0},
+	{0x3611, 0x00, 0, 0},
+	{0x3613, 0xf7, 0, 0},
+	{0x3616, 0x58, 0, 0},
+	{0x3619, 0x99, 0, 0},
+	{0x361b, 0x60, 0, 0},
+	{0x361c, 0x7a, 0, 0},
+	{0x361e, 0x79, 0, 0},
+	{0x361f, 0x02, 0, 0},
+	{0x3632, 0x00, 0, 0},
+	{0x3633, 0x10, 0, 0},
+	{0x3634, 0x10, 0, 0},
+	{0x3635, 0x10, 0, 0},
+	{0x3636, 0x15, 0, 0},
+	{0x3646, 0x86, 0, 0},
+	{0x364a, 0x0b, 0, 0},
+	{0x3700, 0x17, 0, 0},
+	{0x3701, 0x22, 0, 0},
+	{0x3703, 0x10, 0, 0},
+	{0x370a, 0x37, 0, 0},
+	{0x3705, 0x00, 0, 0},
+	{0x3706, 0x63, 0, 0},
+	{0x3709, 0x3c, 0, 0},
+	{0x370b, 0x01, 0, 0},
+	{0x370c, 0x30, 0, 0},
+	{0x3710, 0x24, 0, 0},
+	{0x3711, 0x0c, 0, 0},
+	{0x3716, 0x00, 0, 0},
+	{0x3720, 0x28, 0, 0},
+	{0x3729, 0x7b, 0, 0},
+	{0x372a, 0x84, 0, 0},
+	{0x372b, 0xbd, 0, 0},
+	{0x372c, 0xbc, 0, 0},
+	{0x372e, 0x52, 0, 0},
+	{0x373c, 0x0e, 0, 0},
+	{0x373e, 0x33, 0, 0},
+	{0x3743, 0x10, 0, 0},
+	{0x3744, 0x88, 0, 0},
+	{0x3745, 0xc0, 0, 0},
+	{0x374a, 0x43, 0, 0},
+	{0x374c, 0x00, 0, 0},
+	{0x374e, 0x23, 0, 0},
+	{0x3751, 0x7b, 0, 0},
+	{0x3752, 0x84, 0, 0},
+	{0x3753, 0xbd, 0, 0},
+	{0x3754, 0xbc, 0, 0},
+	{0x3756, 0x52, 0, 0},
+	{0x375c, 0x00, 0, 0},
+	{0x3760, 0x00, 0, 0},
+	{0x3761, 0x00, 0, 0},
+	{0x3762, 0x00, 0, 0},
+	{0x3763, 0x00, 0, 0},
+	{0x3764, 0x00, 0, 0},
+	{0x3767, 0x04, 0, 0},
+	{0x3768, 0x04, 0, 0},
+	{0x3769, 0x08, 0, 0},
+	{0x376a, 0x08, 0, 0},
+	{0x376b, 0x20, 0, 0},
+	{0x376c, 0x00, 0, 0},
+	{0x376d, 0x00, 0, 0},
+	{0x376e, 0x00, 0, 0},
+	{0x3773, 0x00, 0, 0},
+	{0x3774, 0x51, 0, 0},
+	{0x3776, 0xbd, 0, 0},
+	{0x3777, 0xbd, 0, 0},
+	{0x3781, 0x18, 0, 0},
+	{0x3783, 0x25, 0, 0},
+	{0x3798, 0x1b, 0, 0},
+	{0x3800, 0x01, 0, 0},
+	{0x3801, 0x88, 0, 0},
+	{0x3802, 0x00, 0, 0},
+	{0x3803, 0xe0, 0, 0},
+	{0x3804, 0x09, 0, 0},
+	{0x3805, 0x17, 0, 0},
+	{0x3806, 0x05, 0, 0},
+	{0x3807, 0x1f, 0, 0},
+	{0x3808, 0x07, 0, 0},
+	{0x3809, 0x80, 0, 0},
+	{0x380a, 0x04, 0, 0},
+	{0x380b, 0x38, 0, 0},
+	{0x380c, 0x0d, 0, 0},
+	{0x380d, 0x70, 0, 0},
+	{0x380e, 0x04, 0, 0},
+	{0x380f, 0x8A, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x08, 0, 0},
+	{0x3812, 0x00, 0, 0},
+	{0x3813, 0x04, 0, 0},
+	{0x3814, 0x01, 0, 0},
+	{0x3815, 0x01, 0, 0},
+	{0x3819, 0x01, 0, 0},
+	{0x3820, 0x06, 0, 0},
+	{0x3821, 0x00, 0, 0},
+	{0x3829, 0x00, 0, 0},
+	{0x382a, 0x01, 0, 0},
+	{0x382b, 0x01, 0, 0},
+	{0x382d, 0x7f, 0, 0},
+	{0x3830, 0x04, 0, 0},
+	{0x3836, 0x01, 0, 0},
+	{0x3837, 0x00, 0, 0},
+	{0x3841, 0x02, 0, 0},
+	{0x3846, 0x08, 0, 0},
+	{0x3847, 0x07, 0, 0},
+	{0x3d85, 0x36, 0, 0},
+	{0x3d8c, 0x71, 0, 0},
+	{0x3d8d, 0xcb, 0, 0},
+	{0x3f0a, 0x00, 0, 0},
+	{0x4000, 0xf1, 0, 0},
+	{0x4001, 0x40, 0, 0},
+	{0x4002, 0x04, 0, 0},
+	{0x4003, 0x14, 0, 0},
+	{0x400e, 0x00, 0, 0},
+	{0x4011, 0x00, 0, 0},
+	{0x401a, 0x00, 0, 0},
+	{0x401b, 0x00, 0, 0},
+	{0x401c, 0x00, 0, 0},
+	{0x401d, 0x00, 0, 0},
+	{0x401f, 0x00, 0, 0},
+	{0x4020, 0x00, 0, 0},
+	{0x4021, 0x10, 0, 0},
+	{0x4022, 0x06, 0, 0},
+	{0x4023, 0x13, 0, 0},
+	{0x4024, 0x07, 0, 0},
+	{0x4025, 0x40, 0, 0},
+	{0x4026, 0x07, 0, 0},
+	{0x4027, 0x50, 0, 0},
+	{0x4028, 0x00, 0, 0},
+	{0x4029, 0x02, 0, 0},
+	{0x402a, 0x06, 0, 0},
+	{0x402b, 0x04, 0, 0},
+	{0x402c, 0x02, 0, 0},
+	{0x402d, 0x02, 0, 0},
+	{0x402e, 0x0e, 0, 0},
+	{0x402f, 0x04, 0, 0},
+	{0x4302, 0xff, 0, 0},
+	{0x4303, 0xff, 0, 0},
+	{0x4304, 0x00, 0, 0},
+	{0x4305, 0x00, 0, 0},
+	{0x4306, 0x00, 0, 0},
+	{0x4308, 0x02, 0, 0},
+	{0x4500, 0x6c, 0, 0},
+	{0x4501, 0xc4, 0, 0},
+	{0x4502, 0x40, 0, 0},
+	{0x4503, 0x01, 0, 0},
+	{0x4601, 0x77, 0, 0},
+	{0x4800, 0x04, 0, 0},
+	{0x4813, 0x08, 0, 0},
+	{0x481f, 0x40, 0, 0},
+	{0x4829, 0x78, 0, 0},
+	{0x4837, 0x10, 0, 0},
+	{0x4b00, 0x2a, 0, 0},
+	{0x4b0d, 0x00, 0, 0},
+	{0x4d00, 0x04, 0, 0},
+	{0x4d01, 0x42, 0, 0},
+	{0x4d02, 0xd1, 0, 0},
+	{0x4d03, 0x93, 0, 0},
+	{0x4d04, 0xf5, 0, 0},
+	{0x4d05, 0xc1, 0, 0},
+	{0x5000, 0xf3, 0, 0},
+	{0x5001, 0x11, 0, 0},
+	{0x5004, 0x00, 0, 0},
+	{0x500a, 0x00, 0, 0},
+	{0x500b, 0x00, 0, 0},
+	{0x5032, 0x00, 0, 0},
+	{0x5040, 0x00, 0, 0},
+	{0x5050, 0x0c, 0, 0},
+	{0x5500, 0x00, 0, 0},
+	{0x5501, 0x10, 0, 0},
+	{0x5502, 0x01, 0, 0},
+	{0x5503, 0x0f, 0, 0},
+	{0x8000, 0x00, 0, 0},
+	{0x8001, 0x00, 0, 0},
+	{0x8002, 0x00, 0, 0},
+	{0x8003, 0x00, 0, 0},
+	{0x8004, 0x00, 0, 0},
+	{0x8005, 0x00, 0, 0},
+	{0x8006, 0x00, 0, 0},
+	{0x8007, 0x00, 0, 0},
+	{0x8008, 0x00, 0, 0},
+	{0x3638, 0x00, 0, 0},
+};
+
+static const struct reg_value ov4689_setting_VGA_640_480[] = {
+	//@@ RES_640x480_2x_Bin_330fps_816Mbps
+	//OV4689_AM01B_640x480_24M_2lane_816Mbps_330fps_20140210.txt
+	{0x0103, 0x01, 0, 0},
+	{0x3638, 0x00, 0, 0},
+	{0x0300, 0x00, 0, 0}, // 00
+	{0x0302, 0x22, 0, 0}, // 816Mbps 5a ; 64 ; 5a ; 78  ; 78 ; 2a
+	{0x0303, 0x00, 0, 0}, // 03 ; 01 ; 02 ;
+	{0x0304, 0x03, 0, 0},
+	{0x030b, 0x00, 0, 0},
+	{0x030d, 0x1e, 0, 0},
+	{0x030e, 0x04, 0, 0},
+	{0x030f, 0x01, 0, 0},
+	{0x0312, 0x01, 0, 0},
+	{0x031e, 0x00, 0, 0},
+	{0x3000, 0x20, 0, 0},
+	{0x3002, 0x00, 0, 0},
+	{0x3018, 0x32, 0, 0}, // 32/72 2lane/4lane
+	{0x3019, 0x0c, 0, 0}, // 0c/00 2lane/4lane
+	{0x3020, 0x93, 0, 0},
+	{0x3021, 0x03, 0, 0},
+	{0x3022, 0x01, 0, 0},
+	{0x3031, 0x0a, 0, 0},
+	{0x303f, 0x0c, 0, 0},
+	{0x3305, 0xf1, 0, 0},
+	{0x3307, 0x04, 0, 0},
+	{0x3309, 0x29, 0, 0},
+	{0x3500, 0x00, 0, 0},
+	{0x3501, 0x4c, 0, 0},
+	{0x3502, 0x00, 0, 0},
+	{0x3503, 0x04, 0, 0},
+	{0x3504, 0x00, 0, 0},
+	{0x3505, 0x00, 0, 0},
+	{0x3506, 0x00, 0, 0},
+	{0x3507, 0x00, 0, 0},
+	{0x3508, 0x00, 0, 0},
+	{0x3509, 0x80, 0, 0}, // 8X
+	{0x350a, 0x00, 0, 0},
+	{0x350b, 0x00, 0, 0},
+	{0x350c, 0x00, 0, 0},
+	{0x350d, 0x00, 0, 0},
+	{0x350e, 0x00, 0, 0},
+	{0x350f, 0x80, 0, 0},
+	{0x3510, 0x00, 0, 0},
+	{0x3511, 0x00, 0, 0},
+	{0x3512, 0x00, 0, 0},
+	{0x3513, 0x00, 0, 0},
+	{0x3514, 0x00, 0, 0},
+	{0x3515, 0x80, 0, 0},
+	{0x3516, 0x00, 0, 0},
+	{0x3517, 0x00, 0, 0},
+	{0x3518, 0x00, 0, 0},
+	{0x3519, 0x00, 0, 0},
+	{0x351a, 0x00, 0, 0},
+	{0x351b, 0x80, 0, 0},
+	{0x351c, 0x00, 0, 0},
+	{0x351d, 0x00, 0, 0},
+	{0x351e, 0x00, 0, 0},
+	{0x351f, 0x00, 0, 0},
+	{0x3520, 0x00, 0, 0},
+	{0x3521, 0x80, 0, 0},
+	{0x3522, 0x08, 0, 0},
+	{0x3524, 0x08, 0, 0},
+	{0x3526, 0x08, 0, 0},
+	{0x3528, 0x08, 0, 0},
+	{0x352a, 0x08, 0, 0},
+	{0x3602, 0x00, 0, 0},
+	{0x3603, 0x40, 0, 0},
+	{0x3604, 0x02, 0, 0},
+	{0x3605, 0x00, 0, 0},
+	{0x3606, 0x00, 0, 0},
+	{0x3607, 0x00, 0, 0},
+	{0x3609, 0x12, 0, 0},
+	{0x360a, 0x40, 0, 0},
+	{0x360c, 0x08, 0, 0},
+	{0x360f, 0xe5, 0, 0},
+	{0x3608, 0x8f, 0, 0},
+	{0x3611, 0x00, 0, 0},
+	{0x3613, 0xf7, 0, 0},
+	{0x3616, 0x58, 0, 0},
+	{0x3619, 0x99, 0, 0},
+	{0x361b, 0x60, 0, 0},
+	{0x361c, 0x7a, 0, 0},
+	{0x361e, 0x79, 0, 0},
+	{0x361f, 0x02, 0, 0},
+	{0x3632, 0x05, 0, 0},
+	{0x3633, 0x10, 0, 0},
+	{0x3634, 0x10, 0, 0},
+	{0x3635, 0x10, 0, 0},
+	{0x3636, 0x15, 0, 0},
+	{0x3646, 0x86, 0, 0},
+	{0x364a, 0x0b, 0, 0},
+	{0x3700, 0x17, 0, 0},
+	{0x3701, 0x22, 0, 0},
+	{0x3703, 0x10, 0, 0},
+	{0x370a, 0x37, 0, 0},
+	{0x3705, 0x00, 0, 0},
+	{0x3706, 0x63, 0, 0},
+	{0x3709, 0x3c, 0, 0},
+	{0x370b, 0x01, 0, 0},
+	{0x370c, 0x30, 0, 0},
+	{0x3710, 0x24, 0, 0},
+	{0x3711, 0x0c, 0, 0},
+	{0x3716, 0x00, 0, 0},
+	{0x3720, 0x28, 0, 0},
+	{0x3729, 0x7b, 0, 0},
+	{0x372a, 0x84, 0, 0},
+	{0x372b, 0xbd, 0, 0},
+	{0x372c, 0xbc, 0, 0},
+	{0x372e, 0x52, 0, 0},
+	{0x373c, 0x0e, 0, 0},
+	{0x373e, 0x33, 0, 0},
+	{0x3743, 0x10, 0, 0},
+	{0x3744, 0x88, 0, 0},
+	{0x3745, 0xc0, 0, 0},
+	{0x374a, 0x43, 0, 0},
+	{0x374c, 0x00, 0, 0},
+	{0x374e, 0x23, 0, 0},
+	{0x3751, 0x7b, 0, 0},
+	{0x3752, 0x84, 0, 0},
+	{0x3753, 0xbd, 0, 0},
+	{0x3754, 0xbc, 0, 0},
+	{0x3756, 0x52, 0, 0},
+	{0x375c, 0x00, 0, 0},
+	{0x3760, 0x00, 0, 0},
+	{0x3761, 0x00, 0, 0},
+	{0x3762, 0x00, 0, 0},
+	{0x3763, 0x00, 0, 0},
+	{0x3764, 0x00, 0, 0},
+	{0x3767, 0x04, 0, 0},
+	{0x3768, 0x04, 0, 0},
+	{0x3769, 0x08, 0, 0},
+	{0x376a, 0x08, 0, 0},
+	{0x376b, 0x40, 0, 0},
+	{0x376c, 0x00, 0, 0},
+	{0x376d, 0x00, 0, 0},
+	{0x376e, 0x00, 0, 0},
+	{0x3773, 0x00, 0, 0},
+	{0x3774, 0x51, 0, 0},
+	{0x3776, 0xbd, 0, 0},
+	{0x3777, 0xbd, 0, 0},
+	{0x3781, 0x18, 0, 0},
+	{0x3783, 0x25, 0, 0},
+	{0x3798, 0x1b, 0, 0},
+	{0x3800, 0x00, 0, 0},
+	{0x3801, 0x48, 0, 0},
+	{0x3802, 0x00, 0, 0},
+	{0x3803, 0x2C, 0, 0},
+	{0x3804, 0x0a, 0, 0},
+	{0x3805, 0x57, 0, 0},
+	{0x3806, 0x05, 0, 0},
+	{0x3807, 0xD3, 0, 0},
+	{0x3808, 0x02, 0, 0},
+	{0x3809, 0x80, 0, 0},
+	{0x380a, 0x01, 0, 0},
+	{0x380b, 0xe0, 0, 0},
+
+	{0x380c, 0x02, 0, 0}, // 0a ; 03
+	{0x380d, 0x04, 0, 0}, // 1c ; 5C
+
+	{0x380e, 0x03, 0, 0},
+	{0x380f, 0x05, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x04, 0, 0},
+	{0x3812, 0x00, 0, 0},
+	{0x3813, 0x02, 0, 0},
+	{0x3814, 0x03, 0, 0},
+	{0x3815, 0x01, 0, 0},
+	{0x3819, 0x01, 0, 0},
+	{0x3820, 0x06, 0, 0},
+	{0x3821, 0x00, 0, 0},
+	{0x3829, 0x00, 0, 0},
+	{0x382a, 0x03, 0, 0},
+	{0x382b, 0x01, 0, 0},
+	{0x382d, 0x7f, 0, 0},
+	{0x3830, 0x08, 0, 0},
+	{0x3836, 0x02, 0, 0},
+	{0x3837, 0x00, 0, 0},
+	{0x3841, 0x02, 0, 0},
+	{0x3846, 0x08, 0, 0},
+	{0x3847, 0x07, 0, 0},
+	{0x3d85, 0x36, 0, 0},
+	{0x3d8c, 0x71, 0, 0},
+	{0x3d8d, 0xcb, 0, 0},
+	{0x3f0a, 0x00, 0, 0},
+	{0x4000, 0x71, 0, 0},
+	{0x4001, 0x50, 0, 0},
+	{0x4002, 0x04, 0, 0},
+	{0x4003, 0x14, 0, 0},
+	{0x400e, 0x00, 0, 0},
+	{0x4011, 0x00, 0, 0},
+	{0x401a, 0x00, 0, 0},
+	{0x401b, 0x00, 0, 0},
+	{0x401c, 0x00, 0, 0},
+	{0x401d, 0x00, 0, 0},
+	{0x401f, 0x00, 0, 0},
+	{0x4020, 0x00, 0, 0},
+	{0x4021, 0x10, 0, 0},
+	{0x4022, 0x03, 0, 0},
+	{0x4023, 0x93, 0, 0},
+	{0x4024, 0x04, 0, 0},
+	{0x4025, 0xC0, 0, 0},
+	{0x4026, 0x04, 0, 0},
+	{0x4027, 0xD0, 0, 0},
+	{0x4028, 0x00, 0, 0},
+	{0x4029, 0x02, 0, 0},
+	{0x402a, 0x06, 0, 0},
+	{0x402b, 0x04, 0, 0},
+	{0x402c, 0x02, 0, 0},
+	{0x402d, 0x02, 0, 0},
+	{0x402e, 0x0e, 0, 0},
+	{0x402f, 0x04, 0, 0},
+	{0x4302, 0xff, 0, 0},
+	{0x4303, 0xff, 0, 0},
+	{0x4304, 0x00, 0, 0},
+	{0x4305, 0x00, 0, 0},
+	{0x4306, 0x00, 0, 0},
+	{0x4308, 0x02, 0, 0},
+	{0x4500, 0x6c, 0, 0},
+	{0x4501, 0xc4, 0, 0},
+	{0x4502, 0x44, 0, 0},
+	{0x4503, 0x01, 0, 0},
+	{0x4600, 0x00, 0, 0},
+	{0x4601, 0x4F, 0, 0},
+	{0x4800, 0x04, 0, 0},
+	{0x4813, 0x08, 0, 0},
+	{0x481f, 0x40, 0, 0},
+	{0x4829, 0x78, 0, 0},
+	{0x4837, 0x10, 0, 0}, // 20 ; 10
+	{0x4b00, 0x2a, 0, 0},
+	{0x4b0d, 0x00, 0, 0},
+	{0x4d00, 0x04, 0, 0},
+	{0x4d01, 0x42, 0, 0},
+	{0x4d02, 0xd1, 0, 0},
+	{0x4d03, 0x93, 0, 0},
+	{0x4d04, 0xf5, 0, 0},
+	{0x4d05, 0xc1, 0, 0},
+	{0x5000, 0xf3, 0, 0},
+	{0x5001, 0x11, 0, 0},
+	{0x5004, 0x00, 0, 0},
+	{0x500a, 0x00, 0, 0},
+	{0x500b, 0x00, 0, 0},
+	{0x5032, 0x00, 0, 0},
+	{0x5040, 0x00, 0, 0},
+	{0x5050, 0x3c, 0, 0},
+	{0x5500, 0x00, 0, 0},
+	{0x5501, 0x10, 0, 0},
+	{0x5502, 0x01, 0, 0},
+	{0x5503, 0x0f, 0, 0},
+	{0x8000, 0x00, 0, 0},
+	{0x8001, 0x00, 0, 0},
+	{0x8002, 0x00, 0, 0},
+	{0x8003, 0x00, 0, 0},
+	{0x8004, 0x00, 0, 0},
+	{0x8005, 0x00, 0, 0},
+	{0x8006, 0x00, 0, 0},
+	{0x8007, 0x00, 0, 0},
+	{0x8008, 0x00, 0, 0},
+	{0x3638, 0x00, 0, 0},
+};
+
+static const struct reg_value ov4689_setting_720P_1280_720[] = {
+	//@@ RES_1280x720_2x_Bin_150fps_816Mbps
+	//OV4689_AM01B_1280x720_24M_2lane_816Mbps_150fps_20140210.txt
+	{0x0103, 0x01, 0, 0},
+	{0x3638, 0x00, 0, 0},
+	{0x0300, 0x00, 0, 0}, // 00
+	{0x0302, 0x22, 0, 0}, // 816Mbps 5a ; 64 ; 5a ; 78  ; 78 ; 2a
+	{0x0303, 0x00, 0, 0}, // 03 ; 01 ; 02 ;
+	{0x0304, 0x03, 0, 0},
+	{0x030b, 0x00, 0, 0},
+	{0x030d, 0x1e, 0, 0},
+	{0x030e, 0x04, 0, 0},
+	{0x030f, 0x01, 0, 0},
+	{0x0312, 0x01, 0, 0},
+	{0x031e, 0x00, 0, 0},
+	{0x3000, 0x20, 0, 0},
+	{0x3002, 0x00, 0, 0},
+	{0x3018, 0x32, 0, 0}, // 32/72 2lane/4lane
+	{0x3019, 0x0c, 0, 0}, // 0c/00 2lane/4lane
+	{0x3020, 0x93, 0, 0},
+	{0x3021, 0x03, 0, 0},
+	{0x3022, 0x01, 0, 0},
+	{0x3031, 0x0a, 0, 0},
+	{0x303f, 0x0c, 0, 0},
+	{0x3305, 0xf1, 0, 0},
+	{0x3307, 0x04, 0, 0},
+	{0x3309, 0x29, 0, 0},
+	{0x3500, 0x00, 0, 0},
+	{0x3501, 0x30, 0, 0},
+	{0x3502, 0x00, 0, 0},
+	{0x3503, 0x04, 0, 0},
+	{0x3504, 0x00, 0, 0},
+	{0x3505, 0x00, 0, 0},
+	{0x3506, 0x00, 0, 0},
+	{0x3507, 0x00, 0, 0},
+	{0x3508, 0x07, 0, 0},
+	{0x3509, 0x78, 0, 0}, // 8X
+	{0x350a, 0x00, 0, 0},
+	{0x350b, 0x00, 0, 0},
+	{0x350c, 0x00, 0, 0},
+	{0x350d, 0x00, 0, 0},
+	{0x350e, 0x00, 0, 0},
+	{0x350f, 0x80, 0, 0},
+	{0x3510, 0x00, 0, 0},
+	{0x3511, 0x00, 0, 0},
+	{0x3512, 0x00, 0, 0},
+	{0x3513, 0x00, 0, 0},
+	{0x3514, 0x00, 0, 0},
+	{0x3515, 0x80, 0, 0},
+	{0x3516, 0x00, 0, 0},
+	{0x3517, 0x00, 0, 0},
+	{0x3518, 0x00, 0, 0},
+	{0x3519, 0x00, 0, 0},
+	{0x351a, 0x00, 0, 0},
+	{0x351b, 0x80, 0, 0},
+	{0x351c, 0x00, 0, 0},
+	{0x351d, 0x00, 0, 0},
+	{0x351e, 0x00, 0, 0},
+	{0x351f, 0x00, 0, 0},
+	{0x3520, 0x00, 0, 0},
+	{0x3521, 0x80, 0, 0},
+	{0x3522, 0x08, 0, 0},
+	{0x3524, 0x08, 0, 0},
+	{0x3526, 0x08, 0, 0},
+	{0x3528, 0x08, 0, 0},
+	{0x352a, 0x08, 0, 0},
+	{0x3602, 0x00, 0, 0},
+	{0x3603, 0x40, 0, 0},
+	{0x3604, 0x02, 0, 0},
+	{0x3605, 0x00, 0, 0},
+	{0x3606, 0x00, 0, 0},
+	{0x3607, 0x00, 0, 0},
+	{0x3609, 0x12, 0, 0},
+	{0x360a, 0x40, 0, 0},
+	{0x360c, 0x08, 0, 0},
+	{0x360f, 0xe5, 0, 0},
+	{0x3608, 0x8f, 0, 0},
+	{0x3611, 0x00, 0, 0},
+	{0x3613, 0xf7, 0, 0},
+	{0x3616, 0x58, 0, 0},
+	{0x3619, 0x99, 0, 0},
+	{0x361b, 0x60, 0, 0},
+	{0x361c, 0x7a, 0, 0},
+	{0x361e, 0x79, 0, 0},
+	{0x361f, 0x02, 0, 0},
+	{0x3632, 0x05, 0, 0},
+	{0x3633, 0x10, 0, 0},
+	{0x3634, 0x10, 0, 0},
+	{0x3635, 0x10, 0, 0},
+	{0x3636, 0x15, 0, 0},
+	{0x3646, 0x86, 0, 0},
+	{0x364a, 0x0b, 0, 0},
+	{0x3700, 0x17, 0, 0},
+	{0x3701, 0x22, 0, 0},
+	{0x3703, 0x10, 0, 0},
+	{0x370a, 0x37, 0, 0},
+	{0x3705, 0x00, 0, 0},
+	{0x3706, 0x63, 0, 0},
+	{0x3709, 0x3c, 0, 0},
+	{0x370b, 0x01, 0, 0},
+	{0x370c, 0x30, 0, 0},
+	{0x3710, 0x24, 0, 0},
+	{0x3711, 0x0c, 0, 0},
+	{0x3716, 0x00, 0, 0},
+	{0x3720, 0x28, 0, 0},
+	{0x3729, 0x7b, 0, 0},
+	{0x372a, 0x84, 0, 0},
+	{0x372b, 0xbd, 0, 0},
+	{0x372c, 0xbc, 0, 0},
+	{0x372e, 0x52, 0, 0},
+	{0x373c, 0x0e, 0, 0},
+	{0x373e, 0x33, 0, 0},
+	{0x3743, 0x10, 0, 0},
+	{0x3744, 0x88, 0, 0},
+	{0x3745, 0xc0, 0, 0},
+	{0x374a, 0x43, 0, 0},
+	{0x374c, 0x00, 0, 0},
+	{0x374e, 0x23, 0, 0},
+	{0x3751, 0x7b, 0, 0},
+	{0x3752, 0x84, 0, 0},
+	{0x3753, 0xbd, 0, 0},
+	{0x3754, 0xbc, 0, 0},
+	{0x3756, 0x52, 0, 0},
+	{0x375c, 0x00, 0, 0},
+	{0x3760, 0x00, 0, 0},
+	{0x3761, 0x00, 0, 0},
+	{0x3762, 0x00, 0, 0},
+	{0x3763, 0x00, 0, 0},
+	{0x3764, 0x00, 0, 0},
+	{0x3767, 0x04, 0, 0},
+	{0x3768, 0x04, 0, 0},
+	{0x3769, 0x08, 0, 0},
+	{0x376a, 0x08, 0, 0},
+	{0x376b, 0x40, 0, 0},
+	{0x376c, 0x00, 0, 0},
+	{0x376d, 0x00, 0, 0},
+	{0x376e, 0x00, 0, 0},
+	{0x3773, 0x00, 0, 0},
+	{0x3774, 0x51, 0, 0},
+	{0x3776, 0xbd, 0, 0},
+	{0x3777, 0xbd, 0, 0},
+	{0x3781, 0x18, 0, 0},
+	{0x3783, 0x25, 0, 0},
+	{0x3798, 0x1b, 0, 0},
+	{0x3800, 0x00, 0, 0},
+	{0x3801, 0x48, 0, 0},
+	{0x3802, 0x00, 0, 0},
+	{0x3803, 0x2C, 0, 0},
+	{0x3804, 0x0a, 0, 0},
+	{0x3805, 0x57, 0, 0},
+	{0x3806, 0x05, 0, 0},
+	{0x3807, 0xD3, 0, 0},
+	{0x3808, 0x05, 0, 0},
+	{0x3809, 0x00, 0, 0},
+	{0x380a, 0x02, 0, 0},
+	{0x380b, 0xD0, 0, 0},
+#ifndef UNUSED_CODE
+	{0x380c, 0x04, 0, 0}, // 0a ; 03
+	{0x380d, 0x08, 0, 0}, // 1c ; 5C
+#else
+	{0x380c, 0x05, 0, 0}, // 120fps
+	{0x380d, 0x0A, 0, 0},
+#endif
+	{0x380e, 0x03, 0, 0},
+	{0x380f, 0x05, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x04, 0, 0},
+	{0x3812, 0x00, 0, 0},
+	{0x3813, 0x02, 0, 0},
+	{0x3814, 0x03, 0, 0},
+	{0x3815, 0x01, 0, 0},
+	{0x3819, 0x01, 0, 0},
+	{0x3820, 0x06, 0, 0},
+	{0x3821, 0x00, 0, 0},
+	{0x3829, 0x00, 0, 0},
+	{0x382a, 0x03, 0, 0},
+	{0x382b, 0x01, 0, 0},
+	{0x382d, 0x7f, 0, 0},
+	{0x3830, 0x08, 0, 0},
+	{0x3836, 0x02, 0, 0},
+	{0x3837, 0x00, 0, 0},
+	{0x3841, 0x02, 0, 0},
+	{0x3846, 0x08, 0, 0},
+	{0x3847, 0x07, 0, 0},
+	{0x3d85, 0x36, 0, 0},
+	{0x3d8c, 0x71, 0, 0},
+	{0x3d8d, 0xcb, 0, 0},
+	{0x3f0a, 0x00, 0, 0},
+	{0x4000, 0x71, 0, 0},
+	{0x4001, 0x50, 0, 0},
+	{0x4002, 0x04, 0, 0},
+	{0x4003, 0x14, 0, 0},
+	{0x400e, 0x00, 0, 0},
+	{0x4011, 0x00, 0, 0},
+	{0x401a, 0x00, 0, 0},
+	{0x401b, 0x00, 0, 0},
+	{0x401c, 0x00, 0, 0},
+	{0x401d, 0x00, 0, 0},
+	{0x401f, 0x00, 0, 0},
+	{0x4020, 0x00, 0, 0},
+	{0x4021, 0x10, 0, 0},
+	{0x4022, 0x03, 0, 0},
+	{0x4023, 0x93, 0, 0},
+	{0x4024, 0x04, 0, 0},
+	{0x4025, 0xC0, 0, 0},
+	{0x4026, 0x04, 0, 0},
+	{0x4027, 0xD0, 0, 0},
+	{0x4028, 0x00, 0, 0},
+	{0x4029, 0x02, 0, 0},
+	{0x402a, 0x06, 0, 0},
+	{0x402b, 0x04, 0, 0},
+	{0x402c, 0x02, 0, 0},
+	{0x402d, 0x02, 0, 0},
+	{0x402e, 0x0e, 0, 0},
+	{0x402f, 0x04, 0, 0},
+	{0x4302, 0xff, 0, 0},
+	{0x4303, 0xff, 0, 0},
+	{0x4304, 0x00, 0, 0},
+	{0x4305, 0x00, 0, 0},
+	{0x4306, 0x00, 0, 0},
+	{0x4308, 0x02, 0, 0},
+	{0x4500, 0x6c, 0, 0},
+	{0x4501, 0xc4, 0, 0},
+	{0x4502, 0x44, 0, 0},
+	{0x4503, 0x01, 0, 0},
+	{0x4600, 0x00, 0, 0},
+	{0x4601, 0x4F, 0, 0},
+	{0x4800, 0x04, 0, 0},
+	{0x4813, 0x08, 0, 0},
+	{0x481f, 0x40, 0, 0},
+	{0x4829, 0x78, 0, 0},
+	{0x4837, 0x10, 0, 0}, // 20 ; 10
+	{0x4b00, 0x2a, 0, 0},
+	{0x4b0d, 0x00, 0, 0},
+	{0x4d00, 0x04, 0, 0},
+	{0x4d01, 0x42, 0, 0},
+	{0x4d02, 0xd1, 0, 0},
+	{0x4d03, 0x93, 0, 0},
+	{0x4d04, 0xf5, 0, 0},
+	{0x4d05, 0xc1, 0, 0},
+	{0x5000, 0xf3, 0, 0},
+	{0x5001, 0x11, 0, 0},
+	{0x5004, 0x00, 0, 0},
+	{0x500a, 0x00, 0, 0},
+	{0x500b, 0x00, 0, 0},
+	{0x5032, 0x00, 0, 0},
+	{0x5040, 0x00, 0, 0},
+	{0x5050, 0x3c, 0, 0},
+	{0x5500, 0x00, 0, 0},
+	{0x5501, 0x10, 0, 0},
+	{0x5502, 0x01, 0, 0},
+	{0x5503, 0x0f, 0, 0},
+	{0x8000, 0x00, 0, 0},
+	{0x8001, 0x00, 0, 0},
+	{0x8002, 0x00, 0, 0},
+	{0x8003, 0x00, 0, 0},
+	{0x8004, 0x00, 0, 0},
+	{0x8005, 0x00, 0, 0},
+	{0x8006, 0x00, 0, 0},
+	{0x8007, 0x00, 0, 0},
+	{0x8008, 0x00, 0, 0},
+	{0x3638, 0x00, 0, 0},
+};
+
+static const struct reg_value ov4689_setting_1080P_1920_1080[] = {
+	//@@ RES_1920x1080_60fps_816Mbps 2lanes
+	{0x0103, 0x01, 0, 0},
+	{0x3638, 0x00, 0, 0},
+	{0x0300, 0x00, 0, 0},  // clk
+	{0x0302, 0x22, 0, 0},
+	{0x0303, 0x00, 0, 0},
+	{0x0304, 0x03, 0, 0},
+	{0x030b, 0x00, 0, 0},
+	{0x030d, 0x1e, 0, 0},
+	{0x030e, 0x04, 0, 0},
+	{0x030f, 0x01, 0, 0},
+	{0x0312, 0x01, 0, 0},
+	{0x031e, 0x00, 0, 0},
+	{0x3000, 0x20, 0, 0},
+	{0x3002, 0x00, 0, 0},
+	{0x3018, 0x32, 0, 0},
+	{0x3019, 0x0c, 0, 0},
+	{0x3020, 0x93, 0, 0},
+	{0x3021, 0x03, 0, 0},
+	{0x3022, 0x01, 0, 0},
+	{0x3031, 0x0a, 0, 0},
+	{0x303f, 0x0c, 0, 0},
+	{0x3305, 0xf1, 0, 0},
+	{0x3307, 0x04, 0, 0},
+	{0x3309, 0x29, 0, 0},
+	{0x3500, 0x00, 0, 0},  // AEC
+	{0x3501, 0x4c, 0, 0},
+	{0x3502, 0x00, 0, 0},
+	{0x3503, 0x04, 0, 0},
+	{0x3504, 0x00, 0, 0},
+	{0x3505, 0x00, 0, 0},
+	{0x3506, 0x00, 0, 0},
+	{0x3507, 0x00, 0, 0},
+	{0x3508, 0x00, 0, 0},
+	{0x3509, 0x80, 0, 0},
+	{0x350a, 0x00, 0, 0},
+	{0x350b, 0x00, 0, 0},
+	{0x350c, 0x00, 0, 0},
+	{0x350d, 0x00, 0, 0},
+	{0x350e, 0x00, 0, 0},
+	{0x350f, 0x80, 0, 0},
+	{0x3510, 0x00, 0, 0},
+	{0x3511, 0x00, 0, 0},
+	{0x3512, 0x00, 0, 0},
+	{0x3513, 0x00, 0, 0},
+	{0x3514, 0x00, 0, 0},
+	{0x3515, 0x80, 0, 0},
+	{0x3516, 0x00, 0, 0},
+	{0x3517, 0x00, 0, 0},
+	{0x3518, 0x00, 0, 0},
+	{0x3519, 0x00, 0, 0},
+	{0x351a, 0x00, 0, 0},
+	{0x351b, 0x80, 0, 0},
+	{0x351c, 0x00, 0, 0},
+	{0x351d, 0x00, 0, 0},
+	{0x351e, 0x00, 0, 0},
+	{0x351f, 0x00, 0, 0},
+	{0x3520, 0x00, 0, 0},
+	{0x3521, 0x80, 0, 0},
+	{0x3522, 0x08, 0, 0},
+	{0x3524, 0x08, 0, 0},
+	{0x3526, 0x08, 0, 0},
+	{0x3528, 0x08, 0, 0},
+	{0x352a, 0x08, 0, 0},
+	{0x3602, 0x00, 0, 0},
+	{0x3603, 0x40, 0, 0},
+	{0x3604, 0x02, 0, 0},
+	{0x3605, 0x00, 0, 0},
+	{0x3606, 0x00, 0, 0},
+	{0x3607, 0x00, 0, 0},
+	{0x3609, 0x12, 0, 0},
+	{0x360a, 0x40, 0, 0},
+	{0x360c, 0x08, 0, 0},
+	{0x360f, 0xe5, 0, 0},
+	{0x3608, 0x8f, 0, 0},
+	{0x3611, 0x00, 0, 0},
+	{0x3613, 0xf7, 0, 0},
+	{0x3616, 0x58, 0, 0},
+	{0x3619, 0x99, 0, 0},
+	{0x361b, 0x60, 0, 0},
+	{0x361c, 0x7a, 0, 0},
+	{0x361e, 0x79, 0, 0},
+	{0x361f, 0x02, 0, 0},
+	{0x3632, 0x00, 0, 0},
+	{0x3633, 0x10, 0, 0},
+	{0x3634, 0x10, 0, 0},
+	{0x3635, 0x10, 0, 0},
+	{0x3636, 0x15, 0, 0},
+	{0x3646, 0x86, 0, 0},
+	{0x364a, 0x0b, 0, 0},
+	{0x3700, 0x17, 0, 0},
+	{0x3701, 0x22, 0, 0},
+	{0x3703, 0x10, 0, 0},
+	{0x370a, 0x37, 0, 0},
+	{0x3705, 0x00, 0, 0},
+	{0x3706, 0x63, 0, 0},
+	{0x3709, 0x3c, 0, 0},
+	{0x370b, 0x01, 0, 0},
+	{0x370c, 0x30, 0, 0},
+	{0x3710, 0x24, 0, 0},
+	{0x3711, 0x0c, 0, 0},
+	{0x3716, 0x00, 0, 0},
+	{0x3720, 0x28, 0, 0},
+	{0x3729, 0x7b, 0, 0},
+	{0x372a, 0x84, 0, 0},
+	{0x372b, 0xbd, 0, 0},
+	{0x372c, 0xbc, 0, 0},
+	{0x372e, 0x52, 0, 0},
+	{0x373c, 0x0e, 0, 0},
+	{0x373e, 0x33, 0, 0},
+	{0x3743, 0x10, 0, 0},
+	{0x3744, 0x88, 0, 0},
+	{0x3745, 0xc0, 0, 0},
+	{0x374a, 0x43, 0, 0},
+	{0x374c, 0x00, 0, 0},
+	{0x374e, 0x23, 0, 0},
+	{0x3751, 0x7b, 0, 0},
+	{0x3752, 0x84, 0, 0},
+	{0x3753, 0xbd, 0, 0},
+	{0x3754, 0xbc, 0, 0},
+	{0x3756, 0x52, 0, 0},
+	{0x375c, 0x00, 0, 0},
+	{0x3760, 0x00, 0, 0},
+	{0x3761, 0x00, 0, 0},
+	{0x3762, 0x00, 0, 0},
+	{0x3763, 0x00, 0, 0},
+	{0x3764, 0x00, 0, 0},
+	{0x3767, 0x04, 0, 0},
+	{0x3768, 0x04, 0, 0},
+	{0x3769, 0x08, 0, 0},
+	{0x376a, 0x08, 0, 0},
+	{0x376b, 0x20, 0, 0},
+	{0x376c, 0x00, 0, 0},
+	{0x376d, 0x00, 0, 0},
+	{0x376e, 0x00, 0, 0},
+	{0x3773, 0x00, 0, 0},
+	{0x3774, 0x51, 0, 0},
+	{0x3776, 0xbd, 0, 0},
+	{0x3777, 0xbd, 0, 0},
+	{0x3781, 0x18, 0, 0},
+	{0x3783, 0x25, 0, 0},
+	{0x3798, 0x1b, 0, 0},
+	{0x3800, 0x01, 0, 0},   // timings
+	{0x3801, 0x88, 0, 0},
+	{0x3802, 0x00, 0, 0},
+	{0x3803, 0xe0, 0, 0},
+	{0x3804, 0x09, 0, 0},
+	{0x3805, 0x17, 0, 0},
+	{0x3806, 0x05, 0, 0},
+	{0x3807, 0x1f, 0, 0},
+	{0x3808, 0x07, 0, 0},
+	{0x3809, 0x80, 0, 0},
+	{0x380a, 0x04, 0, 0},
+	{0x380b, 0x38, 0, 0},
+	{0x380c, 0x06, 0, 0},
+	{0x380d, 0xe0, 0, 0},
+	{0x380e, 0x04, 0, 0},
+	{0x380f, 0x70, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x08, 0, 0},
+	{0x3812, 0x00, 0, 0},
+	{0x3813, 0x04, 0, 0},
+	{0x3814, 0x01, 0, 0},
+	{0x3815, 0x01, 0, 0},
+	{0x3819, 0x01, 0, 0},
+	{0x3820, 0x06, 0, 0},
+	{0x3821, 0x00, 0, 0},
+	{0x3829, 0x00, 0, 0},
+	{0x382a, 0x01, 0, 0},
+	{0x382b, 0x01, 0, 0},
+	{0x382d, 0x7f, 0, 0},
+	{0x3830, 0x04, 0, 0},
+	{0x3836, 0x01, 0, 0},
+	{0x3837, 0x00, 0, 0},
+	{0x3841, 0x02, 0, 0},
+	{0x3846, 0x08, 0, 0},
+	{0x3847, 0x07, 0, 0},
+	{0x3d85, 0x36, 0, 0},
+	{0x3d8c, 0x71, 0, 0},
+	{0x3d8d, 0xcb, 0, 0},
+	{0x3f0a, 0x00, 0, 0},
+	{0x4000, 0xf1, 0, 0},
+	{0x4001, 0x40, 0, 0},
+	{0x4002, 0x04, 0, 0},
+	{0x4003, 0x14, 0, 0},
+	{0x400e, 0x00, 0, 0},
+	{0x4011, 0x00, 0, 0},
+	{0x401a, 0x00, 0, 0},
+	{0x401b, 0x00, 0, 0},
+	{0x401c, 0x00, 0, 0},
+	{0x401d, 0x00, 0, 0},
+	{0x401f, 0x00, 0, 0},
+	{0x4020, 0x00, 0, 0},
+	{0x4021, 0x10, 0, 0},
+	{0x4022, 0x06, 0, 0},
+	{0x4023, 0x13, 0, 0},
+	{0x4024, 0x07, 0, 0},
+	{0x4025, 0x40, 0, 0},
+	{0x4026, 0x07, 0, 0},
+	{0x4027, 0x50, 0, 0},
+	{0x4028, 0x00, 0, 0},
+	{0x4029, 0x02, 0, 0},
+	{0x402a, 0x06, 0, 0},
+	{0x402b, 0x04, 0, 0},
+	{0x402c, 0x02, 0, 0},
+	{0x402d, 0x02, 0, 0},
+	{0x402e, 0x0e, 0, 0},
+	{0x402f, 0x04, 0, 0},
+	{0x4302, 0xff, 0, 0},
+	{0x4303, 0xff, 0, 0},
+	{0x4304, 0x00, 0, 0},
+	{0x4305, 0x00, 0, 0},
+	{0x4306, 0x00, 0, 0},
+	{0x4308, 0x02, 0, 0},
+	{0x4500, 0x6c, 0, 0},
+	{0x4501, 0xc4, 0, 0},
+	{0x4502, 0x40, 0, 0},
+	{0x4503, 0x01, 0, 0},
+	{0x4601, 0x77, 0, 0},
+	{0x4800, 0x04, 0, 0},
+	{0x4813, 0x08, 0, 0},
+	{0x481f, 0x40, 0, 0},
+	{0x4829, 0x78, 0, 0},
+	{0x4837, 0x10, 0, 0},
+	{0x4b00, 0x2a, 0, 0},
+	{0x4b0d, 0x00, 0, 0},
+	{0x4d00, 0x04, 0, 0},
+	{0x4d01, 0x42, 0, 0},
+	{0x4d02, 0xd1, 0, 0},
+	{0x4d03, 0x93, 0, 0},
+	{0x4d04, 0xf5, 0, 0},
+	{0x4d05, 0xc1, 0, 0},
+	{0x5000, 0xf3, 0, 0},
+	{0x5001, 0x11, 0, 0},
+	{0x5004, 0x00, 0, 0},
+	{0x500a, 0x00, 0, 0},
+	{0x500b, 0x00, 0, 0},
+	{0x5032, 0x00, 0, 0},
+	{0x5040, 0x00, 0, 0},
+	{0x5050, 0x0c, 0, 0},
+	{0x5500, 0x00, 0, 0},
+	{0x5501, 0x10, 0, 0},
+	{0x5502, 0x01, 0, 0},
+	{0x5503, 0x0f, 0, 0},
+	{0x8000, 0x00, 0, 0},
+	{0x8001, 0x00, 0, 0},
+	{0x8002, 0x00, 0, 0},
+	{0x8003, 0x00, 0, 0},
+	{0x8004, 0x00, 0, 0},
+	{0x8005, 0x00, 0, 0},
+	{0x8006, 0x00, 0, 0},
+	{0x8007, 0x00, 0, 0},
+	{0x8008, 0x00, 0, 0},
+	{0x3638, 0x00, 0, 0},
+};
+
+static const struct reg_value ov4689_setting_4M_2688_1520[] = {
+	//@@ 0 10 RES_2688x1520_default(60fps)
+	//102 2630 960
+	{0x0103, 0x01, 0, 0},
+	{0x3638, 0x00, 0, 0},
+	{0x0300, 0x00, 0, 0},
+	{0x0302, 0x22, 0, 0}, // 2a ;1008Mbps,23 ;; 840Mbps
+	{0x0304, 0x03, 0, 0},
+	{0x030b, 0x00, 0, 0},
+	{0x030d, 0x1e, 0, 0},
+	{0x030e, 0x04, 0, 0},
+	{0x030f, 0x01, 0, 0},
+	{0x0312, 0x01, 0, 0},
+	{0x031e, 0x00, 0, 0},
+	{0x3000, 0x20, 0, 0},
+	{0x3002, 0x00, 0, 0},
+	{0x3018, 0x32, 0, 0},
+	{0x3019, 0x0C, 0, 0},
+	{0x3020, 0x93, 0, 0},
+	{0x3021, 0x03, 0, 0},
+	{0x3022, 0x01, 0, 0},
+	{0x3031, 0x0a, 0, 0},
+	{0x303f, 0x0c, 0, 0},
+	{0x3305, 0xf1, 0, 0},
+	{0x3307, 0x04, 0, 0},
+	{0x3309, 0x29, 0, 0},
+	{0x3500, 0x00, 0, 0},
+	{0x3501, 0x60, 0, 0},
+	{0x3502, 0x00, 0, 0},
+	{0x3503, 0x04, 0, 0},
+	{0x3504, 0x00, 0, 0},
+	{0x3505, 0x00, 0, 0},
+	{0x3506, 0x00, 0, 0},
+	{0x3507, 0x00, 0, 0},
+	{0x3508, 0x00, 0, 0},
+	{0x3509, 0x80, 0, 0},
+	{0x350a, 0x00, 0, 0},
+	{0x350b, 0x00, 0, 0},
+	{0x350c, 0x00, 0, 0},
+	{0x350d, 0x00, 0, 0},
+	{0x350e, 0x00, 0, 0},
+	{0x350f, 0x80, 0, 0},
+	{0x3510, 0x00, 0, 0},
+	{0x3511, 0x00, 0, 0},
+	{0x3512, 0x00, 0, 0},
+	{0x3513, 0x00, 0, 0},
+	{0x3514, 0x00, 0, 0},
+	{0x3515, 0x80, 0, 0},
+	{0x3516, 0x00, 0, 0},
+	{0x3517, 0x00, 0, 0},
+	{0x3518, 0x00, 0, 0},
+	{0x3519, 0x00, 0, 0},
+	{0x351a, 0x00, 0, 0},
+	{0x351b, 0x80, 0, 0},
+	{0x351c, 0x00, 0, 0},
+	{0x351d, 0x00, 0, 0},
+	{0x351e, 0x00, 0, 0},
+	{0x351f, 0x00, 0, 0},
+	{0x3520, 0x00, 0, 0},
+	{0x3521, 0x80, 0, 0},
+	{0x3522, 0x08, 0, 0},
+	{0x3524, 0x08, 0, 0},
+	{0x3526, 0x08, 0, 0},
+	{0x3528, 0x08, 0, 0},
+	{0x352a, 0x08, 0, 0},
+	{0x3602, 0x00, 0, 0},
+	{0x3603, 0x40, 0, 0},
+	{0x3604, 0x02, 0, 0},
+	{0x3605, 0x00, 0, 0},
+	{0x3606, 0x00, 0, 0},
+	{0x3607, 0x00, 0, 0},
+	{0x3609, 0x12, 0, 0},
+	{0x360a, 0x40, 0, 0},
+	{0x360c, 0x08, 0, 0},
+	{0x360f, 0xe5, 0, 0},
+	{0x3608, 0x8f, 0, 0},
+	{0x3611, 0x00, 0, 0},
+	{0x3613, 0xf7, 0, 0},
+	{0x3616, 0x58, 0, 0},
+	{0x3619, 0x99, 0, 0},
+	{0x361b, 0x60, 0, 0},
+	{0x361c, 0x7a, 0, 0},
+	{0x361e, 0x79, 0, 0},
+	{0x361f, 0x02, 0, 0},
+	{0x3632, 0x00, 0, 0},
+	{0x3633, 0x10, 0, 0},
+	{0x3634, 0x10, 0, 0},
+	{0x3635, 0x10, 0, 0},
+	{0x3636, 0x15, 0, 0},
+	{0x3646, 0x86, 0, 0},
+	{0x364a, 0x0b, 0, 0},
+	{0x3700, 0x17, 0, 0},
+	{0x3701, 0x22, 0, 0},
+	{0x3703, 0x10, 0, 0},
+	{0x370a, 0x37, 0, 0},
+	{0x3705, 0x00, 0, 0},
+	{0x3706, 0x63, 0, 0},
+	{0x3709, 0x3c, 0, 0},
+	{0x370b, 0x01, 0, 0},
+	{0x370c, 0x30, 0, 0},
+	{0x3710, 0x24, 0, 0},
+	{0x3711, 0x0c, 0, 0},
+	{0x3716, 0x00, 0, 0},
+	{0x3720, 0x28, 0, 0},
+	{0x3729, 0x7b, 0, 0},
+	{0x372a, 0x84, 0, 0},
+	{0x372b, 0xbd, 0, 0},
+	{0x372c, 0xbc, 0, 0},
+	{0x372e, 0x52, 0, 0},
+	{0x373c, 0x0e, 0, 0},
+	{0x373e, 0x33, 0, 0},
+	{0x3743, 0x10, 0, 0},
+	{0x3744, 0x88, 0, 0},
+	{0x3745, 0xc0, 0, 0},
+	{0x374a, 0x43, 0, 0},
+	{0x374c, 0x00, 0, 0},
+	{0x374e, 0x23, 0, 0},
+	{0x3751, 0x7b, 0, 0},
+	{0x3752, 0x84, 0, 0},
+	{0x3753, 0xbd, 0, 0},
+	{0x3754, 0xbc, 0, 0},
+	{0x3756, 0x52, 0, 0},
+	{0x375c, 0x00, 0, 0},
+	{0x3760, 0x00, 0, 0},
+	{0x3761, 0x00, 0, 0},
+	{0x3762, 0x00, 0, 0},
+	{0x3763, 0x00, 0, 0},
+	{0x3764, 0x00, 0, 0},
+	{0x3767, 0x04, 0, 0},
+	{0x3768, 0x04, 0, 0},
+	{0x3769, 0x08, 0, 0},
+	{0x376a, 0x08, 0, 0},
+	{0x376b, 0x20, 0, 0},
+	{0x376c, 0x00, 0, 0},
+	{0x376d, 0x00, 0, 0},
+	{0x376e, 0x00, 0, 0},
+	{0x3773, 0x00, 0, 0},
+	{0x3774, 0x51, 0, 0},
+	{0x3776, 0xbd, 0, 0},
+	{0x3777, 0xbd, 0, 0},
+	{0x3781, 0x18, 0, 0},
+	{0x3783, 0x25, 0, 0},
+	{0x3798, 0x1b, 0, 0},
+	{0x3800, 0x00, 0, 0},
+	{0x3801, 0x08, 0, 0},
+	{0x3802, 0x00, 0, 0},
+	{0x3803, 0x04, 0, 0},
+	{0x3804, 0x0a, 0, 0},
+	{0x3805, 0x97, 0, 0},
+	{0x3806, 0x05, 0, 0},
+	{0x3807, 0xfb, 0, 0},
+	{0x3808, 0x0a, 0, 0},
+	{0x3809, 0x80, 0, 0},
+	{0x380a, 0x05, 0, 0},
+	{0x380b, 0xf0, 0, 0},
+	{0x380c, 0x03, 0, 0},
+	{0x380d, 0x5c, 0, 0},
+	{0x380e, 0x06, 0, 0},
+	{0x380f, 0x12, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x08, 0, 0},
+	{0x3812, 0x00, 0, 0},
+	{0x3813, 0x04, 0, 0},
+	{0x3814, 0x01, 0, 0},
+	{0x3815, 0x01, 0, 0},
+	{0x3819, 0x01, 0, 0},
+	{0x3820, 0x00, 0, 0},
+	{0x3821, 0x06, 0, 0},
+	{0x3829, 0x00, 0, 0},
+	{0x382a, 0x01, 0, 0},
+	{0x382b, 0x01, 0, 0},
+	{0x382d, 0x7f, 0, 0},
+	{0x3830, 0x04, 0, 0},
+	{0x3836, 0x01, 0, 0},
+	{0x3837, 0x00, 0, 0},
+	{0x3841, 0x02, 0, 0},
+	{0x3846, 0x08, 0, 0},
+	{0x3847, 0x07, 0, 0},
+	{0x3d85, 0x36, 0, 0},
+	{0x3d8c, 0x71, 0, 0},
+	{0x3d8d, 0xcb, 0, 0},
+	{0x3f0a, 0x00, 0, 0},
+	{0x4000, 0x71, 0, 0},
+	{0x4001, 0x40, 0, 0},
+	{0x4002, 0x04, 0, 0},
+	{0x4003, 0x14, 0, 0},
+	{0x400e, 0x00, 0, 0},
+	{0x4011, 0x00, 0, 0},
+	{0x401a, 0x00, 0, 0},
+	{0x401b, 0x00, 0, 0},
+	{0x401c, 0x00, 0, 0},
+	{0x401d, 0x00, 0, 0},
+	{0x401f, 0x00, 0, 0},
+	{0x4020, 0x00, 0, 0},
+	{0x4021, 0x10, 0, 0},
+	{0x4022, 0x07, 0, 0},
+	{0x4023, 0xcf, 0, 0},
+	{0x4024, 0x09, 0, 0},
+	{0x4025, 0x60, 0, 0},
+	{0x4026, 0x09, 0, 0},
+	{0x4027, 0x6f, 0, 0},
+	{0x4028, 0x00, 0, 0},
+	{0x4029, 0x02, 0, 0},
+	{0x402a, 0x06, 0, 0},
+	{0x402b, 0x04, 0, 0},
+	{0x402c, 0x02, 0, 0},
+	{0x402d, 0x02, 0, 0},
+	{0x402e, 0x0e, 0, 0},
+	{0x402f, 0x04, 0, 0},
+	{0x4302, 0xff, 0, 0},
+	{0x4303, 0xff, 0, 0},
+	{0x4304, 0x00, 0, 0},
+	{0x4305, 0x00, 0, 0},
+	{0x4306, 0x00, 0, 0},
+	{0x4308, 0x02, 0, 0},
+	{0x4500, 0x6c, 0, 0},
+	{0x4501, 0xc4, 0, 0},
+	{0x4502, 0x40, 0, 0},
+	{0x4503, 0x01, 0, 0},
+	{0x4601, 0x04, 0, 0},
+	{0x4800, 0x04, 0, 0},
+	{0x4813, 0x08, 0, 0},
+	{0x481f, 0x40, 0, 0},
+	{0x4829, 0x78, 0, 0},
+	{0x4837, 0x14, 0, 0}, // 10
+	{0x4b00, 0x2a, 0, 0},
+	{0x4b0d, 0x00, 0, 0},
+	{0x4d00, 0x04, 0, 0},
+	{0x4d01, 0x42, 0, 0},
+	{0x4d02, 0xd1, 0, 0},
+	{0x4d03, 0x93, 0, 0},
+	{0x4d04, 0xf5, 0, 0},
+	{0x4d05, 0xc1, 0, 0},
+	{0x5000, 0xf3, 0, 0},
+	{0x5001, 0x11, 0, 0},
+	{0x5004, 0x00, 0, 0},
+	{0x500a, 0x00, 0, 0},
+	{0x500b, 0x00, 0, 0},
+	{0x5032, 0x00, 0, 0},
+	{0x5040, 0x00, 0, 0},
+	{0x5050, 0x0c, 0, 0},
+	{0x5500, 0x00, 0, 0},
+	{0x5501, 0x10, 0, 0},
+	{0x5502, 0x01, 0, 0},
+	{0x5503, 0x0f, 0, 0},
+	{0x8000, 0x00, 0, 0},
+	{0x8001, 0x00, 0, 0},
+	{0x8002, 0x00, 0, 0},
+	{0x8003, 0x00, 0, 0},
+	{0x8004, 0x00, 0, 0},
+	{0x8005, 0x00, 0, 0},
+	{0x8006, 0x00, 0, 0},
+	{0x8007, 0x00, 0, 0},
+	{0x8008, 0x00, 0, 0},
+	{0x3638, 0x00, 0, 0},
+//	{0x0100, 0x01, 0, 0},
+
+//	{0x0100, 0x00, 0, 0},
+	{0x380c, 0x0A, 0, 0}, // 05
+	{0x380d, 0x0A, 0, 0}, // 10
+	{0x380e, 0x06, 0, 0},
+	{0x380f, 0x12, 0, 0},
+//	{0x0100, 0x01, 0, 0},
+	{0x3105, 0x31, 0, 0},
+	{0x301a, 0xf9, 0, 0},
+	{0x3508, 0x07, 0, 0},
+	{0x484b, 0x05, 0, 0},
+	{0x4805, 0x03, 0, 0},
+	{0x3601, 0x01, 0, 0},
+	{0x3745, 0xc0, 0, 0},
+	{0x3798, 0x1b, 0, 0},
+//	{0x0100, 0x01, 0, 0},
+	{0xffff, 0x0a, 0, 0},
+	{0x3105, 0x11, 0, 0},
+	{0x301a, 0xf1, 0, 0},
+	{0x4805, 0x00, 0, 0},
+	{0x301a, 0xf0, 0, 0},
+	{0x3208, 0x00, 0, 0},
+	{0x302a, 0x00, 0, 0},
+	{0x302a, 0x00, 0, 0},
+	{0x302a, 0x00, 0, 0},
+	{0x302a, 0x00, 0, 0},
+	{0x302a, 0x00, 0, 0},
+	{0x3601, 0x00, 0, 0},
+	{0x3638, 0x00, 0, 0},
+	{0x3208, 0x10, 0, 0},
+	{0x3208, 0xa0, 0, 0},
+};
+
+/* power-on sensor init reg table */
+static const struct ov4689_mode_info ov4689_mode_init_data = {
+
+};
+
+static const struct ov4689_mode_info
+ov4689_mode_data[OV4689_NUM_MODES] = {
+	// {OV4689_MODE_720P_1280_720, SUBSAMPLING,
+	//  1280, 0x408, 720, 0x305,
+	//  ov4689_setting_720P_1280_720,
+	//  ARRAY_SIZE(ov4689_setting_720P_1280_720),
+	//  OV4689_150_FPS},
+	// {OV4689_MODE_1080P_1920_1080, SCALING,
+	//  1920, 0x6e0, 1080, 0x470,
+	//  ov4689_setting_1080P_1920_1080,
+	//  ARRAY_SIZE(ov4689_setting_1080P_1920_1080),
+	//  OV4689_60_FPS},
+	// {OV4689_MODE_4M_2688_1520, SCALING,
+	//  2688, 0xa0a, 1520, 0x612,
+	//  ov4689_setting_4M_2688_1520,
+	//  ARRAY_SIZE(ov4689_setting_4M_2688_1520),
+	//  OV4689_60_FPS},
+
+	{OV4689_MODE_1080P_1920_1080, SCALING,
+	 1920, 0x6e0, 1080, 0x470,
+	 ov4689_init_setting_30fps_1080P,
+	 ARRAY_SIZE(ov4689_init_setting_30fps_1080P),
+	 OV4689_60_FPS},
+};
+
+static int ov4689_write_reg(struct ov4689_dev *sensor, u16 reg, u8 val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg;
+	u8 buf[3];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	buf[2] = val;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.buf = buf;
+	msg.len = sizeof(buf);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x, val=%x\n",
+			__func__, reg, val);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ov4689_read_reg(struct ov4689_dev *sensor, u16 reg, u8 *val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = buf;
+	msg[0].len = sizeof(buf);
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = 1;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x\n",
+			__func__, reg);
+		return ret;
+	}
+
+	*val = buf[0];
+	return 0;
+}
+
+static int ov4689_read_reg16(struct ov4689_dev *sensor, u16 reg, u16 *val)
+{
+	u8 hi, lo;
+	int ret;
+
+	ret = ov4689_read_reg(sensor, reg, &hi);
+	if (ret)
+		return ret;
+	ret = ov4689_read_reg(sensor, reg + 1, &lo);
+	if (ret)
+		return ret;
+
+	*val = ((u16)hi << 8) | (u16)lo;
+	return 0;
+}
+
+static int ov4689_write_reg16(struct ov4689_dev *sensor, u16 reg, u16 val)
+{
+	int ret;
+
+	ret = ov4689_write_reg(sensor, reg, val >> 8);
+	if (ret)
+		return ret;
+
+	return ov4689_write_reg(sensor, reg + 1, val & 0xff);
+}
+
+static int ov4689_mod_reg(struct ov4689_dev *sensor, u16 reg,
+			u8 mask, u8 val)
+{
+	u8 readval;
+	int ret;
+
+	ret = ov4689_read_reg(sensor, reg, &readval);
+	if (ret)
+		return ret;
+
+	readval &= ~mask;
+	val &= mask;
+	val |= readval;
+
+	return ov4689_write_reg(sensor, reg, val);
+}
+
+static int ov4689_set_timings(struct ov4689_dev *sensor,
+			const struct ov4689_mode_info *mode)
+{
+	return 0;
+}
+
+static int ov4689_load_regs(struct ov4689_dev *sensor,
+			const struct ov4689_mode_info *mode)
+{
+	const struct reg_value *regs = mode->reg_data;
+	unsigned int i;
+	u32 delay_ms;
+	u16 reg_addr;
+	u8 mask, val;
+	int ret = 0;
+
+	st_info(ST_SENSOR, "%s, mode = 0x%x\n", __func__, mode->id);
+	for (i = 0; i < mode->reg_data_size; ++i, ++regs) {
+		delay_ms = regs->delay_ms;
+		reg_addr = regs->reg_addr;
+		val = regs->val;
+		mask = regs->mask;
+
+		if (mask)
+			ret = ov4689_mod_reg(sensor, reg_addr, mask, val);
+		else
+			ret = ov4689_write_reg(sensor, reg_addr, val);
+		if (ret)
+			break;
+
+		if (delay_ms)
+			usleep_range(1000 * delay_ms, 1000 * delay_ms + 100);
+	}
+
+	return ov4689_set_timings(sensor, mode);
+}
+
+#ifdef UNUSED_CODE
+static int ov4689_get_exposure(struct ov4689_dev *sensor)
+{
+	int exp, ret;
+	u8 temp;
+
+	ret = ov4689_read_reg(sensor, OV4689_REG_EXPOSURE_HI, &temp);
+	if (ret)
+		return ret;
+	exp = ((int)temp & 0x0f) << 16;
+	ret = ov4689_read_reg(sensor, OV4689_REG_EXPOSURE_MED, &temp);
+	if (ret)
+		return ret;
+	exp |= ((int)temp << 8);
+	ret = ov4689_read_reg(sensor, OV4689_REG_EXPOSURE_LO, &temp);
+	if (ret)
+		return ret;
+	exp |= (int)temp;
+
+	return exp >> 4;
+}
+#endif
+
+static int ov4689_set_exposure(struct ov4689_dev *sensor, u32 exposure)
+{
+	int ret;
+
+	st_info(ST_SENSOR, "%s, exposure = 0x%x\n", __func__, exposure);
+	exposure <<= 4;
+
+	ret = ov4689_write_reg(sensor,
+			OV4689_REG_EXPOSURE_LO,
+			exposure & 0xff);
+	if (ret)
+		return ret;
+	ret = ov4689_write_reg(sensor,
+			OV4689_REG_EXPOSURE_MED,
+			(exposure >> 8) & 0xff);
+	if (ret)
+		return ret;
+	return ov4689_write_reg(sensor,
+				OV4689_REG_EXPOSURE_HI,
+				(exposure >> 16) & 0x0f);
+}
+
+static int ov4689_get_gain(struct ov4689_dev *sensor)
+{
+	u32 gain = 0;
+	u8 val;
+
+	ov4689_read_reg(sensor, OV4689_REG_GAIN_H, &val);
+	gain = (val & 0x3) << 16;
+	ov4689_read_reg(sensor, OV4689_REG_GAIN_M, &val);
+	gain |= val << 8;
+	ov4689_read_reg(sensor, OV4689_REG_GAIN_L, &val);
+	gain |= val;
+
+	return gain;
+}
+
+static int ov4689_set_gain(struct ov4689_dev *sensor, int gain)
+{
+	ov4689_write_reg(sensor, OV4689_REG_GAIN_H,
+				(gain >> 16) & 0x3);
+	ov4689_write_reg(sensor, OV4689_REG_GAIN_M,
+				(gain >> 8) & 0xff);
+	ov4689_write_reg(sensor, OV4689_REG_GAIN_L,
+				gain & 0xff);
+	return 0;
+}
+
+#ifdef UNUSED_CODE
+static int ov4689_get_sysclk(struct ov4689_dev *sensor)
+{
+	return 0;
+}
+
+static int ov4689_set_night_mode(struct ov4689_dev *sensor)
+{
+	return 0;
+}
+
+static int ov4689_get_hts(struct ov4689_dev *sensor)
+{
+	/* read HTS from register settings */
+	u16 hts;
+	int ret;
+
+	ret = ov4689_read_reg16(sensor, OV4689_REG_TIMING_HTS, &hts);
+	if (ret)
+		return ret;
+	return hts;
+}
+#endif
+
+static int ov4689_get_vts(struct ov4689_dev *sensor)
+{
+	u16 vts;
+	int ret;
+
+	ret = ov4689_read_reg16(sensor, OV4689_REG_TIMING_VTS, &vts);
+	if (ret)
+		return ret;
+	return vts;
+}
+
+#ifdef UNUSED_CODE
+static int ov4689_set_vts(struct ov4689_dev *sensor, int vts)
+{
+	return ov4689_write_reg16(sensor, OV4689_REG_TIMING_VTS, vts);
+}
+
+static int ov4689_get_light_freq(struct ov4689_dev *sensor)
+{
+	return 0;
+}
+
+static int ov4689_set_bandingfilter(struct ov4689_dev *sensor)
+{
+	return 0;
+}
+
+static int ov4689_set_ae_target(struct ov4689_dev *sensor, int target)
+{
+	return 0;
+}
+
+static int ov4689_get_binning(struct ov4689_dev *sensor)
+{
+	return 0;
+}
+
+static int ov4689_set_binning(struct ov4689_dev *sensor, bool enable)
+{
+	return 0;
+}
+#endif
+
+static const struct ov4689_mode_info *
+ov4689_find_mode(struct ov4689_dev *sensor, enum ov4689_frame_rate fr,
+		int width, int height, bool nearest)
+{
+	const struct ov4689_mode_info *mode;
+
+	mode = v4l2_find_nearest_size(ov4689_mode_data,
+				ARRAY_SIZE(ov4689_mode_data),
+				hact, vact,
+				width, height);
+
+	if (!mode ||
+		(!nearest && (mode->hact != width || mode->vact != height)))
+		return NULL;
+
+	/* Check to see if the current mode exceeds the max frame rate */
+	if (ov4689_framerates[fr] > ov4689_framerates[mode->max_fps])
+		return NULL;
+
+	return mode;
+}
+
+static u64 ov4689_calc_pixel_rate(struct ov4689_dev *sensor)
+{
+	u64 rate;
+
+	rate = sensor->current_mode->vact * sensor->current_mode->hact;
+	rate *= ov4689_framerates[sensor->current_fr];
+
+	return rate;
+}
+
+/*
+ * After trying the various combinations, reading various
+ * documentations spread around the net, and from the various
+ * feedback, the clock tree is probably as follows:
+ *
+ *   +--------------+
+ *   |  Ext. Clock  |
+ *   +-+------------+
+ *     |  +----------+
+ *     +->|   PLL1   | - reg 0x030a, bit0 for the pre-dividerp
+ *        +-+--------+ - reg 0x0300, bits 0-2 for the pre-divider
+ *        +-+--------+ - reg 0x0301~0x0302, for the multiplier
+ *          |  +--------------+
+ *          +->| MIPI Divider |  - reg 0x0303, bits 0-3 for the pre-divider
+ *               | +---------> MIPI PHY CLK
+ *               |    +-----+
+ *               | +->| PLL1_DIV_MIPI | - reg 0x0304, bits 0-1 for the divider
+ *                 |    +----------------> PCLK
+ *               |    +-----+
+ *
+ *   +--------------+
+ *   |  Ext. Clock  |
+ *   +-+------------+
+ *     |  +----------+
+ *     +->|   PLL2  | - reg 0x0311, bit0 for the pre-dividerp
+ *        +-+--------+ - reg 0x030b, bits 0-2 for the pre-divider
+ *        +-+--------+ - reg 0x030c~0x030d, for the multiplier
+ *          |  +--------------+
+ *          +->| SCLK Divider |  - reg 0x030F, bits 0-3 for the pre-divider
+ *               +-+--------+    - reg 0x030E, bits 0-2 for the divider
+ *               |    +---------> SCLK
+ *
+ *          |       +-----+
+ *          +->| DAC Divider | - reg 0x0312, bits 0-3 for the divider
+ *                    |    +----------------> DACCLK
+ **
+ */
+
+/*
+ * ov4689_set_mipi_pclk() - Calculate the clock tree configuration values
+ *			for the MIPI CSI-2 output.
+ *
+ * @rate: The requested bandwidth per lane in bytes per second.
+ *	'Bandwidth Per Lane' is calculated as:
+ *	bpl = HTOT * VTOT * FPS * bpp / num_lanes;
+ *
+ * This function use the requested bandwidth to calculate:
+ *
+ * - mipi_pclk   = bpl / 2; ( / 2 is for CSI-2 DDR)
+ * - mipi_phy_clk   = mipi_pclk * PLL1_DIV_MIPI;
+ *
+ * with these fixed parameters:
+ *	PLL1_PREDIVP    = 1;
+ *	PLL1_PREDIV     = 1; (MIPI_BIT_MODE == 8 ? 2 : 2,5);
+ *	PLL1_DIVM       = 1;
+ *	PLL1_DIV_MIPI   = 4;
+ *
+ * FIXME: this have been tested with 10-bit raw and 2 lanes setup only.
+ * MIPI_DIV is fixed to value 2, but it -might- be changed according to the
+ * above formula for setups with 1 lane or image formats with different bpp.
+ *
+ * FIXME: this deviates from the sensor manual documentation which is quite
+ * thin on the MIPI clock tree generation part.
+ */
+
+#define PLL1_PREDIVP         1     // bypass
+#define PLL1_PREDIV          1     // bypass
+#define PLL1_DIVM            1  // bypass
+#define PLL1_DIV_MIPI        3  // div
+#define PLL1_DIV_MIPI_BASE   1  // div
+
+#define PLL1_DIVSP    1   // no use
+#define PLL1_DIVS     1   // no use
+
+#define PLL2_PREDIVP       0
+#define PLL2_PREDIV        0
+#define PLL2_DIVSP       1
+#define PLL2_DIVS        4
+#define PLL2_DIVDAC      1
+
+#define OV4689_PLL1_PREDIVP         0x030a   // bits[0]
+#define OV4689_PLL1_PREDIV          0x0300   // bits[2:0]
+#define OV4689_PLL1_MULTIPLIER      0x0301   // bits[9:8]  0x0302 bits[7:0]
+#define OV4689_PLL1_DIVM            0x0303   // bits[3:0]
+#define OV4689_PLL1_DIV_MIPI        0x0304   // bits[1:0]
+
+#define OV4689_PLL1_DIVSP           0x0305   //bits[1:0]
+#define OV4689_PLL1_DIVS            0x0306   // bits[0]
+
+#define OV4689_PLL2_PREDIVP         0x0311   // bits[0]
+#define OV4689_PLL2_PREDIV          0x030b   // bits[2:0]
+#define OV4689_PLL2_MULTIPLIER      0x030c   // bits[9:8]   0x030d bits[7:0]
+#define OV4689_PLL2_DIVSP           0x030f  // bits[3:0]
+#define OV4689_PLL2_DIVS            0x030e  // bits[2:0]
+#define OV4689_PLL2_DIVDAC          0x0312  // bits[3:0]
+
+static int ov4689_set_mipi_pclk(struct ov4689_dev *sensor,
+				unsigned long rate)
+{
+	const struct ov4689_mode_info *mode = sensor->current_mode;
+	//const struct ov4689_mode_info *orig_mode = sensor->last_mode;
+	u8 val;
+	int ret = 0;
+	int fps = ov4689_framerates[sensor->current_fr];
+	u16 htot, val16;
+
+	htot = mode->htot * ov4689_framerates[mode->max_fps] / fps;
+
+	ret = ov4689_write_reg16(sensor, OV4689_REG_TIMING_HTS, htot);
+
+	ret = ov4689_read_reg(sensor, OV4689_REG_TIMING_HTS, &val);
+	val16 = val << 8;
+	ret = ov4689_read_reg(sensor, OV4689_REG_TIMING_HTS + 1, &val);
+	val16 |= val;
+
+	st_info(ST_SENSOR, "fps = %d, max_fps = %d\n", fps, mode->max_fps);
+	st_info(ST_SENSOR, "mode->htot = 0x%x, htot = 0x%x\n", mode->htot,
+			htot);
+	st_info(ST_SENSOR, "reg: 0x%x = 0x%x\n", OV4689_REG_TIMING_HTS, val16);
+
+	return 0;
+}
+
+/*
+ * if sensor changes inside scaling or subsampling
+ * change mode directly
+ */
+static int ov4689_set_mode_direct(struct ov4689_dev *sensor,
+				const struct ov4689_mode_info *mode)
+{
+	if (!mode->reg_data)
+		return -EINVAL;
+
+	/* Write capture setting */
+	return ov4689_load_regs(sensor, mode);
+}
+
+static int ov4689_set_mode(struct ov4689_dev *sensor)
+{
+	const struct ov4689_mode_info *mode = sensor->current_mode;
+
+	int ret = 0;
+
+	ret = ov4689_set_mode_direct(sensor, mode);
+	if (ret < 0)
+		return ret;
+
+	ret = ov4689_set_mipi_pclk(sensor, 0);
+	if (ret < 0)
+		return 0;
+
+	sensor->pending_mode_change = false;
+	sensor->last_mode = mode;
+	return 0;
+}
+
+/* restore the last set video mode after chip power-on */
+static int ov4689_restore_mode(struct ov4689_dev *sensor)
+{
+	int ret;
+
+	/* first load the initial register values */
+	ret = ov4689_load_regs(sensor, &ov4689_mode_init_data);
+	if (ret < 0)
+		return ret;
+	sensor->last_mode = &ov4689_mode_init_data;
+
+	/* now restore the last capture mode */
+	ret = ov4689_set_mode(sensor);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+static void ov4689_power(struct ov4689_dev *sensor, bool enable)
+{
+	if (!sensor->pwdn_gpio)
+		return;
+	gpiod_set_value_cansleep(sensor->pwdn_gpio, enable ? 0 : 1);
+}
+
+static void ov4689_reset(struct ov4689_dev *sensor)
+{
+	if (!sensor->reset_gpio)
+		return;
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+
+	usleep_range(5000, 25000);
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 1);
+	usleep_range(1000, 2000);
+}
+
+static int ov4689_set_power_on(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	int ret;
+
+	ret = clk_prepare_enable(sensor->xclk);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable clock\n",
+			__func__);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(OV4689_NUM_SUPPLIES,
+				sensor->supplies);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable regulators\n",
+			__func__);
+		goto xclk_off;
+	}
+
+	ov4689_reset(sensor);
+	ov4689_power(sensor, true);
+
+	return 0;
+
+xclk_off:
+	clk_disable_unprepare(sensor->xclk);
+	return ret;
+}
+
+static int ov4689_set_power_off(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+
+	ov4689_power(sensor, false);
+	regulator_bulk_disable(OV4689_NUM_SUPPLIES, sensor->supplies);
+	clk_disable_unprepare(sensor->xclk);
+
+	return 0;
+}
+
+static int ov4689_try_frame_interval(struct ov4689_dev *sensor,
+				struct v4l2_fract *fi,
+				u32 width, u32 height)
+{
+	const struct ov4689_mode_info *mode;
+	enum ov4689_frame_rate rate = OV4689_15_FPS;
+	int minfps, maxfps, best_fps, fps;
+	int i;
+
+	minfps = ov4689_framerates[OV4689_15_FPS];
+	maxfps = ov4689_framerates[OV4689_NUM_FRAMERATES - 1];
+
+	if (fi->numerator == 0) {
+		fi->denominator = maxfps;
+		fi->numerator = 1;
+		rate = OV4689_60_FPS;
+		goto find_mode;
+	}
+
+	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
+			minfps, maxfps);
+
+	best_fps = minfps;
+	for (i = 0; i < ARRAY_SIZE(ov4689_framerates); i++) {
+		int curr_fps = ov4689_framerates[i];
+
+		if (abs(curr_fps - fps) < abs(best_fps - fps)) {
+			best_fps = curr_fps;
+			rate = i;
+		}
+	}
+	st_info(ST_SENSOR, "best_fps = %d, fps = %d\n", best_fps, fps);
+
+	fi->numerator = 1;
+	fi->denominator = best_fps;
+
+find_mode:
+	mode = ov4689_find_mode(sensor, rate, width, height, false);
+	return mode ? rate : -EINVAL;
+}
+
+static int ov4689_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad != 0)
+		return -EINVAL;
+
+	if (code->index)
+		return -EINVAL;
+
+	code->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	return 0;
+}
+
+static int ov4689_get_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *format)
+{
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	struct v4l2_mbus_framefmt *fmt;
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(&sensor->sd, cfg,
+						format->pad);
+	else
+		fmt = &sensor->fmt;
+
+	format->format = *fmt;
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int ov4689_try_fmt_internal(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt,
+				enum ov4689_frame_rate fr,
+				const struct ov4689_mode_info **new_mode)
+{
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	const struct ov4689_mode_info *mode;
+
+	mode = ov4689_find_mode(sensor, fr, fmt->width, fmt->height, true);
+	if (!mode)
+		return -EINVAL;
+	fmt->width = mode->hact;
+	fmt->height = mode->vact;
+
+	if (new_mode)
+		*new_mode = mode;
+
+	fmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+
+	return 0;
+}
+
+static int ov4689_set_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *format)
+{
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	const struct ov4689_mode_info *new_mode;
+	struct v4l2_mbus_framefmt *mbus_fmt = &format->format;
+	struct v4l2_mbus_framefmt *fmt;
+	int ret;
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = ov4689_try_fmt_internal(sd, mbus_fmt, 0, &new_mode);
+	if (ret)
+		goto out;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(sd, cfg, 0);
+	else
+		fmt = &sensor->fmt;
+
+	*fmt = *mbus_fmt;
+
+	if (new_mode != sensor->current_mode) {
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+	if (new_mode->max_fps < sensor->current_fr) {
+		sensor->current_fr = new_mode->max_fps;
+		sensor->frame_interval.numerator = 1;
+		sensor->frame_interval.denominator =
+			ov4689_framerates[sensor->current_fr];
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+
+	__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
+				ov4689_calc_pixel_rate(sensor));
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+/*
+ * Sensor Controls.
+ */
+
+static int ov4689_set_ctrl_hue(struct ov4689_dev *sensor, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int ov4689_set_ctrl_contrast(struct ov4689_dev *sensor, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int ov4689_set_ctrl_saturation(struct ov4689_dev *sensor, int value)
+{
+	int ret  = 0;
+
+	return ret;
+}
+
+static int ov4689_set_ctrl_white_balance(struct ov4689_dev *sensor, int awb)
+{
+	struct ov4689_ctrls *ctrls = &sensor->ctrls;
+	int ret = 0;
+
+	if (!awb && (ctrls->red_balance->is_new
+			|| ctrls->blue_balance->is_new)) {
+		u16 red = (u16)ctrls->red_balance->val;
+		u16 blue = (u16)ctrls->blue_balance->val;
+
+		st_info(ST_SENSOR, "red = 0x%x, blue = 0x%x\n", red, blue);
+		ret = ov4689_write_reg16(sensor, OV4689_REG_AWB_R_GAIN, red);
+		if (ret)
+			return ret;
+		ret = ov4689_write_reg16(sensor, OV4689_REG_AWB_B_GAIN, blue);
+	}
+	return ret;
+}
+
+static int ov4689_set_ctrl_exposure(struct ov4689_dev *sensor,
+				enum v4l2_exposure_auto_type auto_exposure)
+{
+	struct ov4689_ctrls *ctrls = &sensor->ctrls;
+	bool auto_exp = (auto_exposure == V4L2_EXPOSURE_AUTO);
+	int ret = 0;
+
+	if (!auto_exp && ctrls->exposure->is_new) {
+		u16 max_exp = 0;
+
+		ret = ov4689_read_reg16(sensor, OV4689_REG_V_OUTPUT_SIZE,
+					&max_exp);
+
+		ret = ov4689_get_vts(sensor);
+		if (ret < 0)
+			return ret;
+		max_exp += ret;
+		ret = 0;
+
+		st_info(ST_SENSOR, "%s, max_exp = 0x%x\n", __func__, max_exp);
+		if (ctrls->exposure->val < max_exp)
+			ret = ov4689_set_exposure(sensor, ctrls->exposure->val);
+	}
+
+	return ret;
+}
+
+static const s64 link_freq_menu_items[] = {
+	OV4689_LINK_FREQ_500MHZ
+};
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Color bars",
+	"Color bars w/ rolling bar",
+	"Color squares",
+	"Color squares w/ rolling bar",
+};
+
+#define OV4689_TEST_ENABLE		BIT(7)
+#define OV4689_TEST_ROLLING		BIT(6)  /* rolling horizontal bar */
+#define OV4689_TEST_TRANSPARENT		BIT(5)
+#define OV4689_TEST_SQUARE_BW		BIT(4)  /* black & white squares */
+#define OV4689_TEST_BAR_STANDARD	(0 << 2)
+#define OV4689_TEST_BAR_DARKER_1	(1 << 2)
+#define OV4689_TEST_BAR_DARKER_2	(2 << 2)
+#define OV4689_TEST_BAR_DARKER_3	(3 << 2)
+#define OV4689_TEST_BAR			(0 << 0)
+#define OV4689_TEST_RANDOM		(1 << 0)
+#define OV4689_TEST_SQUARE		(2 << 0)
+#define OV4689_TEST_BLACK		(3 << 0)
+
+static const u8 test_pattern_val[] = {
+	0,
+	OV4689_TEST_ENABLE | OV4689_TEST_BAR_STANDARD |
+		OV4689_TEST_BAR,
+	OV4689_TEST_ENABLE | OV4689_TEST_ROLLING |
+		OV4689_TEST_BAR_DARKER_1 | OV4689_TEST_BAR,
+	OV4689_TEST_ENABLE | OV4689_TEST_SQUARE,
+	OV4689_TEST_ENABLE | OV4689_TEST_ROLLING | OV4689_TEST_SQUARE,
+};
+
+static int ov4689_set_ctrl_test_pattern(struct ov4689_dev *sensor, int value)
+{
+	return ov4689_write_reg(sensor, OV4689_REG_TEST_PATTERN,
+			test_pattern_val[value]);
+}
+
+static int ov4689_set_ctrl_light_freq(struct ov4689_dev *sensor, int value)
+{
+	return 0;
+}
+
+static int ov4689_set_ctrl_hflip(struct ov4689_dev *sensor, int value)
+{
+	/*
+	 * TIMING TC REG21:
+	 * - [2]:       Digital mirror
+	 * - [1]:       Array mirror
+	 */
+	return ov4689_mod_reg(sensor, OV4689_REG_TIMING_TC_REG21,
+			BIT(2) | BIT(1),
+			(!(value ^ sensor->upside_down)) ?
+			(BIT(2) | BIT(1)) : 0);
+}
+
+static int ov4689_set_ctrl_vflip(struct ov4689_dev *sensor, int value)
+{
+	/*
+	 * TIMING TC REG20:
+	 * - [2]:       Digital vflip
+	 * - [1]:       Array vflip
+	 */
+	return ov4689_mod_reg(sensor, OV4689_REG_TIMING_TC_REG20,
+				BIT(2) | BIT(1),
+				(value ^ sensor->upside_down) ?
+				(BIT(2) | BIT(1)) : 0);
+}
+
+static int ov4689_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	int val;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		val = ov4689_get_gain(sensor);
+		break;
+	}
+
+	pm_runtime_put(&sensor->i2c_client->dev);
+
+	return 0;
+}
+
+static int ov4689_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored at start streaming time.
+	 */
+	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_ANALOGUE_GAIN:
+		ret = ov4689_set_gain(sensor, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE:
+		ret = ov4689_set_ctrl_exposure(sensor, V4L2_EXPOSURE_MANUAL);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		ret = ov4689_set_ctrl_white_balance(sensor, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		ret = ov4689_set_ctrl_hue(sensor, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = ov4689_set_ctrl_contrast(sensor, ctrl->val);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = ov4689_set_ctrl_saturation(sensor, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov4689_set_ctrl_test_pattern(sensor, ctrl->val);
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		ret = ov4689_set_ctrl_light_freq(sensor, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = ov4689_set_ctrl_hflip(sensor, ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = ov4689_set_ctrl_vflip(sensor, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&sensor->i2c_client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov4689_ctrl_ops = {
+	.g_volatile_ctrl = ov4689_g_volatile_ctrl,
+	.s_ctrl = ov4689_s_ctrl,
+};
+
+static int ov4689_init_controls(struct ov4689_dev *sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &ov4689_ctrl_ops;
+	struct ov4689_ctrls *ctrls = &sensor->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	v4l2_ctrl_handler_init(hdl, 32);
+
+	/* we can use our own mutex for the ctrl lock */
+	hdl->lock = &sensor->lock;
+
+	/* Clock related controls */
+	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
+					0, INT_MAX, 1,
+					ov4689_calc_pixel_rate(sensor));
+
+	/* Auto/manual white balance */
+	ctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_AUTO_WHITE_BALANCE,
+					0, 1, 1, 0);
+	ctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,
+						0, 4095, 1, 1024);
+	ctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,
+						0, 4095, 1, 1024);
+
+	ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,
+					4, 0xfff8, 1, 0x4c00);
+	ctrls->anal_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_ANALOGUE_GAIN,
+					0x10, 0xfff8, 1, 0x0080);
+	ctrls->test_pattern =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+					ARRAY_SIZE(test_pattern_menu) - 1,
+					0, 0, test_pattern_menu);
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					0, 1, 1, 0);
+	ctrls->light_freq =
+		v4l2_ctrl_new_std_menu(hdl, ops,
+					V4L2_CID_POWER_LINE_FREQUENCY,
+					V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,
+					V4L2_CID_POWER_LINE_FREQUENCY_50HZ);
+	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops, V4L2_CID_LINK_FREQ,
+					0, 0, link_freq_menu_items);
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	// ctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	// ctrls->anal_gain->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	v4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);
+
+	sensor->sd.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+
+static int ov4689_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->pad != 0)
+		return -EINVAL;
+	if (fse->index >= OV4689_NUM_MODES)
+		return -EINVAL;
+
+	fse->min_width =
+		ov4689_mode_data[fse->index].hact;
+	fse->max_width = fse->min_width;
+	fse->min_height =
+		ov4689_mode_data[fse->index].vact;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov4689_enum_frame_interval(
+	struct v4l2_subdev *sd,
+	struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_frame_interval_enum *fie)
+{
+	//struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	struct v4l2_fract tpf;
+	int i = 0;
+
+	if (fie->pad != 0)
+		return -EINVAL;
+	if (fie->index >= OV4689_NUM_FRAMERATES)
+		return -EINVAL;
+
+	tpf.numerator = 1;
+	tpf.denominator = ov4689_framerates[fie->index];
+
+	// ret = ov4689_try_frame_interval(sensor, &tpf,
+	//		fie->width, fie->height);
+	// if (ret < 0)
+	//	return -EINVAL;
+
+	pr_debug("fie->width = %d, fie->height = %d\n", fie->width, fie->height);
+	for (i = 0; i < OV4689_NUM_MODES; i++) {
+		if (fie->width == ov4689_mode_data[i].hact &&
+			fie->height == ov4689_mode_data[i].vact)
+			break;
+	}
+	if (i == OV4689_NUM_MODES)
+		return -ENOTTY;
+
+	fie->interval = tpf;
+	fie->width = ov4689_mode_data[i].hact;
+	fie->height = ov4689_mode_data[i].vact;
+
+	return 0;
+}
+
+static int ov4689_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *fi)
+{
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+
+	mutex_lock(&sensor->lock);
+	fi->interval = sensor->frame_interval;
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int ov4689_s_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *fi)
+{
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	const struct ov4689_mode_info *mode;
+	int frame_rate, ret = 0;
+
+	if (fi->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	mode = sensor->current_mode;
+
+	frame_rate = ov4689_try_frame_interval(sensor, &fi->interval,
+					mode->hact, mode->vact);
+	if (frame_rate < 0) {
+		/* Always return a valid frame interval value */
+		fi->interval = sensor->frame_interval;
+		goto out;
+	}
+
+	mode = ov4689_find_mode(sensor, frame_rate, mode->hact,
+				mode->vact, true);
+	if (!mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (mode != sensor->current_mode ||
+		frame_rate != sensor->current_fr) {
+		sensor->current_fr = frame_rate;
+		sensor->frame_interval = fi->interval;
+		sensor->current_mode = mode;
+		sensor->pending_mode_change = true;
+
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
+					ov4689_calc_pixel_rate(sensor));
+	}
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int ov4689_stream_start(struct ov4689_dev *sensor, int enable)
+{
+	return ov4689_write_reg(sensor, OV4689_REG_STREAM_ON, enable);
+}
+
+static int ov4689_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+	int ret = 0;
+
+	if (enable) {
+		pm_runtime_get_sync(&sensor->i2c_client->dev);
+
+		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+		if (ret) {
+			pm_runtime_put_sync(&sensor->i2c_client->dev);
+			return ret;
+		}
+	}
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming == !enable) {
+		if (enable) {
+			ret = ov4689_restore_mode(sensor);
+			if (ret)
+				goto out;
+		}
+
+		if (enable && sensor->pending_mode_change) {
+			ret = ov4689_set_mode(sensor);
+			if (ret)
+				goto out;
+		}
+
+		ret = ov4689_stream_start(sensor, enable);
+		if (ret)
+			goto out;
+	}
+	sensor->streaming += enable ? 1 : -1;
+	WARN_ON(sensor->streaming < 0);
+out:
+	mutex_unlock(&sensor->lock);
+
+	if (!enable || ret)
+		pm_runtime_put_sync(&sensor->i2c_client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops ov4689_core_ops = {
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops ov4689_video_ops = {
+	.g_frame_interval = ov4689_g_frame_interval,
+	.s_frame_interval = ov4689_s_frame_interval,
+	.s_stream = ov4689_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov4689_pad_ops = {
+	.enum_mbus_code = ov4689_enum_mbus_code,
+	.get_fmt = ov4689_get_fmt,
+	.set_fmt = ov4689_set_fmt,
+	.enum_frame_size = ov4689_enum_frame_size,
+	.enum_frame_interval = ov4689_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops ov4689_subdev_ops = {
+	.core = &ov4689_core_ops,
+	.video = &ov4689_video_ops,
+	.pad = &ov4689_pad_ops,
+};
+
+static int ov4689_get_regulators(struct ov4689_dev *sensor)
+{
+	int i;
+
+	for (i = 0; i < OV4689_NUM_SUPPLIES; i++)
+		sensor->supplies[i].supply = ov4689_supply_name[i];
+
+	return devm_regulator_bulk_get(&sensor->i2c_client->dev,
+					OV4689_NUM_SUPPLIES,
+					sensor->supplies);
+}
+
+static int ov4689_check_chip_id(struct ov4689_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int ret = 0;
+	u16 chip_id;
+
+	ret = ov4689_read_reg16(sensor, OV4689_REG_CHIP_ID, &chip_id);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to read chip identifier\n",
+			__func__);
+		return ret;
+	}
+
+	if (chip_id != OV4689_CHIP_ID) {
+		dev_err(&client->dev, "%s: wrong chip identifier, expected 0x%x,  got 0x%x\n",
+			__func__, OV4689_CHIP_ID, chip_id);
+		return -ENXIO;
+	}
+	dev_err(&client->dev, "%s: chip identifier, got 0x%x\n",
+		__func__, chip_id);
+
+	return 0;
+}
+
+static int ov4689_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	struct ov4689_dev *sensor;
+	struct v4l2_mbus_framefmt *fmt;
+	u32 rotation;
+	int ret;
+
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	sensor->i2c_client = client;
+
+	fmt = &sensor->fmt;
+	fmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = 1920;
+	fmt->height = 1080;
+	fmt->field = V4L2_FIELD_NONE;
+	sensor->frame_interval.numerator = 1;
+	sensor->frame_interval.denominator = ov4689_framerates[OV4689_30_FPS];
+	sensor->current_fr = OV4689_30_FPS;
+	sensor->current_mode =
+		&ov4689_mode_data[OV4689_MODE_1080P_1920_1080];
+	sensor->last_mode = sensor->current_mode;
+
+
+	/* optional indication of physical rotation of sensor */
+	ret = fwnode_property_read_u32(dev_fwnode(&client->dev), "rotation",
+					&rotation);
+	if (!ret) {
+		switch (rotation) {
+		case 180:
+			sensor->upside_down = true;
+			fallthrough;
+		case 0:
+			break;
+		default:
+			dev_warn(dev, "%u degrees rotation is not supported, ignoring...\n",
+				rotation);
+		}
+	}
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev),
+						NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &sensor->ep);
+	fwnode_handle_put(endpoint);
+	if (ret) {
+		dev_err(dev, "Could not parse endpoint\n");
+		return ret;
+	}
+
+	if (sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+		dev_err(dev, "Unsupported bus type %d\n", sensor->ep.bus_type);
+		return -EINVAL;
+	}
+
+	/* get system clock (xclk) */
+	sensor->xclk = devm_clk_get(dev, "xclk");
+	if (IS_ERR(sensor->xclk)) {
+		dev_err(dev, "failed to get xclk\n");
+		return PTR_ERR(sensor->xclk);
+	}
+
+	sensor->xclk_freq = clk_get_rate(sensor->xclk);
+	if (sensor->xclk_freq < OV4689_XCLK_MIN ||
+		sensor->xclk_freq > OV4689_XCLK_MAX) {
+		dev_err(dev, "xclk frequency out of range: %d Hz\n",
+			sensor->xclk_freq);
+		return -EINVAL;
+	}
+
+	/* request optional power down pin */
+	sensor->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
+						GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->pwdn_gpio))
+		return PTR_ERR(sensor->pwdn_gpio);
+
+	/* request optional reset pin */
+	sensor->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->reset_gpio))
+		return PTR_ERR(sensor->reset_gpio);
+
+	v4l2_i2c_subdev_init(&sensor->sd, client, &ov4689_subdev_ops);
+
+	sensor->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			V4L2_SUBDEV_FL_HAS_EVENTS;
+	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);
+	if (ret)
+		return ret;
+
+	ret = ov4689_get_regulators(sensor);
+	if (ret)
+		return ret;
+
+	mutex_init(&sensor->lock);
+
+	ret = ov4689_set_power_on(dev);
+	if (ret) {
+		dev_err(dev, "failed to power on\n");
+		goto entity_cleanup;
+	}
+
+	ret = ov4689_check_chip_id(sensor);
+	if (ret)
+		goto error_power_off;
+
+	ret = ov4689_init_controls(sensor);
+	if (ret)
+		goto error_power_off;
+
+	ret = v4l2_async_register_subdev_sensor_common(&sensor->sd);
+	if (ret)
+		goto free_ctrls;
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+error_power_off:
+	ov4689_set_power_off(dev);
+entity_cleanup:
+	media_entity_cleanup(&sensor->sd.entity);
+	mutex_destroy(&sensor->lock);
+	return ret;
+}
+
+static int ov4689_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov4689_dev *sensor = to_ov4689_dev(sd);
+
+	v4l2_async_unregister_subdev(&sensor->sd);
+	media_entity_cleanup(&sensor->sd.entity);
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+	mutex_destroy(&sensor->lock);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		ov4689_set_power_off(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov4689_id[] = {
+	{ "ov4689", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ov4689_id);
+
+static const struct of_device_id ov4689_dt_ids[] = {
+	{ .compatible = "ovti,ov4689" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ov4689_dt_ids);
+
+static const struct dev_pm_ops ov4689_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov4689_set_power_off, ov4689_set_power_on, NULL)
+};
+
+static struct i2c_driver ov4689_i2c_driver = {
+	.driver = {
+		.name  = "ov4689",
+		.of_match_table = ov4689_dt_ids,
+		.pm = &ov4689_pm_ops,
+	},
+	.id_table = ov4689_id,
+	.probe_new = ov4689_probe,
+	.remove   = ov4689_remove,
+};
+
+module_i2c_driver(ov4689_i2c_driver);
+
+MODULE_DESCRIPTION("OV4689 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/starfive/v4l2_driver/ov5640.c b/drivers/media/platform/starfive/v4l2_driver/ov5640.c
new file mode 100644
index 000000000000..16a3881a3855
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/ov5640.c
@@ -0,0 +1,3227 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2014-2017 Mentor Graphics Inc.
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include "stfcamss.h"
+
+/* min/typical/max system clock (xclk) frequencies */
+#define OV5640_XCLK_MIN  6000000
+#define OV5640_XCLK_MAX 54000000
+
+#define OV5640_SKIP_FRAMES      4
+
+#define OV5640_CHIP_ID		0x5640
+#define OV5640_DEFAULT_SLAVE_ID 0x3c
+
+#define OV5640_REG_SYS_RESET02		0x3002
+#define OV5640_REG_SYS_CLOCK_ENABLE02	0x3006
+#define OV5640_REG_SYS_CTRL0		0x3008
+#define OV5640_REG_SYS_CTRL0_SW_PWDN	0x42
+#define OV5640_REG_SYS_CTRL0_SW_PWUP	0x02
+#define OV5640_REG_CHIP_ID		0x300a
+#define OV5640_REG_IO_MIPI_CTRL00	0x300e
+#define OV5640_REG_PAD_OUTPUT_ENABLE01	0x3017
+#define OV5640_REG_PAD_OUTPUT_ENABLE02	0x3018
+#define OV5640_REG_PAD_OUTPUT00		0x3019
+#define OV5640_REG_SYSTEM_CONTROL1	0x302e
+#define OV5640_REG_SC_PLL_CTRL0		0x3034
+#define OV5640_REG_SC_PLL_CTRL1		0x3035
+#define OV5640_REG_SC_PLL_CTRL2		0x3036
+#define OV5640_REG_SC_PLL_CTRL3		0x3037
+#define OV5640_REG_SLAVE_ID		0x3100
+#define OV5640_REG_SCCB_SYS_CTRL1	0x3103
+#define OV5640_REG_SYS_ROOT_DIVIDER	0x3108
+#define OV5640_REG_AWB_R_GAIN		0x3400
+#define OV5640_REG_AWB_G_GAIN		0x3402
+#define OV5640_REG_AWB_B_GAIN		0x3404
+#define OV5640_REG_AWB_MANUAL_CTRL	0x3406
+#define OV5640_REG_AEC_PK_EXPOSURE_HI	0x3500
+#define OV5640_REG_AEC_PK_EXPOSURE_MED	0x3501
+#define OV5640_REG_AEC_PK_EXPOSURE_LO	0x3502
+#define OV5640_REG_AEC_PK_MANUAL	0x3503
+#define OV5640_REG_AEC_PK_REAL_GAIN	0x350a
+#define OV5640_REG_AEC_PK_VTS		0x350c
+#define OV5640_REG_TIMING_DVPHO		0x3808
+#define OV5640_REG_TIMING_DVPVO		0x380a
+#define OV5640_REG_TIMING_HTS		0x380c
+#define OV5640_REG_TIMING_VTS		0x380e
+#define OV5640_REG_TIMING_TC_REG20	0x3820
+#define OV5640_REG_TIMING_TC_REG21	0x3821
+#define OV5640_REG_AEC_CTRL00		0x3a00
+#define OV5640_REG_AEC_B50_STEP		0x3a08
+#define OV5640_REG_AEC_B60_STEP		0x3a0a
+#define OV5640_REG_AEC_CTRL0D		0x3a0d
+#define OV5640_REG_AEC_CTRL0E		0x3a0e
+#define OV5640_REG_AEC_CTRL0F		0x3a0f
+#define OV5640_REG_AEC_CTRL10		0x3a10
+#define OV5640_REG_AEC_CTRL11		0x3a11
+#define OV5640_REG_AEC_CTRL1B		0x3a1b
+#define OV5640_REG_AEC_CTRL1E		0x3a1e
+#define OV5640_REG_AEC_CTRL1F		0x3a1f
+#define OV5640_REG_HZ5060_CTRL00	0x3c00
+#define OV5640_REG_HZ5060_CTRL01	0x3c01
+#define OV5640_REG_SIGMADELTA_CTRL0C	0x3c0c
+#define OV5640_REG_FRAME_CTRL01		0x4202
+#define OV5640_REG_FORMAT_CONTROL00	0x4300
+#define OV5640_REG_VFIFO_HSIZE		0x4602
+#define OV5640_REG_VFIFO_VSIZE		0x4604
+#define OV5640_REG_JPG_MODE_SELECT	0x4713
+#define OV5640_REG_CCIR656_CTRL00	0x4730
+#define OV5640_REG_POLARITY_CTRL00	0x4740
+#define OV5640_REG_MIPI_CTRL00		0x4800
+#define OV5640_REG_DEBUG_MODE		0x4814
+#define OV5640_REG_ISP_FORMAT_MUX_CTRL	0x501f
+#define OV5640_REG_PRE_ISP_TEST_SET1	0x503d
+#define OV5640_REG_SDE_CTRL0		0x5580
+#define OV5640_REG_SDE_CTRL1		0x5581
+#define OV5640_REG_SDE_CTRL3		0x5583
+#define OV5640_REG_SDE_CTRL4		0x5584
+#define OV5640_REG_SDE_CTRL5		0x5585
+#define OV5640_REG_AVG_READOUT		0x56a1
+
+enum ov5640_mode_id {
+	OV5640_MODE_QCIF_176_144 = 0,
+	OV5640_MODE_QVGA_320_240,
+	OV5640_MODE_VGA_640_480,
+	OV5640_MODE_NTSC_720_480,
+	OV5640_MODE_PAL_720_576,
+	OV5640_MODE_XGA_1024_768,
+	OV5640_MODE_720P_1280_720,
+	OV5640_MODE_1080P_1920_1080,
+	OV5640_MODE_QSXGA_2592_1944,
+	OV5640_NUM_MODES,
+};
+
+enum ov5640_frame_rate {
+	OV5640_15_FPS = 0,
+	OV5640_30_FPS,
+	OV5640_60_FPS,
+	OV5640_NUM_FRAMERATES,
+};
+
+enum ov5640_format_mux {
+	OV5640_FMT_MUX_YUV422 = 0,
+	OV5640_FMT_MUX_RGB,
+	OV5640_FMT_MUX_DITHER,
+	OV5640_FMT_MUX_RAW_DPC,
+	OV5640_FMT_MUX_SNR_RAW,
+	OV5640_FMT_MUX_RAW_CIP,
+};
+
+struct ov5640_pixfmt {
+	u32 code;
+	u32 colorspace;
+};
+
+static const struct ov5640_pixfmt ov5640_formats[] = {
+	{ MEDIA_BUS_FMT_JPEG_1X8, V4L2_COLORSPACE_JPEG, },
+	{ MEDIA_BUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_RGB565_2X8_BE, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_COLORSPACE_SRGB, },
+};
+
+/*
+ * FIXME: remove this when a subdev API becomes available
+ * to set the MIPI CSI-2 virtual channel.
+ */
+static unsigned int virtual_channel;
+module_param(virtual_channel, uint, 0444);
+MODULE_PARM_DESC(virtual_channel,
+		 "MIPI CSI-2 virtual channel (0..3), default 0");
+
+static const int ov5640_framerates[] = {
+	[OV5640_15_FPS] = 15,
+	[OV5640_30_FPS] = 30,
+	[OV5640_60_FPS] = 60,
+};
+
+/* regulator supplies */
+static const char * const ov5640_supply_name[] = {
+	"DOVDD", /* Digital I/O (1.8V) supply */
+	"AVDD",  /* Analog (2.8V) supply */
+	"DVDD",  /* Digital Core (1.5V) supply */
+};
+
+#define OV5640_NUM_SUPPLIES ARRAY_SIZE(ov5640_supply_name)
+
+/*
+ * Image size under 1280 * 960 are SUBSAMPLING
+ * Image size upper 1280 * 960 are SCALING
+ */
+enum ov5640_downsize_mode {
+	SUBSAMPLING,
+	SCALING,
+};
+
+struct reg_value {
+	u16 reg_addr;
+	u8 val;
+	u8 mask;
+	u32 delay_ms;
+};
+
+struct ov5640_mode_info {
+	enum ov5640_mode_id id;
+	enum ov5640_downsize_mode dn_mode;
+	u32 hact;
+	u32 htot;
+	u32 vact;
+	u32 vtot;
+	const struct reg_value *reg_data;
+	u32 reg_data_size;
+	u32 max_fps;
+};
+
+struct ov5640_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct {
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+	};
+	struct {
+		struct v4l2_ctrl *auto_wb;
+		struct v4l2_ctrl *blue_balance;
+		struct v4l2_ctrl *red_balance;
+	};
+	struct {
+		struct v4l2_ctrl *auto_gain;
+		struct v4l2_ctrl *gain;
+	};
+	struct v4l2_ctrl *brightness;
+	struct v4l2_ctrl *light_freq;
+	struct v4l2_ctrl *saturation;
+	struct v4l2_ctrl *contrast;
+	struct v4l2_ctrl *hue;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+};
+
+struct ov5640_dev {
+	struct i2c_client *i2c_client;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_fwnode_endpoint ep; /* the parsed DT endpoint info */
+	struct clk *xclk; /* system clock to OV5640 */
+	u32 xclk_freq;
+
+	struct regulator_bulk_data supplies[OV5640_NUM_SUPPLIES];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *pwdn_gpio;
+	bool   upside_down;
+
+	/* lock to protect all members below */
+	struct mutex lock;
+
+	int power_count;
+
+	struct v4l2_mbus_framefmt fmt;
+	bool pending_fmt_change;
+
+	const struct ov5640_mode_info *current_mode;
+	const struct ov5640_mode_info *last_mode;
+	enum ov5640_frame_rate current_fr;
+	struct v4l2_fract frame_interval;
+
+	struct ov5640_ctrls ctrls;
+
+	u32 prev_sysclk, prev_hts;
+	u32 ae_low, ae_high, ae_target;
+
+	bool pending_mode_change;
+	int streaming;
+};
+
+static inline struct ov5640_dev *to_ov5640_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ov5640_dev, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov5640_dev,
+			     ctrls.handler)->sd;
+}
+
+/*
+ * FIXME: all of these register tables are likely filled with
+ * entries that set the register to their power-on default values,
+ * and which are otherwise not touched by this driver. Those entries
+ * should be identified and removed to speed register load time
+ * over i2c.
+ */
+/* YUV422 UYVY VGA@30fps */
+static const struct reg_value ov5640_init_setting_30fps_VGA[] = {
+	{0x3103, 0x11, 0, 0}, {0x3008, 0x82, 0, 5}, {0x3008, 0x42, 0, 0},
+	{0x3103, 0x03, 0, 0}, {0x3630, 0x36, 0, 0},
+	{0x3631, 0x0e, 0, 0}, {0x3632, 0xe2, 0, 0}, {0x3633, 0x12, 0, 0},
+	{0x3621, 0xe0, 0, 0}, {0x3704, 0xa0, 0, 0}, {0x3703, 0x5a, 0, 0},
+	{0x3715, 0x78, 0, 0}, {0x3717, 0x01, 0, 0}, {0x370b, 0x60, 0, 0},
+	{0x3705, 0x1a, 0, 0}, {0x3905, 0x02, 0, 0}, {0x3906, 0x10, 0, 0},
+	{0x3901, 0x0a, 0, 0}, {0x3731, 0x12, 0, 0}, {0x3600, 0x08, 0, 0},
+	{0x3601, 0x33, 0, 0}, {0x302d, 0x60, 0, 0}, {0x3620, 0x52, 0, 0},
+	{0x371b, 0x20, 0, 0}, {0x471c, 0x50, 0, 0}, {0x3a13, 0x43, 0, 0},
+	{0x3a18, 0x00, 0, 0}, {0x3a19, 0xf8, 0, 0}, {0x3635, 0x13, 0, 0},
+	{0x3636, 0x03, 0, 0}, {0x3634, 0x40, 0, 0}, {0x3622, 0x01, 0, 0},
+	{0x3c01, 0xa4, 0, 0}, {0x3c04, 0x28, 0, 0}, {0x3c05, 0x98, 0, 0},
+	{0x3c06, 0x00, 0, 0}, {0x3c07, 0x08, 0, 0}, {0x3c08, 0x00, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3820, 0x41, 0, 0}, {0x3821, 0x07, 0, 0}, {0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0}, {0x3000, 0x00, 0, 0},
+	{0x3002, 0x1c, 0, 0}, {0x3004, 0xff, 0, 0}, {0x3006, 0xc3, 0, 0},
+	{0x302e, 0x08, 0, 0}, {0x4300, 0x3f, 0, 0},
+	{0x501f, 0x00, 0, 0}, {0x4407, 0x04, 0, 0},
+	{0x440e, 0x00, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x4837, 0x0a, 0, 0}, {0x3824, 0x02, 0, 0},
+	{0x5000, 0xa7, 0, 0}, {0x5001, 0xa3, 0, 0}, {0x5180, 0xff, 0, 0},
+	{0x5181, 0xf2, 0, 0}, {0x5182, 0x00, 0, 0}, {0x5183, 0x14, 0, 0},
+	{0x5184, 0x25, 0, 0}, {0x5185, 0x24, 0, 0}, {0x5186, 0x09, 0, 0},
+	{0x5187, 0x09, 0, 0}, {0x5188, 0x09, 0, 0}, {0x5189, 0x88, 0, 0},
+	{0x518a, 0x54, 0, 0}, {0x518b, 0xee, 0, 0}, {0x518c, 0xb2, 0, 0},
+	{0x518d, 0x50, 0, 0}, {0x518e, 0x34, 0, 0}, {0x518f, 0x6b, 0, 0},
+	{0x5190, 0x46, 0, 0}, {0x5191, 0xf8, 0, 0}, {0x5192, 0x04, 0, 0},
+	{0x5193, 0x70, 0, 0}, {0x5194, 0xf0, 0, 0}, {0x5195, 0xf0, 0, 0},
+	{0x5196, 0x03, 0, 0}, {0x5197, 0x01, 0, 0}, {0x5198, 0x04, 0, 0},
+	{0x5199, 0x6c, 0, 0}, {0x519a, 0x04, 0, 0}, {0x519b, 0x00, 0, 0},
+	{0x519c, 0x09, 0, 0}, {0x519d, 0x2b, 0, 0}, {0x519e, 0x38, 0, 0},
+	{0x5381, 0x1e, 0, 0}, {0x5382, 0x5b, 0, 0}, {0x5383, 0x08, 0, 0},
+	{0x5384, 0x0a, 0, 0}, {0x5385, 0x7e, 0, 0}, {0x5386, 0x88, 0, 0},
+	{0x5387, 0x7c, 0, 0}, {0x5388, 0x6c, 0, 0}, {0x5389, 0x10, 0, 0},
+	{0x538a, 0x01, 0, 0}, {0x538b, 0x98, 0, 0}, {0x5300, 0x08, 0, 0},
+	{0x5301, 0x30, 0, 0}, {0x5302, 0x10, 0, 0}, {0x5303, 0x00, 0, 0},
+	{0x5304, 0x08, 0, 0}, {0x5305, 0x30, 0, 0}, {0x5306, 0x08, 0, 0},
+	{0x5307, 0x16, 0, 0}, {0x5309, 0x08, 0, 0}, {0x530a, 0x30, 0, 0},
+	{0x530b, 0x04, 0, 0}, {0x530c, 0x06, 0, 0}, {0x5480, 0x01, 0, 0},
+	{0x5481, 0x08, 0, 0}, {0x5482, 0x14, 0, 0}, {0x5483, 0x28, 0, 0},
+	{0x5484, 0x51, 0, 0}, {0x5485, 0x65, 0, 0}, {0x5486, 0x71, 0, 0},
+	{0x5487, 0x7d, 0, 0}, {0x5488, 0x87, 0, 0}, {0x5489, 0x91, 0, 0},
+	{0x548a, 0x9a, 0, 0}, {0x548b, 0xaa, 0, 0}, {0x548c, 0xb8, 0, 0},
+	{0x548d, 0xcd, 0, 0}, {0x548e, 0xdd, 0, 0}, {0x548f, 0xea, 0, 0},
+	{0x5490, 0x1d, 0, 0}, {0x5580, 0x02, 0, 0}, {0x5583, 0x40, 0, 0},
+	{0x5584, 0x10, 0, 0}, {0x5589, 0x10, 0, 0}, {0x558a, 0x00, 0, 0},
+	{0x558b, 0xf8, 0, 0}, {0x5800, 0x23, 0, 0}, {0x5801, 0x14, 0, 0},
+	{0x5802, 0x0f, 0, 0}, {0x5803, 0x0f, 0, 0}, {0x5804, 0x12, 0, 0},
+	{0x5805, 0x26, 0, 0}, {0x5806, 0x0c, 0, 0}, {0x5807, 0x08, 0, 0},
+	{0x5808, 0x05, 0, 0}, {0x5809, 0x05, 0, 0}, {0x580a, 0x08, 0, 0},
+	{0x580b, 0x0d, 0, 0}, {0x580c, 0x08, 0, 0}, {0x580d, 0x03, 0, 0},
+	{0x580e, 0x00, 0, 0}, {0x580f, 0x00, 0, 0}, {0x5810, 0x03, 0, 0},
+	{0x5811, 0x09, 0, 0}, {0x5812, 0x07, 0, 0}, {0x5813, 0x03, 0, 0},
+	{0x5814, 0x00, 0, 0}, {0x5815, 0x01, 0, 0}, {0x5816, 0x03, 0, 0},
+	{0x5817, 0x08, 0, 0}, {0x5818, 0x0d, 0, 0}, {0x5819, 0x08, 0, 0},
+	{0x581a, 0x05, 0, 0}, {0x581b, 0x06, 0, 0}, {0x581c, 0x08, 0, 0},
+	{0x581d, 0x0e, 0, 0}, {0x581e, 0x29, 0, 0}, {0x581f, 0x17, 0, 0},
+	{0x5820, 0x11, 0, 0}, {0x5821, 0x11, 0, 0}, {0x5822, 0x15, 0, 0},
+	{0x5823, 0x28, 0, 0}, {0x5824, 0x46, 0, 0}, {0x5825, 0x26, 0, 0},
+	{0x5826, 0x08, 0, 0}, {0x5827, 0x26, 0, 0}, {0x5828, 0x64, 0, 0},
+	{0x5829, 0x26, 0, 0}, {0x582a, 0x24, 0, 0}, {0x582b, 0x22, 0, 0},
+	{0x582c, 0x24, 0, 0}, {0x582d, 0x24, 0, 0}, {0x582e, 0x06, 0, 0},
+	{0x582f, 0x22, 0, 0}, {0x5830, 0x40, 0, 0}, {0x5831, 0x42, 0, 0},
+	{0x5832, 0x24, 0, 0}, {0x5833, 0x26, 0, 0}, {0x5834, 0x24, 0, 0},
+	{0x5835, 0x22, 0, 0}, {0x5836, 0x22, 0, 0}, {0x5837, 0x26, 0, 0},
+	{0x5838, 0x44, 0, 0}, {0x5839, 0x24, 0, 0}, {0x583a, 0x26, 0, 0},
+	{0x583b, 0x28, 0, 0}, {0x583c, 0x42, 0, 0}, {0x583d, 0xce, 0, 0},
+	{0x5025, 0x00, 0, 0}, {0x3a0f, 0x30, 0, 0}, {0x3a10, 0x28, 0, 0},
+	{0x3a1b, 0x30, 0, 0}, {0x3a1e, 0x26, 0, 0}, {0x3a11, 0x60, 0, 0},
+	{0x3a1f, 0x14, 0, 0}, {0x3008, 0x02, 0, 0}, {0x3c00, 0x04, 0, 300},
+};
+
+static const struct reg_value ov5640_setting_VGA_640_480[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_XGA_1024_768[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_QVGA_320_240[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_QCIF_176_144[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_NTSC_720_480[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x3c, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_PAL_720_576[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x04, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9b, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x38, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x06, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0xa3, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_720P_1280_720[] = {
+	{0x3c07, 0x07, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x31, 0, 0},
+	{0x3815, 0x31, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0xfa, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x06, 0, 0}, {0x3807, 0xa9, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
+	{0x3618, 0x00, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3709, 0x52, 0, 0}, {0x370c, 0x03, 0, 0}, {0x3a02, 0x02, 0, 0},
+	{0x3a03, 0xe4, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0xbc, 0, 0},
+	{0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x72, 0, 0}, {0x3a0e, 0x01, 0, 0},
+	{0x3a0d, 0x02, 0, 0}, {0x3a14, 0x02, 0, 0}, {0x3a15, 0xe4, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x02, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
+	{0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_1080P_1920_1080[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x11, 0, 0},
+	{0x3815, 0x11, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x00, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9f, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
+	{0x3618, 0x04, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x21, 0, 0},
+	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x35, 0, 0}, {0x460c, 0x22, 0, 0},
+	{0x3824, 0x02, 0, 0}, {0x5001, 0x83, 0, 0},
+	{0x3c07, 0x07, 0, 0}, {0x3c08, 0x00, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3800, 0x01, 0, 0}, {0x3801, 0x50, 0, 0}, {0x3802, 0x01, 0, 0},
+	{0x3803, 0xb2, 0, 0}, {0x3804, 0x08, 0, 0}, {0x3805, 0xef, 0, 0},
+	{0x3806, 0x05, 0, 0}, {0x3807, 0xf1, 0, 0},
+	{0x3612, 0x2b, 0, 0}, {0x3708, 0x64, 0, 0},
+	{0x3a02, 0x04, 0, 0}, {0x3a03, 0x60, 0, 0}, {0x3a08, 0x01, 0, 0},
+	{0x3a09, 0x50, 0, 0}, {0x3a0a, 0x01, 0, 0}, {0x3a0b, 0x18, 0, 0},
+	{0x3a0e, 0x03, 0, 0}, {0x3a0d, 0x04, 0, 0}, {0x3a14, 0x04, 0, 0},
+	{0x3a15, 0x60, 0, 0}, {0x4407, 0x04, 0, 0},
+	{0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0}, {0x3824, 0x04, 0, 0},
+	{0x4005, 0x1a, 0, 0},
+};
+
+static const struct reg_value ov5640_setting_QSXGA_2592_1944[] = {
+	{0x3c07, 0x08, 0, 0},
+	{0x3c09, 0x1c, 0, 0}, {0x3c0a, 0x9c, 0, 0}, {0x3c0b, 0x40, 0, 0},
+	{0x3814, 0x11, 0, 0},
+	{0x3815, 0x11, 0, 0}, {0x3800, 0x00, 0, 0}, {0x3801, 0x00, 0, 0},
+	{0x3802, 0x00, 0, 0}, {0x3803, 0x00, 0, 0}, {0x3804, 0x0a, 0, 0},
+	{0x3805, 0x3f, 0, 0}, {0x3806, 0x07, 0, 0}, {0x3807, 0x9f, 0, 0},
+	{0x3810, 0x00, 0, 0},
+	{0x3811, 0x10, 0, 0}, {0x3812, 0x00, 0, 0}, {0x3813, 0x04, 0, 0},
+	{0x3618, 0x04, 0, 0}, {0x3612, 0x29, 0, 0}, {0x3708, 0x21, 0, 0},
+	{0x3709, 0x12, 0, 0}, {0x370c, 0x00, 0, 0}, {0x3a02, 0x03, 0, 0},
+	{0x3a03, 0xd8, 0, 0}, {0x3a08, 0x01, 0, 0}, {0x3a09, 0x27, 0, 0},
+	{0x3a0a, 0x00, 0, 0}, {0x3a0b, 0xf6, 0, 0}, {0x3a0e, 0x03, 0, 0},
+	{0x3a0d, 0x04, 0, 0}, {0x3a14, 0x03, 0, 0}, {0x3a15, 0xd8, 0, 0},
+	{0x4001, 0x02, 0, 0}, {0x4004, 0x06, 0, 0},
+	{0x4407, 0x04, 0, 0}, {0x460b, 0x37, 0, 0}, {0x460c, 0x20, 0, 0},
+	{0x3824, 0x04, 0, 0}, {0x5001, 0x83, 0, 70},
+};
+
+/* power-on sensor init reg table */
+static const struct ov5640_mode_info ov5640_mode_init_data = {
+	0, SUBSAMPLING, 640, 1896, 480, 984,
+	ov5640_init_setting_30fps_VGA,
+	ARRAY_SIZE(ov5640_init_setting_30fps_VGA),
+	OV5640_30_FPS,
+};
+
+static const struct ov5640_mode_info
+ov5640_mode_data[OV5640_NUM_MODES] = {
+	{OV5640_MODE_QCIF_176_144, SUBSAMPLING,
+	 176, 1896, 144, 984,
+	 ov5640_setting_QCIF_176_144,
+	 ARRAY_SIZE(ov5640_setting_QCIF_176_144),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QVGA_320_240, SUBSAMPLING,
+	 320, 1896, 240, 984,
+	 ov5640_setting_QVGA_320_240,
+	 ARRAY_SIZE(ov5640_setting_QVGA_320_240),
+	 OV5640_30_FPS},
+	{OV5640_MODE_VGA_640_480, SUBSAMPLING,
+	 640, 1896, 480, 1080,
+	 ov5640_setting_VGA_640_480,
+	 ARRAY_SIZE(ov5640_setting_VGA_640_480),
+	 OV5640_60_FPS},
+	{OV5640_MODE_NTSC_720_480, SUBSAMPLING,
+	 720, 1896, 480, 984,
+	 ov5640_setting_NTSC_720_480,
+	 ARRAY_SIZE(ov5640_setting_NTSC_720_480),
+	OV5640_30_FPS},
+	{OV5640_MODE_PAL_720_576, SUBSAMPLING,
+	 720, 1896, 576, 984,
+	 ov5640_setting_PAL_720_576,
+	 ARRAY_SIZE(ov5640_setting_PAL_720_576),
+	 OV5640_30_FPS},
+	{OV5640_MODE_XGA_1024_768, SUBSAMPLING,
+	 1024, 1896, 768, 1080,
+	 ov5640_setting_XGA_1024_768,
+	 ARRAY_SIZE(ov5640_setting_XGA_1024_768),
+	 OV5640_30_FPS},
+	{OV5640_MODE_720P_1280_720, SUBSAMPLING,
+	 1280, 1892, 720, 740,
+	 ov5640_setting_720P_1280_720,
+	 ARRAY_SIZE(ov5640_setting_720P_1280_720),
+	 OV5640_30_FPS},
+	{OV5640_MODE_1080P_1920_1080, SCALING,
+	 1920, 2500, 1080, 1120,
+	 ov5640_setting_1080P_1920_1080,
+	 ARRAY_SIZE(ov5640_setting_1080P_1920_1080),
+	 OV5640_30_FPS},
+	{OV5640_MODE_QSXGA_2592_1944, SCALING,
+	 2592, 2844, 1944, 1968,
+	 ov5640_setting_QSXGA_2592_1944,
+	 ARRAY_SIZE(ov5640_setting_QSXGA_2592_1944),
+	 OV5640_15_FPS},
+};
+
+static int ov5640_init_slave_id(struct ov5640_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg;
+	u8 buf[3];
+	int ret;
+
+	if (client->addr == OV5640_DEFAULT_SLAVE_ID)
+		return 0;
+
+	buf[0] = OV5640_REG_SLAVE_ID >> 8;
+	buf[1] = OV5640_REG_SLAVE_ID & 0xff;
+	buf[2] = client->addr << 1;
+
+	msg.addr = OV5640_DEFAULT_SLAVE_ID;
+	msg.flags = 0;
+	msg.buf = buf;
+	msg.len = sizeof(buf);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: failed with %d\n", __func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ov5640_write_reg(struct ov5640_dev *sensor, u16 reg, u8 val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg;
+	u8 buf[3];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	buf[2] = val;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.buf = buf;
+	msg.len = sizeof(buf);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x, val=%x\n",
+			__func__, reg, val);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ov5640_read_reg(struct ov5640_dev *sensor, u16 reg, u8 *val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = buf;
+	msg[0].len = sizeof(buf);
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = 1;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x\n",
+			__func__, reg);
+		return ret;
+	}
+
+	*val = buf[0];
+	return 0;
+}
+
+static int ov5640_read_reg16(struct ov5640_dev *sensor, u16 reg, u16 *val)
+{
+	u8 hi, lo;
+	int ret;
+
+	ret = ov5640_read_reg(sensor, reg, &hi);
+	if (ret)
+		return ret;
+	ret = ov5640_read_reg(sensor, reg + 1, &lo);
+	if (ret)
+		return ret;
+
+	*val = ((u16)hi << 8) | (u16)lo;
+	return 0;
+}
+
+static int ov5640_write_reg16(struct ov5640_dev *sensor, u16 reg, u16 val)
+{
+	int ret;
+
+	ret = ov5640_write_reg(sensor, reg, val >> 8);
+	if (ret)
+		return ret;
+
+	return ov5640_write_reg(sensor, reg + 1, val & 0xff);
+}
+
+static int ov5640_mod_reg(struct ov5640_dev *sensor, u16 reg,
+			  u8 mask, u8 val)
+{
+	u8 readval;
+	int ret;
+
+	ret = ov5640_read_reg(sensor, reg, &readval);
+	if (ret)
+		return ret;
+
+	readval &= ~mask;
+	val &= mask;
+	val |= readval;
+
+	return ov5640_write_reg(sensor, reg, val);
+}
+
+/*
+ * After trying the various combinations, reading various
+ * documentations spread around the net, and from the various
+ * feedback, the clock tree is probably as follows:
+ *
+ *   +--------------+
+ *   |  Ext. Clock  |
+ *   +-+------------+
+ *     |  +----------+
+ *     +->|   PLL1   | - reg 0x3036, for the multiplier
+ *        +-+--------+ - reg 0x3037, bits 0-3 for the pre-divider
+ *          |  +--------------+
+ *          +->| System Clock |  - reg 0x3035, bits 4-7
+ *             +-+------------+
+ *               |  +--------------+
+ *               +->| MIPI Divider | - reg 0x3035, bits 0-3
+ *               |  +-+------------+
+ *               |    +----------------> MIPI SCLK
+ *               |    +  +-----+
+ *               |    +->| / 2 |-------> MIPI BIT CLK
+ *               |       +-----+
+ *               |  +--------------+
+ *               +->| PLL Root Div | - reg 0x3037, bit 4
+ *                  +-+------------+
+ *                    |  +---------+
+ *                    +->| Bit Div | - reg 0x3034, bits 0-3
+ *                       +-+-------+
+ *                         |  +-------------+
+ *                         +->| SCLK Div    | - reg 0x3108, bits 0-1
+ *                         |  +-+-----------+
+ *                         |    +---------------> SCLK
+ *                         |  +-------------+
+ *                         +->| SCLK 2X Div | - reg 0x3108, bits 2-3
+ *                         |  +-+-----------+
+ *                         |    +---------------> SCLK 2X
+ *                         |  +-------------+
+ *                         +->| PCLK Div    | - reg 0x3108, bits 4-5
+ *                            ++------------+
+ *                             +  +-----------+
+ *                             +->|   P_DIV   | - reg 0x3035, bits 0-3
+ *                                +-----+-----+
+ *                                       +------------> PCLK
+ *
+ * This is deviating from the datasheet at least for the register
+ * 0x3108, since it's said here that the PCLK would be clocked from
+ * the PLL.
+ *
+ * There seems to be also (unverified) constraints:
+ *  - the PLL pre-divider output rate should be in the 4-27MHz range
+ *  - the PLL multiplier output rate should be in the 500-1000MHz range
+ *  - PCLK >= SCLK * 2 in YUV, >= SCLK in Raw or JPEG
+ *
+ * In the two latter cases, these constraints are met since our
+ * factors are hardcoded. If we were to change that, we would need to
+ * take this into account. The only varying parts are the PLL
+ * multiplier and the system clock divider, which are shared between
+ * all these clocks so won't cause any issue.
+ */
+
+/*
+ * This is supposed to be ranging from 1 to 8, but the value is always
+ * set to 3 in the vendor kernels.
+ */
+#define OV5640_PLL_PREDIV	3
+
+#define OV5640_PLL_MULT_MIN	4
+#define OV5640_PLL_MULT_MAX	252
+
+/*
+ * This is supposed to be ranging from 1 to 16, but the value is
+ * always set to either 1 or 2 in the vendor kernels.
+ */
+#define OV5640_SYSDIV_MIN	1
+#define OV5640_SYSDIV_MAX	16
+
+/*
+ * Hardcode these values for scaler and non-scaler modes.
+ * FIXME: to be re-calcualted for 1 data lanes setups
+ */
+#define OV5640_MIPI_DIV_PCLK	2
+#define OV5640_MIPI_DIV_SCLK	1
+
+/*
+ * This is supposed to be ranging from 1 to 2, but the value is always
+ * set to 2 in the vendor kernels.
+ */
+#define OV5640_PLL_ROOT_DIV			2
+#define OV5640_PLL_CTRL3_PLL_ROOT_DIV_2		BIT(4)
+
+/*
+ * We only supports 8-bit formats at the moment
+ */
+#define OV5640_BIT_DIV				2
+#define OV5640_PLL_CTRL0_MIPI_MODE_8BIT		0x08
+
+/*
+ * This is supposed to be ranging from 1 to 8, but the value is always
+ * set to 2 in the vendor kernels.
+ */
+#define OV5640_SCLK_ROOT_DIV	2
+
+/*
+ * This is hardcoded so that the consistency is maintained between SCLK and
+ * SCLK 2x.
+ */
+#define OV5640_SCLK2X_ROOT_DIV (OV5640_SCLK_ROOT_DIV / 2)
+
+/*
+ * This is supposed to be ranging from 1 to 8, but the value is always
+ * set to 1 in the vendor kernels.
+ */
+#define OV5640_PCLK_ROOT_DIV			1
+#define OV5640_PLL_SYS_ROOT_DIVIDER_BYPASS	0x00
+
+static unsigned long ov5640_compute_sys_clk(struct ov5640_dev *sensor,
+					    u8 pll_prediv, u8 pll_mult,
+					    u8 sysdiv)
+{
+	unsigned long sysclk = sensor->xclk_freq / pll_prediv * pll_mult;
+
+	/* PLL1 output cannot exceed 1GHz. */
+	if (sysclk / 1000000 > 1000)
+		return 0;
+
+	return sysclk / sysdiv;
+}
+
+static unsigned long ov5640_calc_sys_clk(struct ov5640_dev *sensor,
+					 unsigned long rate,
+					 u8 *pll_prediv, u8 *pll_mult,
+					 u8 *sysdiv)
+{
+	unsigned long best = ~0;
+	u8 best_sysdiv = 1, best_mult = 1;
+	u8 _sysdiv, _pll_mult;
+
+	for (_sysdiv = OV5640_SYSDIV_MIN;
+	     _sysdiv <= OV5640_SYSDIV_MAX;
+	     _sysdiv++) {
+		for (_pll_mult = OV5640_PLL_MULT_MIN;
+		     _pll_mult <= OV5640_PLL_MULT_MAX;
+		     _pll_mult++) {
+			unsigned long _rate;
+
+			/*
+			 * The PLL multiplier cannot be odd if above
+			 * 127.
+			 */
+			if (_pll_mult > 127 && (_pll_mult % 2))
+				continue;
+
+			_rate = ov5640_compute_sys_clk(sensor,
+						       OV5640_PLL_PREDIV,
+						       _pll_mult, _sysdiv);
+
+			/*
+			 * We have reached the maximum allowed PLL1 output,
+			 * increase sysdiv.
+			 */
+			if (!_rate)
+				break;
+
+			/*
+			 * Prefer rates above the expected clock rate than
+			 * below, even if that means being less precise.
+			 */
+			if (_rate < rate)
+				continue;
+
+			if (abs(rate - _rate) < abs(rate - best)) {
+				best = _rate;
+				best_sysdiv = _sysdiv;
+				best_mult = _pll_mult;
+			}
+
+			if (_rate == rate)
+				goto out;
+		}
+	}
+
+out:
+	*sysdiv = best_sysdiv;
+	*pll_prediv = OV5640_PLL_PREDIV;
+	*pll_mult = best_mult;
+
+	return best;
+}
+
+/*
+ * ov5640_set_mipi_pclk() - Calculate the clock tree configuration values
+ *			    for the MIPI CSI-2 output.
+ *
+ * @rate: The requested bandwidth per lane in bytes per second.
+ *	  'Bandwidth Per Lane' is calculated as:
+ *	  bpl = HTOT * VTOT * FPS * bpp / num_lanes;
+ *
+ * This function use the requested bandwidth to calculate:
+ * - sample_rate = bpl / (bpp / num_lanes);
+ *	         = bpl / (PLL_RDIV * BIT_DIV * PCLK_DIV * MIPI_DIV / num_lanes);
+ *
+ * - mipi_sclk   = bpl / MIPI_DIV / 2; ( / 2 is for CSI-2 DDR)
+ *
+ * with these fixed parameters:
+ *	PLL_RDIV	= 2;
+ *	BIT_DIVIDER	= 2; (MIPI_BIT_MODE == 8 ? 2 : 2,5);
+ *	PCLK_DIV	= 1;
+ *
+ * The MIPI clock generation differs for modes that use the scaler and modes
+ * that do not. In case the scaler is in use, the MIPI_SCLK generates the MIPI
+ * BIT CLk, and thus:
+ *
+ * - mipi_sclk = bpl / MIPI_DIV / 2;
+ *   MIPI_DIV = 1;
+ *
+ * For modes that do not go through the scaler, the MIPI BIT CLOCK is generated
+ * from the pixel clock, and thus:
+ *
+ * - sample_rate = bpl / (bpp / num_lanes);
+ *	         = bpl / (2 * 2 * 1 * MIPI_DIV / num_lanes);
+ *		 = bpl / (4 * MIPI_DIV / num_lanes);
+ * - MIPI_DIV	 = bpp / (4 * num_lanes);
+ *
+ * FIXME: this have been tested with 16bpp and 2 lanes setup only.
+ * MIPI_DIV is fixed to value 2, but it -might- be changed according to the
+ * above formula for setups with 1 lane or image formats with different bpp.
+ *
+ * FIXME: this deviates from the sensor manual documentation which is quite
+ * thin on the MIPI clock tree generation part.
+ */
+static int ov5640_set_mipi_pclk(struct ov5640_dev *sensor,
+				unsigned long rate)
+{
+	const struct ov5640_mode_info *mode = sensor->current_mode;
+	u8 prediv, mult, sysdiv;
+	u8 mipi_div;
+	int ret;
+
+	/*
+	 * 1280x720 is reported to use 'SUBSAMPLING' only,
+	 * but according to the sensor manual it goes through the
+	 * scaler before subsampling.
+	 */
+	if (mode->dn_mode == SCALING ||
+	   (mode->id == OV5640_MODE_720P_1280_720))
+		mipi_div = OV5640_MIPI_DIV_SCLK;
+	else
+		mipi_div = OV5640_MIPI_DIV_PCLK;
+
+	ov5640_calc_sys_clk(sensor, rate, &prediv, &mult, &sysdiv);
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL0,
+			     0x0f, OV5640_PLL_CTRL0_MIPI_MODE_8BIT);
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL1,
+			     0xff, sysdiv << 4 | mipi_div);
+	if (ret)
+		return ret;
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL2, 0xff, mult);
+	if (ret)
+		return ret;
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL3,
+			     0x1f, OV5640_PLL_CTRL3_PLL_ROOT_DIV_2 | prediv);
+	if (ret)
+		return ret;
+
+	return ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER,
+			      0x30, OV5640_PLL_SYS_ROOT_DIVIDER_BYPASS);
+}
+
+static unsigned long ov5640_calc_pclk(struct ov5640_dev *sensor,
+				      unsigned long rate,
+				      u8 *pll_prediv, u8 *pll_mult, u8 *sysdiv,
+				      u8 *pll_rdiv, u8 *bit_div, u8 *pclk_div)
+{
+	unsigned long _rate = rate * OV5640_PLL_ROOT_DIV * OV5640_BIT_DIV *
+				OV5640_PCLK_ROOT_DIV;
+
+	_rate = ov5640_calc_sys_clk(sensor, _rate, pll_prediv, pll_mult,
+				    sysdiv);
+	*pll_rdiv = OV5640_PLL_ROOT_DIV;
+	*bit_div = OV5640_BIT_DIV;
+	*pclk_div = OV5640_PCLK_ROOT_DIV;
+
+	return _rate / *pll_rdiv / *bit_div / *pclk_div;
+}
+
+static int ov5640_set_dvp_pclk(struct ov5640_dev *sensor, unsigned long rate)
+{
+	u8 prediv, mult, sysdiv, pll_rdiv, bit_div, pclk_div;
+	int ret;
+
+	ov5640_calc_pclk(sensor, rate, &prediv, &mult, &sysdiv, &pll_rdiv,
+			 &bit_div, &pclk_div);
+
+#ifndef CONFIG_VIN_SENSOR_OV5640
+	if (bit_div == 2)
+		bit_div = 8;
+#else
+	bit_div = 0xa;
+#endif
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL0,
+			     0x0f, bit_div);
+	if (ret)
+		return ret;
+
+	/*
+	 * We need to set sysdiv according to the clock, and to clear
+	 * the MIPI divider.
+	 */
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL1,
+			     0xff, sysdiv << 4);
+	if (ret)
+		return ret;
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL2,
+			     0xff, mult);
+	if (ret)
+		return ret;
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SC_PLL_CTRL3,
+			     0x1f, prediv | ((pll_rdiv - 1) << 4));
+	if (ret)
+		return ret;
+
+	return ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x30,
+			      (ilog2(pclk_div) << 4));
+}
+
+/* set JPEG framing sizes */
+static int ov5640_set_jpeg_timings(struct ov5640_dev *sensor,
+				   const struct ov5640_mode_info *mode)
+{
+	int ret;
+
+	/*
+	 * compression mode 3 timing
+	 *
+	 * Data is transmitted with programmable width (VFIFO_HSIZE).
+	 * No padding done. Last line may have less data. Varying
+	 * number of lines per frame, depending on amount of data.
+	 */
+	ret = ov5640_mod_reg(sensor, OV5640_REG_JPG_MODE_SELECT, 0x7, 0x3);
+	if (ret < 0)
+		return ret;
+
+	ret = ov5640_write_reg16(sensor, OV5640_REG_VFIFO_HSIZE, mode->hact);
+	if (ret < 0)
+		return ret;
+
+	return ov5640_write_reg16(sensor, OV5640_REG_VFIFO_VSIZE, mode->vact);
+}
+
+/* download ov5640 settings to sensor through i2c */
+static int ov5640_set_timings(struct ov5640_dev *sensor,
+			      const struct ov5640_mode_info *mode)
+{
+	int ret;
+
+	if (sensor->fmt.code == MEDIA_BUS_FMT_JPEG_1X8) {
+		ret = ov5640_set_jpeg_timings(sensor, mode);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPHO, mode->hact);
+	if (ret < 0)
+		return ret;
+
+	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_DVPVO, mode->vact);
+	if (ret < 0)
+		return ret;
+
+	ret = ov5640_write_reg16(sensor, OV5640_REG_TIMING_HTS, mode->htot);
+	if (ret < 0)
+		return ret;
+
+	return ov5640_write_reg16(sensor, OV5640_REG_TIMING_VTS, mode->vtot);
+}
+
+static int ov5640_load_regs(struct ov5640_dev *sensor,
+			    const struct ov5640_mode_info *mode)
+{
+	const struct reg_value *regs = mode->reg_data;
+	unsigned int i;
+	u32 delay_ms;
+	u16 reg_addr;
+	u8 mask, val;
+	int ret = 0;
+
+	st_info(ST_SENSOR, "%s, mode = 0x%x\n", __func__, mode->id);
+	for (i = 0; i < mode->reg_data_size; ++i, ++regs) {
+		delay_ms = regs->delay_ms;
+		reg_addr = regs->reg_addr;
+		val = regs->val;
+		mask = regs->mask;
+
+		/* remain in power down mode for DVP */
+		if (regs->reg_addr == OV5640_REG_SYS_CTRL0 &&
+		    val == OV5640_REG_SYS_CTRL0_SW_PWUP &&
+		    sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY)
+			continue;
+
+		if (mask)
+			ret = ov5640_mod_reg(sensor, reg_addr, mask, val);
+		else
+			ret = ov5640_write_reg(sensor, reg_addr, val);
+		if (ret)
+			break;
+
+		if (delay_ms)
+			usleep_range(1000 * delay_ms, 1000 * delay_ms + 100);
+	}
+
+	return ov5640_set_timings(sensor, mode);
+}
+
+static int ov5640_set_autoexposure(struct ov5640_dev *sensor, bool on)
+{
+	return ov5640_mod_reg(sensor, OV5640_REG_AEC_PK_MANUAL,
+			      BIT(0), on ? 0 : BIT(0));
+}
+
+/* read exposure, in number of line periods */
+static int ov5640_get_exposure(struct ov5640_dev *sensor)
+{
+	int exp, ret;
+	u8 temp;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_AEC_PK_EXPOSURE_HI, &temp);
+	if (ret)
+		return ret;
+	exp = ((int)temp & 0x0f) << 16;
+	ret = ov5640_read_reg(sensor, OV5640_REG_AEC_PK_EXPOSURE_MED, &temp);
+	if (ret)
+		return ret;
+	exp |= ((int)temp << 8);
+	ret = ov5640_read_reg(sensor, OV5640_REG_AEC_PK_EXPOSURE_LO, &temp);
+	if (ret)
+		return ret;
+	exp |= (int)temp;
+
+	return exp >> 4;
+}
+
+/* write exposure, given number of line periods */
+static int ov5640_set_exposure(struct ov5640_dev *sensor, u32 exposure)
+{
+	int ret;
+
+	exposure <<= 4;
+
+	ret = ov5640_write_reg(sensor,
+			       OV5640_REG_AEC_PK_EXPOSURE_LO,
+			       exposure & 0xff);
+	if (ret)
+		return ret;
+	ret = ov5640_write_reg(sensor,
+			       OV5640_REG_AEC_PK_EXPOSURE_MED,
+			       (exposure >> 8) & 0xff);
+	if (ret)
+		return ret;
+	return ov5640_write_reg(sensor,
+				OV5640_REG_AEC_PK_EXPOSURE_HI,
+				(exposure >> 16) & 0x0f);
+}
+
+static int ov5640_get_gain(struct ov5640_dev *sensor)
+{
+	u16 gain;
+	int ret;
+
+	ret = ov5640_read_reg16(sensor, OV5640_REG_AEC_PK_REAL_GAIN, &gain);
+	if (ret)
+		return ret;
+
+	return gain & 0x3ff;
+}
+
+static int ov5640_set_gain(struct ov5640_dev *sensor, int gain)
+{
+	return ov5640_write_reg16(sensor, OV5640_REG_AEC_PK_REAL_GAIN,
+				  (u16)gain & 0x3ff);
+}
+
+static int ov5640_set_autogain(struct ov5640_dev *sensor, bool on)
+{
+	return ov5640_mod_reg(sensor, OV5640_REG_AEC_PK_MANUAL,
+			      BIT(1), on ? 0 : BIT(1));
+}
+
+static int ov5640_set_stream_dvp(struct ov5640_dev *sensor, bool on)
+{
+	return ov5640_write_reg(sensor, OV5640_REG_SYS_CTRL0, on ?
+				OV5640_REG_SYS_CTRL0_SW_PWUP :
+				OV5640_REG_SYS_CTRL0_SW_PWDN);
+}
+
+static int ov5640_set_stream_mipi(struct ov5640_dev *sensor, bool on)
+{
+	int ret;
+
+	/*
+	 * Enable/disable the MIPI interface
+	 *
+	 * 0x300e = on ? 0x45 : 0x40
+	 *
+	 * FIXME: the sensor manual (version 2.03) reports
+	 * [7:5] = 000  : 1 data lane mode
+	 * [7:5] = 001  : 2 data lanes mode
+	 * But this settings do not work, while the following ones
+	 * have been validated for 2 data lanes mode.
+	 *
+	 * [7:5] = 010	: 2 data lanes mode
+	 * [4] = 0	: Power up MIPI HS Tx
+	 * [3] = 0	: Power up MIPI LS Rx
+	 * [2] = 1/0	: MIPI interface enable/disable
+	 * [1:0] = 01/00: FIXME: 'debug'
+	 */
+	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00,
+			       on ? 0x45 : 0x40);
+	if (ret)
+		return ret;
+
+	return ov5640_write_reg(sensor, OV5640_REG_FRAME_CTRL01,
+				on ? 0x00 : 0x0f);
+}
+
+static int ov5640_get_sysclk(struct ov5640_dev *sensor)
+{
+	 /* calculate sysclk */
+	u32 xvclk = sensor->xclk_freq / 10000;
+	u32 multiplier, prediv, VCO, sysdiv, pll_rdiv;
+	u32 sclk_rdiv_map[] = {1, 2, 4, 8};
+	u32 bit_div2x = 1, sclk_rdiv, sysclk;
+	u8 temp1, temp2;
+	int ret;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_SC_PLL_CTRL0, &temp1);
+	if (ret)
+		return ret;
+	temp2 = temp1 & 0x0f;
+	if (temp2 == 8 || temp2 == 10)
+		bit_div2x = temp2 / 2;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_SC_PLL_CTRL1, &temp1);
+	if (ret)
+		return ret;
+	sysdiv = temp1 >> 4;
+	if (sysdiv == 0)
+		sysdiv = 16;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_SC_PLL_CTRL2, &temp1);
+	if (ret)
+		return ret;
+	multiplier = temp1;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_SC_PLL_CTRL3, &temp1);
+	if (ret)
+		return ret;
+	prediv = temp1 & 0x0f;
+	pll_rdiv = ((temp1 >> 4) & 0x01) + 1;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, &temp1);
+	if (ret)
+		return ret;
+	temp2 = temp1 & 0x03;
+	sclk_rdiv = sclk_rdiv_map[temp2];
+
+	if (!prediv || !sysdiv || !pll_rdiv || !bit_div2x)
+		return -EINVAL;
+
+	VCO = xvclk * multiplier / prediv;
+
+	sysclk = VCO / sysdiv / pll_rdiv * 2 / bit_div2x / sclk_rdiv;
+
+	return sysclk;
+}
+
+static int ov5640_set_night_mode(struct ov5640_dev *sensor)
+{
+	 /* read HTS from register settings */
+	u8 mode;
+	int ret;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_AEC_CTRL00, &mode);
+	if (ret)
+		return ret;
+	mode &= 0xfb;
+	return ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL00, mode);
+}
+
+static int ov5640_get_hts(struct ov5640_dev *sensor)
+{
+	/* read HTS from register settings */
+	u16 hts;
+	int ret;
+
+	ret = ov5640_read_reg16(sensor, OV5640_REG_TIMING_HTS, &hts);
+	if (ret)
+		return ret;
+	return hts;
+}
+
+static int ov5640_get_vts(struct ov5640_dev *sensor)
+{
+	u16 vts;
+	int ret;
+
+	ret = ov5640_read_reg16(sensor, OV5640_REG_TIMING_VTS, &vts);
+	if (ret)
+		return ret;
+	return vts;
+}
+
+static int ov5640_set_vts(struct ov5640_dev *sensor, int vts)
+{
+	return ov5640_write_reg16(sensor, OV5640_REG_TIMING_VTS, vts);
+}
+
+static int ov5640_get_light_freq(struct ov5640_dev *sensor)
+{
+	/* get banding filter value */
+	int ret, light_freq = 0;
+	u8 temp, temp1;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_HZ5060_CTRL01, &temp);
+	if (ret)
+		return ret;
+
+	if (temp & 0x80) {
+		/* manual */
+		ret = ov5640_read_reg(sensor, OV5640_REG_HZ5060_CTRL00,
+				      &temp1);
+		if (ret)
+			return ret;
+		if (temp1 & 0x04) {
+			/* 50Hz */
+			light_freq = 50;
+		} else {
+			/* 60Hz */
+			light_freq = 60;
+		}
+	} else {
+		/* auto */
+		ret = ov5640_read_reg(sensor, OV5640_REG_SIGMADELTA_CTRL0C,
+				      &temp1);
+		if (ret)
+			return ret;
+
+		if (temp1 & 0x01) {
+			/* 50Hz */
+			light_freq = 50;
+		} else {
+			/* 60Hz */
+		}
+	}
+
+	return light_freq;
+}
+
+static int ov5640_set_bandingfilter(struct ov5640_dev *sensor)
+{
+	u32 band_step60, max_band60, band_step50, max_band50, prev_vts;
+	int ret;
+
+	/* read preview PCLK */
+	ret = ov5640_get_sysclk(sensor);
+	if (ret < 0)
+		return ret;
+	if (ret == 0)
+		return -EINVAL;
+	sensor->prev_sysclk = ret;
+	/* read preview HTS */
+	ret = ov5640_get_hts(sensor);
+	if (ret < 0)
+		return ret;
+	if (ret == 0)
+		return -EINVAL;
+	sensor->prev_hts = ret;
+
+	/* read preview VTS */
+	ret = ov5640_get_vts(sensor);
+	if (ret < 0)
+		return ret;
+	prev_vts = ret;
+
+	/* calculate banding filter */
+	/* 60Hz */
+	band_step60 = sensor->prev_sysclk * 100 / sensor->prev_hts * 100 / 120;
+	ret = ov5640_write_reg16(sensor, OV5640_REG_AEC_B60_STEP, band_step60);
+	if (ret)
+		return ret;
+	if (!band_step60)
+		return -EINVAL;
+	max_band60 = (int)((prev_vts - 4) / band_step60);
+	ret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL0D, max_band60);
+	if (ret)
+		return ret;
+
+	/* 50Hz */
+	band_step50 = sensor->prev_sysclk * 100 / sensor->prev_hts;
+	ret = ov5640_write_reg16(sensor, OV5640_REG_AEC_B50_STEP, band_step50);
+	if (ret)
+		return ret;
+	if (!band_step50)
+		return -EINVAL;
+	max_band50 = (int)((prev_vts - 4) / band_step50);
+	return ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL0E, max_band50);
+}
+
+static int ov5640_set_ae_target(struct ov5640_dev *sensor, int target)
+{
+	/* stable in high */
+	u32 fast_high, fast_low;
+	int ret;
+
+	sensor->ae_low = target * 23 / 25;	/* 0.92 */
+	sensor->ae_high = target * 27 / 25;	/* 1.08 */
+
+	fast_high = sensor->ae_high << 1;
+	if (fast_high > 255)
+		fast_high = 255;
+
+	fast_low = sensor->ae_low >> 1;
+
+	ret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL0F, sensor->ae_high);
+	if (ret)
+		return ret;
+	ret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL10, sensor->ae_low);
+	if (ret)
+		return ret;
+	ret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL1B, sensor->ae_high);
+	if (ret)
+		return ret;
+	ret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL1E, sensor->ae_low);
+	if (ret)
+		return ret;
+	ret = ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL11, fast_high);
+	if (ret)
+		return ret;
+	return ov5640_write_reg(sensor, OV5640_REG_AEC_CTRL1F, fast_low);
+}
+
+static int ov5640_get_binning(struct ov5640_dev *sensor)
+{
+	u8 temp;
+	int ret;
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_TIMING_TC_REG21, &temp);
+	if (ret)
+		return ret;
+
+	return temp & BIT(0);
+}
+
+static int ov5640_set_binning(struct ov5640_dev *sensor, bool enable)
+{
+	int ret;
+
+	/*
+	 * TIMING TC REG21:
+	 * - [0]:	Horizontal binning enable
+	 */
+	ret = ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG21,
+			     BIT(0), enable ? BIT(0) : 0);
+	if (ret)
+		return ret;
+	/*
+	 * TIMING TC REG20:
+	 * - [0]:	Undocumented, but hardcoded init sequences
+	 *		are always setting REG21/REG20 bit 0 to same value...
+	 */
+	return ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG20,
+			      BIT(0), enable ? BIT(0) : 0);
+}
+
+static int ov5640_set_virtual_channel(struct ov5640_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	u8 temp, channel = virtual_channel;
+	int ret;
+
+	if (channel > 3) {
+		dev_err(&client->dev,
+			"%s: wrong virtual_channel parameter, expected (0..3), got %d\n",
+			__func__, channel);
+		return -EINVAL;
+	}
+
+	ret = ov5640_read_reg(sensor, OV5640_REG_DEBUG_MODE, &temp);
+	if (ret)
+		return ret;
+	temp &= ~(3 << 6);
+	temp |= (channel << 6);
+	return ov5640_write_reg(sensor, OV5640_REG_DEBUG_MODE, temp);
+}
+
+static const struct ov5640_mode_info *
+ov5640_find_mode(struct ov5640_dev *sensor, enum ov5640_frame_rate fr,
+		 int width, int height, bool nearest)
+{
+	const struct ov5640_mode_info *mode;
+
+	mode = v4l2_find_nearest_size(ov5640_mode_data,
+				      ARRAY_SIZE(ov5640_mode_data),
+				      hact, vact,
+				      width, height);
+
+	if (!mode ||
+	    (!nearest && (mode->hact != width || mode->vact != height)))
+		return NULL;
+
+	/* Check to see if the current mode exceeds the max frame rate */
+	if (ov5640_framerates[fr] > ov5640_framerates[mode->max_fps])
+		return NULL;
+
+	return mode;
+}
+
+static u64 ov5640_calc_pixel_rate(struct ov5640_dev *sensor)
+{
+	u64 rate;
+
+	rate = sensor->current_mode->vtot * sensor->current_mode->htot;
+	rate *= ov5640_framerates[sensor->current_fr];
+
+	return rate;
+}
+
+/*
+ * sensor changes between scaling and subsampling, go through
+ * exposure calculation
+ */
+static int ov5640_set_mode_exposure_calc(struct ov5640_dev *sensor,
+					 const struct ov5640_mode_info *mode)
+{
+	u32 prev_shutter, prev_gain16;
+	u32 cap_shutter, cap_gain16;
+	u32 cap_sysclk, cap_hts, cap_vts;
+	u32 light_freq, cap_bandfilt, cap_maxband;
+	u32 cap_gain16_shutter;
+	u8 average;
+	int ret;
+
+	if (!mode->reg_data)
+		return -EINVAL;
+
+	/* read preview shutter */
+	ret = ov5640_get_exposure(sensor);
+	if (ret < 0)
+		return ret;
+	prev_shutter = ret;
+	ret = ov5640_get_binning(sensor);
+	if (ret < 0)
+		return ret;
+	if (ret && mode->id != OV5640_MODE_720P_1280_720 &&
+	    mode->id != OV5640_MODE_1080P_1920_1080)
+		prev_shutter *= 2;
+
+	/* read preview gain */
+	ret = ov5640_get_gain(sensor);
+	if (ret < 0)
+		return ret;
+	prev_gain16 = ret;
+
+	/* get average */
+	ret = ov5640_read_reg(sensor, OV5640_REG_AVG_READOUT, &average);
+	if (ret)
+		return ret;
+
+	/* turn off night mode for capture */
+	ret = ov5640_set_night_mode(sensor);
+	if (ret < 0)
+		return ret;
+
+	/* Write capture setting */
+	ret = ov5640_load_regs(sensor, mode);
+	if (ret < 0)
+		return ret;
+
+	/* read capture VTS */
+	ret = ov5640_get_vts(sensor);
+	if (ret < 0)
+		return ret;
+	cap_vts = ret;
+	ret = ov5640_get_hts(sensor);
+	if (ret < 0)
+		return ret;
+	if (ret == 0)
+		return -EINVAL;
+	cap_hts = ret;
+
+	ret = ov5640_get_sysclk(sensor);
+	if (ret < 0)
+		return ret;
+	if (ret == 0)
+		return -EINVAL;
+	cap_sysclk = ret;
+
+	/* calculate capture banding filter */
+	ret = ov5640_get_light_freq(sensor);
+	if (ret < 0)
+		return ret;
+	light_freq = ret;
+
+	if (light_freq == 60) {
+		/* 60Hz */
+		cap_bandfilt = cap_sysclk * 100 / cap_hts * 100 / 120;
+	} else {
+		/* 50Hz */
+		cap_bandfilt = cap_sysclk * 100 / cap_hts;
+	}
+
+	if (!sensor->prev_sysclk) {
+		ret = ov5640_get_sysclk(sensor);
+		if (ret < 0)
+			return ret;
+		if (ret == 0)
+			return -EINVAL;
+		sensor->prev_sysclk = ret;
+	}
+
+	if (!cap_bandfilt)
+		return -EINVAL;
+
+	cap_maxband = (int)((cap_vts - 4) / cap_bandfilt);
+
+	/* calculate capture shutter/gain16 */
+	if (average > sensor->ae_low && average < sensor->ae_high) {
+		/* in stable range */
+		cap_gain16_shutter =
+			prev_gain16 * prev_shutter *
+			cap_sysclk / sensor->prev_sysclk *
+			sensor->prev_hts / cap_hts *
+			sensor->ae_target / average;
+	} else {
+		cap_gain16_shutter =
+			prev_gain16 * prev_shutter *
+			cap_sysclk / sensor->prev_sysclk *
+			sensor->prev_hts / cap_hts;
+	}
+
+	/* gain to shutter */
+	if (cap_gain16_shutter < (cap_bandfilt * 16)) {
+		/* shutter < 1/100 */
+		cap_shutter = cap_gain16_shutter / 16;
+		if (cap_shutter < 1)
+			cap_shutter = 1;
+
+		cap_gain16 = cap_gain16_shutter / cap_shutter;
+		if (cap_gain16 < 16)
+			cap_gain16 = 16;
+	} else {
+		if (cap_gain16_shutter > (cap_bandfilt * cap_maxband * 16)) {
+			/* exposure reach max */
+			cap_shutter = cap_bandfilt * cap_maxband;
+			if (!cap_shutter)
+				return -EINVAL;
+
+			cap_gain16 = cap_gain16_shutter / cap_shutter;
+		} else {
+			/* 1/100 < (cap_shutter = n/100) =< max */
+			cap_shutter =
+				((int)(cap_gain16_shutter / 16 / cap_bandfilt))
+				* cap_bandfilt;
+			if (!cap_shutter)
+				return -EINVAL;
+
+			cap_gain16 = cap_gain16_shutter / cap_shutter;
+		}
+	}
+
+	/* set capture gain */
+	ret = ov5640_set_gain(sensor, cap_gain16);
+	if (ret)
+		return ret;
+
+	/* write capture shutter */
+	if (cap_shutter > (cap_vts - 4)) {
+		cap_vts = cap_shutter + 4;
+		ret = ov5640_set_vts(sensor, cap_vts);
+		if (ret < 0)
+			return ret;
+	}
+
+	/* set exposure */
+	return ov5640_set_exposure(sensor, cap_shutter);
+}
+
+/*
+ * if sensor changes inside scaling or subsampling
+ * change mode directly
+ */
+static int ov5640_set_mode_direct(struct ov5640_dev *sensor,
+				  const struct ov5640_mode_info *mode)
+{
+	if (!mode->reg_data)
+		return -EINVAL;
+
+	/* Write capture setting */
+	return ov5640_load_regs(sensor, mode);
+}
+
+static int ov5640_set_mode(struct ov5640_dev *sensor)
+{
+	const struct ov5640_mode_info *mode = sensor->current_mode;
+	const struct ov5640_mode_info *orig_mode = sensor->last_mode;
+	enum ov5640_downsize_mode dn_mode, orig_dn_mode;
+	bool auto_gain = sensor->ctrls.auto_gain->val == 1;
+	bool auto_exp =  sensor->ctrls.auto_exp->val == V4L2_EXPOSURE_AUTO;
+	unsigned long rate;
+	int ret;
+
+	dn_mode = mode->dn_mode;
+	orig_dn_mode = orig_mode->dn_mode;
+
+	/* auto gain and exposure must be turned off when changing modes */
+	if (auto_gain) {
+		ret = ov5640_set_autogain(sensor, false);
+		if (ret)
+			return ret;
+	}
+
+	if (auto_exp) {
+		ret = ov5640_set_autoexposure(sensor, false);
+		if (ret)
+			goto restore_auto_gain;
+	}
+
+	/*
+	 * All the formats we support have 16 bits per pixel, seems to require
+	 * the same rate than YUV, so we can just use 16 bpp all the time.
+	 */
+	rate = ov5640_calc_pixel_rate(sensor) * 16;
+	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY) {
+		rate = rate / sensor->ep.bus.mipi_csi2.num_data_lanes;
+		ret = ov5640_set_mipi_pclk(sensor, rate);
+	} else {
+		rate = rate / sensor->ep.bus.parallel.bus_width;
+		ret = ov5640_set_dvp_pclk(sensor, rate);
+	}
+
+	if (ret < 0)
+		return 0;
+
+	if ((dn_mode == SUBSAMPLING && orig_dn_mode == SCALING) ||
+	    (dn_mode == SCALING && orig_dn_mode == SUBSAMPLING)) {
+		/*
+		 * change between subsampling and scaling
+		 * go through exposure calculation
+		 */
+		ret = ov5640_set_mode_exposure_calc(sensor, mode);
+	} else {
+		/*
+		 * change inside subsampling or scaling
+		 * download firmware directly
+		 */
+		ret = ov5640_set_mode_direct(sensor, mode);
+	}
+	if (ret < 0)
+		goto restore_auto_exp_gain;
+
+	/* restore auto gain and exposure */
+	if (auto_gain)
+		ov5640_set_autogain(sensor, true);
+	if (auto_exp)
+		ov5640_set_autoexposure(sensor, true);
+
+	ret = ov5640_set_binning(sensor, dn_mode != SCALING);
+	if (ret < 0)
+		return ret;
+	ret = ov5640_set_ae_target(sensor, sensor->ae_target);
+	if (ret < 0)
+		return ret;
+	ret = ov5640_get_light_freq(sensor);
+	if (ret < 0)
+		return ret;
+	ret = ov5640_set_bandingfilter(sensor);
+	if (ret < 0)
+		return ret;
+	ret = ov5640_set_virtual_channel(sensor);
+	if (ret < 0)
+		return ret;
+
+	sensor->pending_mode_change = false;
+	sensor->last_mode = mode;
+
+	return 0;
+
+restore_auto_exp_gain:
+	if (auto_exp)
+		ov5640_set_autoexposure(sensor, true);
+restore_auto_gain:
+	if (auto_gain)
+		ov5640_set_autogain(sensor, true);
+
+	return ret;
+}
+
+static int ov5640_set_framefmt(struct ov5640_dev *sensor,
+			       struct v4l2_mbus_framefmt *format);
+
+/* restore the last set video mode after chip power-on */
+static int ov5640_restore_mode(struct ov5640_dev *sensor)
+{
+	int ret;
+
+	/* first load the initial register values */
+	ret = ov5640_load_regs(sensor, &ov5640_mode_init_data);
+	if (ret < 0)
+		return ret;
+	sensor->last_mode = &ov5640_mode_init_data;
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SYS_ROOT_DIVIDER, 0x3f,
+			     (ilog2(OV5640_SCLK2X_ROOT_DIV) << 2) |
+			     ilog2(OV5640_SCLK_ROOT_DIV));
+	if (ret)
+		return ret;
+
+	/* now restore the last capture mode */
+	ret = ov5640_set_mode(sensor);
+	if (ret < 0)
+		return ret;
+
+	return ov5640_set_framefmt(sensor, &sensor->fmt);
+}
+
+static void ov5640_power(struct ov5640_dev *sensor, bool enable)
+{
+	if (!sensor->pwdn_gpio)
+		return;
+	gpiod_set_value_cansleep(sensor->pwdn_gpio, enable ? 0 : 1);
+}
+
+static void ov5640_reset(struct ov5640_dev *sensor)
+{
+	if (!sensor->reset_gpio)
+		return;
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+
+	/* camera power cycle */
+	ov5640_power(sensor, false);
+	usleep_range(5000, 10000);
+	ov5640_power(sensor, true);
+	usleep_range(5000, 10000);
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 1);
+	usleep_range(1000, 2000);
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+	usleep_range(20000, 25000);
+}
+
+static int ov5640_set_power_on(struct ov5640_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int ret;
+
+	ret = clk_prepare_enable(sensor->xclk);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable clock\n",
+			__func__);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(OV5640_NUM_SUPPLIES,
+				    sensor->supplies);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable regulators\n",
+			__func__);
+		goto xclk_off;
+	}
+
+	ov5640_reset(sensor);
+	ov5640_power(sensor, true);
+
+	ret = ov5640_init_slave_id(sensor);
+	if (ret)
+		goto power_off;
+
+	return 0;
+
+power_off:
+	ov5640_power(sensor, false);
+	regulator_bulk_disable(OV5640_NUM_SUPPLIES, sensor->supplies);
+xclk_off:
+	clk_disable_unprepare(sensor->xclk);
+	return ret;
+}
+
+static void ov5640_set_power_off(struct ov5640_dev *sensor)
+{
+	ov5640_power(sensor, false);
+	regulator_bulk_disable(OV5640_NUM_SUPPLIES, sensor->supplies);
+	clk_disable_unprepare(sensor->xclk);
+}
+
+static int ov5640_set_power_mipi(struct ov5640_dev *sensor, bool on)
+{
+	int ret;
+
+	if (!on) {
+		/* Reset MIPI bus settings to their default values. */
+		ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x58);
+		ov5640_write_reg(sensor, OV5640_REG_MIPI_CTRL00, 0x04);
+		ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT00, 0x00);
+		return 0;
+	}
+
+	/*
+	 * Power up MIPI HS Tx and LS Rx; 2 data lanes mode
+	 *
+	 * 0x300e = 0x40
+	 * [7:5] = 010	: 2 data lanes mode (see FIXME note in
+	 *		  "ov5640_set_stream_mipi()")
+	 * [4] = 0	: Power up MIPI HS Tx
+	 * [3] = 0	: Power up MIPI LS Rx
+	 * [2] = 0	: MIPI interface disabled
+	 */
+	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x40);
+	if (ret)
+		return ret;
+
+	/*
+	 * Gate clock and set LP11 in 'no packets mode' (idle)
+	 *
+	 * 0x4800 = 0x24
+	 * [5] = 1	: Gate clock when 'no packets'
+	 * [2] = 1	: MIPI bus in LP11 when 'no packets'
+	 */
+	ret = ov5640_write_reg(sensor, OV5640_REG_MIPI_CTRL00, 0x24);
+	if (ret)
+		return ret;
+
+	/*
+	 * Set data lanes and clock in LP11 when 'sleeping'
+	 *
+	 * 0x3019 = 0x70
+	 * [6] = 1	: MIPI data lane 2 in LP11 when 'sleeping'
+	 * [5] = 1	: MIPI data lane 1 in LP11 when 'sleeping'
+	 * [4] = 1	: MIPI clock lane in LP11 when 'sleeping'
+	 */
+	ret = ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT00, 0x70);
+	if (ret)
+		return ret;
+
+	/* Give lanes some time to coax into LP11 state. */
+	usleep_range(500, 1000);
+
+	return 0;
+}
+
+static int ov5640_set_power_dvp(struct ov5640_dev *sensor, bool on)
+{
+	unsigned int flags = sensor->ep.bus.parallel.flags;
+	bool bt656 = sensor->ep.bus_type == V4L2_MBUS_BT656;
+	u8 polarities = 0;
+	int ret;
+
+	if (!on) {
+		/* Reset settings to their default values. */
+		ov5640_write_reg(sensor, OV5640_REG_CCIR656_CTRL00, 0x00);
+		ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x58);
+		ov5640_write_reg(sensor, OV5640_REG_POLARITY_CTRL00, 0x20);
+		ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT_ENABLE01, 0x00);
+		ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT_ENABLE02, 0x00);
+		return 0;
+	}
+
+	/*
+	 * Note about parallel port configuration.
+	 *
+	 * When configured in parallel mode, the OV5640 will
+	 * output 10 bits data on DVP data lines [9:0].
+	 * If only 8 bits data are wanted, the 8 bits data lines
+	 * of the camera interface must be physically connected
+	 * on the DVP data lines [9:2].
+	 *
+	 * Control lines polarity can be configured through
+	 * devicetree endpoint control lines properties.
+	 * If no endpoint control lines properties are set,
+	 * polarity will be as below:
+	 * - VSYNC:	active high
+	 * - HREF:	active low
+	 * - PCLK:	active low
+	 *
+	 * VSYNC & HREF are not configured if BT656 bus mode is selected
+	 */
+
+	/*
+	 * BT656 embedded synchronization configuration
+	 *
+	 * CCIR656 CTRL00
+	 * - [7]:	SYNC code selection (0: auto generate sync code,
+	 *		1: sync code from regs 0x4732-0x4735)
+	 * - [6]:	f value in CCIR656 SYNC code when fixed f value
+	 * - [5]:	Fixed f value
+	 * - [4:3]:	Blank toggle data options (00: data=1'h040/1'h200,
+	 *		01: data from regs 0x4736-0x4738, 10: always keep 0)
+	 * - [1]:	Clip data disable
+	 * - [0]:	CCIR656 mode enable
+	 *
+	 * Default CCIR656 SAV/EAV mode with default codes
+	 * SAV=0xff000080 & EAV=0xff00009d is enabled here with settings:
+	 * - CCIR656 mode enable
+	 * - auto generation of sync codes
+	 * - blank toggle data 1'h040/1'h200
+	 * - clip reserved data (0x00 & 0xff changed to 0x01 & 0xfe)
+	 */
+	ret = ov5640_write_reg(sensor, OV5640_REG_CCIR656_CTRL00,
+			       bt656 ? 0x01 : 0x00);
+	if (ret)
+		return ret;
+
+	/*
+	 * configure parallel port control lines polarity
+	 *
+	 * POLARITY CTRL0
+	 * - [5]:	PCLK polarity (0: active low, 1: active high)
+	 * - [1]:	HREF polarity (0: active low, 1: active high)
+	 * - [0]:	VSYNC polarity (mismatch here between
+	 *		datasheet and hardware, 0 is active high
+	 *		and 1 is active low...)
+	 */
+	if (!bt656) {
+		if (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+			polarities |= BIT(1);
+		if (flags & V4L2_MBUS_VSYNC_ACTIVE_LOW)
+			polarities |= BIT(0);
+	}
+	if (flags & V4L2_MBUS_PCLK_SAMPLE_RISING)
+		polarities |= BIT(5);
+
+	ret = ov5640_write_reg(sensor, OV5640_REG_POLARITY_CTRL00, polarities);
+	if (ret)
+		return ret;
+
+	/*
+	 * powerdown MIPI TX/RX PHY & enable DVP
+	 *
+	 * MIPI CONTROL 00
+	 * [4] = 1	: Power down MIPI HS Tx
+	 * [3] = 1	: Power down MIPI LS Rx
+	 * [2] = 0	: DVP enable (MIPI disable)
+	 */
+	ret = ov5640_write_reg(sensor, OV5640_REG_IO_MIPI_CTRL00, 0x58);
+	if (ret)
+		return ret;
+
+	/*
+	 * enable VSYNC/HREF/PCLK DVP control lines
+	 * & D[9:6] DVP data lines
+	 *
+	 * PAD OUTPUT ENABLE 01
+	 * - 6:		VSYNC output enable
+	 * - 5:		HREF output enable
+	 * - 4:		PCLK output enable
+	 * - [3:0]:	D[9:6] output enable
+	 */
+	ret = ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT_ENABLE01,
+			       bt656 ? 0x1f : 0x7f);
+	if (ret)
+		return ret;
+
+	/*
+	 * enable D[5:0] DVP data lines
+	 *
+	 * PAD OUTPUT ENABLE 02
+	 * - [7:2]:	D[5:0] output enable
+	 */
+	return ov5640_write_reg(sensor, OV5640_REG_PAD_OUTPUT_ENABLE02, 0xfc);
+}
+
+static int ov5640_set_power(struct ov5640_dev *sensor, bool on)
+{
+	int ret = 0;
+
+	if (on) {
+		ret = ov5640_set_power_on(sensor);
+		if (ret)
+			return ret;
+
+		ret = ov5640_restore_mode(sensor);
+		if (ret)
+			goto power_off;
+	}
+
+	if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)
+		ret = ov5640_set_power_mipi(sensor, on);
+	else
+		ret = ov5640_set_power_dvp(sensor, on);
+	if (ret)
+		goto power_off;
+
+	if (!on)
+		ov5640_set_power_off(sensor);
+
+	return 0;
+
+power_off:
+	ov5640_set_power_off(sensor);
+	return ret;
+}
+
+/* --------------- Subdev Operations --------------- */
+
+static int ov5640_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	int ret = 0;
+
+	mutex_lock(&sensor->lock);
+
+	/*
+	 * If the power count is modified from 0 to != 0 or from != 0 to 0,
+	 * update the power state.
+	 */
+	if (sensor->power_count == !on) {
+		ret = ov5640_set_power(sensor, !!on);
+		if (ret)
+			goto out;
+	}
+
+	/* Update the power count. */
+	sensor->power_count += on ? 1 : -1;
+	WARN_ON(sensor->power_count < 0);
+out:
+	mutex_unlock(&sensor->lock);
+
+	if (on && !ret && sensor->power_count == 1) {
+		/* restore controls */
+		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+	}
+
+	return ret;
+}
+
+static int ov5640_try_frame_interval(struct ov5640_dev *sensor,
+				     struct v4l2_fract *fi,
+				     u32 width, u32 height)
+{
+	const struct ov5640_mode_info *mode;
+	enum ov5640_frame_rate rate = OV5640_15_FPS;
+	int minfps, maxfps, best_fps, fps;
+	int i;
+
+	minfps = ov5640_framerates[OV5640_15_FPS];
+	maxfps = ov5640_framerates[OV5640_60_FPS];
+
+	if (fi->numerator == 0) {
+		fi->denominator = maxfps;
+		fi->numerator = 1;
+		rate = OV5640_60_FPS;
+		goto find_mode;
+	}
+
+	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
+			minfps, maxfps);
+
+	best_fps = minfps;
+	for (i = 0; i < ARRAY_SIZE(ov5640_framerates); i++) {
+		int curr_fps = ov5640_framerates[i];
+
+		if (abs(curr_fps - fps) < abs(best_fps - fps)) {
+			best_fps = curr_fps;
+			rate = i;
+		}
+	}
+
+	fi->numerator = 1;
+	fi->denominator = best_fps;
+
+find_mode:
+	mode = ov5640_find_mode(sensor, rate, width, height, false);
+	return mode ? rate : -EINVAL;
+}
+
+static int ov5640_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	struct v4l2_mbus_framefmt *fmt;
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(&sensor->sd, cfg,
+						 format->pad);
+	else
+		fmt = &sensor->fmt;
+
+	format->format = *fmt;
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int ov5640_try_fmt_internal(struct v4l2_subdev *sd,
+				   struct v4l2_mbus_framefmt *fmt,
+				   enum ov5640_frame_rate fr,
+				   const struct ov5640_mode_info **new_mode)
+{
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	const struct ov5640_mode_info *mode;
+	int i;
+
+	mode = ov5640_find_mode(sensor, fr, fmt->width, fmt->height, true);
+	if (!mode)
+		return -EINVAL;
+	fmt->width = mode->hact;
+	fmt->height = mode->vact;
+
+	if (new_mode)
+		*new_mode = mode;
+
+	for (i = 0; i < ARRAY_SIZE(ov5640_formats); i++)
+		if (ov5640_formats[i].code == fmt->code)
+			break;
+	if (i >= ARRAY_SIZE(ov5640_formats))
+		i = 0;
+
+	fmt->code = ov5640_formats[i].code;
+	fmt->colorspace = ov5640_formats[i].colorspace;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+
+	return 0;
+}
+
+static int ov5640_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	const struct ov5640_mode_info *new_mode;
+	struct v4l2_mbus_framefmt *mbus_fmt = &format->format;
+	struct v4l2_mbus_framefmt *fmt;
+	int ret;
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = ov5640_try_fmt_internal(sd, mbus_fmt, 0, &new_mode);
+	if (ret)
+		goto out;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(sd, cfg, 0);
+	else
+		fmt = &sensor->fmt;
+
+	if (mbus_fmt->code != sensor->fmt.code)
+		sensor->pending_fmt_change = true;
+
+	*fmt = *mbus_fmt;
+
+	if (new_mode != sensor->current_mode) {
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+	if (new_mode->max_fps < sensor->current_fr) {
+		sensor->current_fr = new_mode->max_fps;
+		sensor->frame_interval.numerator = 1;
+		sensor->frame_interval.denominator =
+			ov5640_framerates[sensor->current_fr];
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+
+	__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
+				 ov5640_calc_pixel_rate(sensor));
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int ov5640_set_framefmt(struct ov5640_dev *sensor,
+			       struct v4l2_mbus_framefmt *format)
+{
+	int ret = 0;
+	bool is_jpeg = false;
+	u8 fmt, mux;
+
+	switch (format->code) {
+	case MEDIA_BUS_FMT_UYVY8_2X8:
+		/* YUV422, UYVY */
+		fmt = 0x3f;
+		mux = OV5640_FMT_MUX_YUV422;
+		break;
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+		/* YUV422, YUYV */
+		fmt = 0x30;
+		mux = OV5640_FMT_MUX_YUV422;
+		break;
+	case MEDIA_BUS_FMT_RGB565_2X8_LE:
+		/* RGB565 {g[2:0],b[4:0]},{r[4:0],g[5:3]} */
+		fmt = 0x6F;
+		mux = OV5640_FMT_MUX_RGB;
+		break;
+	case MEDIA_BUS_FMT_RGB565_2X8_BE:
+		/* RGB565 {r[4:0],g[5:3]},{g[2:0],b[4:0]} */
+		fmt = 0x61;
+		mux = OV5640_FMT_MUX_RGB;
+		break;
+	case MEDIA_BUS_FMT_JPEG_1X8:
+		/* YUV422, YUYV */
+		fmt = 0x30;
+		mux = OV5640_FMT_MUX_YUV422;
+		is_jpeg = true;
+		break;
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+		/* Raw, BGBG... / GRGR... */
+		fmt = 0x00;
+		mux = OV5640_FMT_MUX_RAW_DPC;
+		break;
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+		/* Raw bayer, GBGB... / RGRG... */
+		fmt = 0x01;
+		mux = OV5640_FMT_MUX_RAW_DPC;
+		break;
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+		/* Raw bayer, GRGR... / BGBG... */
+		fmt = 0x02;
+		mux = OV5640_FMT_MUX_RAW_DPC;
+		break;
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		/* Raw bayer, RGRG... / GBGB... */
+		fmt = 0x03;
+		mux = OV5640_FMT_MUX_RAW_DPC;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* FORMAT CONTROL00: YUV and RGB formatting */
+	ret = ov5640_write_reg(sensor, OV5640_REG_FORMAT_CONTROL00, fmt);
+	if (ret)
+		return ret;
+
+	/* FORMAT MUX CONTROL: ISP YUV or RGB */
+	ret = ov5640_write_reg(sensor, OV5640_REG_ISP_FORMAT_MUX_CTRL, mux);
+	if (ret)
+		return ret;
+
+	/*
+	 * TIMING TC REG21:
+	 * - [5]:	JPEG enable
+	 */
+	ret = ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG21,
+			     BIT(5), is_jpeg ? BIT(5) : 0);
+	if (ret)
+		return ret;
+
+	/*
+	 * SYSTEM RESET02:
+	 * - [4]:	Reset JFIFO
+	 * - [3]:	Reset SFIFO
+	 * - [2]:	Reset JPEG
+	 */
+	ret = ov5640_mod_reg(sensor, OV5640_REG_SYS_RESET02,
+			     BIT(4) | BIT(3) | BIT(2),
+			     is_jpeg ? 0 : (BIT(4) | BIT(3) | BIT(2)));
+	if (ret)
+		return ret;
+
+	/*
+	 * CLOCK ENABLE02:
+	 * - [5]:	Enable JPEG 2x clock
+	 * - [3]:	Enable JPEG clock
+	 */
+	return ov5640_mod_reg(sensor, OV5640_REG_SYS_CLOCK_ENABLE02,
+			      BIT(5) | BIT(3),
+			      is_jpeg ? (BIT(5) | BIT(3)) : 0);
+}
+
+/*
+ * Sensor Controls.
+ */
+
+static int ov5640_set_ctrl_hue(struct ov5640_dev *sensor, int value)
+{
+	int ret;
+
+	if (value) {
+		ret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0,
+				     BIT(0), BIT(0));
+		if (ret)
+			return ret;
+		ret = ov5640_write_reg16(sensor, OV5640_REG_SDE_CTRL1, value);
+	} else {
+		ret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0, BIT(0), 0);
+	}
+
+	return ret;
+}
+
+static int ov5640_set_ctrl_contrast(struct ov5640_dev *sensor, int value)
+{
+	int ret;
+
+	if (value) {
+		ret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0,
+				     BIT(2), BIT(2));
+		if (ret)
+			return ret;
+		ret = ov5640_write_reg(sensor, OV5640_REG_SDE_CTRL5,
+				       value & 0xff);
+	} else {
+		ret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0, BIT(2), 0);
+	}
+
+	return ret;
+}
+
+static int ov5640_set_ctrl_saturation(struct ov5640_dev *sensor, int value)
+{
+	int ret;
+
+	if (value) {
+		ret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0,
+				     BIT(1), BIT(1));
+		if (ret)
+			return ret;
+		ret = ov5640_write_reg(sensor, OV5640_REG_SDE_CTRL3,
+				       value & 0xff);
+		if (ret)
+			return ret;
+		ret = ov5640_write_reg(sensor, OV5640_REG_SDE_CTRL4,
+				       value & 0xff);
+	} else {
+		ret = ov5640_mod_reg(sensor, OV5640_REG_SDE_CTRL0, BIT(1), 0);
+	}
+
+	return ret;
+}
+
+static int ov5640_set_ctrl_white_balance(struct ov5640_dev *sensor, int awb)
+{
+	int ret;
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_AWB_MANUAL_CTRL,
+			     BIT(0), awb ? 0 : 1);
+	if (ret)
+		return ret;
+
+	if (!awb) {
+		u16 red = (u16)sensor->ctrls.red_balance->val;
+		u16 blue = (u16)sensor->ctrls.blue_balance->val;
+
+		ret = ov5640_write_reg16(sensor, OV5640_REG_AWB_R_GAIN, red);
+		if (ret)
+			return ret;
+		ret = ov5640_write_reg16(sensor, OV5640_REG_AWB_B_GAIN, blue);
+	}
+
+	return ret;
+}
+
+static int ov5640_set_ctrl_exposure(struct ov5640_dev *sensor,
+				    enum v4l2_exposure_auto_type auto_exposure)
+{
+	struct ov5640_ctrls *ctrls = &sensor->ctrls;
+	bool auto_exp = (auto_exposure == V4L2_EXPOSURE_AUTO);
+	int ret = 0;
+
+	if (ctrls->auto_exp->is_new) {
+		ret = ov5640_set_autoexposure(sensor, auto_exp);
+		if (ret)
+			return ret;
+	}
+
+	if (!auto_exp && ctrls->exposure->is_new) {
+		u16 max_exp;
+
+		ret = ov5640_read_reg16(sensor, OV5640_REG_AEC_PK_VTS,
+					&max_exp);
+		if (ret)
+			return ret;
+		ret = ov5640_get_vts(sensor);
+		if (ret < 0)
+			return ret;
+		max_exp += ret;
+		ret = 0;
+
+		if (ctrls->exposure->val < max_exp)
+			ret = ov5640_set_exposure(sensor, ctrls->exposure->val);
+	}
+
+	return ret;
+}
+
+static int ov5640_set_ctrl_gain(struct ov5640_dev *sensor, bool auto_gain)
+{
+	struct ov5640_ctrls *ctrls = &sensor->ctrls;
+	int ret = 0;
+
+	if (ctrls->auto_gain->is_new) {
+		ret = ov5640_set_autogain(sensor, auto_gain);
+		if (ret)
+			return ret;
+	}
+
+	if (!auto_gain && ctrls->gain->is_new)
+		ret = ov5640_set_gain(sensor, ctrls->gain->val);
+
+	return ret;
+}
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Color bars",
+	"Color bars w/ rolling bar",
+	"Color squares",
+	"Color squares w/ rolling bar",
+};
+
+#define OV5640_TEST_ENABLE		BIT(7)
+#define OV5640_TEST_ROLLING		BIT(6)	/* rolling horizontal bar */
+#define OV5640_TEST_TRANSPARENT		BIT(5)
+#define OV5640_TEST_SQUARE_BW		BIT(4)	/* black & white squares */
+#define OV5640_TEST_BAR_STANDARD	(0 << 2)
+#define OV5640_TEST_BAR_VERT_CHANGE_1	(1 << 2)
+#define OV5640_TEST_BAR_HOR_CHANGE	(2 << 2)
+#define OV5640_TEST_BAR_VERT_CHANGE_2	(3 << 2)
+#define OV5640_TEST_BAR			(0 << 0)
+#define OV5640_TEST_RANDOM		(1 << 0)
+#define OV5640_TEST_SQUARE		(2 << 0)
+#define OV5640_TEST_BLACK		(3 << 0)
+
+static const u8 test_pattern_val[] = {
+	0,
+	OV5640_TEST_ENABLE | OV5640_TEST_BAR_VERT_CHANGE_1 |
+		OV5640_TEST_BAR,
+	OV5640_TEST_ENABLE | OV5640_TEST_ROLLING |
+		OV5640_TEST_BAR_VERT_CHANGE_1 | OV5640_TEST_BAR,
+	OV5640_TEST_ENABLE | OV5640_TEST_SQUARE,
+	OV5640_TEST_ENABLE | OV5640_TEST_ROLLING | OV5640_TEST_SQUARE,
+};
+
+static int ov5640_set_ctrl_test_pattern(struct ov5640_dev *sensor, int value)
+{
+	return ov5640_write_reg(sensor, OV5640_REG_PRE_ISP_TEST_SET1,
+				test_pattern_val[value]);
+}
+
+static int ov5640_set_ctrl_light_freq(struct ov5640_dev *sensor, int value)
+{
+	int ret;
+
+	ret = ov5640_mod_reg(sensor, OV5640_REG_HZ5060_CTRL01, BIT(7),
+			     (value == V4L2_CID_POWER_LINE_FREQUENCY_AUTO) ?
+			     0 : BIT(7));
+	if (ret)
+		return ret;
+
+	return ov5640_mod_reg(sensor, OV5640_REG_HZ5060_CTRL00, BIT(2),
+			      (value == V4L2_CID_POWER_LINE_FREQUENCY_50HZ) ?
+			      BIT(2) : 0);
+}
+
+static int ov5640_set_ctrl_hflip(struct ov5640_dev *sensor, int value)
+{
+	/*
+	 * If sensor is mounted upside down, mirror logic is inversed.
+	 *
+	 * Sensor is a BSI (Back Side Illuminated) one,
+	 * so image captured is physically mirrored.
+	 * This is why mirror logic is inversed in
+	 * order to cancel this mirror effect.
+	 */
+
+	/*
+	 * TIMING TC REG21:
+	 * - [2]:	ISP mirror
+	 * - [1]:	Sensor mirror
+	 */
+	return ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG21,
+			      BIT(2) | BIT(1),
+			      (!(value ^ sensor->upside_down)) ?
+			      (BIT(2) | BIT(1)) : 0);
+}
+
+static int ov5640_set_ctrl_vflip(struct ov5640_dev *sensor, int value)
+{
+	/* If sensor is mounted upside down, flip logic is inversed */
+
+	/*
+	 * TIMING TC REG20:
+	 * - [2]:	ISP vflip
+	 * - [1]:	Sensor vflip
+	 */
+	return ov5640_mod_reg(sensor, OV5640_REG_TIMING_TC_REG20,
+			      BIT(2) | BIT(1),
+			      (value ^ sensor->upside_down) ?
+			      (BIT(2) | BIT(1)) : 0);
+}
+
+static int ov5640_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	int val;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUTOGAIN:
+		val = ov5640_get_gain(sensor);
+		if (val < 0)
+			return val;
+		sensor->ctrls.gain->val = val;
+		break;
+	case V4L2_CID_EXPOSURE_AUTO:
+		val = ov5640_get_exposure(sensor);
+		if (val < 0)
+			return val;
+		sensor->ctrls.exposure->val = val;
+		break;
+	}
+
+	return 0;
+}
+
+static int ov5640_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored right after power-up.
+	 */
+	if (sensor->power_count == 0)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUTOGAIN:
+		ret = ov5640_set_ctrl_gain(sensor, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE_AUTO:
+		ret = ov5640_set_ctrl_exposure(sensor, ctrl->val);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		ret = ov5640_set_ctrl_white_balance(sensor, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		ret = ov5640_set_ctrl_hue(sensor, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = ov5640_set_ctrl_contrast(sensor, ctrl->val);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = ov5640_set_ctrl_saturation(sensor, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = ov5640_set_ctrl_test_pattern(sensor, ctrl->val);
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		ret = ov5640_set_ctrl_light_freq(sensor, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = ov5640_set_ctrl_hflip(sensor, ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = ov5640_set_ctrl_vflip(sensor, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov5640_ctrl_ops = {
+	.g_volatile_ctrl = ov5640_g_volatile_ctrl,
+	.s_ctrl = ov5640_s_ctrl,
+};
+
+static int ov5640_init_controls(struct ov5640_dev *sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &ov5640_ctrl_ops;
+	struct ov5640_ctrls *ctrls = &sensor->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	v4l2_ctrl_handler_init(hdl, 32);
+
+	/* we can use our own mutex for the ctrl lock */
+	hdl->lock = &sensor->lock;
+
+	/* Clock related controls */
+	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
+					      0, INT_MAX, 1,
+					      ov5640_calc_pixel_rate(sensor));
+
+	/* Auto/manual white balance */
+	ctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,
+					   V4L2_CID_AUTO_WHITE_BALANCE,
+					   0, 1, 1, 1);
+	ctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,
+						0, 4095, 1, 0);
+	ctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,
+					       0, 4095, 1, 0);
+	/* Auto/manual exposure */
+	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+						 V4L2_CID_EXPOSURE_AUTO,
+						 V4L2_EXPOSURE_MANUAL, 0,
+						 V4L2_EXPOSURE_AUTO);
+	ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,
+					    0, 65535, 1, 0);
+	/* Auto/manual gain */
+	ctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,
+					     0, 1, 1, 1);
+	ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,
+					0, 1023, 1, 0);
+
+	ctrls->saturation = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION,
+					      0, 255, 1, 64);
+	ctrls->hue = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HUE,
+				       0, 359, 1, 0);
+	ctrls->contrast = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST,
+					    0, 255, 1, 0);
+	ctrls->test_pattern =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+					     ARRAY_SIZE(test_pattern_menu) - 1,
+					     0, 0, test_pattern_menu);
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					 0, 1, 1, 0);
+
+	ctrls->light_freq =
+		v4l2_ctrl_new_std_menu(hdl, ops,
+				       V4L2_CID_POWER_LINE_FREQUENCY,
+				       V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,
+				       V4L2_CID_POWER_LINE_FREQUENCY_50HZ);
+
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	ctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	v4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);
+	v4l2_ctrl_auto_cluster(2, &ctrls->auto_gain, 0, true);
+	v4l2_ctrl_auto_cluster(2, &ctrls->auto_exp, 1, true);
+
+	sensor->sd.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+
+static int ov5640_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->pad != 0)
+		return -EINVAL;
+	if (fse->index >= OV5640_NUM_MODES)
+		return -EINVAL;
+
+	fse->min_width =
+		ov5640_mode_data[fse->index].hact;
+	fse->max_width = fse->min_width;
+	fse->min_height =
+		ov5640_mode_data[fse->index].vact;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int ov5640_enum_frame_interval(
+	struct v4l2_subdev *sd,
+	struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	struct v4l2_fract tpf;
+	int ret;
+
+	if (fie->pad != 0)
+		return -EINVAL;
+	if (fie->index >= OV5640_NUM_FRAMERATES)
+		return -EINVAL;
+
+	tpf.numerator = 1;
+	tpf.denominator = ov5640_framerates[fie->index];
+
+	ret = ov5640_try_frame_interval(sensor, &tpf,
+					fie->width, fie->height);
+	if (ret < 0)
+		return -EINVAL;
+
+	fie->interval = tpf;
+	return 0;
+}
+
+static int ov5640_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+
+	mutex_lock(&sensor->lock);
+	fi->interval = sensor->frame_interval;
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int ov5640_s_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	const struct ov5640_mode_info *mode;
+	int frame_rate, ret = 0;
+
+	if (fi->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	mode = sensor->current_mode;
+
+	frame_rate = ov5640_try_frame_interval(sensor, &fi->interval,
+					       mode->hact, mode->vact);
+	if (frame_rate < 0) {
+		/* Always return a valid frame interval value */
+		fi->interval = sensor->frame_interval;
+		goto out;
+	}
+
+	mode = ov5640_find_mode(sensor, frame_rate, mode->hact,
+				mode->vact, true);
+	if (!mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (mode != sensor->current_mode ||
+	    frame_rate != sensor->current_fr) {
+		sensor->current_fr = frame_rate;
+		sensor->frame_interval = fi->interval;
+		sensor->current_mode = mode;
+		sensor->pending_mode_change = true;
+
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
+					 ov5640_calc_pixel_rate(sensor));
+	}
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int ov5640_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad != 0)
+		return -EINVAL;
+	if (code->index >= ARRAY_SIZE(ov5640_formats))
+		return -EINVAL;
+
+	code->code = ov5640_formats[code->index].code;
+	return 0;
+}
+
+static int ov5640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+	int ret = 0;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming == !enable) {
+		if (enable && sensor->pending_mode_change) {
+			ret = ov5640_set_mode(sensor);
+			if (ret)
+				goto out;
+		}
+
+		if (enable && sensor->pending_fmt_change) {
+			ret = ov5640_set_framefmt(sensor, &sensor->fmt);
+			if (ret)
+				goto out;
+			sensor->pending_fmt_change = false;
+		}
+
+		if (sensor->ep.bus_type == V4L2_MBUS_CSI2_DPHY)
+			ret = ov5640_set_stream_mipi(sensor, enable);
+		else
+			ret = ov5640_set_stream_dvp(sensor, enable);
+
+		if (ret)
+			goto out;
+	}
+	sensor->streaming += enable ? 1 : -1;
+	WARN_ON(sensor->streaming < 0);
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+int ov5640_skip_frames(struct v4l2_subdev *sd, u32 *frames)
+{
+	*frames = OV5640_SKIP_FRAMES;
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops ov5640_core_ops = {
+	.s_power = ov5640_s_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops ov5640_video_ops = {
+	.g_frame_interval = ov5640_g_frame_interval,
+	.s_frame_interval = ov5640_s_frame_interval,
+	.s_stream = ov5640_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov5640_pad_ops = {
+	.enum_mbus_code = ov5640_enum_mbus_code,
+	.get_fmt = ov5640_get_fmt,
+	.set_fmt = ov5640_set_fmt,
+	.enum_frame_size = ov5640_enum_frame_size,
+	.enum_frame_interval = ov5640_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_sensor_ops ov5640_sensor_ops = {
+	.g_skip_frames = ov5640_skip_frames,
+};
+
+static const struct v4l2_subdev_ops ov5640_subdev_ops = {
+	.core = &ov5640_core_ops,
+	.video = &ov5640_video_ops,
+	.pad = &ov5640_pad_ops,
+	.sensor = &ov5640_sensor_ops,
+};
+
+static int ov5640_get_regulators(struct ov5640_dev *sensor)
+{
+	int i;
+
+	for (i = 0; i < OV5640_NUM_SUPPLIES; i++)
+		sensor->supplies[i].supply = ov5640_supply_name[i];
+
+	return devm_regulator_bulk_get(&sensor->i2c_client->dev,
+				       OV5640_NUM_SUPPLIES,
+				       sensor->supplies);
+}
+
+static int ov5640_check_chip_id(struct ov5640_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int ret = 0;
+	u16 chip_id;
+
+	ret = ov5640_set_power_on(sensor);
+	if (ret)
+		return ret;
+
+	ret = ov5640_read_reg16(sensor, OV5640_REG_CHIP_ID, &chip_id);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to read chip identifier\n",
+			__func__);
+		goto power_off;
+	}
+
+	if (chip_id != OV5640_CHIP_ID) {
+		dev_err(&client->dev, "%s: wrong chip identifier, expected 0x%x, got 0x%x\n",
+			__func__, OV5640_CHIP_ID, chip_id);
+		ret = -ENXIO;
+	}
+	dev_err(&client->dev, "%s: chip identifier, got 0x%x\n",
+		__func__, chip_id);
+
+power_off:
+	ov5640_set_power_off(sensor);
+	return ret;
+}
+
+static int ov5640_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	struct ov5640_dev *sensor;
+	struct v4l2_mbus_framefmt *fmt;
+	u32 rotation;
+	int ret;
+
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	sensor->i2c_client = client;
+
+	/*
+	 * default init sequence initialize sensor to
+	 * YUV422 UYVY VGA@30fps
+	 */
+	fmt = &sensor->fmt;
+	fmt->code = MEDIA_BUS_FMT_UYVY8_2X8;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = 640;
+	fmt->height = 480;
+	fmt->field = V4L2_FIELD_NONE;
+	sensor->frame_interval.numerator = 1;
+	sensor->frame_interval.denominator = ov5640_framerates[OV5640_30_FPS];
+	sensor->current_fr = OV5640_30_FPS;
+	sensor->current_mode =
+		&ov5640_mode_data[OV5640_MODE_VGA_640_480];
+	sensor->last_mode = sensor->current_mode;
+
+	sensor->ae_target = 52;
+
+	/* optional indication of physical rotation of sensor */
+	ret = fwnode_property_read_u32(dev_fwnode(&client->dev), "rotation",
+				       &rotation);
+	if (!ret) {
+		switch (rotation) {
+		case 180:
+			sensor->upside_down = true;
+			fallthrough;
+		case 0:
+			break;
+		default:
+			dev_warn(dev, "%u degrees rotation is not supported, ignoring...\n",
+				 rotation);
+		}
+	}
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev),
+						  NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &sensor->ep);
+	fwnode_handle_put(endpoint);
+	if (ret) {
+		dev_err(dev, "Could not parse endpoint\n");
+		return ret;
+	}
+
+	if (sensor->ep.bus_type != V4L2_MBUS_PARALLEL &&
+	    sensor->ep.bus_type != V4L2_MBUS_CSI2_DPHY &&
+	    sensor->ep.bus_type != V4L2_MBUS_BT656) {
+		dev_err(dev, "Unsupported bus type %d\n", sensor->ep.bus_type);
+		return -EINVAL;
+	}
+
+	/* get system clock (xclk) */
+	sensor->xclk = devm_clk_get(dev, "xclk");
+	if (IS_ERR(sensor->xclk)) {
+		dev_err(dev, "failed to get xclk\n");
+		return PTR_ERR(sensor->xclk);
+	}
+
+	sensor->xclk_freq = clk_get_rate(sensor->xclk);
+	if (sensor->xclk_freq < OV5640_XCLK_MIN ||
+	    sensor->xclk_freq > OV5640_XCLK_MAX) {
+		dev_err(dev, "xclk frequency out of range: %d Hz\n",
+			sensor->xclk_freq);
+		return -EINVAL;
+	}
+
+	/* request optional power down pin */
+	sensor->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->pwdn_gpio))
+		return PTR_ERR(sensor->pwdn_gpio);
+
+	/* request optional reset pin */
+	sensor->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						     GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->reset_gpio))
+		return PTR_ERR(sensor->reset_gpio);
+
+	v4l2_i2c_subdev_init(&sensor->sd, client, &ov5640_subdev_ops);
+
+	sensor->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			    V4L2_SUBDEV_FL_HAS_EVENTS;
+	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);
+	if (ret)
+		return ret;
+
+	ret = ov5640_get_regulators(sensor);
+	if (ret)
+		return ret;
+
+	mutex_init(&sensor->lock);
+
+	ret = ov5640_check_chip_id(sensor);
+	if (ret)
+		goto entity_cleanup;
+
+	ret = ov5640_init_controls(sensor);
+	if (ret)
+		goto entity_cleanup;
+
+	ret = v4l2_async_register_subdev_sensor_common(&sensor->sd);
+	if (ret)
+		goto free_ctrls;
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+entity_cleanup:
+	media_entity_cleanup(&sensor->sd.entity);
+	mutex_destroy(&sensor->lock);
+	return ret;
+}
+
+static int ov5640_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov5640_dev *sensor = to_ov5640_dev(sd);
+
+	v4l2_async_unregister_subdev(&sensor->sd);
+	media_entity_cleanup(&sensor->sd.entity);
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+	mutex_destroy(&sensor->lock);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov5640_id[] = {
+	{"ov5640", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ov5640_id);
+
+static const struct of_device_id ov5640_dt_ids[] = {
+	{ .compatible = "ovti,ov5640" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ov5640_dt_ids);
+
+static struct i2c_driver ov5640_i2c_driver = {
+	.driver = {
+		.name  = "ov5640",
+		.of_match_table	= ov5640_dt_ids,
+	},
+	.id_table = ov5640_id,
+	.probe_new = ov5640_probe,
+	.remove   = ov5640_remove,
+};
+
+module_i2c_driver(ov5640_i2c_driver);
+
+MODULE_DESCRIPTION("OV5640 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/starfive/v4l2_driver/sc2235.c b/drivers/media/platform/starfive/v4l2_driver/sc2235.c
new file mode 100644
index 000000000000..c44c1849cb2a
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/sc2235.c
@@ -0,0 +1,1918 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2011-2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2014-2017 Mentor Graphics Inc.
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pm_runtime.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include "stfcamss.h"
+
+/* min/typical/max system clock (xclk) frequencies */
+#define SC2235_XCLK_MIN			6000000
+#define SC2235_XCLK_MAX			27000000
+
+#define SC2235_CHIP_ID		(0x2235)
+
+#define SC2235_REG_CHIP_ID				0x3107
+#define SC2235_REG_AEC_PK_MANUAL		0x3e03
+#define SC2235_REG_AEC_PK_EXPOSURE_HI	0x3e01
+#define SC2235_REG_AEC_PK_EXPOSURE_LO	0x3e02
+#define SC2235_REG_AEC_PK_REAL_GAIN		0x3e08
+#define SC2235_REG_TIMING_HTS			0x320c
+#define SC2235_REG_TIMING_VTS			0x320e
+#define SC2235_REG_TEST_SET0			0x4501
+#define SC2235_REG_TEST_SET1			0x3902
+#define SC2235_REG_TIMING_TC_REG21		0x3221
+#define SC2235_REG_SC_PLL_CTRL0			0x3039
+#define SC2235_REG_SC_PLL_CTRL1			0x303a
+#define SC2235_REG_STREAM_ON            0x0100
+
+enum sc2235_mode_id {
+	SC2235_MODE_1080P_1920_1080 = 0,
+	SC2235_NUM_MODES,
+};
+
+enum sc2235_frame_rate {
+	SC2235_15_FPS = 0,
+	SC2235_30_FPS,
+	SC2235_NUM_FRAMERATES,
+};
+
+struct sc2235_pixfmt {
+	u32 code;
+	u32 colorspace;
+};
+
+static const struct sc2235_pixfmt sc2235_formats[] = {
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_COLORSPACE_SRGB, },
+};
+
+static const int sc2235_framerates[] = {
+	[SC2235_15_FPS] = 15,
+	[SC2235_30_FPS] = 30,
+};
+
+/* regulator supplies */
+static const char * const sc2235_supply_name[] = {
+	"DOVDD", /* Digital I/O (1.8V) supply */
+	"AVDD",  /* Analog (2.8V) supply */
+	"DVDD",  /* Digital Core (1.5V) supply */
+};
+
+#define SC2235_NUM_SUPPLIES ARRAY_SIZE(sc2235_supply_name)
+
+struct reg_value {
+	u16 reg_addr;
+	u8 val;
+	u8 mask;
+	u32 delay_ms;
+};
+
+struct sc2235_mode_info {
+	enum sc2235_mode_id id;
+	u32 hact;
+	u32 htot;
+	u32 vact;
+	u32 vtot;
+	const struct reg_value *reg_data;
+	u32 reg_data_size;
+	u32 max_fps;
+};
+
+struct sc2235_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct {
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+	};
+	struct {
+		struct v4l2_ctrl *auto_wb;
+		struct v4l2_ctrl *blue_balance;
+		struct v4l2_ctrl *red_balance;
+	};
+	struct {
+		struct v4l2_ctrl *auto_gain;
+		struct v4l2_ctrl *gain;
+	};
+	struct v4l2_ctrl *brightness;
+	struct v4l2_ctrl *light_freq;
+	struct v4l2_ctrl *saturation;
+	struct v4l2_ctrl *contrast;
+	struct v4l2_ctrl *hue;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+};
+
+struct sc2235_dev {
+	struct i2c_client *i2c_client;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_fwnode_endpoint ep; /* the parsed DT endpoint info */
+	struct clk *xclk; /* system clock to SC2235 */
+	u32 xclk_freq;
+
+	struct regulator_bulk_data supplies[SC2235_NUM_SUPPLIES];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *pwdn_gpio;
+	bool   upside_down;
+
+	/* lock to protect all members below */
+	struct mutex lock;
+
+	struct v4l2_mbus_framefmt fmt;
+	bool pending_fmt_change;
+
+	const struct sc2235_mode_info *current_mode;
+	const struct sc2235_mode_info *last_mode;
+	enum sc2235_frame_rate current_fr;
+	struct v4l2_fract frame_interval;
+
+	struct sc2235_ctrls ctrls;
+
+	bool pending_mode_change;
+
+	int streaming;
+};
+
+static inline struct sc2235_dev *to_sc2235_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct sc2235_dev, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct sc2235_dev,
+				ctrls.handler)->sd;
+}
+
+/* sc2235 initial register 30fps*/
+static struct reg_value sc2235_init_regs_tbl_1080[] = {
+	{0x0103, 0x01, 0, 50},
+	{0x0100, 0x00, 0, 0},
+	{0x3039, 0x80, 0, 0},
+	{0x3621, 0x28, 0, 0},
+
+	{0x3309, 0x60, 0, 0},
+	{0x331f, 0x4d, 0, 0},
+	{0x3321, 0x4f, 0, 0},
+	{0x33b5, 0x10, 0, 0},
+
+	{0x3303, 0x20, 0, 0},
+	{0x331e, 0x0d, 0, 0},
+	{0x3320, 0x0f, 0, 0},
+
+	{0x3622, 0x02, 0, 0},
+	{0x3633, 0x42, 0, 0},
+	{0x3634, 0x42, 0, 0},
+
+	{0x3306, 0x66, 0, 0},
+	{0x330b, 0xd1, 0, 0},
+
+	{0x3301, 0x0e, 0, 0},
+
+	{0x320c, 0x08, 0, 0},
+	{0x320d, 0x98, 0, 0},
+
+	{0x3364, 0x05, 0, 0},		// [2] 1: write at sampling ending
+
+	{0x363c, 0x28, 0, 0},		//bypass nvdd
+	{0x363b, 0x0a, 0, 0},		//HVDD
+	{0x3635, 0xa0, 0, 0},		//TXVDD
+
+	{0x4500, 0x59, 0, 0},
+	{0x3d08, 0x00, 0, 0},
+	{0x3908, 0x11, 0, 0},
+
+	{0x363c, 0x08, 0, 0},
+
+	{0x3e03, 0x03, 0, 0},
+	{0x3e01, 0x46, 0, 0},
+
+	//0703
+	{0x3381, 0x0a, 0, 0},
+	{0x3348, 0x09, 0, 0},
+	{0x3349, 0x50, 0, 0},
+	{0x334a, 0x02, 0, 0},
+	{0x334b, 0x60, 0, 0},
+
+	{0x3380, 0x04, 0, 0},
+	{0x3340, 0x06, 0, 0},
+	{0x3341, 0x50, 0, 0},
+	{0x3342, 0x02, 0, 0},
+	{0x3343, 0x60, 0, 0},
+
+	//0707
+
+	{0x3632, 0x88, 0, 0},		//anti sm
+	{0x3309, 0xa0, 0, 0},
+	{0x331f, 0x8d, 0, 0},
+	{0x3321, 0x8f, 0, 0},
+
+	{0x335e, 0x01, 0, 0},		//ana dithering
+	{0x335f, 0x03, 0, 0},
+	{0x337c, 0x04, 0, 0},
+	{0x337d, 0x06, 0, 0},
+	{0x33a0, 0x05, 0, 0},
+	{0x3301, 0x05, 0, 0},
+
+	{0x337f, 0x03, 0, 0},
+	{0x3368, 0x02, 0, 0},
+	{0x3369, 0x00, 0, 0},
+	{0x336a, 0x00, 0, 0},
+	{0x336b, 0x00, 0, 0},
+	{0x3367, 0x08, 0, 0},
+	{0x330e, 0x30, 0, 0},
+
+	{0x3366, 0x7c, 0, 0},		// div_rst gap
+
+	{0x3635, 0xc1, 0, 0},
+	{0x363b, 0x09, 0, 0},
+	{0x363c, 0x07, 0, 0},
+
+	{0x391e, 0x00, 0, 0},
+
+	{0x3637, 0x14, 0, 0},		//fullwell 7K
+
+	{0x3306, 0x54, 0, 0},
+	{0x330b, 0xd8, 0, 0},
+	{0x366e, 0x08, 0, 0},		// ofs auto en [3]
+	{0x366f, 0x2f, 0, 0},
+
+	{0x3631, 0x84, 0, 0},
+	{0x3630, 0x48, 0, 0},
+	{0x3622, 0x06, 0, 0},
+
+	//ramp by sc
+	{0x3638, 0x1f, 0, 0},
+	{0x3625, 0x02, 0, 0},
+	{0x3636, 0x24, 0, 0},
+
+	//0714
+	{0x3348, 0x08, 0, 0},
+	{0x3e03, 0x0b, 0, 0},
+
+	//7.17 fpn
+	{0x3342, 0x03, 0, 0},
+	{0x3343, 0xa0, 0, 0},
+	{0x334a, 0x03, 0, 0},
+	{0x334b, 0xa0, 0, 0},
+
+	//0718
+	{0x3343, 0xb0, 0, 0},
+	{0x334b, 0xb0, 0, 0},
+
+	//0720
+	//digital ctrl
+	{0x3802, 0x01, 0, 0},
+	{0x3235, 0x04, 0, 0},
+	{0x3236, 0x63, 0, 0},		// vts-2
+
+	//fpn
+	{0x3343, 0xd0, 0, 0},
+	{0x334b, 0xd0, 0, 0},
+	{0x3348, 0x07, 0, 0},
+	{0x3349, 0x80, 0, 0},
+
+	//0724
+	{0x391b, 0x4d, 0, 0},
+
+	{0x3342, 0x04, 0, 0},
+	{0x3343, 0x20, 0, 0},
+	{0x334a, 0x04, 0, 0},
+	{0x334b, 0x20, 0, 0},
+
+	//0804
+	{0x3222, 0x29, 0, 0},
+	{0x3901, 0x02, 0, 0},
+
+	//0808
+
+	// auto blc
+	{0x3900, 0xD5, 0, 0},		// Bit[0]: blc_enable
+	{0x3902, 0x45, 0, 0},		// Bit[6]: blc_auto_en
+
+	// blc target
+	{0x3907, 0x00, 0, 0},
+	{0x3908, 0x00, 0, 0},
+
+	// auto dpc
+	{0x5000, 0x00, 0, 0},		// Bit[2]: white dead pixel cancel enable, Bit[1]: black dead pixel cancel enable
+
+	//digital ctrl
+	{0x3f00, 0x07, 0, 0},		// bit[2] = 1
+	{0x3f04, 0x08, 0, 0},
+	{0x3f05, 0x74, 0, 0},		// hts - { 0x24
+
+	//0809
+	{0x330b, 0xc8, 0, 0},
+
+	//0817
+	{0x3306, 0x4a, 0, 0},
+	{0x330b, 0xca, 0, 0},
+	{0x3639, 0x09, 0, 0},
+
+	//manual DPC
+	{0x5780, 0xff, 0, 0},
+	{0x5781, 0x04, 0, 0},
+	{0x5785, 0x18, 0, 0},
+
+	//0822
+	{0x3039, 0x35, 0, 0},		//fps
+	{0x303a, 0x2e, 0, 0},
+	{0x3034, 0x05, 0, 0},
+	{0x3035, 0x2a, 0, 0},
+
+	{0x320c, 0x08, 0, 0},
+	{0x320d, 0xca, 0, 0},
+	{0x320e, 0x04, 0, 0},
+	{0x320f, 0xb0, 0, 0},
+
+	{0x3f04, 0x08, 0, 0},
+	{0x3f05, 0xa6, 0, 0},		// hts - { 0x24
+
+	{0x3235, 0x04, 0, 0},
+	{0x3236, 0xae, 0, 0},		// vts-2
+
+	//0825
+	{0x3313, 0x05, 0, 0},
+	{0x3678, 0x42, 0, 0},
+
+	//for AE control per frame
+	{0x3670, 0x00, 0, 0},
+	{0x3633, 0x42, 0, 0},
+
+	{0x3802, 0x00, 0, 0},
+
+	//20180126
+	{0x3677, 0x3f, 0, 0},
+	{0x3306, 0x44, 0, 0},		//20180126[3c },4a]
+	{0x330b, 0xca, 0, 0},		//20180126[c2 },d3]
+
+	//20180202
+	{0x3237, 0x08, 0, 0},
+	{0x3238, 0x9a, 0, 0},		//hts-0x30
+
+	//20180417
+	{0x3640, 0x01, 0, 0},
+	{0x3641, 0x02, 0, 0},
+
+	{0x3301, 0x12, 0, 0},		//[8 },15]20180126
+	{0x3631, 0x84, 0, 0},
+	{0x366f, 0x2f, 0, 0},
+	{0x3622, 0xc6, 0, 0},		//20180117
+
+	{0x3e03, 0x03, 0, 0},		// Bit[3]: AGC table mapping method, Bit[1]: AGC manual, BIt[0]: AEC manual
+
+	// {0x0100, 0x00, 0, 0},
+	// {0x4501, 0xc8, 0, 0},	//bar testing
+	// {0x3902, 0x45, 0, 0},
+};
+
+static struct reg_value sc2235_setting_1080P_1920_1080[] = {
+
+};
+
+/* power-on sensor init reg table */
+static const struct sc2235_mode_info sc2235_mode_init_data = {
+	SC2235_MODE_1080P_1920_1080,
+	1920, 0x8ca, 1080, 0x4b0,
+	sc2235_init_regs_tbl_1080,
+	ARRAY_SIZE(sc2235_init_regs_tbl_1080),
+	SC2235_30_FPS,
+};
+
+static const struct sc2235_mode_info
+sc2235_mode_data[SC2235_NUM_MODES] = {
+	{SC2235_MODE_1080P_1920_1080,
+	 1920, 0x8ca, 1080, 0x4b0,
+	 sc2235_setting_1080P_1920_1080,
+	 ARRAY_SIZE(sc2235_setting_1080P_1920_1080),
+	 SC2235_30_FPS},
+};
+
+static int sc2235_write_reg(struct sc2235_dev *sensor, u16 reg, u8 val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg;
+	u8 buf[3];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	buf[2] = val;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.buf = buf;
+	msg.len = sizeof(buf);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x, val=%x\n",
+			__func__, reg, val);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sc2235_read_reg(struct sc2235_dev *sensor, u16 reg, u8 *val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = buf;
+	msg[0].len = sizeof(buf);
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = 1;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x\n",
+			__func__, reg);
+		return ret;
+	}
+
+	*val = buf[0];
+	return 0;
+}
+
+static int sc2235_read_reg16(struct sc2235_dev *sensor, u16 reg, u16 *val)
+{
+	u8 hi, lo;
+	int ret;
+
+	ret = sc2235_read_reg(sensor, reg, &hi);
+	if (ret)
+		return ret;
+	ret = sc2235_read_reg(sensor, reg + 1, &lo);
+	if (ret)
+		return ret;
+
+	*val = ((u16)hi << 8) | (u16)lo;
+	return 0;
+}
+
+static int sc2235_write_reg16(struct sc2235_dev *sensor, u16 reg, u16 val)
+{
+	int ret;
+
+	ret = sc2235_write_reg(sensor, reg, val >> 8);
+	if (ret)
+		return ret;
+
+	return sc2235_write_reg(sensor, reg + 1, val & 0xff);
+}
+
+static int sc2235_mod_reg(struct sc2235_dev *sensor, u16 reg,
+			u8 mask, u8 val)
+{
+	u8 readval;
+	int ret;
+
+	ret = sc2235_read_reg(sensor, reg, &readval);
+	if (ret)
+		return ret;
+
+	readval &= ~mask;
+	val &= mask;
+	val |= readval;
+
+	return sc2235_write_reg(sensor, reg, val);
+}
+
+#define SC2235_PLL_PREDIV	3
+
+#define SC2235_SYSDIV_MIN	0
+#define SC2235_SYSDIV_MAX	7
+
+#define SC2235_PLL_MULT_MIN	0
+#define SC2235_PLL_MULT_MAX	63
+
+#ifdef UNUSED_CODE
+static unsigned long sc2235_compute_sys_clk(struct sc2235_dev *sensor,
+					u8 pll_pre, u8 pll_mult,
+					u8 sysdiv)
+{
+	unsigned long sysclk =
+		sensor->xclk_freq * (64 - pll_mult) / (pll_pre * (sysdiv + 1));
+
+	/* PLL1 output cannot exceed 1GHz. */
+	if (sysclk / 1000000 > 1000)
+		return 0;
+
+	return sysclk;
+}
+
+static unsigned long sc2235_calc_sys_clk(struct sc2235_dev *sensor,
+					unsigned long rate,
+					u8 *pll_prediv, u8 *pll_mult,
+					u8 *sysdiv)
+{
+	unsigned long best = ~0;
+	u8 best_sysdiv = 1, best_mult = 1;
+	u8 _sysdiv, _pll_mult;
+
+	for (_sysdiv = SC2235_SYSDIV_MIN;
+		_sysdiv <= SC2235_SYSDIV_MAX;
+		_sysdiv++) {
+		for (_pll_mult = SC2235_PLL_MULT_MIN;
+			_pll_mult <= SC2235_PLL_MULT_MAX;
+			_pll_mult++) {
+			unsigned long _rate;
+
+			_rate = sc2235_compute_sys_clk(sensor,
+							SC2235_PLL_PREDIV,
+							_pll_mult, _sysdiv);
+
+			/*
+			 * We have reached the maximum allowed PLL1 output,
+			 * increase sysdiv.
+			 */
+			if (!_rate)
+				break;
+
+			/*
+			 * Prefer rates above the expected clock rate than
+			 * below, even if that means being less precise.
+			 */
+			if (_rate < rate)
+				continue;
+
+			if (abs(rate - _rate) < abs(rate - best)) {
+				best = _rate;
+				best_sysdiv = _sysdiv;
+				best_mult = _pll_mult;
+			}
+
+			if (_rate == rate)
+				goto out;
+		}
+	}
+
+out:
+	*sysdiv = best_sysdiv;
+	*pll_prediv = SC2235_PLL_PREDIV;
+	*pll_mult = best_mult;
+
+	return best;
+}
+#endif
+
+static int sc2235_set_timings(struct sc2235_dev *sensor,
+				const struct sc2235_mode_info *mode)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int sc2235_load_regs(struct sc2235_dev *sensor,
+				const struct sc2235_mode_info *mode)
+{
+	const struct reg_value *regs = mode->reg_data;
+	unsigned int i;
+	u32 delay_ms;
+	u16 reg_addr;
+	u8 mask, val;
+	int ret = 0;
+
+	for (i = 0; i < mode->reg_data_size; ++i, ++regs) {
+		delay_ms = regs->delay_ms;
+		reg_addr = regs->reg_addr;
+		val = regs->val;
+		mask = regs->mask;
+
+		if (mask)
+			ret = sc2235_mod_reg(sensor, reg_addr, mask, val);
+		else
+			ret = sc2235_write_reg(sensor, reg_addr, val);
+		if (ret)
+			break;
+
+		if (delay_ms)
+			usleep_range(1000 * delay_ms, 1000 * delay_ms + 100);
+	}
+
+	return sc2235_set_timings(sensor, mode);
+}
+
+static int sc2235_set_autoexposure(struct sc2235_dev *sensor, bool on)
+{
+	return sc2235_mod_reg(sensor, SC2235_REG_AEC_PK_MANUAL,
+				BIT(0), on ? 0 : BIT(0));
+}
+
+static int sc2235_get_exposure(struct sc2235_dev *sensor)
+{
+	int exp = 0, ret = 0;
+	u8 temp;
+
+	ret = sc2235_read_reg(sensor, SC2235_REG_AEC_PK_EXPOSURE_HI, &temp);
+	if (ret)
+		return ret;
+	exp |= (int)temp << 8;
+	ret = sc2235_read_reg(sensor, SC2235_REG_AEC_PK_EXPOSURE_LO, &temp);
+	if (ret)
+		return ret;
+	exp |= (int)temp;
+
+	return exp >> 4;
+}
+
+static int sc2235_set_exposure(struct sc2235_dev *sensor, u32 exposure)
+{
+	int ret;
+
+	exposure <<= 4;
+
+	ret = sc2235_write_reg(sensor,
+				SC2235_REG_AEC_PK_EXPOSURE_LO,
+				exposure & 0xff);
+	if (ret)
+		return ret;
+	return sc2235_write_reg(sensor,
+				SC2235_REG_AEC_PK_EXPOSURE_HI,
+				(exposure >> 8) & 0xff);
+}
+
+static int sc2235_get_gain(struct sc2235_dev *sensor)
+{
+	u16 gain;
+	int ret;
+
+	ret = sc2235_read_reg16(sensor, SC2235_REG_AEC_PK_REAL_GAIN, &gain);
+	if (ret)
+		return ret;
+
+	return gain & 0x1fff;
+}
+
+static int sc2235_set_gain(struct sc2235_dev *sensor, int gain)
+{
+	return sc2235_write_reg16(sensor, SC2235_REG_AEC_PK_REAL_GAIN,
+					(u16)gain & 0x1fff);
+}
+
+static int sc2235_set_autogain(struct sc2235_dev *sensor, bool on)
+{
+	return sc2235_mod_reg(sensor, SC2235_REG_AEC_PK_MANUAL,
+				BIT(1), on ? 0 : BIT(1));
+}
+
+#ifdef UNUSED_CODE
+static int sc2235_get_sysclk(struct sc2235_dev *sensor)
+{
+	return 0;
+}
+
+static int sc2235_set_night_mode(struct sc2235_dev *sensor)
+{
+	return 0;
+}
+
+static int sc2235_get_hts(struct sc2235_dev *sensor)
+{
+	u16 hts;
+	int ret;
+
+	ret = sc2235_read_reg16(sensor, SC2235_REG_TIMING_HTS, &hts);
+	if (ret)
+		return ret;
+	return hts;
+}
+#endif
+
+static int sc2235_get_vts(struct sc2235_dev *sensor)
+{
+	u16 vts;
+	int ret;
+
+	ret = sc2235_read_reg16(sensor, SC2235_REG_TIMING_VTS, &vts);
+	if (ret)
+		return ret;
+	return vts;
+}
+
+#ifdef UNUSED_CODE
+static int sc2235_set_vts(struct sc2235_dev *sensor, int vts)
+{
+	return sc2235_write_reg16(sensor, SC2235_REG_TIMING_VTS, vts);
+}
+
+static int sc2235_get_light_freq(struct sc2235_dev *sensor)
+{
+	return 0;
+}
+
+static int sc2235_set_bandingfilter(struct sc2235_dev *sensor)
+{
+	return 0;
+}
+
+static int sc2235_set_ae_target(struct sc2235_dev *sensor, int target)
+{
+	return 0;
+}
+
+static int sc2235_get_binning(struct sc2235_dev *sensor)
+{
+	return 0;
+}
+
+static int sc2235_set_binning(struct sc2235_dev *sensor, bool enable)
+{
+	return 0;
+}
+
+#endif
+
+static const struct sc2235_mode_info *
+sc2235_find_mode(struct sc2235_dev *sensor, enum sc2235_frame_rate fr,
+		 int width, int height, bool nearest)
+{
+	const struct sc2235_mode_info *mode;
+
+	mode = v4l2_find_nearest_size(sc2235_mode_data,
+					ARRAY_SIZE(sc2235_mode_data),
+					hact, vact,
+					width, height);
+
+	if (!mode ||
+		(!nearest && (mode->hact != width || mode->vact != height)))
+		return NULL;
+
+	/* Check to see if the current mode exceeds the max frame rate */
+	if (sc2235_framerates[fr] > sc2235_framerates[mode->max_fps])
+		return NULL;
+
+	return mode;
+}
+
+static u64 sc2235_calc_pixel_rate(struct sc2235_dev *sensor)
+{
+	u64 rate;
+
+	rate = sensor->current_mode->vtot * sensor->current_mode->htot;
+	rate *= sc2235_framerates[sensor->current_fr];
+
+	return rate;
+}
+
+#ifdef UNUSED_CODE
+/*
+ * sc2235_set_dvp_pclk() - Calculate the clock tree configuration values
+ *				for the dvp output.
+ *
+ * @rate: The requested bandwidth per lane in bytes per second.
+ *	'Bandwidth Per Lane' is calculated as:
+ *	rate = HTOT * VTOT * FPS;
+ *
+ * This function use the requested bandwidth to calculate:
+ * - rate = xclk * (64 - M) / (N * (S + 1));
+ *
+ */
+
+#define PLL_PREDIV  1
+#define PLL_SYSEL   0
+
+static int sc2235_set_dvp_pclk(struct sc2235_dev *sensor,
+				unsigned long rate)
+{
+	u8 prediv, mult, sysdiv;
+	int ret = 0;
+
+	sc2235_calc_sys_clk(sensor, rate, &prediv, &mult,
+				&sysdiv);
+
+
+	return ret;
+}
+
+/*
+ * if sensor changes inside scaling or subsampling
+ * change mode directly
+ */
+static int sc2235_set_mode_direct(struct sc2235_dev *sensor,
+				const struct sc2235_mode_info *mode)
+{
+	if (!mode->reg_data)
+		return -EINVAL;
+
+	/* Write capture setting */
+	return sc2235_load_regs(sensor, mode);
+}
+#endif
+
+static int sc2235_set_mode(struct sc2235_dev *sensor)
+{
+#ifdef UNUSED_CODE
+	bool auto_exp =  sensor->ctrls.auto_exp->val == V4L2_EXPOSURE_AUTO;
+	const struct sc2235_mode_info *mode = sensor->current_mode;
+#endif
+	bool auto_gain = sensor->ctrls.auto_gain->val == 1;
+	int ret = 0;
+
+	/* auto gain and exposure must be turned off when changing modes */
+	if (auto_gain) {
+		ret = sc2235_set_autogain(sensor, false);
+		if (ret)
+			return ret;
+	}
+#ifdef UNUSED_CODE
+	/* This issue will be addressed in the EVB board*/
+	/* This action will result in poor image display 2021 1111*/
+	if (auto_exp) {
+		ret = sc2235_set_autoexposure(sensor, false);
+		if (ret)
+			goto restore_auto_gain;
+	}
+
+	rate = sc2235_calc_pixel_rate(sensor);
+
+	ret = sc2235_set_dvp_pclk(sensor, rate);
+	if (ret < 0)
+		return 0;
+
+	ret = sc2235_set_mode_direct(sensor, mode);
+	if (ret < 0)
+		goto restore_auto_exp_gain;
+
+	/* restore auto gain and exposure */
+	if (auto_gain)
+		sc2235_set_autogain(sensor, true);
+	if (auto_exp)
+		sc2235_set_autoexposure(sensor, true);
+
+
+	sensor->pending_mode_change = false;
+	sensor->last_mode = mode;
+	return 0;
+
+restore_auto_exp_gain:
+	if (auto_exp)
+		sc2235_set_autoexposure(sensor, true);
+restore_auto_gain:
+	if (auto_gain)
+		sc2235_set_autogain(sensor, true);
+#endif
+	return ret;
+}
+
+static int sc2235_set_framefmt(struct sc2235_dev *sensor,
+				struct v4l2_mbus_framefmt *format);
+
+/* restore the last set video mode after chip power-on */
+static int sc2235_restore_mode(struct sc2235_dev *sensor)
+{
+	int ret;
+
+	/* first load the initial register values */
+	ret = sc2235_load_regs(sensor, &sc2235_mode_init_data);
+	if (ret < 0)
+		return ret;
+	sensor->last_mode = &sc2235_mode_init_data;
+	/* now restore the last capture mode */
+	ret = sc2235_set_mode(sensor);
+	if (ret < 0)
+		return ret;
+
+	return sc2235_set_framefmt(sensor, &sensor->fmt);
+}
+
+static void sc2235_power(struct sc2235_dev *sensor, bool enable)
+{
+	if (!sensor->pwdn_gpio)
+		return;
+	gpiod_set_value_cansleep(sensor->pwdn_gpio, enable ? 0 : 1);
+}
+
+static void sc2235_reset(struct sc2235_dev *sensor)
+{
+	if (!sensor->reset_gpio)
+		return;
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+
+	/* camera power cycle */
+	sc2235_power(sensor, false);
+	usleep_range(5000, 10000);
+	sc2235_power(sensor, true);
+	usleep_range(5000, 10000);
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 1);
+	usleep_range(1000, 2000);
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+	usleep_range(20000, 25000);
+}
+
+static int sc2235_set_power_on(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	int ret;
+
+	ret = clk_prepare_enable(sensor->xclk);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable clock\n",
+			__func__);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(SC2235_NUM_SUPPLIES,
+					sensor->supplies);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable regulators\n",
+			__func__);
+		goto xclk_off;
+	}
+
+	sc2235_reset(sensor);
+	sc2235_power(sensor, true);
+
+	return 0;
+
+xclk_off:
+	clk_disable_unprepare(sensor->xclk);
+	return ret;
+}
+
+static int sc2235_set_power_off(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+
+	sc2235_power(sensor, false);
+	regulator_bulk_disable(SC2235_NUM_SUPPLIES, sensor->supplies);
+	clk_disable_unprepare(sensor->xclk);
+
+	return 0;
+}
+
+static int sc2235_set_power(struct sc2235_dev *sensor, bool on)
+{
+	int ret = 0;
+
+	if (on) {
+		pm_runtime_get_sync(&sensor->i2c_client->dev);
+
+		ret = sc2235_restore_mode(sensor);
+		if (ret)
+			goto power_off;
+	}
+
+	if (!on)
+		pm_runtime_put_sync(&sensor->i2c_client->dev);
+
+	return 0;
+
+power_off:
+	pm_runtime_put_sync(&sensor->i2c_client->dev);
+
+	return ret;
+}
+
+static int sc2235_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	int ret = 0;
+
+	mutex_lock(&sensor->lock);
+
+	ret = sc2235_set_power(sensor, !!on);
+	if (ret)
+		goto out;
+
+	mutex_unlock(&sensor->lock);
+	return 0;
+
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int sc2235_try_frame_interval(struct sc2235_dev *sensor,
+				struct v4l2_fract *fi,
+				u32 width, u32 height)
+{
+	const struct sc2235_mode_info *mode;
+	enum sc2235_frame_rate rate = SC2235_15_FPS;
+	int minfps, maxfps, best_fps, fps;
+	int i;
+
+	minfps = sc2235_framerates[SC2235_15_FPS];
+	maxfps = sc2235_framerates[SC2235_30_FPS];
+
+	if (fi->numerator == 0) {
+		fi->denominator = maxfps;
+		fi->numerator = 1;
+		rate = SC2235_30_FPS;
+		goto find_mode;
+	}
+
+	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
+			minfps, maxfps);
+
+	best_fps = minfps;
+	for (i = 0; i < ARRAY_SIZE(sc2235_framerates); i++) {
+		int curr_fps = sc2235_framerates[i];
+
+		if (abs(curr_fps - fps) < abs(best_fps - fps)) {
+			best_fps = curr_fps;
+			rate = i;
+		}
+	}
+
+	fi->numerator = 1;
+	fi->denominator = best_fps;
+
+find_mode:
+	mode = sc2235_find_mode(sensor, rate, width, height, false);
+	return mode ? rate : -EINVAL;
+}
+
+static int sc2235_get_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *format)
+{
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	struct v4l2_mbus_framefmt *fmt;
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(&sensor->sd, cfg,
+						format->pad);
+	else
+		fmt = &sensor->fmt;
+
+	format->format = *fmt;
+
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int sc2235_try_fmt_internal(struct v4l2_subdev *sd,
+				struct v4l2_mbus_framefmt *fmt,
+				enum sc2235_frame_rate fr,
+				const struct sc2235_mode_info **new_mode)
+{
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	const struct sc2235_mode_info *mode;
+	int i;
+
+	mode = sc2235_find_mode(sensor, fr, fmt->width, fmt->height, true);
+	if (!mode)
+		return -EINVAL;
+	fmt->width = mode->hact;
+	fmt->height = mode->vact;
+
+	if (new_mode)
+		*new_mode = mode;
+
+	for (i = 0; i < ARRAY_SIZE(sc2235_formats); i++)
+		if (sc2235_formats[i].code == fmt->code)
+			break;
+	if (i >= ARRAY_SIZE(sc2235_formats))
+		i = 0;
+
+	fmt->code = sc2235_formats[i].code;
+	fmt->colorspace = sc2235_formats[i].colorspace;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+
+	return 0;
+}
+
+static int sc2235_set_fmt(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *format)
+{
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	const struct sc2235_mode_info *new_mode;
+	struct v4l2_mbus_framefmt *mbus_fmt = &format->format;
+	struct v4l2_mbus_framefmt *fmt;
+	int ret;
+
+	if (format->pad != 0)
+		return -EINVAL;
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = sc2235_try_fmt_internal(sd, mbus_fmt, 0, &new_mode);
+	if (ret)
+		goto out;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(sd, cfg, 0);
+	else
+		fmt = &sensor->fmt;
+
+	if (mbus_fmt->code != sensor->fmt.code)
+		sensor->pending_fmt_change = true;
+
+	*fmt = *mbus_fmt;
+
+	if (new_mode != sensor->current_mode) {
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+	if (new_mode->max_fps < sensor->current_fr) {
+		sensor->current_fr = new_mode->max_fps;
+		sensor->frame_interval.numerator = 1;
+		sensor->frame_interval.denominator =
+			sc2235_framerates[sensor->current_fr];
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+
+	__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
+				sc2235_calc_pixel_rate(sensor));
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int sc2235_set_framefmt(struct sc2235_dev *sensor,
+				struct v4l2_mbus_framefmt *format)
+{
+	int ret = 0;
+
+	switch (format->code) {
+	default:
+		return ret;
+	}
+	return ret;
+}
+
+/*
+ * Sensor Controls.
+ */
+
+static int sc2235_set_ctrl_hue(struct sc2235_dev *sensor, int value)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int sc2235_set_ctrl_contrast(struct sc2235_dev *sensor, int value)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int sc2235_set_ctrl_saturation(struct sc2235_dev *sensor, int value)
+{
+	int ret  = 0;
+	return ret;
+}
+
+static int sc2235_set_ctrl_white_balance(struct sc2235_dev *sensor, int awb)
+{
+	int ret = 0;
+	return ret;
+}
+
+static int sc2235_set_ctrl_exposure(struct sc2235_dev *sensor,
+				enum v4l2_exposure_auto_type auto_exposure)
+{
+	struct sc2235_ctrls *ctrls = &sensor->ctrls;
+	bool auto_exp = (auto_exposure == V4L2_EXPOSURE_AUTO);
+	int ret = 0;
+
+	if (ctrls->auto_exp->is_new) {
+		ret = sc2235_set_autoexposure(sensor, auto_exp);
+		if (ret)
+			return ret;
+	}
+
+	if (!auto_exp && ctrls->exposure->is_new) {
+		u16 max_exp = 0;
+
+		ret = sc2235_get_vts(sensor);
+		if (ret < 0)
+			return ret;
+		max_exp += ret - 4;
+		ret = 0;
+
+		if (ctrls->exposure->val < max_exp)
+			ret = sc2235_set_exposure(sensor, ctrls->exposure->val);
+	}
+
+	return ret;
+}
+
+static int sc2235_set_ctrl_gain(struct sc2235_dev *sensor, bool auto_gain)
+{
+	struct sc2235_ctrls *ctrls = &sensor->ctrls;
+	int ret = 0;
+
+	if (ctrls->auto_gain->is_new) {
+		ret = sc2235_set_autogain(sensor, auto_gain);
+		if (ret)
+			return ret;
+	}
+
+	if (!auto_gain && ctrls->gain->is_new)
+		ret = sc2235_set_gain(sensor, ctrls->gain->val);
+
+	return ret;
+}
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Black bars",
+	"Auto Black bars",
+};
+
+#define SC2235_TEST_ENABLE		BIT(3)
+#define SC2235_TEST_BLACK		(3 << 0)
+
+static int sc2235_set_ctrl_test_pattern(struct sc2235_dev *sensor, int value)
+{
+	int ret = 0;
+	/*
+	 *For 7110 platform, refer to 1125 FW code configuration. This operation will cause the image to be white.
+	 */
+#ifdef UNUSED_CODE
+	ret = sc2235_mod_reg(sensor, SC2235_REG_TEST_SET0, BIT(3),
+				!!value << 3);
+
+	ret |= sc2235_mod_reg(sensor, SC2235_REG_TEST_SET1, BIT(6),
+				(value >> 1) << 6);
+#endif
+	return ret;
+}
+
+static int sc2235_set_ctrl_light_freq(struct sc2235_dev *sensor, int value)
+{
+	return 0;
+}
+
+static int sc2235_set_ctrl_hflip(struct sc2235_dev *sensor, int value)
+{
+	return sc2235_mod_reg(sensor, SC2235_REG_TIMING_TC_REG21,
+				BIT(2) | BIT(1),
+				(!(value ^ sensor->upside_down)) ?
+				(BIT(2) | BIT(1)) : 0);
+}
+
+static int sc2235_set_ctrl_vflip(struct sc2235_dev *sensor, int value)
+{
+	return sc2235_mod_reg(sensor, SC2235_REG_TIMING_TC_REG21,
+				BIT(6) | BIT(5),
+				(value ^ sensor->upside_down) ?
+				(BIT(6) | BIT(5)) : 0);
+}
+
+static int sc2235_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	int val;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUTOGAIN:
+		val = sc2235_get_gain(sensor);
+		if (val < 0)
+			return val;
+		sensor->ctrls.gain->val = val;
+		break;
+	case V4L2_CID_EXPOSURE_AUTO:
+		val = sc2235_get_exposure(sensor);
+		if (val < 0)
+			return val;
+		sensor->ctrls.exposure->val = val;
+		break;
+	}
+
+	pm_runtime_put(&sensor->i2c_client->dev);
+
+	return 0;
+}
+
+static int sc2235_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	int ret;
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored at start streaming time.
+	 */
+	if (!pm_runtime_get_if_in_use(&sensor->i2c_client->dev))
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUTOGAIN:
+		ret = sc2235_set_ctrl_gain(sensor, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE_AUTO:
+		ret = sc2235_set_ctrl_exposure(sensor, ctrl->val);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		ret = sc2235_set_ctrl_white_balance(sensor, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		ret = sc2235_set_ctrl_hue(sensor, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = sc2235_set_ctrl_contrast(sensor, ctrl->val);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = sc2235_set_ctrl_saturation(sensor, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = sc2235_set_ctrl_test_pattern(sensor, ctrl->val);
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		ret = sc2235_set_ctrl_light_freq(sensor, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = sc2235_set_ctrl_hflip(sensor, ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = sc2235_set_ctrl_vflip(sensor, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	pm_runtime_put(&sensor->i2c_client->dev);
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops sc2235_ctrl_ops = {
+	.g_volatile_ctrl = sc2235_g_volatile_ctrl,
+	.s_ctrl = sc2235_s_ctrl,
+};
+
+static int sc2235_init_controls(struct sc2235_dev *sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &sc2235_ctrl_ops;
+	struct sc2235_ctrls *ctrls = &sensor->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	v4l2_ctrl_handler_init(hdl, 32);
+
+	/* we can use our own mutex for the ctrl lock */
+	hdl->lock = &sensor->lock;
+
+	/* Clock related controls */
+	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
+						0, INT_MAX, 1,
+						sc2235_calc_pixel_rate(sensor));
+
+	/* Auto/manual white balance */
+	ctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,
+					V4L2_CID_AUTO_WHITE_BALANCE,
+					0, 1, 1, 1);
+	ctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,
+						0, 4095, 1, 0);
+	ctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,
+						0, 4095, 1, 0);
+	/* Auto/manual exposure */
+#ifdef UNUSED_CODE
+	/*
+	 *For 7110 platform, This operation will cause the image to be white.
+	 */
+	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+						V4L2_CID_EXPOSURE_AUTO,
+						V4L2_EXPOSURE_MANUAL, 0,
+						V4L2_EXPOSURE_AUTO);
+	ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,
+					0, 65535, 1, 0);
+	/* Auto/manual gain */
+	ctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,
+						0, 1, 1, 1);
+	ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,
+					0, 1023, 1, 0);
+#else
+	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+						V4L2_CID_EXPOSURE_AUTO,
+						V4L2_EXPOSURE_MANUAL, 0,
+						1);
+	ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,
+					0, 65535, 1, 720);
+	/* Auto/manual gain */
+	ctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,
+						0, 1, 1, 0);
+	ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,
+					0, 1023, 1, 0x10);
+#endif
+	ctrls->saturation = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION,
+						0, 255, 1, 64);
+	ctrls->hue = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HUE,
+					0, 359, 1, 0);
+	ctrls->contrast = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST,
+						0, 255, 1, 0);
+	ctrls->test_pattern =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+					ARRAY_SIZE(test_pattern_menu) - 1,
+					0, 0, test_pattern_menu);   //0x02
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					0, 1, 1, 1);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					0, 1, 1, 0);
+
+	ctrls->light_freq =
+		v4l2_ctrl_new_std_menu(hdl, ops,
+					V4L2_CID_POWER_LINE_FREQUENCY,
+					V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,
+					V4L2_CID_POWER_LINE_FREQUENCY_50HZ);
+
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	ctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	v4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);
+	v4l2_ctrl_auto_cluster(2, &ctrls->auto_gain, 0, true);
+	v4l2_ctrl_auto_cluster(2, &ctrls->auto_exp, 1, true);
+
+	sensor->sd.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+
+static int sc2235_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->pad != 0)
+		return -EINVAL;
+	if (fse->index >= SC2235_NUM_MODES)
+		return -EINVAL;
+
+	fse->min_width =
+		sc2235_mode_data[fse->index].hact;
+	fse->max_width = fse->min_width;
+	fse->min_height =
+		sc2235_mode_data[fse->index].vact;
+	fse->max_height = fse->min_height;
+
+	return 0;
+}
+
+static int sc2235_enum_frame_interval(
+	struct v4l2_subdev *sd,
+	struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct v4l2_fract tpf;
+	int i;
+
+	if (fie->pad != 0)
+		return -EINVAL;
+
+	if (fie->index >= SC2235_NUM_FRAMERATES)
+		return -EINVAL;
+
+	tpf.numerator = 1;
+	tpf.denominator = sc2235_framerates[fie->index];
+
+	for (i = 0; i < SC2235_NUM_MODES; i++) {
+		if (fie->width == sc2235_mode_data[i].hact &&
+			fie->height == sc2235_mode_data[i].vact)
+			break;
+	}
+	if (i == SC2235_NUM_MODES)
+		return -ENOTTY;
+
+	fie->interval = tpf;
+	return 0;
+}
+
+static int sc2235_g_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *fi)
+{
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+
+	mutex_lock(&sensor->lock);
+	fi->interval = sensor->frame_interval;
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int sc2235_s_frame_interval(struct v4l2_subdev *sd,
+				struct v4l2_subdev_frame_interval *fi)
+{
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	const struct sc2235_mode_info *mode;
+	int frame_rate, ret = 0;
+
+	if (fi->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	mode = sensor->current_mode;
+
+	frame_rate = sc2235_try_frame_interval(sensor, &fi->interval,
+						mode->hact, mode->vact);
+	if (frame_rate < 0) {
+		/* Always return a valid frame interval value */
+		fi->interval = sensor->frame_interval;
+		goto out;
+	}
+
+	mode = sc2235_find_mode(sensor, frame_rate, mode->hact,
+				mode->vact, true);
+	if (!mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (mode != sensor->current_mode ||
+	    frame_rate != sensor->current_fr) {
+		sensor->current_fr = frame_rate;
+		sensor->frame_interval = fi->interval;
+		sensor->current_mode = mode;
+		sensor->pending_mode_change = true;
+
+		__v4l2_ctrl_s_ctrl_int64(sensor->ctrls.pixel_rate,
+					sc2235_calc_pixel_rate(sensor));
+	}
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int sc2235_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad != 0)
+		return -EINVAL;
+	if (code->index >= ARRAY_SIZE(sc2235_formats))
+		return -EINVAL;
+
+	code->code = sc2235_formats[code->index].code;
+	return 0;
+}
+
+static int sc2235_stream_start(struct sc2235_dev *sensor, int enable)
+{
+	return sc2235_mod_reg(sensor, SC2235_REG_STREAM_ON, BIT(0), !!enable);
+}
+
+static int sc2235_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+	int ret = 0;
+
+	if (enable) {
+		ret = v4l2_ctrl_handler_setup(&sensor->ctrls.handler);
+		if (ret)
+			return ret;
+	}
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming == !enable) {
+		if (enable && sensor->pending_mode_change) {
+			ret = sc2235_set_mode(sensor);
+			if (ret)
+				goto out;
+		}
+
+		if (enable && sensor->pending_fmt_change) {
+			ret = sc2235_set_framefmt(sensor, &sensor->fmt);
+			if (ret)
+				goto out;
+			sensor->pending_fmt_change = false;
+		}
+
+		ret = sc2235_stream_start(sensor, enable);
+		if (ret)
+			goto out;
+	}
+	sensor->streaming += enable ? 1 : -1;
+	WARN_ON(sensor->streaming < 0);
+out:
+	mutex_unlock(&sensor->lock);
+
+	return ret;
+}
+
+static const struct v4l2_subdev_core_ops sc2235_core_ops = {
+	.s_power = sc2235_s_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops sc2235_video_ops = {
+	.g_frame_interval = sc2235_g_frame_interval,
+	.s_frame_interval = sc2235_s_frame_interval,
+	.s_stream = sc2235_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops sc2235_pad_ops = {
+	.enum_mbus_code = sc2235_enum_mbus_code,
+	.get_fmt = sc2235_get_fmt,
+	.set_fmt = sc2235_set_fmt,
+	.enum_frame_size = sc2235_enum_frame_size,
+	.enum_frame_interval = sc2235_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops sc2235_subdev_ops = {
+	.core = &sc2235_core_ops,
+	.video = &sc2235_video_ops,
+	.pad = &sc2235_pad_ops,
+};
+
+static int sc2235_get_regulators(struct sc2235_dev *sensor)
+{
+	int i;
+
+	for (i = 0; i < SC2235_NUM_SUPPLIES; i++)
+		sensor->supplies[i].supply = sc2235_supply_name[i];
+
+	return devm_regulator_bulk_get(&sensor->i2c_client->dev,
+					SC2235_NUM_SUPPLIES,
+					sensor->supplies);
+}
+
+static int sc2235_check_chip_id(struct sc2235_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int ret = 0;
+	u16 chip_id;
+
+	ret = sc2235_read_reg16(sensor, SC2235_REG_CHIP_ID, &chip_id);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to read chip identifier\n",
+			__func__);
+		return ret;
+	}
+
+	if (chip_id != SC2235_CHIP_ID) {
+		dev_err(&client->dev, "%s: wrong chip identifier, expected 0x%x, got 0x%x\n",
+			__func__, SC2235_CHIP_ID, chip_id);
+		return -ENXIO;
+	}
+	dev_err(&client->dev, "%s: chip identifier, got 0x%x\n",
+		__func__, chip_id);
+
+	return 0;
+}
+
+static int sc2235_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	struct sc2235_dev *sensor;
+	struct v4l2_mbus_framefmt *fmt;
+	u32 rotation;
+	int ret;
+
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	sensor->i2c_client = client;
+
+	fmt = &sensor->fmt;
+	fmt->code = MEDIA_BUS_FMT_SBGGR10_1X10;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = 1920;
+	fmt->height = 1080;
+	fmt->field = V4L2_FIELD_NONE;
+	sensor->frame_interval.numerator = 1;
+	sensor->frame_interval.denominator = sc2235_framerates[SC2235_30_FPS];
+	sensor->current_fr = SC2235_30_FPS;
+	sensor->current_mode =
+		&sc2235_mode_data[SC2235_MODE_1080P_1920_1080];
+	sensor->last_mode = sensor->current_mode;
+
+	/* optional indication of physical rotation of sensor */
+	ret = fwnode_property_read_u32(dev_fwnode(&client->dev), "rotation",
+					&rotation);
+	if (!ret) {
+		switch (rotation) {
+		case 180:
+			sensor->upside_down = true;
+			fallthrough;
+		case 0:
+			break;
+		default:
+			dev_warn(dev, "%u degrees rotation is not supported, ignoring...\n",
+				rotation);
+		}
+	}
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev),
+						NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &sensor->ep);
+	fwnode_handle_put(endpoint);
+	if (ret) {
+		dev_err(dev, "Could not parse endpoint\n");
+		return ret;
+	}
+
+	if (sensor->ep.bus_type != V4L2_MBUS_PARALLEL) {
+		dev_err(dev, "Unsupported bus type %d\n", sensor->ep.bus_type);
+		return -EINVAL;
+	}
+
+	/* get system clock (xclk) */
+	sensor->xclk = devm_clk_get(dev, "xclk");
+	if (IS_ERR(sensor->xclk)) {
+		dev_err(dev, "failed to get xclk\n");
+		return PTR_ERR(sensor->xclk);
+	}
+
+	sensor->xclk_freq = clk_get_rate(sensor->xclk);
+	if (sensor->xclk_freq < SC2235_XCLK_MIN ||
+	    sensor->xclk_freq > SC2235_XCLK_MAX) {
+		dev_err(dev, "xclk frequency out of range: %d Hz\n",
+			sensor->xclk_freq);
+		return -EINVAL;
+	}
+
+	sensor->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
+						GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->pwdn_gpio))
+		return PTR_ERR(sensor->pwdn_gpio);
+
+	sensor->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->reset_gpio))
+		return PTR_ERR(sensor->reset_gpio);
+
+	v4l2_i2c_subdev_init(&sensor->sd, client, &sc2235_subdev_ops);
+
+	sensor->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			V4L2_SUBDEV_FL_HAS_EVENTS;
+	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);
+	if (ret)
+		return ret;
+
+	ret = sc2235_get_regulators(sensor);
+	if (ret)
+		return ret;
+	mutex_init(&sensor->lock);
+
+	ret = sc2235_set_power_on(dev);
+	if (ret) {
+		dev_err(dev, "failed to power on\n");
+		goto entity_cleanup;
+	}
+
+	ret = sc2235_check_chip_id(sensor);
+	if (ret)
+		goto entity_power_off;
+
+	ret = sc2235_init_controls(sensor);
+	if (ret)
+		goto entity_power_off;
+
+	ret = v4l2_async_register_subdev_sensor_common(&sensor->sd);
+	if (ret)
+		goto free_ctrls;
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+entity_power_off:
+	sc2235_set_power_off(dev);
+entity_cleanup:
+	media_entity_cleanup(&sensor->sd.entity);
+	mutex_destroy(&sensor->lock);
+	return ret;
+}
+
+static int sc2235_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct sc2235_dev *sensor = to_sc2235_dev(sd);
+
+	v4l2_async_unregister_subdev(&sensor->sd);
+	media_entity_cleanup(&sensor->sd.entity);
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+	mutex_destroy(&sensor->lock);
+
+	pm_runtime_disable(&client->dev);
+	if (!pm_runtime_status_suspended(&client->dev))
+		sc2235_set_power_off(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	return 0;
+}
+
+static const struct i2c_device_id sc2235_id[] = {
+	{ "sc2235", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, sc2235_id);
+
+static const struct of_device_id sc2235_dt_ids[] = {
+	{ .compatible = "smartsens,sc2235" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sc2235_dt_ids);
+
+static const struct dev_pm_ops sc2235_pm_ops = {
+	SET_RUNTIME_PM_OPS(sc2235_set_power_off, sc2235_set_power_on, NULL)
+};
+
+static struct i2c_driver sc2235_i2c_driver = {
+	.driver = {
+		.name  = "sc2235",
+		.of_match_table	= sc2235_dt_ids,
+		.pm = &sc2235_pm_ops,
+	},
+	.id_table = sc2235_id,
+	.probe_new = sc2235_probe,
+	.remove   = sc2235_remove,
+};
+
+module_i2c_driver(sc2235_i2c_driver);
+
+MODULE_DESCRIPTION("SC2235 Camera Subdev Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_common.h b/drivers/media/platform/starfive/v4l2_driver/stf_common.h
new file mode 100644
index 000000000000..8793f360b61f
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_common.h
@@ -0,0 +1,183 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_COMMON_H
+#define STF_COMMON_H
+
+#include <linux/kern_levels.h>
+
+// #define STF_DEBUG
+
+#define USE_CSIDPHY_ONE_CLK_MODE 1
+
+enum {
+	ST_DVP = 0x0001,
+	ST_CSIPHY = 0x0002,
+	ST_CSI = 0x0004,
+	ST_ISP = 0x0008,
+	ST_VIN = 0x0010,
+	ST_VIDEO = 0x0020,
+	ST_CAMSS = 0x0040,
+	ST_SENSOR = 0x0080,
+};
+
+enum {
+	ST_NONE = 0x00,
+	ST_ERR = 0x01,
+	ST_WARN = 0x02,
+	ST_INFO = 0x03,
+	ST_DEBUG = 0x04,
+};
+
+extern unsigned int stdbg_level;
+extern unsigned int stdbg_mask;
+
+#define ST_MODULE2STRING(__module) ({ \
+	char *__str; \
+	\
+	switch (__module) { \
+	case ST_DVP: \
+		__str = "st_dvp"; \
+		break; \
+	case ST_CSIPHY: \
+		__str = "st_csiphy"; \
+		break; \
+	case ST_CSI: \
+		__str = "st_csi"; \
+		break; \
+	case ST_ISP: \
+		__str = "st_isp"; \
+		break; \
+	case ST_VIN: \
+		__str = "st_vin"; \
+		break; \
+	case ST_VIDEO: \
+		__str = "st_video"; \
+		break; \
+	case ST_CAMSS: \
+		__str = "st_camss"; \
+		break; \
+	case ST_SENSOR: \
+		__str = "st_sensor"; \
+		break; \
+	default: \
+		__str = "unknow"; \
+		break; \
+	} \
+	\
+	__str; \
+	})
+
+#define st_debug(module, __fmt, arg...)	\
+	do { \
+		if (stdbg_level > ST_INFO) { \
+			if (stdbg_mask & module)  \
+				pr_err("[%s] debug: " __fmt, \
+						ST_MODULE2STRING(module), \
+						## arg); \
+		} \
+	} while (0)
+
+#define st_info(module, __fmt, arg...)	\
+	do { \
+		if (stdbg_level > ST_WARN) { \
+			if (stdbg_mask & module)  \
+				pr_err("[%s] info: " __fmt, \
+						ST_MODULE2STRING(module), \
+						## arg); \
+		} \
+	} while (0)
+
+#define st_warn(module, __fmt, arg...)	\
+	do { \
+		if (stdbg_level > ST_ERR) { \
+			if (stdbg_mask & module)  \
+				pr_err("[%s] warn: " __fmt, \
+						ST_MODULE2STRING(module), \
+						## arg); \
+		} \
+	} while (0)
+
+#define st_err(module, __fmt, arg...)	\
+	do { \
+		if (stdbg_level > ST_NONE) { \
+			if (stdbg_mask & module) \
+				pr_err("[%s] error: " __fmt, \
+						ST_MODULE2STRING(module), \
+						## arg); \
+		} \
+	} while (0)
+
+#define st_err_ratelimited(module, fmt, ...)                 \
+	do {                                                                    \
+		static DEFINE_RATELIMIT_STATE(_rs,                              \
+						DEFAULT_RATELIMIT_INTERVAL,     \
+						DEFAULT_RATELIMIT_BURST);       \
+		if (__ratelimit(&_rs) && (stdbg_level > ST_NONE)) {             \
+			if (stdbg_mask & module)                                \
+				pr_err("[%s] error: " fmt,                      \
+						ST_MODULE2STRING(module),       \
+						##__VA_ARGS__);                 \
+		} \
+	} while (0)
+
+#define set_bits(p, v, b, m)	(((p) & ~(m)) | ((v) << (b)))
+
+static inline u32 reg_read(void __iomem *base, u32 reg)
+{
+	return ioread32(base + reg);
+}
+
+static inline void reg_write(void __iomem *base, u32 reg, u32 val)
+{
+	iowrite32(val, base + reg);
+}
+
+static inline void reg_set_bit(void __iomem *base, u32 reg, u32 mask, u32 val)
+{
+	u32 value;
+
+	value = ioread32(base + reg) & ~mask;
+	val &= mask;
+	val |= value;
+	iowrite32(val, base + reg);
+}
+
+static inline void reg_set(void __iomem *base, u32 reg, u32 mask)
+{
+	iowrite32(ioread32(base + reg) | mask, base + reg);
+}
+
+static inline void reg_clear(void __iomem *base, u32 reg, u32 mask)
+{
+	iowrite32(ioread32(base + reg) & ~mask, base + reg);
+}
+
+static inline void reg_set_highest_bit(void __iomem *base, u32 reg)
+{
+	u32 val;
+
+	val = ioread32(base + reg);
+	val &= ~(0x1 << 31);
+	val |= (0x1 & 0x1) << 31;
+	iowrite32(val, base + reg);
+}
+
+static inline void reg_clr_highest_bit(void __iomem *base, u32 reg)
+{
+	u32 val;
+
+	val = ioread32(base + reg);
+	val &= ~(0x1 << 31);
+	val |= (0x0 & 0x1) << 31;
+	iowrite32(val, base + reg);
+}
+
+static inline void print_reg(unsigned int module, void __iomem *base, u32 reg)
+{
+	//st_debug(module, "REG 0x%x = 0x%x\n",
+	//		base + reg, ioread32(base + reg));
+}
+
+#endif /* STF_COMMON_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_csi.c b/drivers/media/platform/starfive/v4l2_driver/stf_csi.c
new file mode 100644
index 000000000000..bf3010c4aad4
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_csi.c
@@ -0,0 +1,424 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include "stfcamss.h"
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+static const struct csi_format csi_formats_st7110[] = {
+	{ MEDIA_BUS_FMT_YUYV8_2X8, 16},
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, 16},
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10},
+};
+
+static int csi_find_format(u32 code,
+		const struct csi_format *formats,
+		unsigned int nformats)
+{
+	int i;
+
+	for (i = 0; i < nformats; i++)
+		if (formats[i].code == code)
+			return i;
+	return -EINVAL;
+}
+
+int stf_csi_subdev_init(struct stfcamss *stfcamss)
+{
+	struct stf_csi_dev *csi_dev = stfcamss->csi_dev;
+
+	csi_dev->s_type = SENSOR_VIN;
+	csi_dev->hw_ops = &csi_ops;
+	csi_dev->stfcamss = stfcamss;
+	csi_dev->formats = csi_formats_st7110;
+	csi_dev->nformats = ARRAY_SIZE(csi_formats_st7110);
+	mutex_init(&csi_dev->stream_lock);
+	return 0;
+}
+
+static int csi_set_power(struct v4l2_subdev *sd, int on)
+{
+	struct stf_csi_dev *csi_dev = v4l2_get_subdevdata(sd);
+
+	csi_dev->hw_ops->csi_power_on(csi_dev, (u8)on);
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__csi_get_format(struct stf_csi_dev *csi_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		unsigned int pad,
+		enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(&csi_dev->subdev, cfg, pad);
+
+	return &csi_dev->fmt[pad];
+}
+
+static u32 code_to_data_type(int code)
+{
+	switch (code) {
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+		return 0x2b;
+	case MEDIA_BUS_FMT_YUYV8_2X8:
+		return 0x1E;
+	case MEDIA_BUS_FMT_RGB565_2X8_LE:
+		return 0x22;
+	default:
+		return 0x2b;
+	}
+}
+
+static int csi_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct stf_csi_dev *csi_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+	int ret = 0;
+	u32 code, width, dt;
+
+	format = __csi_get_format(csi_dev, NULL, STF_CSI_PAD_SRC,
+				V4L2_SUBDEV_FORMAT_ACTIVE);
+	if (format == NULL)
+		return -EINVAL;
+
+	width = format->width;
+
+	ret = csi_find_format(format->code,
+				csi_dev->formats,
+				csi_dev->nformats);
+	if (ret < 0)
+		return ret;
+
+	code = csi_dev->formats[ret].code;
+	dt = code_to_data_type(code);
+
+	mutex_lock(&csi_dev->stream_lock);
+	if (enable) {
+		if (csi_dev->stream_count == 0) {
+			csi_dev->hw_ops->csi_clk_enable(csi_dev);
+			csi_dev->hw_ops->csi_stream_set(csi_dev, enable, dt, width);
+		}
+		csi_dev->stream_count++;
+	} else {
+		if (csi_dev->stream_count == 0)
+			goto exit;
+		if (csi_dev->stream_count == 1) {
+			csi_dev->hw_ops->csi_stream_set(csi_dev, enable, dt, width);
+			csi_dev->hw_ops->csi_clk_disable(csi_dev);
+		}
+		csi_dev->stream_count--;
+	}
+exit:
+	mutex_unlock(&csi_dev->stream_lock);
+	return 0;
+}
+
+static void csi_try_format(struct stf_csi_dev *csi_dev,
+			struct v4l2_subdev_pad_config *cfg,
+			unsigned int pad,
+			struct v4l2_mbus_framefmt *fmt,
+			enum v4l2_subdev_format_whence which)
+{
+	unsigned int i;
+
+	switch (pad) {
+	case STF_CSI_PAD_SINK:
+		/* Set format on sink pad */
+
+		for (i = 0; i < csi_dev->nformats; i++)
+			if (fmt->code == csi_dev->formats[i].code)
+				break;
+
+		if (i >= csi_dev->nformats)
+			fmt->code = csi_dev->formats[0].code;
+
+		fmt->width = clamp_t(u32,
+				fmt->width,
+				STFCAMSS_FRAME_MIN_WIDTH,
+				STFCAMSS_FRAME_MAX_WIDTH);
+		fmt->height = clamp_t(u32,
+				fmt->height,
+				STFCAMSS_FRAME_MIN_HEIGHT,
+				STFCAMSS_FRAME_MAX_HEIGHT);
+
+
+		fmt->field = V4L2_FIELD_NONE;
+		fmt->colorspace = V4L2_COLORSPACE_SRGB;
+		fmt->flags = 0;
+
+		break;
+
+	case STF_CSI_PAD_SRC:
+
+		*fmt = *__csi_get_format(csi_dev, cfg, STF_CSI_PAD_SINK, which);
+
+		break;
+	}
+}
+
+static int csi_enum_mbus_code(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct stf_csi_dev *csi_dev = v4l2_get_subdevdata(sd);
+
+	if (code->index >= csi_dev->nformats)
+		return -EINVAL;
+	if (code->pad == STF_CSI_PAD_SINK) {
+		code->code = csi_dev->formats[code->index].code;
+	} else {
+		struct v4l2_mbus_framefmt *sink_fmt;
+
+		sink_fmt = __csi_get_format(csi_dev, cfg, STF_CSI_PAD_SINK,
+						code->which);
+
+		code->code = sink_fmt->code;
+		if (!code->code)
+			return -EINVAL;
+	}
+	code->flags = 0;
+
+	return 0;
+}
+
+static int csi_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct stf_csi_dev *csi_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt format;
+
+	if (fse->index != 0)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = 1;
+	format.height = 1;
+	csi_try_format(csi_dev, cfg, fse->pad, &format, fse->which);
+	fse->min_width = format.width;
+	fse->min_height = format.height;
+
+	if (format.code != fse->code)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = -1;
+	format.height = -1;
+	csi_try_format(csi_dev, cfg, fse->pad, &format, fse->which);
+	fse->max_width = format.width;
+	fse->max_height = format.height;
+
+	return 0;
+}
+
+static int csi_get_format(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct stf_csi_dev *csi_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __csi_get_format(csi_dev, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int csi_set_format(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct stf_csi_dev *csi_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __csi_get_format(csi_dev, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&csi_dev->stream_lock);
+	if (csi_dev->stream_count) {
+		fmt->format = *format;
+		mutex_unlock(&csi_dev->stream_lock);
+		goto out;
+	} else {
+		csi_try_format(csi_dev, cfg, fmt->pad, &fmt->format, fmt->which);
+		*format = fmt->format;
+	}
+	mutex_unlock(&csi_dev->stream_lock);
+
+	/* Propagate the format from sink to source */
+	if (fmt->pad == STF_CSI_PAD_SINK) {
+		format = __csi_get_format(csi_dev, cfg, STF_CSI_PAD_SRC,
+					fmt->which);
+
+		*format = fmt->format;
+		csi_try_format(csi_dev, cfg, STF_CSI_PAD_SRC, format,
+					fmt->which);
+	}
+out:
+	return 0;
+}
+
+static int csi_init_formats(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh)
+{
+	struct v4l2_subdev_format format = {
+		.pad = STF_CSI_PAD_SINK,
+		.which = fh ? V4L2_SUBDEV_FORMAT_TRY :
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+		.format = {
+			.code = MEDIA_BUS_FMT_RGB565_2X8_LE,
+			.width = 1920,
+			.height = 1080
+		}
+	};
+
+	return csi_set_format(sd, fh ? fh->pad : NULL, &format);
+}
+
+static int csi_link_setup(struct media_entity *entity,
+			const struct media_pad *local,
+			const struct media_pad *remote, u32 flags)
+{
+	if ((local->flags & MEDIA_PAD_FL_SOURCE) &&
+		(flags & MEDIA_LNK_FL_ENABLED)) {
+		struct v4l2_subdev *sd;
+		struct stf_csi_dev *csi_dev;
+		struct vin_line *line;
+
+		if (media_entity_remote_pad(local))
+			return -EBUSY;
+
+		sd = media_entity_to_v4l2_subdev(entity);
+		csi_dev = v4l2_get_subdevdata(sd);
+
+		sd = media_entity_to_v4l2_subdev(remote->entity);
+		line = v4l2_get_subdevdata(sd);
+		if (line->sdev_type == VIN_DEV_TYPE)
+			csi_dev->s_type = SENSOR_VIN;
+		if (line->sdev_type == ISP_DEV_TYPE)
+			csi_dev->s_type = SENSOR_ISP;
+		st_info(ST_CSI, "CSI device sensor type: %d\n", csi_dev->s_type);
+	}
+
+	if ((local->flags & MEDIA_PAD_FL_SINK) &&
+		(flags & MEDIA_LNK_FL_ENABLED)) {
+		struct v4l2_subdev *sd;
+		struct stf_csi_dev *csi_dev;
+		struct stf_csiphy_dev *csiphy_dev;
+
+		if (media_entity_remote_pad(local))
+			return -EBUSY;
+
+		sd = media_entity_to_v4l2_subdev(entity);
+		csi_dev = v4l2_get_subdevdata(sd);
+
+		sd = media_entity_to_v4l2_subdev(remote->entity);
+		csiphy_dev = v4l2_get_subdevdata(sd);
+
+		st_info(ST_CSI, "CSI0 link to csiphy0\n");
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops csi_core_ops = {
+	.s_power = csi_set_power,
+};
+
+static const struct v4l2_subdev_video_ops csi_video_ops = {
+	.s_stream = csi_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops csi_pad_ops = {
+	.enum_mbus_code = csi_enum_mbus_code,
+	.enum_frame_size = csi_enum_frame_size,
+	.get_fmt = csi_get_format,
+	.set_fmt = csi_set_format,
+};
+
+static const struct v4l2_subdev_ops csi_v4l2_ops = {
+	.core = &csi_core_ops,
+	.video = &csi_video_ops,
+	.pad = &csi_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops csi_v4l2_internal_ops = {
+	.open = csi_init_formats,
+};
+
+static const struct media_entity_operations csi_media_ops = {
+	.link_setup = csi_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+int stf_csi_register(struct stf_csi_dev *csi_dev, struct v4l2_device *v4l2_dev)
+{
+	struct v4l2_subdev *sd = &csi_dev->subdev;
+	struct device *dev = csi_dev->stfcamss->dev;
+	struct media_pad *pads = csi_dev->pads;
+	int ret;
+
+	csi_dev->mipirx_0p9 = devm_regulator_get(dev, "mipi_0p9");
+	if (IS_ERR(csi_dev->mipirx_0p9))
+		return PTR_ERR(csi_dev->mipirx_0p9);
+
+	v4l2_subdev_init(sd, &csi_v4l2_ops);
+	sd->internal_ops = &csi_v4l2_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	snprintf(sd->name, ARRAY_SIZE(sd->name), "%s%d",
+		STF_CSI_NAME, 0);
+	v4l2_set_subdevdata(sd, csi_dev);
+
+	ret = csi_init_formats(sd, NULL);
+	if (ret < 0) {
+		dev_err(dev, "Failed to init format: %d\n", ret);
+		return ret;
+	}
+
+	pads[STF_CSI_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	pads[STF_CSI_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE;
+
+	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+	sd->entity.ops = &csi_media_ops;
+	ret = media_entity_pads_init(&sd->entity, STF_CSI_PADS_NUM, pads);
+	if (ret < 0) {
+		dev_err(dev, "Failed to init media entity: %d\n", ret);
+		return ret;
+	}
+
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register subdev: %d\n", ret);
+		goto err_sreg;
+	}
+
+	return 0;
+
+err_sreg:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+int stf_csi_unregister(struct stf_csi_dev *csi_dev)
+{
+	v4l2_device_unregister_subdev(&csi_dev->subdev);
+	media_entity_cleanup(&csi_dev->subdev.entity);
+	mutex_destroy(&csi_dev->stream_lock);
+	return 0;
+}
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_csi.h b/drivers/media/platform/starfive/v4l2_driver/stf_csi.h
new file mode 100644
index 000000000000..c480b225fd96
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_csi.h
@@ -0,0 +1,57 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_CSI_H
+#define STF_CSI_H
+
+#include <linux/regulator/consumer.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/media-entity.h>
+#include <video/stf-vin.h>
+
+#define STF_CSI_NAME "stf_csi"
+
+#define STF_CSI_PAD_SINK     0
+#define STF_CSI_PAD_SRC      1
+#define STF_CSI_PADS_NUM     2
+
+struct csi_format {
+	u32 code;
+	u8 bpp;
+};
+
+struct stf_csi_dev;
+
+struct csi_hw_ops {
+	int (*csi_power_on)(struct stf_csi_dev *csi_dev, u8 on);
+	int (*csi_clk_enable)(struct stf_csi_dev *csi_dev);
+	int (*csi_clk_disable)(struct stf_csi_dev *csi_dev);
+	int (*csi_set_format)(struct stf_csi_dev *csi_dev,
+			u32 vsize, u8 bpp, int is_raw10);
+	int (*csi_stream_set)(struct stf_csi_dev *csi_dev, int on, u32 dt, u32 width);
+};
+
+struct stf_csi_dev {
+	struct stfcamss *stfcamss;
+	enum sensor_type s_type;
+	struct v4l2_subdev subdev;
+	struct media_pad pads[STF_CSI_PADS_NUM];
+	struct v4l2_mbus_framefmt fmt[STF_CSI_PADS_NUM];
+	const struct csi_format *formats;
+	unsigned int nformats;
+	struct csi_hw_ops *hw_ops;
+	struct mutex stream_lock;
+	int stream_count;
+	struct regulator *mipirx_0p9;
+};
+
+extern int stf_csi_subdev_init(struct stfcamss *stfcamss);
+extern int stf_csi_register(struct stf_csi_dev *csi_dev,
+			struct v4l2_device *v4l2_dev);
+extern int stf_csi_unregister(struct stf_csi_dev *csi_dev);
+extern struct csi_hw_ops csi_ops;
+extern void dump_csi_reg(void *__iomem csibase);
+
+#endif /* STF_CSI_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_csi_hw_ops.c b/drivers/media/platform/starfive/v4l2_driver/stf_csi_hw_ops.c
new file mode 100644
index 000000000000..687785a80477
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_csi_hw_ops.c
@@ -0,0 +1,282 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * linux/drivers/media/platform/starfive/stf_csi.c
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ *
+ */
+#include "stfcamss.h"
+#include <linux/regmap.h>
+
+#define CSI2RX_DEVICE_CFG_REG			0x000
+
+#define CSI2RX_SOFT_RESET_REG			0x004
+#define CSI2RX_SOFT_RESET_PROTOCOL		BIT(1)
+#define CSI2RX_SOFT_RESET_FRONT			BIT(0)
+
+#define CSI2RX_DPHY_LANE_CONTROL                0x040
+
+#define CSI2RX_STATIC_CFG_REG			0x008
+#define CSI2RX_STATIC_CFG_DLANE_MAP(llane, plane)	\
+		((plane) << (16 + (llane) * 4))
+#define CSI2RX_STATIC_CFG_LANES_MASK		GENMASK(11, 8)
+
+#define CSI2RX_STREAM_BASE(n)		(((n) + 1) * 0x100)
+
+#define CSI2RX_STREAM_CTRL_REG(n)		(CSI2RX_STREAM_BASE(n) + 0x000)
+#define CSI2RX_STREAM_CTRL_START		BIT(0)
+
+#define CSI2RX_STREAM_DATA_CFG_REG(n)		(CSI2RX_STREAM_BASE(n) + 0x008)
+#define CSI2RX_STREAM_DATA_CFG_EN_VC_SELECT	BIT(31)
+#define CSI2RX_STREAM_DATA_CFG_EN_DATA_TYPE_0 BIT(7)
+#define CSI2RX_STREAM_DATA_CFG_VC_SELECT(n)	BIT((n) + 16)
+
+#define CSI2RX_STREAM_CFG_REG(n)		(CSI2RX_STREAM_BASE(n) + 0x00c)
+#define CSI2RX_STREAM_CFG_FIFO_MODE_LARGE_BUF	(1 << 8)
+
+#define CSI2RX_LANES_MAX	4
+#define CSI2RX_STREAMS_MAX	4
+
+static int stf_csi_power_on(struct stf_csi_dev *csi_dev, u8 on)
+{
+	struct stfcamss *stfcamss = csi_dev->stfcamss;
+	int ret;
+
+	if (on) {
+		ret = regulator_enable(csi_dev->mipirx_0p9);
+		if (ret) {
+			st_err(ST_CSI, "Cannot enable mipirx_0p9 regulator\n");
+			return ret;
+		}
+	} else
+		regulator_disable(csi_dev->mipirx_0p9);
+
+	regmap_update_bits(stfcamss->stf_aon_syscon, stfcamss->aon_gp_reg,
+				BIT(31), BIT(31));
+
+	return 0;
+}
+
+static int stf_csi_clk_enable(struct stf_csi_dev *csi_dev)
+{
+	struct stfcamss *stfcamss = csi_dev->stfcamss;
+
+	clk_set_rate(stfcamss->sys_clk[STFCLK_MIPI_RX0_PXL].clk, 198000000);
+	clk_prepare_enable(stfcamss->sys_clk[STFCLK_PIXEL_CLK_IF0].clk);
+	clk_prepare_enable(stfcamss->sys_clk[STFCLK_PIXEL_CLK_IF1].clk);
+	clk_prepare_enable(stfcamss->sys_clk[STFCLK_PIXEL_CLK_IF2].clk);
+	clk_prepare_enable(stfcamss->sys_clk[STFCLK_PIXEL_CLK_IF3].clk);
+
+	reset_control_deassert(stfcamss->sys_rst[STFRST_PIXEL_CLK_IF0].rstc);
+	reset_control_deassert(stfcamss->sys_rst[STFRST_PIXEL_CLK_IF1].rstc);
+	reset_control_deassert(stfcamss->sys_rst[STFRST_PIXEL_CLK_IF2].rstc);
+	reset_control_deassert(stfcamss->sys_rst[STFRST_PIXEL_CLK_IF3].rstc);
+
+	switch (csi_dev->s_type) {
+	case SENSOR_VIN:
+		reset_control_deassert(stfcamss->sys_rst[STFRST_AXIWR].rstc);
+		clk_set_parent(stfcamss->sys_clk[STFCLK_AXIWR].clk,
+			stfcamss->sys_clk[STFCLK_MIPI_RX0_PXL].clk);
+		break;
+	case SENSOR_ISP:
+		clk_set_parent(stfcamss->sys_clk[STFCLK_WRAPPER_CLK_C].clk,
+			stfcamss->sys_clk[STFCLK_MIPI_RX0_PXL].clk);
+		break;
+	}
+
+	return 0;
+}
+
+static int stf_csi_clk_disable(struct stf_csi_dev *csi_dev)
+{
+	struct stfcamss *stfcamss = csi_dev->stfcamss;
+
+	switch (csi_dev->s_type) {
+	case SENSOR_VIN:
+		reset_control_assert(stfcamss->sys_rst[STFRST_AXIWR].rstc);
+		break;
+	case SENSOR_ISP:
+		break;
+	}
+
+	reset_control_assert(stfcamss->sys_rst[STFRST_PIXEL_CLK_IF3].rstc);
+	reset_control_assert(stfcamss->sys_rst[STFRST_PIXEL_CLK_IF2].rstc);
+	reset_control_assert(stfcamss->sys_rst[STFRST_PIXEL_CLK_IF1].rstc);
+	reset_control_assert(stfcamss->sys_rst[STFRST_PIXEL_CLK_IF0].rstc);
+
+	clk_disable_unprepare(stfcamss->sys_clk[STFCLK_PIXEL_CLK_IF3].clk);
+	clk_disable_unprepare(stfcamss->sys_clk[STFCLK_PIXEL_CLK_IF2].clk);
+	clk_disable_unprepare(stfcamss->sys_clk[STFCLK_PIXEL_CLK_IF1].clk);
+	clk_disable_unprepare(stfcamss->sys_clk[STFCLK_PIXEL_CLK_IF0].clk);
+
+	return 0;
+}
+
+static void csi2rx_reset(void *reg_base)
+{
+	writel(CSI2RX_SOFT_RESET_PROTOCOL | CSI2RX_SOFT_RESET_FRONT,
+	       reg_base + CSI2RX_SOFT_RESET_REG);
+
+	udelay(10);
+
+	writel(0, reg_base + CSI2RX_SOFT_RESET_REG);
+}
+
+static int csi2rx_start(struct stf_csi_dev *csi_dev, void *reg_base, u32 dt)
+{
+	struct stfcamss *stfcamss = csi_dev->stfcamss;
+	struct csi2phy_cfg *csiphy =
+		stfcamss->csiphy_dev->csiphy;
+	unsigned int i;
+	unsigned long lanes_used = 0;
+	u32 reg;
+
+	if (!csiphy) {
+		st_err(ST_CSI, "csiphy0 config not exist\n");
+		return -EINVAL;
+	}
+
+	csi2rx_reset(reg_base);
+
+	reg = csiphy->num_data_lanes << 8;
+	for (i = 0; i < csiphy->num_data_lanes; i++) {
+#ifndef USE_CSIDPHY_ONE_CLK_MODE
+		reg |= CSI2RX_STATIC_CFG_DLANE_MAP(i, csiphy->data_lanes[i]);
+		set_bit(csiphy->data_lanes[i] - 1, &lanes_used);
+#else
+		reg |= CSI2RX_STATIC_CFG_DLANE_MAP(i, i + 1);
+		set_bit(i, &lanes_used);
+#endif
+	}
+
+	/*
+	 * Even the unused lanes need to be mapped. In order to avoid
+	 * to map twice to the same physical lane, keep the lanes used
+	 * in the previous loop, and only map unused physical lanes to
+	 * the rest of our logical lanes.
+	 */
+	for (i = csiphy->num_data_lanes; i < CSI2RX_LANES_MAX; i++) {
+		unsigned int idx = find_first_zero_bit(&lanes_used,
+						       CSI2RX_LANES_MAX);
+
+		set_bit(idx, &lanes_used);
+		reg |= CSI2RX_STATIC_CFG_DLANE_MAP(i, idx + 1);
+	}
+
+	writel(reg, reg_base + CSI2RX_STATIC_CFG_REG);
+
+	// 0x40 DPHY_LANE_CONTROL
+	reg = 0;
+#ifndef USE_CSIDPHY_ONE_CLK_MODE
+	for (i = 0; i < csiphy->num_data_lanes; i++)
+		reg |= 1 << (csiphy->data_lanes[i] - 1)
+			| 1 << (csiphy->data_lanes[i] + 11);
+#else
+	for (i = 0; i < csiphy->num_data_lanes; i++)
+		reg |= 1 << i | 1 << (i + 12);		//data_clane
+#endif
+
+	reg |= 1 << 4 | 1 << 16;		//clk_lane
+	writel(reg, reg_base + CSI2RX_DPHY_LANE_CONTROL);
+
+	/*
+	 * Create a static mapping between the CSI virtual channels
+	 * and the output stream.
+	 *
+	 * This should be enhanced, but v4l2 lacks the support for
+	 * changing that mapping dynamically.
+	 *
+	 * We also cannot enable and disable independent streams here,
+	 * hence the reference counting.
+	 */
+	for (i = 0; i < CSI2RX_STREAMS_MAX; i++) {
+		writel(CSI2RX_STREAM_CFG_FIFO_MODE_LARGE_BUF,
+		       reg_base + CSI2RX_STREAM_CFG_REG(i));
+
+		writel(CSI2RX_STREAM_DATA_CFG_EN_VC_SELECT |
+		       CSI2RX_STREAM_DATA_CFG_VC_SELECT(i) |
+		       CSI2RX_STREAM_DATA_CFG_EN_DATA_TYPE_0 | dt,
+		       reg_base + CSI2RX_STREAM_DATA_CFG_REG(i));
+
+		writel(CSI2RX_STREAM_CTRL_START,
+		       reg_base + CSI2RX_STREAM_CTRL_REG(i));
+	}
+
+	return 0;
+}
+
+static void csi2rx_stop(struct stf_csi_dev *csi_dev, void *reg_base)
+{
+	unsigned int i;
+
+	for (i = 0; i < CSI2RX_STREAMS_MAX; i++)
+		writel(0, reg_base + CSI2RX_STREAM_CTRL_REG(i));
+}
+
+static int stf_csi_stream_set(struct stf_csi_dev *csi_dev,
+					int on, u32 dt, u32 width)
+{
+	struct stf_vin_dev *vin = csi_dev->stfcamss->vin;
+	void __iomem *reg_base = vin->csi2rx_base;
+
+	switch (csi_dev->s_type) {
+	case SENSOR_VIN:
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_20,
+			BIT(3)|BIT(2)|BIT(1)|BIT(0),
+			0<<0);		//u0_vin_cnfg_axiwr0_channel_sel
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_28,
+			BIT(14)|BIT(13),
+			1<<13);		//u0_vin_cnfg_axiwr0_pix_ct
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_28,
+			BIT(16)|BIT(15),
+			0<<15);		//u0_vin_cnfg_axiwr0_pixel_high_bit_sel
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_28,
+			BIT(12)|BIT(11)|BIT(10)|BIT(9)|BIT(8)|BIT(7)|BIT(6)|BIT(5)|BIT(4)|BIT(3)|BIT(2),
+			(width / 4 - 1)<<2);	//u0_vin_cnfg_axiwr0_pix_cnt_end
+		break;
+	case SENSOR_ISP:
+		reg_set_bit(vin->sysctrl_base,	SYSCONSAIF_SYSCFG_36,
+			BIT(7)|BIT(6),
+			0<<6);		//u0_vin_cnfg_mipi_byte_en_isp
+		reg_set_bit(vin->sysctrl_base,	SYSCONSAIF_SYSCFG_36,
+			BIT(11)|BIT(10)|BIT(9)|BIT(8),
+			0<<8);		//u0_vin_cnfg_mipi_channel_sel0
+		reg_set_bit(vin->sysctrl_base,	SYSCONSAIF_SYSCFG_36,
+			BIT(16)|BIT(15)|BIT(14)|BIT(13),
+			0<<13);		//u0_vin_cnfg_pix_num
+
+		if (dt == 0x2b)
+			reg_set_bit(vin->sysctrl_base,	SYSCONSAIF_SYSCFG_36,
+				BIT(12),
+				1<<12);		//u0_vin_cnfg_p_i_mipi_header_en0
+		break;
+	}
+
+	if (on)
+		csi2rx_start(csi_dev, reg_base, dt);
+	else
+		csi2rx_stop(csi_dev, reg_base);
+
+	return 0;
+}
+
+void dump_csi_reg(void *__iomem csibase)
+{
+	st_info(ST_CSI, "DUMP CSI register:\n");
+	print_reg(ST_CSI, csibase, 0x00);
+	print_reg(ST_CSI, csibase, 0x04);
+	print_reg(ST_CSI, csibase, 0x08);
+	print_reg(ST_CSI, csibase, 0x10);
+
+	print_reg(ST_CSI, csibase, 0x40);
+	print_reg(ST_CSI, csibase, 0x48);
+	print_reg(ST_CSI, csibase, 0x4c);
+	print_reg(ST_CSI, csibase, 0x50);
+}
+
+struct csi_hw_ops csi_ops = {
+	.csi_power_on          = stf_csi_power_on,
+	.csi_clk_enable        = stf_csi_clk_enable,
+	.csi_clk_disable       = stf_csi_clk_disable,
+	.csi_stream_set        = stf_csi_stream_set,
+};
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_csiphy.c b/drivers/media/platform/starfive/v4l2_driver/stf_csiphy.c
new file mode 100644
index 000000000000..af5132fe2c2b
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_csiphy.c
@@ -0,0 +1,356 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include "stfcamss.h"
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+static const struct csiphy_format csiphy_formats_st7110[] = {
+	{ MEDIA_BUS_FMT_YUYV8_2X8, 16},
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, 16},
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10},
+};
+
+int stf_csiphy_subdev_init(struct stfcamss *stfcamss)
+{
+	struct stf_csiphy_dev *csiphy_dev = stfcamss->csiphy_dev;
+
+	csiphy_dev->hw_ops = &csiphy_ops;
+	csiphy_dev->stfcamss = stfcamss;
+	csiphy_dev->formats = csiphy_formats_st7110;
+	csiphy_dev->nformats = ARRAY_SIZE(csiphy_formats_st7110);
+	mutex_init(&csiphy_dev->stream_lock);
+	return 0;
+}
+
+static int csiphy_set_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static int csiphy_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct stf_csiphy_dev *csiphy_dev = v4l2_get_subdevdata(sd);
+
+	mutex_lock(&csiphy_dev->stream_lock);
+	if (enable) {
+		if (csiphy_dev->stream_count == 0) {
+			csiphy_dev->hw_ops->csiphy_clk_enable(csiphy_dev);
+			csiphy_dev->hw_ops->csiphy_config_set(csiphy_dev);
+			csiphy_dev->hw_ops->csiphy_stream_set(csiphy_dev, 1);
+		}
+		csiphy_dev->stream_count++;
+	} else {
+		if (csiphy_dev->stream_count == 0)
+			goto exit;
+		if (csiphy_dev->stream_count == 1) {
+			csiphy_dev->hw_ops->csiphy_clk_disable(csiphy_dev);
+			csiphy_dev->hw_ops->csiphy_stream_set(csiphy_dev, 0);
+		}
+		csiphy_dev->stream_count--;
+	}
+exit:
+	mutex_unlock(&csiphy_dev->stream_lock);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__csiphy_get_format(struct stf_csiphy_dev *csiphy_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		unsigned int pad,
+		enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(
+				&csiphy_dev->subdev,
+				cfg,
+				pad);
+
+	return &csiphy_dev->fmt[pad];
+}
+
+static void csiphy_try_format(struct stf_csiphy_dev *csiphy_dev,
+			struct v4l2_subdev_pad_config *cfg,
+			unsigned int pad,
+			struct v4l2_mbus_framefmt *fmt,
+			enum v4l2_subdev_format_whence which)
+{
+	unsigned int i;
+
+	switch (pad) {
+	case STF_CSIPHY_PAD_SINK:
+		/* Set format on sink pad */
+
+		for (i = 0; i < csiphy_dev->nformats; i++)
+			if (fmt->code == csiphy_dev->formats[i].code)
+				break;
+
+		if (i >= csiphy_dev->nformats)
+			fmt->code = csiphy_dev->formats[0].code;
+
+		fmt->width = clamp_t(u32,
+				fmt->width,
+				STFCAMSS_FRAME_MIN_WIDTH,
+				STFCAMSS_FRAME_MAX_WIDTH);
+		fmt->height = clamp_t(u32,
+				fmt->height,
+				STFCAMSS_FRAME_MIN_HEIGHT,
+				STFCAMSS_FRAME_MAX_HEIGHT);
+
+		fmt->field = V4L2_FIELD_NONE;
+		fmt->colorspace = V4L2_COLORSPACE_SRGB;
+		fmt->flags = 0;
+
+		break;
+
+	case STF_CSIPHY_PAD_SRC:
+
+		*fmt = *__csiphy_get_format(csiphy_dev,
+				cfg,
+				STF_CSIPHY_PAD_SINK, which);
+
+		break;
+	}
+}
+
+static int csiphy_enum_mbus_code(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct stf_csiphy_dev *csiphy_dev = v4l2_get_subdevdata(sd);
+
+	if (code->index >= csiphy_dev->nformats)
+		return -EINVAL;
+
+	if (code->pad == STF_CSIPHY_PAD_SINK) {
+		code->code = csiphy_dev->formats[code->index].code;
+	} else {
+		struct v4l2_mbus_framefmt *sink_fmt;
+
+		sink_fmt = __csiphy_get_format(csiphy_dev, cfg,
+					STF_CSIPHY_PAD_SINK,
+					code->which);
+
+		code->code = sink_fmt->code;
+		if (!code->code)
+			return -EINVAL;
+	}
+	code->flags = 0;
+	return 0;
+}
+
+static int csiphy_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct stf_csiphy_dev *csiphy_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt format;
+
+	if (fse->index != 0)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = 1;
+	format.height = 1;
+	csiphy_try_format(csiphy_dev, cfg, fse->pad, &format, fse->which);
+	fse->min_width = format.width;
+	fse->min_height = format.height;
+
+	if (format.code != fse->code)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = -1;
+	format.height = -1;
+	csiphy_try_format(csiphy_dev, cfg, fse->pad, &format, fse->which);
+	fse->max_width = format.width;
+	fse->max_height = format.height;
+
+	return 0;
+}
+
+static int csiphy_get_format(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct stf_csiphy_dev *csiphy_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __csiphy_get_format(csiphy_dev, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int csiphy_set_format(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct stf_csiphy_dev *csiphy_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __csiphy_get_format(csiphy_dev, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&csiphy_dev->stream_lock);
+	if (csiphy_dev->stream_count) {
+		fmt->format = *format;
+		mutex_unlock(&csiphy_dev->stream_lock);
+		goto out;
+	} else {
+		csiphy_try_format(csiphy_dev, cfg, fmt->pad, &fmt->format, fmt->which);
+		*format = fmt->format;
+	}
+	mutex_unlock(&csiphy_dev->stream_lock);
+
+	/* Propagate the format from sink to source */
+	if (fmt->pad == STF_CSIPHY_PAD_SINK) {
+		format = __csiphy_get_format(csiphy_dev,
+					cfg,
+					STF_CSIPHY_PAD_SRC,
+					fmt->which);
+
+		*format = fmt->format;
+		csiphy_try_format(csiphy_dev, cfg, STF_CSIPHY_PAD_SRC, format,
+					fmt->which);
+	}
+out:
+	return 0;
+}
+
+static int csiphy_init_formats(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh)
+{
+	struct v4l2_subdev_format format = {
+		.pad = STF_CSIPHY_PAD_SINK,
+		.which = fh ? V4L2_SUBDEV_FORMAT_TRY :
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+		.format = {
+			.code = MEDIA_BUS_FMT_RGB565_2X8_LE,
+			.width = 1920,
+			.height = 1080
+		}
+	};
+
+	return csiphy_set_format(sd, fh ? fh->pad : NULL, &format);
+}
+
+static int csiphy_link_setup(struct media_entity *entity,
+			const struct media_pad *local,
+			const struct media_pad *remote, u32 flags)
+{
+	if ((local->flags & MEDIA_PAD_FL_SOURCE) &&
+		(flags & MEDIA_LNK_FL_ENABLED)) {
+		struct v4l2_subdev *sd;
+		struct stf_csiphy_dev *csiphy_dev;
+		struct stf_csi_dev *csi_dev;
+
+		if (media_entity_remote_pad(local))
+			return -EBUSY;
+
+		sd = media_entity_to_v4l2_subdev(entity);
+		csiphy_dev = v4l2_get_subdevdata(sd);
+
+		sd = media_entity_to_v4l2_subdev(remote->entity);
+		csi_dev = v4l2_get_subdevdata(sd);
+		st_info(ST_CSIPHY, "CSIPHY0 link to CSI0\n");
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops csiphy_core_ops = {
+	.s_power = csiphy_set_power,
+};
+
+static const struct v4l2_subdev_video_ops csiphy_video_ops = {
+	.s_stream = csiphy_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops csiphy_pad_ops = {
+	.enum_mbus_code = csiphy_enum_mbus_code,
+	.enum_frame_size = csiphy_enum_frame_size,
+	.get_fmt = csiphy_get_format,
+	.set_fmt = csiphy_set_format,
+};
+
+static const struct v4l2_subdev_ops csiphy_v4l2_ops = {
+	.core = &csiphy_core_ops,
+	.video = &csiphy_video_ops,
+	.pad = &csiphy_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops csiphy_v4l2_internal_ops = {
+	.open = csiphy_init_formats,
+};
+
+static const struct media_entity_operations csiphy_media_ops = {
+	.link_setup = csiphy_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+int stf_csiphy_register(struct stf_csiphy_dev *csiphy_dev,
+			struct v4l2_device *v4l2_dev)
+{
+	struct v4l2_subdev *sd = &csiphy_dev->subdev;
+	struct device *dev = csiphy_dev->stfcamss->dev;
+	struct media_pad *pads = csiphy_dev->pads;
+	int ret;
+
+	v4l2_subdev_init(sd, &csiphy_v4l2_ops);
+	sd->internal_ops = &csiphy_v4l2_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	snprintf(sd->name, ARRAY_SIZE(sd->name), "%s%d",
+		STF_CSIPHY_NAME, 0);
+	v4l2_set_subdevdata(sd, csiphy_dev);
+
+	ret = csiphy_init_formats(sd, NULL);
+	if (ret < 0) {
+		dev_err(dev, "Failed to init format: %d\n", ret);
+		return ret;
+	}
+
+	pads[STF_CSIPHY_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	pads[STF_CSIPHY_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE;
+
+	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+	sd->entity.ops = &csiphy_media_ops;
+	ret = media_entity_pads_init(&sd->entity, STF_CSIPHY_PADS_NUM, pads);
+	if (ret < 0) {
+		dev_err(dev, "Failed to init media entity: %d\n", ret);
+		return ret;
+	}
+
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register subdev: %d\n", ret);
+		goto err_sreg;
+	}
+
+	return 0;
+
+err_sreg:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+int stf_csiphy_unregister(struct stf_csiphy_dev *csiphy_dev)
+{
+	v4l2_device_unregister_subdev(&csiphy_dev->subdev);
+	media_entity_cleanup(&csiphy_dev->subdev.entity);
+	mutex_destroy(&csiphy_dev->stream_lock);
+	return 0;
+}
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_csiphy.h b/drivers/media/platform/starfive/v4l2_driver/stf_csiphy.h
new file mode 100644
index 000000000000..aa4e61ef8bc1
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_csiphy.h
@@ -0,0 +1,186 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_CSIPHY_H
+#define STF_CSIPHY_H
+
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/media-entity.h>
+#include <video/stf-vin.h>
+
+#define STF_CSIPHY_NAME "stf_csiphy"
+
+#define STF_CSIPHY_PAD_SINK     0
+#define STF_CSIPHY_PAD_SRC      1
+#define STF_CSIPHY_PADS_NUM     2
+
+#define STF_CSI2_MAX_DATA_LANES      4
+
+union static_config {
+	u32 raw;
+	struct {
+		u32 sel                 : 2;
+		u32 rsvd_6              : 2;
+		u32 v2p0_support_enable : 1;
+		u32 rsvd_5              : 3;
+		u32 lane_nb             : 3;
+		u32 rsvd_4              : 5;
+		u32 dl0_map             : 3;
+		u32 rsvd_3              : 1;
+		u32 dl1_map             : 3;
+		u32 rsvd_2              : 1;
+		u32 dl2_map             : 3;
+		u32 rsvd_1              : 1;
+		u32 dl3_map             : 3;
+		u32 rsvd_0              : 1;
+	} bits;
+};
+
+union error_bypass_cfg {
+	u32 value;
+	struct {
+		u32 crc             :  1;
+		u32 ecc             :  1;
+		u32 data_id         :  1;
+		u32 rsvd_0          : 29;
+	};
+};
+
+union stream_monitor_ctrl {
+	u32 value;
+	struct {
+		u32 lb_vc             : 4;
+		u32 lb_en             : 1;
+		u32 timer_vc          : 4;
+		u32 timer_en          : 1;
+		u32 timer_eof         : 1;
+		u32 frame_mon_vc      : 4;
+		u32 frame_mon_en      : 1;
+		u32 frame_length      : 16;
+	};
+};
+
+union stream_cfg {
+	u32 value;
+	struct {
+		u32 interface_mode :  1;
+		u32 ls_le_mode     :  1;
+		u32 rsvd_3         :  2;
+		u32 num_pixels     :  2;
+		u32 rsvd_2         :  2;
+		u32 fifo_mode      :  2;
+		u32 rsvd_1         :  2;
+		u32 bpp_bypass     :  3;
+		u32 rsvd_0         :  1;
+		u32 fifo_fill      : 16;
+	};
+};
+
+union dphy_lane_ctrl {
+	u32 raw;
+	struct {
+		u32 dl0_en    : 1;
+		u32 dl1_en    : 1;
+		u32 dl2_en    : 1;
+		u32 dl3_en    : 1;
+		u32 cl_en     : 1;
+		u32 rsvd_1    : 7;
+		u32 dl0_reset : 1;
+		u32 dl1_reset : 1;
+		u32 dl2_reset : 1;
+		u32 dl3_reset : 1;
+		u32 cl_reset  : 1;
+		u32 rsvd_0    : 15;
+	} bits;
+};
+
+union dphy_lane_swap {
+	u32 raw;
+	struct {
+		u32 rx_1c2c_sel        : 1;
+		u32 lane_swap_clk      : 3;
+		u32 lane_swap_clk1     : 3;
+		u32 lane_swap_lan0     : 3;
+		u32 lane_swap_lan1     : 3;
+		u32 lane_swap_lan2     : 3;
+		u32 lane_swap_lan3     : 3;
+		u32 dpdn_swap_clk      : 1;
+		u32 dpdn_swap_clk1     : 1;
+		u32 dpdn_swap_lan0     : 1;
+		u32 dpdn_swap_lan1     : 1;
+		u32 dpdn_swap_lan2     : 1;
+		u32 dpdn_swap_lan3     : 1;
+		u32 hs_freq_chang_clk0 : 1;
+		u32 hs_freq_chang_clk1 : 1;
+		u32 reserved           : 5;
+	} bits;
+};
+
+union dphy_lane_en {
+	u32 raw;
+	struct {
+		u32 gpio_en		: 6;
+		u32 mp_test_mode_sel	: 5;
+		u32 mp_test_en		: 1;
+		u32 dphy_enable_lan0	: 1;
+		u32 dphy_enable_lan1	: 1;
+		u32 dphy_enable_lan2	: 1;
+		u32 dphy_enable_lan3	: 1;
+		u32 rsvd_0		: 16;
+	} bits;
+};
+
+struct csiphy_format {
+	u32 code;
+	u8 bpp;
+};
+
+struct csi2phy_cfg {
+	unsigned int flags;
+	unsigned char data_lanes[STF_CSI2_MAX_DATA_LANES];
+	unsigned char clock_lane;
+	unsigned char num_data_lanes;
+	bool lane_polarities[1 + STF_CSI2_MAX_DATA_LANES];
+};
+
+struct csi2phy_cfg2 {
+	unsigned char data_lanes[STF_CSI2_MAX_DATA_LANES];
+	unsigned char num_data_lanes;
+	unsigned char num_clks;
+	unsigned char clock_lane;
+	unsigned char clock1_lane;
+	bool lane_polarities[2 + STF_CSI2_MAX_DATA_LANES];
+};
+
+struct stf_csiphy_dev;
+
+struct csiphy_hw_ops {
+	int (*csiphy_clk_enable)(struct stf_csiphy_dev *csiphy_dev);
+	int (*csiphy_clk_disable)(struct stf_csiphy_dev *csiphy_dev);
+	int (*csiphy_config_set)(struct stf_csiphy_dev *csiphy_dev);
+	int (*csiphy_stream_set)(struct stf_csiphy_dev *csiphy_dev, int on);
+};
+
+struct stf_csiphy_dev {
+	struct stfcamss *stfcamss;
+	struct csi2phy_cfg *csiphy;
+	struct v4l2_subdev subdev;
+	struct media_pad pads[STF_CSIPHY_PADS_NUM];
+	struct v4l2_mbus_framefmt fmt[STF_CSIPHY_PADS_NUM];
+	const struct csiphy_format *formats;
+	unsigned int nformats;
+	struct csiphy_hw_ops *hw_ops;
+	struct mutex stream_lock;
+	int stream_count;
+};
+
+extern int stf_csiphy_subdev_init(struct stfcamss *stfcamss);
+extern int stf_csiphy_register(struct stf_csiphy_dev *csiphy_dev,
+			struct v4l2_device *v4l2_dev);
+extern int stf_csiphy_unregister(struct stf_csiphy_dev *csiphy_dev);
+
+extern struct csiphy_hw_ops csiphy_ops;
+
+#endif /* STF_CSIPHY_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_csiphy_hw_ops.c b/drivers/media/platform/starfive/v4l2_driver/stf_csiphy_hw_ops.c
new file mode 100644
index 000000000000..bcf52fdd673e
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_csiphy_hw_ops.c
@@ -0,0 +1,331 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include "stfcamss.h"
+#include <linux/sort.h>
+
+static int stf_csiphy_clk_set(struct stf_csiphy_dev *csiphy_dev, int on)
+{
+	struct stfcamss *stfcamss = csiphy_dev->stfcamss;
+	static int init_flag;
+	static struct mutex count_lock;
+	static int count;
+
+	if (!init_flag) {
+		init_flag = 1;
+		mutex_init(&count_lock);
+	}
+	mutex_lock(&count_lock);
+	if (on) {
+		clk_set_rate(stfcamss->sys_clk[STFCLK_M31DPHY_CFGCLK_IN].clk,
+			99000000);
+		clk_set_rate(stfcamss->sys_clk[STFCLK_M31DPHY_REFCLK_IN].clk,
+			49500000);
+		clk_set_rate(stfcamss->sys_clk[STFCLK_M31DPHY_TXCLKESC_LAN0].clk,
+			19800000);
+
+		reset_control_deassert(stfcamss->sys_rst[STFRST_M31DPHY_HW].rstc);
+		reset_control_deassert(stfcamss->sys_rst[STFRST_M31DPHY_B09_ALWAYS_ON].rstc);
+
+		count++;
+	} else {
+		if (count == 0)
+			goto exit;
+		if (count == 1) {
+			reset_control_assert(stfcamss->sys_rst[STFRST_M31DPHY_HW].rstc);
+			reset_control_assert(stfcamss->sys_rst[STFRST_M31DPHY_B09_ALWAYS_ON].rstc);
+		}
+		count--;
+	}
+exit:
+	mutex_unlock(&count_lock);
+	return 0;
+}
+
+static int stf_csiphy_clk_enable(struct stf_csiphy_dev *csiphy_dev)
+{
+	return stf_csiphy_clk_set(csiphy_dev, 1);
+}
+
+static int stf_csiphy_clk_disable(struct stf_csiphy_dev *csiphy_dev)
+{
+	return stf_csiphy_clk_set(csiphy_dev, 0);
+}
+
+#ifndef USE_CSIDPHY_ONE_CLK_MODE
+static int cmp_func(const void *x1, const void *x2)
+{
+	return *((unsigned char *)x1) - *((unsigned char *)x2);
+}
+#endif
+
+int try_cfg(struct csi2phy_cfg2 *cfg, struct csi2phy_cfg *cfg0,
+		struct csi2phy_cfg *cfg1)
+{
+	int i = 0;
+
+	cfg->clock_lane = 4;
+	cfg->clock1_lane = 5;
+	cfg->data_lanes[0] = 0;
+	cfg->data_lanes[1] = 1;
+	cfg->data_lanes[2] = 2;
+	cfg->data_lanes[3] = 3;
+
+	if (cfg0 && cfg1) {
+		st_debug(ST_CSIPHY, "CSIPHY use 2 clk mode\n");
+		cfg->num_clks = 2;
+		cfg->num_data_lanes =
+			cfg1->num_data_lanes + cfg0->num_data_lanes;
+		if (cfg->num_data_lanes > STF_CSI2_MAX_DATA_LANES)
+			return -EINVAL;
+		cfg->clock_lane = cfg0->clock_lane;
+		cfg->lane_polarities[0] = cfg0->lane_polarities[0];
+		cfg->clock1_lane = cfg1->clock_lane;
+		cfg->lane_polarities[1] = cfg1->lane_polarities[0];
+		for (i = 0; i < cfg0->num_data_lanes; i++) {
+			cfg->data_lanes[i] = cfg0->data_lanes[i];
+			cfg->lane_polarities[i + 2] =
+				cfg0->lane_polarities[i + 1];
+		}
+
+		for (i = cfg0->num_data_lanes; i < cfg->num_data_lanes; i++) {
+			cfg->data_lanes[i] =
+				cfg1->data_lanes[i - cfg0->num_data_lanes];
+			cfg->lane_polarities[i + 2] =
+				cfg1->lane_polarities[i - cfg0->num_data_lanes + 1];
+		}
+	} else if (cfg0 && !cfg1) {
+		st_debug(ST_CSIPHY, "CSIPHY cfg0 use 1 clk mode\n");
+		cfg->num_clks = 1;
+		cfg->num_data_lanes = cfg0->num_data_lanes;
+		cfg->lane_polarities[0] = cfg->lane_polarities[1] =
+						cfg0->lane_polarities[0];
+		for (i = 0; i < cfg0->num_data_lanes; i++) {
+			cfg->data_lanes[i] = cfg0->data_lanes[i];
+			cfg->lane_polarities[i + 2] = cfg0->lane_polarities[i + 1];
+		}
+	} else if (!cfg0 && cfg1) {
+		st_debug(ST_CSIPHY, "CSIPHY cfg1 use 1 clk mode\n");
+		cfg->num_clks = 1;
+		cfg->num_data_lanes = cfg1->num_data_lanes;
+		cfg->lane_polarities[0] = cfg->lane_polarities[1] =
+						cfg1->lane_polarities[0];
+		for (i = 0; i < cfg1->num_data_lanes; i++) {
+			cfg->data_lanes[i] = cfg1->data_lanes[i];
+			cfg->lane_polarities[i + 2] = cfg1->lane_polarities[i + 1];
+		}
+	} else {
+		return -EINVAL;
+	}
+
+#ifndef USE_CSIDPHY_ONE_CLK_MODE
+	sort(cfg->data_lanes, cfg->num_data_lanes,
+			sizeof(cfg->data_lanes[0]), cmp_func, NULL);
+#endif
+	for (i = 0; i < cfg->num_data_lanes; i++)
+		st_debug(ST_CSIPHY, "%d: %d\n", i, cfg->data_lanes[i]);
+	return 0;
+}
+
+static int csi2rx_dphy_config(struct stf_vin_dev *vin,
+		struct stf_csiphy_dev *csiphy_dev)
+{
+	struct csi2phy_cfg2 cfg2 = {0};
+	struct csi2phy_cfg2 *cfg = &cfg2;
+	struct csi2phy_cfg *phycfg = csiphy_dev->csiphy;
+
+	if (!phycfg)
+		return -EINVAL;
+
+	if (try_cfg(cfg, phycfg, NULL))
+		return -EINVAL;
+
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_4, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_8, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_12, 0xfff0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_16, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_20, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_24, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_28, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_32, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_36, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_40, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_44, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_48, 0x24000000);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_52, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_56, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_60, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_64, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_68, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_72, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_76, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_80, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_84, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_88, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_92, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_96, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_100, 0x02000000);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_104, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_108, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_112, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_116, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_120, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_124, 0xc);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_128, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_132, 0xcc500000);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_136, 0xcc);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_140, 0x0);
+	reg_write(vin->rstgen_base, M31DPHY_APBCFGSAIF__SYSCFG_144, 0x0);
+
+	reg_set_bit(vin->rstgen_base,		//r100_ctrl0_2d1c_efuse_en
+		M31DPHY_APBCFGSAIF__SYSCFG_0,
+		BIT(6), 1<<6);
+	reg_set_bit(vin->rstgen_base,		//r100_ctrl0_2d1c_efuse_in
+		M31DPHY_APBCFGSAIF__SYSCFG_0,
+		BIT(12)|BIT(11)|BIT(10)|BIT(9)|BIT(8)|BIT(7), 0x1b<<7);
+	reg_set_bit(vin->rstgen_base,		//r100_ctrl1_2d1c_efuse_en
+		M31DPHY_APBCFGSAIF__SYSCFG_0,
+		BIT(13), 1<<13);
+	reg_set_bit(vin->rstgen_base,		//r100_ctrl1_2d1c_efuse_in
+		M31DPHY_APBCFGSAIF__SYSCFG_0,
+		BIT(19)|BIT(18)|BIT(17)|BIT(16)|BIT(15)|BIT(14), 0x1b<<14);
+
+	reg_set_bit(vin->rstgen_base,		//data_bus16_8
+		M31DPHY_APBCFGSAIF__SYSCFG_184,
+		BIT(8), 0<<8);
+
+	reg_set_bit(vin->rstgen_base,		//debug_mode_sel
+		M31DPHY_APBCFGSAIF__SYSCFG_184,
+		BIT(15)|BIT(14)|BIT(13)|BIT(12)|BIT(11)|BIT(10)|BIT(9), 0x5a<<9);
+
+	reg_set_bit(vin->rstgen_base,			//dpdn_swap_clk0
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(0), cfg->lane_polarities[0]<<0);
+	reg_set_bit(vin->rstgen_base,			//dpdn_swap_clk1
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(1), cfg->lane_polarities[1]<<1);
+	reg_set_bit(vin->rstgen_base,			//dpdn_swap_lan0
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(2), cfg->lane_polarities[2]<<2);
+	reg_set_bit(vin->rstgen_base,			//dpdn_swap_lan1
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(3), cfg->lane_polarities[3]<<3);
+	reg_set_bit(vin->rstgen_base,			//dpdn_swap_lan2
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(4), cfg->lane_polarities[4]<<4);
+	reg_set_bit(vin->rstgen_base,			//dpdn_swap_lan3
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(5), cfg->lane_polarities[5]<<5);
+	reg_set_bit(vin->rstgen_base,			//enable clk0
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(6), 1<<6);
+	reg_set_bit(vin->rstgen_base,			//enable clk1
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(7), 1<<7);
+	reg_set_bit(vin->rstgen_base,			//enable lan0
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(8), 1<<8);
+	reg_set_bit(vin->rstgen_base,			//enable lan1
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(9), 1<<9);
+	reg_set_bit(vin->rstgen_base,			//enable lan2
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(10), 1<<10);
+	reg_set_bit(vin->rstgen_base,			//enable lan3
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(11), 1<<11);
+	reg_set_bit(vin->rstgen_base,			//gpi_en
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(17)|BIT(16)|BIT(15)|BIT(14)|BIT(13)|BIT(12),
+		0<<12);
+	reg_set_bit(vin->rstgen_base,			//hs_freq_change_clk0
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(18), 0<<18);
+	reg_set_bit(vin->rstgen_base,			//hs_freq_change_clk1
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(19), 0<<19);
+
+	reg_set_bit(vin->rstgen_base,
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(22)|BIT(21)|BIT(20), cfg->clock_lane<<20);          //clock lane 0
+	reg_set_bit(vin->rstgen_base,
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(25)|BIT(24)|BIT(23), cfg->clock1_lane<<23);         //clock lane 1
+
+	reg_set_bit(vin->rstgen_base,
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(28)|BIT(27)|BIT(26), cfg->data_lanes[0]<<26);       //data lane 0
+	reg_set_bit(vin->rstgen_base,
+		M31DPHY_APBCFGSAIF__SYSCFG_188,
+		BIT(31)|BIT(30)|BIT(29), cfg->data_lanes[1]<<29);       //data lane 1
+	reg_set_bit(vin->rstgen_base,
+		M31DPHY_APBCFGSAIF__SYSCFG_192,
+		BIT(2)|BIT(1)|BIT(0), cfg->data_lanes[2]<<0);           //data lane 2
+	reg_set_bit(vin->rstgen_base,
+		M31DPHY_APBCFGSAIF__SYSCFG_192,
+		BIT(5)|BIT(4)|BIT(3), cfg->data_lanes[3]<<3);           //data lane 3
+
+	reg_set_bit(vin->rstgen_base,		//mp_test_en
+		M31DPHY_APBCFGSAIF__SYSCFG_192,
+		BIT(6), 0<<6);
+	reg_set_bit(vin->rstgen_base,		//mp_test_mode_sel
+		M31DPHY_APBCFGSAIF__SYSCFG_192,
+		BIT(11)|BIT(10)|BIT(9)|BIT(8)|BIT(7), 0<<7);
+
+	reg_set_bit(vin->rstgen_base,		//pll_clk_sel
+		M31DPHY_APBCFGSAIF__SYSCFG_192,
+		BIT(20)|BIT(19)|BIT(18)|BIT(17)|BIT(16)|BIT(15)|BIT(14)|BIT(13)|BIT(12),
+		0x37c<<12);
+
+	reg_set_bit(vin->rstgen_base,		//rx_1c2c_sel
+		M31DPHY_APBCFGSAIF__SYSCFG_200,
+		BIT(8), 0<<8);
+
+	reg_set_bit(vin->rstgen_base,		//precounter in clk0
+		M31DPHY_APBCFGSAIF__SYSCFG_192,
+		BIT(29)|BIT(28)|BIT(27)|BIT(26)|BIT(25)|BIT(24)|BIT(23)|BIT(22),
+		8<<22);
+	reg_set_bit(vin->rstgen_base,		//precounter in clk1
+		M31DPHY_APBCFGSAIF__SYSCFG_196,
+		BIT(7)|BIT(6)|BIT(5)|BIT(4)|BIT(3)|BIT(2)|BIT(1)|BIT(0),
+		8<<0);
+	reg_set_bit(vin->rstgen_base,		//precounter in lan0
+		M31DPHY_APBCFGSAIF__SYSCFG_196,
+		BIT(15)|BIT(14)|BIT(13)|BIT(12)|BIT(11)|BIT(10)|BIT(9)|BIT(8),
+		7<<8);
+	reg_set_bit(vin->rstgen_base,		//precounter in lan1
+		M31DPHY_APBCFGSAIF__SYSCFG_196,
+		BIT(23)|BIT(22)|BIT(21)|BIT(20)|BIT(19)|BIT(18)|BIT(17)|BIT(16),
+		7<<16);
+	reg_set_bit(vin->rstgen_base,		//precounter in lan2
+		M31DPHY_APBCFGSAIF__SYSCFG_196,
+		BIT(31)|BIT(30)|BIT(29)|BIT(28)|BIT(27)|BIT(26)|BIT(25)|BIT(24),
+		7<<24);
+	reg_set_bit(vin->rstgen_base,		//precounter in lan3
+		M31DPHY_APBCFGSAIF__SYSCFG_200,
+		BIT(7)|BIT(6)|BIT(5)|BIT(4)|BIT(3)|BIT(2)|BIT(1)|BIT(0),
+		7<<0);
+
+	return 0;
+}
+
+static int stf_csiphy_config_set(struct stf_csiphy_dev *csiphy_dev)
+{
+	struct stf_vin_dev *vin = csiphy_dev->stfcamss->vin;
+
+	csi2rx_dphy_config(vin, csiphy_dev);
+	return 0;
+}
+
+static int stf_csiphy_stream_set(struct stf_csiphy_dev *csiphy_dev, int on)
+{
+	return 0;
+}
+
+struct csiphy_hw_ops csiphy_ops = {
+	.csiphy_clk_enable        = stf_csiphy_clk_enable,
+	.csiphy_clk_disable       = stf_csiphy_clk_disable,
+	.csiphy_config_set        = stf_csiphy_config_set,
+	.csiphy_stream_set        = stf_csiphy_stream_set,
+};
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_dmabuf.c b/drivers/media/platform/starfive/v4l2_driver/stf_dmabuf.c
new file mode 100644
index 000000000000..f2020144671b
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_dmabuf.c
@@ -0,0 +1,123 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/dma-buf.h>
+#include <media/v4l2-subdev.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "stf_isp_ioctl.h"
+#include "stf_dmabuf.h"
+
+#define TOTAL_SIZE_LIMIT      (64 * 1024 * 1024)
+
+static size_t total_size;
+static struct vb2_queue	vb2_queue = {
+	.dma_attrs = 0,
+	.gfp_flags = 0,
+	.dma_dir = DMA_TO_DEVICE,
+};
+static struct vb2_buffer vb = {
+	.vb2_queue = &vb2_queue,
+};
+
+static int dmabuf_create(struct device *dev,
+			   struct dmabuf_create *head)
+{
+	struct dma_buf *dmabuf = NULL;
+	void *mem_priv = NULL;
+	dma_addr_t *paddr = NULL;
+	int ret = 0;
+
+	mem_priv = vb2_dma_contig_memops.alloc(dev, vb.vb2_queue->dma_attrs,
+				head->size, vb.vb2_queue->dma_dir, vb.vb2_queue->gfp_flags);
+	if (IS_ERR_OR_NULL(mem_priv)) {
+		if (mem_priv)
+			ret = PTR_ERR(mem_priv);
+		goto exit;
+	}
+
+	dmabuf = vb2_dma_contig_memops.get_dmabuf(mem_priv, O_RDWR);
+	if (IS_ERR(dmabuf)) {
+		ret = PTR_ERR(dmabuf);
+		goto free;
+	}
+
+	head->fd = dma_buf_fd(dmabuf, O_CLOEXEC);
+	if (head->fd < 0) {
+		dma_buf_put(dmabuf);
+		ret = head->fd;
+		goto free;
+	}
+
+	paddr = vb2_dma_contig_memops.cookie(mem_priv);
+	head->paddr = *paddr;
+	return 0;
+free:
+	vb2_dma_contig_memops.put(mem_priv);
+exit:
+	return ret;
+}
+
+int stf_dmabuf_ioctl_alloc(struct device *dev, void *arg)
+{
+	struct dmabuf_create *head = arg;
+	int ret = -EINVAL;
+
+	if (IS_ERR_OR_NULL(head))
+		return -EFAULT;
+
+	head->size = PAGE_ALIGN(head->size);
+	if (!head->size)
+		return -EINVAL;
+	if ((head->size + total_size) > TOTAL_SIZE_LIMIT)
+		return -ENOMEM;
+
+	ret = dmabuf_create(dev, head);
+	if (ret)
+		return -EFAULT;
+
+	total_size += head->size;
+	return ret;
+}
+
+int stf_dmabuf_ioctl_free(struct device *dev, void *arg)
+{
+	struct dmabuf_create *head = arg;
+	struct dma_buf *dmabuf = NULL;
+	int ret = 0;
+
+	if (IS_ERR_OR_NULL(head))
+		return -EFAULT;
+	if (head->size != PAGE_ALIGN(head->size))
+		return -EINVAL;
+	if (head->size > total_size)
+		return -EINVAL;
+
+	dmabuf = dma_buf_get(head->fd);
+	if (IS_ERR_OR_NULL(dmabuf))
+		return -EINVAL;
+
+	dma_buf_put(dmabuf);
+	vb2_dma_contig_memops.put(dmabuf->priv);
+	total_size -= head->size;
+	return ret;
+}
+
+int stf_dmabuf_ioctl(struct device *dev, unsigned int cmd, void *arg)
+{
+	int ret = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case VIDIOC_STF_DMABUF_ALLOC:
+		ret = stf_dmabuf_ioctl_alloc(dev, arg);
+		break;
+	case VIDIOC_STF_DMABUF_FREE:
+		ret = stf_dmabuf_ioctl_free(dev, arg);
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_dmabuf.h b/drivers/media/platform/starfive/v4l2_driver/stf_dmabuf.h
new file mode 100644
index 000000000000..6b2f0d45b589
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_dmabuf.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_DMABUF_H
+#define STF_DMABUF_H
+
+extern int stf_dmabuf_ioctl(struct device *dev, unsigned int cmd, void *arg);
+
+#endif /* STF_DMABUF_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_dvp.c b/drivers/media/platform/starfive/v4l2_driver/stf_dvp.c
new file mode 100644
index 000000000000..ccbf8648209d
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_dvp.c
@@ -0,0 +1,383 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include "stfcamss.h"
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+static const struct dvp_format dvp_formats_st7110[] = {
+	{ MEDIA_BUS_FMT_YUYV8_2X8, 8},
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, 8},
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8},
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8},
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8},
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8},
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 8},
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 8},
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 8},
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 8},
+};
+
+static int dvp_find_format(u32 code,
+		const struct dvp_format *formats,
+		unsigned int nformats)
+{
+	int i;
+
+	for (i = 0; i < nformats; i++)
+		if (formats[i].code == code)
+			return i;
+	return -EINVAL;
+}
+
+int stf_dvp_subdev_init(struct stfcamss *stfcamss)
+{
+	struct stf_dvp_dev *dvp_dev = stfcamss->dvp_dev;
+
+	dvp_dev->s_type = SENSOR_VIN;
+	dvp_dev->hw_ops = &dvp_ops;
+	dvp_dev->stfcamss = stfcamss;
+	dvp_dev->formats = dvp_formats_st7110;
+	dvp_dev->nformats = ARRAY_SIZE(dvp_formats_st7110);
+	mutex_init(&dvp_dev->stream_lock);
+	dvp_dev->stream_count = 0;
+	return 0;
+}
+
+static int dvp_set_power(struct v4l2_subdev *sd, int on)
+{
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__dvp_get_format(struct stf_dvp_dev *dvp_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		unsigned int pad,
+		enum v4l2_subdev_format_whence which)
+{
+
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(
+			&dvp_dev->subdev, cfg, pad);
+	return &dvp_dev->fmt[pad];
+}
+
+static int dvp_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct stf_dvp_dev *dvp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+	int ret = 0;
+
+	format = __dvp_get_format(dvp_dev, NULL, STF_DVP_PAD_SRC,
+				V4L2_SUBDEV_FORMAT_ACTIVE);
+	if (format == NULL)
+		return -EINVAL;
+	ret = dvp_find_format(format->code,
+				dvp_dev->formats,
+				dvp_dev->nformats);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&dvp_dev->stream_lock);
+	if (enable) {
+		if (dvp_dev->stream_count == 0) {
+			dvp_dev->hw_ops->dvp_clk_enable(dvp_dev);
+			dvp_dev->hw_ops->dvp_config_set(dvp_dev);
+			dvp_dev->hw_ops->dvp_set_format(dvp_dev,
+				format->width, dvp_dev->formats[ret].bpp);
+			dvp_dev->hw_ops->dvp_stream_set(dvp_dev, 1);
+		}
+		dvp_dev->stream_count++;
+	} else {
+		if (dvp_dev->stream_count == 0)
+			goto exit;
+		if (dvp_dev->stream_count == 1) {
+			dvp_dev->hw_ops->dvp_stream_set(dvp_dev, 0);
+			dvp_dev->hw_ops->dvp_clk_disable(dvp_dev);
+		}
+		dvp_dev->stream_count--;
+	}
+exit:
+	mutex_unlock(&dvp_dev->stream_lock);
+	return 0;
+}
+
+static void dvp_try_format(struct stf_dvp_dev *dvp_dev,
+			struct v4l2_subdev_pad_config *cfg,
+			unsigned int pad,
+			struct v4l2_mbus_framefmt *fmt,
+			enum v4l2_subdev_format_whence which)
+{
+	unsigned int i;
+
+	switch (pad) {
+	case STF_DVP_PAD_SINK:
+		/* Set format on sink pad */
+
+		for (i = 0; i < dvp_dev->nformats; i++)
+			if (fmt->code == dvp_dev->formats[i].code)
+				break;
+
+		if (i >= dvp_dev->nformats)
+			fmt->code = dvp_dev->formats[0].code;
+
+		fmt->width = clamp_t(u32,
+				fmt->width, STFCAMSS_FRAME_MIN_WIDTH,
+				STFCAMSS_FRAME_MAX_WIDTH);
+		fmt->height = clamp_t(u32,
+				fmt->height, STFCAMSS_FRAME_MIN_HEIGHT,
+				STFCAMSS_FRAME_MAX_HEIGHT);
+
+		fmt->field = V4L2_FIELD_NONE;
+		fmt->colorspace = V4L2_COLORSPACE_SRGB;
+		fmt->flags = 0;
+
+		break;
+
+	case STF_DVP_PAD_SRC:
+
+		*fmt = *__dvp_get_format(dvp_dev, cfg, STF_DVP_PAD_SINK, which);
+
+		break;
+	}
+}
+
+static int dvp_enum_mbus_code(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct stf_dvp_dev *dvp_dev = v4l2_get_subdevdata(sd);
+
+	if (code->index >= dvp_dev->nformats)
+		return -EINVAL;
+
+	if (code->pad == STF_DVP_PAD_SINK) {
+		code->code = dvp_dev->formats[code->index].code;
+	} else {
+		struct v4l2_mbus_framefmt *sink_fmt;
+
+		sink_fmt = __dvp_get_format(dvp_dev, cfg, STF_DVP_PAD_SINK,
+					code->which);
+
+		code->code = sink_fmt->code;
+		if (!code->code)
+			return -EINVAL;
+	}
+	code->flags = 0;
+
+	return 0;
+}
+
+static int dvp_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct stf_dvp_dev *dvp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt format;
+
+	if (fse->index != 0)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = 1;
+	format.height = 1;
+	dvp_try_format(dvp_dev, cfg, fse->pad, &format, fse->which);
+	fse->min_width = format.width;
+	fse->min_height = format.height;
+
+	if (format.code != fse->code)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = -1;
+	format.height = -1;
+	dvp_try_format(dvp_dev, cfg, fse->pad, &format, fse->which);
+	fse->max_width = format.width;
+	fse->max_height = format.height;
+
+	return 0;
+}
+
+static int dvp_get_format(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct stf_dvp_dev *dvp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __dvp_get_format(dvp_dev, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int dvp_set_format(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct stf_dvp_dev *dvp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __dvp_get_format(dvp_dev, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&dvp_dev->stream_lock);
+	if (dvp_dev->stream_count) {
+		fmt->format = *format;
+		mutex_unlock(&dvp_dev->stream_lock);
+		goto out;
+	} else {
+		dvp_try_format(dvp_dev, cfg, fmt->pad, &fmt->format, fmt->which);
+		*format = fmt->format;
+	}
+	mutex_unlock(&dvp_dev->stream_lock);
+
+	/* Propagate the format from sink to source */
+	if (fmt->pad == STF_DVP_PAD_SINK) {
+		format = __dvp_get_format(dvp_dev, cfg, STF_DVP_PAD_SRC,
+					fmt->which);
+
+		*format = fmt->format;
+		dvp_try_format(dvp_dev, cfg, STF_DVP_PAD_SRC, format,
+					fmt->which);
+	}
+
+out:
+	return 0;
+}
+
+static int dvp_init_formats(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh)
+{
+	struct v4l2_subdev_format format = {
+		.pad = STF_DVP_PAD_SINK,
+		.which = fh ? V4L2_SUBDEV_FORMAT_TRY :
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+		.format = {
+			.code = MEDIA_BUS_FMT_RGB565_2X8_LE,
+			.width = 1920,
+			.height = 1080
+		}
+	};
+
+	return dvp_set_format(sd, fh ? fh->pad : NULL, &format);
+}
+
+static int dvp_link_setup(struct media_entity *entity,
+			const struct media_pad *local,
+			const struct media_pad *remote, u32 flags)
+{
+	if ((local->flags & MEDIA_PAD_FL_SOURCE) &&
+		(flags & MEDIA_LNK_FL_ENABLED)) {
+		struct v4l2_subdev *sd;
+		struct stf_dvp_dev *dvp_dev;
+		struct vin_line *line;
+
+		if (media_entity_remote_pad(local))
+			return -EBUSY;
+
+		sd = media_entity_to_v4l2_subdev(entity);
+		dvp_dev = v4l2_get_subdevdata(sd);
+
+		sd = media_entity_to_v4l2_subdev(remote->entity);
+		line = v4l2_get_subdevdata(sd);
+		if (line->sdev_type == VIN_DEV_TYPE)
+			dvp_dev->s_type = SENSOR_VIN;
+		if (line->sdev_type == ISP_DEV_TYPE)
+			dvp_dev->s_type = SENSOR_ISP;
+		st_info(ST_DVP, "DVP device sensor type: %d\n", dvp_dev->s_type);
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops dvp_core_ops = {
+	.s_power = dvp_set_power,
+};
+
+static const struct v4l2_subdev_video_ops dvp_video_ops = {
+	.s_stream = dvp_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops dvp_pad_ops = {
+	.enum_mbus_code = dvp_enum_mbus_code,
+	.enum_frame_size = dvp_enum_frame_size,
+	.get_fmt = dvp_get_format,
+	.set_fmt = dvp_set_format,
+};
+
+static const struct v4l2_subdev_ops dvp_v4l2_ops = {
+	.core = &dvp_core_ops,
+	.video = &dvp_video_ops,
+	.pad = &dvp_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops dvp_v4l2_internal_ops = {
+	.open = dvp_init_formats,
+};
+
+static const struct media_entity_operations dvp_media_ops = {
+	.link_setup = dvp_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+int stf_dvp_register(struct stf_dvp_dev *dvp_dev,
+		struct v4l2_device *v4l2_dev)
+{
+	struct v4l2_subdev *sd = &dvp_dev->subdev;
+	struct media_pad *pads = dvp_dev->pads;
+	int ret;
+
+	v4l2_subdev_init(sd, &dvp_v4l2_ops);
+	sd->internal_ops = &dvp_v4l2_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	snprintf(sd->name, ARRAY_SIZE(sd->name), "%s%d",
+		STF_DVP_NAME, 0);
+	v4l2_set_subdevdata(sd, dvp_dev);
+
+	ret = dvp_init_formats(sd, NULL);
+	if (ret < 0) {
+		st_err(ST_DVP, "Failed to init format: %d\n", ret);
+		return ret;
+	}
+
+	pads[STF_DVP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	pads[STF_DVP_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE;
+
+	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+	sd->entity.ops = &dvp_media_ops;
+	ret = media_entity_pads_init(&sd->entity, STF_DVP_PADS_NUM, pads);
+	if (ret < 0) {
+		st_err(ST_DVP, "Failed to init media entity: %d\n", ret);
+		return ret;
+	}
+
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		st_err(ST_DVP, "Failed to register subdev: %d\n", ret);
+		goto err_sreg;
+	}
+
+	return 0;
+
+err_sreg:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+int stf_dvp_unregister(struct stf_dvp_dev *dvp_dev)
+{
+	v4l2_device_unregister_subdev(&dvp_dev->subdev);
+	media_entity_cleanup(&dvp_dev->subdev.entity);
+	mutex_destroy(&dvp_dev->stream_lock);
+	return 0;
+}
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_dvp.h b/drivers/media/platform/starfive/v4l2_driver/stf_dvp.h
new file mode 100644
index 000000000000..41b2ae4024a0
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_dvp.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_DVP_H
+#define STF_DVP_H
+
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-device.h>
+#include <media/media-entity.h>
+#include <video/stf-vin.h>
+
+#define STF_DVP_NAME "stf_dvp"
+
+#define STF_DVP_PAD_SINK     0
+#define STF_DVP_PAD_SRC      1
+#define STF_DVP_PADS_NUM     2
+
+struct dvp_format {
+	u32 code;
+	u8 bpp;
+};
+
+enum sensor_type;
+enum subdev_type;
+
+struct dvp_cfg {
+	unsigned int flags;
+	unsigned char bus_width;
+	unsigned char data_shift;
+};
+
+struct stf_dvp_dev;
+
+struct dvp_hw_ops {
+	int (*dvp_clk_enable)(struct stf_dvp_dev *dvp_dev);
+	int (*dvp_clk_disable)(struct stf_dvp_dev *dvp_dev);
+	int (*dvp_config_set)(struct stf_dvp_dev *dvp_dev);
+	int (*dvp_set_format)(struct stf_dvp_dev *dvp_dev,
+			u32 pix_width, u8 bpp);
+	int (*dvp_stream_set)(struct stf_dvp_dev *dvp_dev, int on);
+};
+
+struct stf_dvp_dev {
+	struct stfcamss *stfcamss;
+	struct dvp_cfg *dvp;
+	enum sensor_type s_type;
+	struct v4l2_subdev subdev;
+	struct media_pad pads[STF_DVP_PADS_NUM];
+	struct v4l2_mbus_framefmt fmt[STF_DVP_PADS_NUM];
+	const struct dvp_format *formats;
+	unsigned int nformats;
+	struct dvp_hw_ops *hw_ops;
+	struct mutex stream_lock;
+	int stream_count;
+};
+
+extern int stf_dvp_subdev_init(struct stfcamss *stfcamss);
+extern int stf_dvp_register(struct stf_dvp_dev *dvp_dev,
+			struct v4l2_device *v4l2_dev);
+extern int stf_dvp_unregister(struct stf_dvp_dev *dvp_dev);
+
+extern struct dvp_hw_ops dvp_ops;
+
+#endif /* STF_DVP_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_dvp_hw_ops.c b/drivers/media/platform/starfive/v4l2_driver/stf_dvp_hw_ops.c
new file mode 100644
index 000000000000..c6181596cfb5
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_dvp_hw_ops.c
@@ -0,0 +1,185 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include "stfcamss.h"
+
+static int stf_dvp_clk_enable(struct stf_dvp_dev *dvp_dev)
+{
+	struct stfcamss *stfcamss = dvp_dev->stfcamss;
+
+	switch (dvp_dev->s_type) {
+	case SENSOR_VIN:
+		reset_control_deassert(stfcamss->sys_rst[STFRST_AXIWR].rstc);
+		clk_set_phase(stfcamss->sys_clk[STFCLK_DVP_INV].clk, 0);
+		clk_set_parent(stfcamss->sys_clk[STFCLK_AXIWR].clk,
+			stfcamss->sys_clk[STFCLK_DVP_INV].clk);
+		break;
+	case SENSOR_ISP:
+		clk_set_phase(stfcamss->sys_clk[STFCLK_DVP_INV].clk, 0);
+		clk_set_parent(stfcamss->sys_clk[STFCLK_WRAPPER_CLK_C].clk,
+			stfcamss->sys_clk[STFCLK_DVP_INV].clk);
+		break;
+	}
+
+	return 0;
+}
+
+static int stf_dvp_clk_disable(struct stf_dvp_dev *dvp_dev)
+{
+	struct stfcamss *stfcamss = dvp_dev->stfcamss;
+
+	switch (dvp_dev->s_type) {
+	case SENSOR_VIN:
+		clk_set_parent(stfcamss->sys_clk[STFCLK_AXIWR].clk,
+			stfcamss->sys_clk[STFCLK_MIPI_RX0_PXL].clk);
+		reset_control_assert(stfcamss->sys_rst[STFRST_AXIWR].rstc);
+		break;
+	case SENSOR_ISP:
+		clk_set_parent(stfcamss->sys_clk[STFCLK_WRAPPER_CLK_C].clk,
+			stfcamss->sys_clk[STFCLK_MIPI_RX0_PXL].clk);
+		break;
+	}
+
+	return 0;
+}
+
+static int stf_dvp_config_set(struct stf_dvp_dev *dvp_dev)
+{
+
+	struct stf_vin_dev *vin = dvp_dev->stfcamss->vin;
+	unsigned int flags = 0;
+	unsigned char data_shift = 0;
+	u32 polarities = 0;
+
+	if (!dvp_dev->dvp)
+		return -EINVAL;
+
+	flags = dvp_dev->dvp->flags;
+	data_shift = dvp_dev->dvp->data_shift;
+	st_info(ST_DVP, "%s, polarities = 0x%x, flags = 0x%x\n",
+			__func__, polarities, flags);
+
+	if (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+		polarities |= BIT(1);
+	if (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)
+		polarities |= BIT(3);
+	print_reg(ST_DVP, vin->sysctrl_base, SYSCONSAIF_SYSCFG_36);
+	reg_set_bit(vin->sysctrl_base,	SYSCONSAIF_SYSCFG_36,
+		U0_VIN_CNFG_DVP_HS_POS
+		| U0_VIN_CNFG_DVP_VS_POS,
+		polarities);
+	print_reg(ST_DVP, vin->sysctrl_base, SYSCONSAIF_SYSCFG_36);
+
+	switch (data_shift) {
+	case 0:
+		data_shift = 0;
+		break;
+	case 2:
+		data_shift = 1;
+		break;
+	case 4:
+		data_shift = 2;
+		break;
+	case 6:
+		data_shift = 3;
+		break;
+	default:
+		data_shift = 0;
+		break;
+	};
+	print_reg(ST_DVP, vin->sysctrl_base, SYSCONSAIF_SYSCFG_28);
+	reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_28,
+		UO_VIN_CNFG_AXIWR0_PIXEL_HEIGH_BIT_SEL,
+		data_shift << 15);
+	print_reg(ST_DVP, vin->sysctrl_base, SYSCONSAIF_SYSCFG_28);
+
+	return 0;
+}
+
+static int set_vin_axiwr_pix_ct(struct stf_vin_dev *vin, u8 bpp)
+{
+	u32 value = 0;
+	int cnfg_axiwr_pix_ct = 64 / bpp;
+
+	// need check
+	if (cnfg_axiwr_pix_ct == 2)
+		value = 1;
+	else if (cnfg_axiwr_pix_ct == 4)
+		value = 1;
+	else if (cnfg_axiwr_pix_ct == 8)
+		value = 0;
+	else
+		return 0;
+
+	print_reg(ST_DVP, vin->sysctrl_base, SYSCONSAIF_SYSCFG_28);
+	reg_set_bit(vin->sysctrl_base,
+		SYSCONSAIF_SYSCFG_28,
+		U0_VIN_CNFG_AXIWR0_PIX_CT,
+		value<<13);
+	print_reg(ST_DVP, vin->sysctrl_base, SYSCONSAIF_SYSCFG_28);
+
+	return cnfg_axiwr_pix_ct;
+
+}
+
+static int stf_dvp_set_format(struct stf_dvp_dev *dvp_dev,
+		u32 pix_width, u8 bpp)
+{
+	struct stf_vin_dev *vin = dvp_dev->stfcamss->vin;
+	int val, pix_ct;
+
+	if (dvp_dev->s_type == SENSOR_VIN) {
+		pix_ct = set_vin_axiwr_pix_ct(vin, bpp);
+		val = (pix_width / pix_ct) - 1;
+		print_reg(ST_DVP, vin->sysctrl_base, SYSCTRL_VIN_WR_PIX_TOTAL);
+		reg_set_bit(vin->sysctrl_base,
+			SYSCONSAIF_SYSCFG_28,
+			U0_VIN_CNFG_AXIWR0_PIX_CNT_END,
+			val << 2);
+		print_reg(ST_DVP, vin->sysctrl_base, SYSCTRL_VIN_WR_PIX_TOTAL);
+
+	}
+
+	return 0;
+}
+
+static int stf_dvp_stream_set(struct stf_dvp_dev *dvp_dev, int on)
+{
+	struct stf_vin_dev *vin = dvp_dev->stfcamss->vin;
+
+	switch (dvp_dev->s_type) {
+	case SENSOR_VIN:
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_36,
+			U0_VIN_CNFG_ISP_DVP_EN0,
+			0);
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_0,
+			U0_VIN_CNFG_AXI_DVP_EN,
+			!!on<<2);
+		break;
+	case SENSOR_ISP:
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_36,
+			U0_VIN_CNFG_ISP_DVP_EN0,
+			!!on<<5);
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_0,
+			U0_VIN_CNFG_AXI_DVP_EN,
+			0);
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_36,
+			U0_VIN_CNFG_DVP_SWAP_EN,
+			0);
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_36,
+			U0_VIN_CNFG_GEN_EN_AXIRD,
+			0);
+		break;
+	}
+
+	return 0;
+}
+
+struct dvp_hw_ops dvp_ops = {
+	.dvp_clk_enable        = stf_dvp_clk_enable,
+	.dvp_clk_disable       = stf_dvp_clk_disable,
+	.dvp_config_set        = stf_dvp_config_set,
+	.dvp_set_format        = stf_dvp_set_format,
+	.dvp_stream_set        = stf_dvp_stream_set,
+};
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_event.c b/drivers/media/platform/starfive/v4l2_driver/stf_event.c
new file mode 100644
index 000000000000..3d47639b0002
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_event.c
@@ -0,0 +1,36 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Event for VIC Video In
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/notifier.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+
+static ATOMIC_NOTIFIER_HEAD(vin_notifier_list);
+
+int vin_notifier_register(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&vin_notifier_list, nb);
+}
+EXPORT_SYMBOL_GPL(vin_notifier_register);
+
+void vin_notifier_unregister(struct notifier_block *nb)
+{
+	atomic_notifier_chain_unregister(&vin_notifier_list, nb);
+}
+EXPORT_SYMBOL_GPL(vin_notifier_unregister);
+
+int vin_notifier_call(unsigned long e, void *v)
+{
+	return atomic_notifier_call_chain(&vin_notifier_list, e, v);
+}
+EXPORT_SYMBOL_GPL(vin_notifier_call);
+
+MODULE_AUTHOR("StarFive Technology Co., Ltd.");
+MODULE_DESCRIPTION("Starfive VIC video in notifier");
+MODULE_LICENSE("GPL");
+//MODULE_SUPPORTED_DEVICE("video");
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_isp.c b/drivers/media/platform/starfive/v4l2_driver/stf_isp.c
new file mode 100644
index 000000000000..0d455f136291
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_isp.c
@@ -0,0 +1,1501 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include "stfcamss.h"
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+#include <linux/firmware.h>
+#include "stf_isp_ioctl.h"
+#include "stf_dmabuf.h"
+
+static int user_config_isp;
+static int isp_set_selection(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_pad_config *cfg,
+			     struct v4l2_subdev_selection *sel);
+
+static struct v4l2_rect *
+__isp_get_compose(struct stf_isp_dev *isp_dev,
+		  struct v4l2_subdev_pad_config *cfg,
+		  enum v4l2_subdev_format_whence which);
+
+static struct v4l2_rect *
+__isp_get_crop(struct stf_isp_dev *isp_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		enum v4l2_subdev_format_whence which);
+
+static struct v4l2_rect *
+__isp_get_scale(struct stf_isp_dev *isp_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_selection *sel);
+
+static struct v4l2_rect *
+__isp_get_itiws(struct stf_isp_dev *isp_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		enum v4l2_subdev_format_whence which);
+
+// sink format and raw format must one by one
+static const struct isp_format isp_formats_st7110_sink[] = {
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10},
+};
+
+static const struct isp_format isp_formats_st7110_raw[] = {
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12},
+};
+
+static const struct isp_format isp_formats_st7110_compat_10bit_raw[] = {
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10},
+};
+
+static const struct isp_format isp_formats_st7110_compat_8bit_raw[] = {
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8},
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8},
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8},
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8},
+};
+
+static const struct isp_format isp_formats_st7110_uo[] = {
+	{ MEDIA_BUS_FMT_Y12_1X12, 8},
+};
+
+static const struct isp_format isp_formats_st7110_iti[] = {
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10},
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12},
+	{ MEDIA_BUS_FMT_Y12_1X12, 8},
+	{ MEDIA_BUS_FMT_YUV8_1X24, 8},
+};
+
+#define SINK_FORMATS_INDEX    0
+#define UO_FORMATS_INDEX      1
+#define ITI_FORMATS_INDEX     2
+#define RAW_FORMATS_INDEX     3
+
+static const struct isp_format_table isp_formats_st7110[] = {
+	{ isp_formats_st7110_sink, ARRAY_SIZE(isp_formats_st7110_sink) }, // 0
+	{ isp_formats_st7110_uo, ARRAY_SIZE(isp_formats_st7110_uo) },     // 1
+	{ isp_formats_st7110_iti, ARRAY_SIZE(isp_formats_st7110_iti) },   // 2
+	{ isp_formats_st7110_raw, ARRAY_SIZE(isp_formats_st7110_raw) },   // 3
+};
+
+int stf_isp_subdev_init(struct stfcamss *stfcamss)
+{
+	struct stf_isp_dev *isp_dev = stfcamss->isp_dev;
+
+	isp_dev->sdev_type = ISP_DEV_TYPE;
+	isp_dev->hw_ops = &isp_ops;
+	isp_dev->stfcamss = stfcamss;
+	isp_dev->formats = isp_formats_st7110;
+	isp_dev->nformats = ARRAY_SIZE(isp_formats_st7110);
+	mutex_init(&isp_dev->stream_lock);
+	mutex_init(&isp_dev->power_lock);
+	mutex_init(&isp_dev->setfile_lock);
+	atomic_set(&isp_dev->shadow_count, 0);
+	return 0;
+}
+
+/*
+ * ISP Controls.
+ */
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct stf_isp_dev,
+			     ctrls.handler)->subdev;
+}
+
+static u64 isp_calc_pixel_rate(struct stf_isp_dev *isp_dev)
+{
+	u64 rate = 0;
+
+	return rate;
+}
+
+static int isp_set_ctrl_hue(struct stf_isp_dev *isp_dev, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int isp_set_ctrl_contrast(struct stf_isp_dev *isp_dev, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int isp_set_ctrl_saturation(struct stf_isp_dev *isp_dev, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int isp_set_ctrl_white_balance(struct stf_isp_dev *isp_dev, int awb)
+{
+	struct isp_ctrls *ctrls = &isp_dev->ctrls;
+	int ret = 0;
+
+	if (!awb && (ctrls->red_balance->is_new
+			|| ctrls->blue_balance->is_new)) {
+		u16 red = (u16)ctrls->red_balance->val;
+		u16 blue = (u16)ctrls->blue_balance->val;
+
+		st_debug(ST_ISP, "red = 0x%x, blue = 0x%x\n", red, blue);
+		//isp_dev->hw_ops->isp_set_awb_r_gain(isp_dev, red);
+		//if (ret)
+		//	return ret;
+		//isp_dev->hw_ops->isp_set_awb_b_gain(isp_dev, blue);
+	}
+
+	return ret;
+}
+
+static int isp_set_ctrl_exposure(struct stf_isp_dev *isp_dev,
+				    enum v4l2_exposure_auto_type auto_exposure)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int isp_set_ctrl_gain(struct stf_isp_dev *isp_dev, bool auto_gain)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Color bars",
+	"Color bars w/ rolling bar",
+	"Color squares",
+	"Color squares w/ rolling bar",
+};
+
+#define ISP_TEST_ENABLE			BIT(7)
+#define ISP_TEST_ROLLING		BIT(6)	/* rolling horizontal bar */
+#define ISP_TEST_TRANSPARENT		BIT(5)
+#define ISP_TEST_SQUARE_BW		BIT(4)	/* black & white squares */
+#define ISP_TEST_BAR_STANDARD		(0 << 2)
+#define ISP_TEST_BAR_VERT_CHANGE_1	(1 << 2)
+#define ISP_TEST_BAR_HOR_CHANGE		(2 << 2)
+#define ISP_TEST_BAR_VERT_CHANGE_2	(3 << 2)
+#define ISP_TEST_BAR			(0 << 0)
+#define ISP_TEST_RANDOM			(1 << 0)
+#define ISP_TEST_SQUARE			(2 << 0)
+#define ISP_TEST_BLACK			(3 << 0)
+
+static const u8 test_pattern_val[] = {
+	0,
+	ISP_TEST_ENABLE | ISP_TEST_BAR_VERT_CHANGE_1 |
+		ISP_TEST_BAR,
+	ISP_TEST_ENABLE | ISP_TEST_ROLLING |
+		ISP_TEST_BAR_VERT_CHANGE_1 | ISP_TEST_BAR,
+	ISP_TEST_ENABLE | ISP_TEST_SQUARE,
+	ISP_TEST_ENABLE | ISP_TEST_ROLLING | ISP_TEST_SQUARE,
+};
+
+static int isp_set_ctrl_test_pattern(struct stf_isp_dev *isp_dev, int value)
+{
+	int ret = 0;
+
+	// return isp_write_reg(isp_dev, ISP_REG_PRE_ISP_TEST_SET1,
+	//			test_pattern_val[value]);
+	return ret;
+}
+
+static int isp_set_ctrl_light_freq(struct stf_isp_dev *isp_dev, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int isp_set_ctrl_hflip(struct stf_isp_dev *isp_dev, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int isp_set_ctrl_vflip(struct stf_isp_dev *isp_dev, int value)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+static int isp_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_AUTOGAIN:
+		break;
+	case V4L2_CID_EXPOSURE_AUTO:
+		break;
+	}
+
+	return 0;
+}
+
+static int isp_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	int ret;
+
+	/*
+	 * If the device is not powered up by the host driver do
+	 * not apply any controls to H/W at this time. Instead
+	 * the controls will be restored right after power-up.
+	 */
+	mutex_lock(&isp_dev->power_lock);
+	if (isp_dev->power_count == 0) {
+		mutex_unlock(&isp_dev->power_lock);
+		return 0;
+	}
+	mutex_unlock(&isp_dev->power_lock);
+
+	switch (ctrl->id) {
+	case V4L2_CID_AUTOGAIN:
+		ret = isp_set_ctrl_gain(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_EXPOSURE_AUTO:
+		ret = isp_set_ctrl_exposure(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+		ret = isp_set_ctrl_white_balance(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		ret = isp_set_ctrl_hue(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = isp_set_ctrl_contrast(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = isp_set_ctrl_saturation(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_TEST_PATTERN:
+		ret = isp_set_ctrl_test_pattern(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_POWER_LINE_FREQUENCY:
+		ret = isp_set_ctrl_light_freq(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_HFLIP:
+		ret = isp_set_ctrl_hflip(isp_dev, ctrl->val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = isp_set_ctrl_vflip(isp_dev, ctrl->val);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops isp_ctrl_ops = {
+	.g_volatile_ctrl = isp_g_volatile_ctrl,
+	.s_ctrl = isp_s_ctrl,
+};
+
+static int isp_init_controls(struct stf_isp_dev *isp_dev)
+{
+	const struct v4l2_ctrl_ops *ops = &isp_ctrl_ops;
+	struct isp_ctrls *ctrls = &isp_dev->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	v4l2_ctrl_handler_init(hdl, 32);
+
+	/* Clock related controls */
+	ctrls->pixel_rate = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_PIXEL_RATE,
+					      0, INT_MAX, 1,
+					      isp_calc_pixel_rate(isp_dev));
+
+	/* Auto/manual white balance */
+	ctrls->auto_wb = v4l2_ctrl_new_std(hdl, ops,
+					   V4L2_CID_AUTO_WHITE_BALANCE,
+					   0, 1, 1, 1);
+	ctrls->blue_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_BLUE_BALANCE,
+						0, 4095, 1, 0);
+	ctrls->red_balance = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_RED_BALANCE,
+					       0, 4095, 1, 0);
+	/* Auto/manual exposure */
+	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops,
+						 V4L2_CID_EXPOSURE_AUTO,
+						 V4L2_EXPOSURE_MANUAL, 0,
+						 V4L2_EXPOSURE_AUTO);
+	ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,
+					    0, 65535, 1, 0);
+	/* Auto/manual gain */
+	ctrls->auto_gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_AUTOGAIN,
+					     0, 1, 1, 1);
+	ctrls->gain = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_GAIN,
+					0, 1023, 1, 0);
+
+	ctrls->saturation = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_SATURATION,
+					      0, 255, 1, 64);
+	ctrls->hue = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HUE,
+				       0, 359, 1, 0);
+	ctrls->contrast = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_CONTRAST,
+					    0, 255, 1, 0);
+	ctrls->test_pattern =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+					     ARRAY_SIZE(test_pattern_menu) - 1,
+					     0, 0, test_pattern_menu);
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					 0, 1, 1, 0);
+
+	ctrls->light_freq =
+		v4l2_ctrl_new_std_menu(hdl, ops,
+				       V4L2_CID_POWER_LINE_FREQUENCY,
+				       V4L2_CID_POWER_LINE_FREQUENCY_AUTO, 0,
+				       V4L2_CID_POWER_LINE_FREQUENCY_50HZ);
+
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	ctrls->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+	ctrls->gain->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	ctrls->exposure->flags |= V4L2_CTRL_FLAG_VOLATILE;
+
+	v4l2_ctrl_auto_cluster(3, &ctrls->auto_wb, 0, false);
+	v4l2_ctrl_auto_cluster(2, &ctrls->auto_gain, 0, true);
+	v4l2_ctrl_auto_cluster(2, &ctrls->auto_exp, 1, true);
+
+	isp_dev->subdev.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+
+static int isp_set_power(struct v4l2_subdev *sd, int on)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+
+	st_debug(ST_ISP, "%s, %d\n", __func__, __LINE__);
+	mutex_lock(&isp_dev->power_lock);
+	if (on) {
+		if (isp_dev->power_count == 0)
+			st_debug(ST_ISP, "turn on isp\n");
+		isp_dev->power_count++;
+	} else {
+		if (isp_dev->power_count == 0)
+			goto exit;
+		isp_dev->power_count--;
+	}
+exit:
+	mutex_unlock(&isp_dev->power_lock);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__isp_get_format(struct stf_isp_dev *isp_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		unsigned int pad,
+		enum v4l2_subdev_format_whence which)
+{
+
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(&isp_dev->subdev, cfg, pad);
+
+	return &isp_dev->fmt[pad];
+}
+
+static int isp_get_interface_type(struct media_entity *entity)
+{
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad = &entity->pads[0];
+
+	if (!(pad->flags & MEDIA_PAD_FL_SINK))
+		return -EINVAL;
+
+	pad = media_entity_remote_pad(pad);
+	if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+		return -EINVAL;
+
+	subdev = media_entity_to_v4l2_subdev(pad->entity);
+
+	st_debug(ST_ISP, "interface subdev name %s\n", subdev->name);
+	if (!strncmp(subdev->name, STF_CSI_NAME, strlen(STF_CSI_NAME)))
+		return CSI_SENSOR;
+	if (!strncmp(subdev->name, STF_DVP_NAME, strlen(STF_DVP_NAME)))
+		return DVP_SENSOR;
+	return -EINVAL;
+}
+
+static int isp_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	int ret = 0, interface_type;
+	struct v4l2_mbus_framefmt *fmt;
+	struct v4l2_event src_ch = { 0 };
+
+	fmt = __isp_get_format(isp_dev, NULL, STF_ISP_PAD_SINK, V4L2_SUBDEV_FORMAT_ACTIVE);
+	mutex_lock(&isp_dev->stream_lock);
+	if (enable) {
+		if (isp_dev->stream_count == 0) {
+			isp_dev->hw_ops->isp_clk_enable(isp_dev);
+			if (!user_config_isp)
+				isp_dev->hw_ops->isp_config_set(isp_dev);
+			interface_type = isp_get_interface_type(&sd->entity);
+			if (interface_type < 0) {
+				st_err(ST_ISP, "%s, pipeline not config\n", __func__);
+				goto exit;
+			}
+			isp_dev->hw_ops->isp_set_format(isp_dev,
+					isp_dev->rect, fmt->code, interface_type);
+			isp_dev->hw_ops->isp_reset(isp_dev);
+			isp_dev->hw_ops->isp_stream_set(isp_dev, enable);
+			user_config_isp = 0;
+		}
+		isp_dev->stream_count++;
+	} else {
+		if (isp_dev->stream_count == 0)
+			goto exit;
+		if (isp_dev->stream_count == 1) {
+			isp_dev->hw_ops->isp_stream_set(isp_dev, enable);
+			isp_dev->hw_ops->isp_clk_disable(isp_dev);
+		}
+		isp_dev->stream_count--;
+	}
+	src_ch.type = V4L2_EVENT_SOURCE_CHANGE,
+	src_ch.u.src_change.changes = isp_dev->stream_count,
+
+	v4l2_subdev_notify_event(sd, &src_ch);
+exit:
+	mutex_unlock(&isp_dev->stream_lock);
+
+	mutex_lock(&isp_dev->power_lock);
+	/* restore controls */
+	if (enable && isp_dev->power_count == 1) {
+		mutex_unlock(&isp_dev->power_lock);
+		ret = v4l2_ctrl_handler_setup(&isp_dev->ctrls.handler);
+	} else
+		mutex_unlock(&isp_dev->power_lock);
+
+	return ret;
+}
+
+/*Try to match sensor format with sink, and then get the index as default.*/
+static int isp_match_sensor_format_get_index(struct stf_isp_dev *isp_dev)
+{
+	int ret, idx;
+	struct media_entity *sensor;
+	struct v4l2_subdev *subdev;
+	struct v4l2_subdev_format fmt;
+	const struct isp_format_table *formats;
+
+	if (!isp_dev)
+		return -EINVAL;
+
+	sensor = stfcamss_find_sensor(&isp_dev->subdev.entity);
+	if (!sensor)
+		return -EINVAL;
+
+	subdev = media_entity_to_v4l2_subdev(sensor);
+	st_debug(ST_ISP, "Found sensor = %s\n", sensor->name);
+
+	fmt.pad = 0;
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);
+	if (ret) {
+		st_warn(ST_ISP, "Sonser get format failed !!\n");
+		return -EINVAL;
+	}
+
+	st_debug(ST_ISP, "Got sensor format 0x%x !!\n", fmt.format.code);
+
+	formats = &isp_dev->formats[SINK_FORMATS_INDEX];
+	for (idx = 0; idx < formats->nfmts; idx++) {
+		if (formats->fmts[idx].code == fmt.format.code) {
+			st_info(ST_ISP,
+				"Match sensor format to isp_formats_st7110_sink index %d !!\n",
+				idx);
+			return idx;
+		}
+	}
+	return -ERANGE;
+}
+
+static int isp_match_format_get_index(const struct isp_format_table *f_table,
+			__u32 mbus_code,
+			unsigned int pad)
+{
+	int i;
+
+	for (i = 0; i < f_table->nfmts; i++) {
+		if (mbus_code == f_table->fmts[i].code) {
+			break;
+		} else {
+			if (pad == STF_ISP_PAD_SRC_RAW || pad == STF_ISP_PAD_SRC_SCD_Y) {
+				if (mbus_code == (isp_formats_st7110_compat_10bit_raw[i].code ||
+					isp_formats_st7110_compat_8bit_raw[i].code))
+					break;
+			}
+		}
+	}
+
+	return i;
+}
+
+static void isp_try_format(struct stf_isp_dev *isp_dev,
+			struct v4l2_subdev_pad_config *cfg,
+			unsigned int pad,
+			struct v4l2_mbus_framefmt *fmt,
+			enum v4l2_subdev_format_whence which)
+{
+	const struct isp_format_table *formats;
+	unsigned int i;
+	u32 code = fmt->code;
+	u32 bpp;
+
+	switch (pad) {
+	case STF_ISP_PAD_SINK:
+		/* Set format on sink pad */
+
+		formats = &isp_dev->formats[SINK_FORMATS_INDEX];
+		fmt->width = clamp_t(u32,
+				fmt->width, STFCAMSS_FRAME_MIN_WIDTH,
+				STFCAMSS_FRAME_MAX_WIDTH);
+		fmt->height = clamp_t(u32,
+				fmt->height, STFCAMSS_FRAME_MIN_HEIGHT,
+				STFCAMSS_FRAME_MAX_HEIGHT);
+		fmt->height &= ~0x1;
+
+		fmt->field = V4L2_FIELD_NONE;
+		fmt->colorspace = V4L2_COLORSPACE_SRGB;
+		fmt->flags = 0;
+
+		break;
+
+	case STF_ISP_PAD_SRC:
+	case STF_ISP_PAD_SRC_SS0:
+	case STF_ISP_PAD_SRC_SS1:
+		formats = &isp_dev->formats[UO_FORMATS_INDEX];
+		break;
+
+	case STF_ISP_PAD_SRC_ITIW:
+	case STF_ISP_PAD_SRC_ITIR:
+		formats = &isp_dev->formats[ITI_FORMATS_INDEX];
+		break;
+
+	case STF_ISP_PAD_SRC_RAW:
+	case STF_ISP_PAD_SRC_SCD_Y:
+		formats = &isp_dev->formats[RAW_FORMATS_INDEX];
+		break;
+	}
+
+	i = isp_match_format_get_index(formats, fmt->code, pad);
+	st_debug(ST_ISP, "%s pad=%d, code=%x isp_match_format_get_index = %d\n",
+					__func__, pad, code, i);
+
+	if (i >= formats->nfmts &&
+		(pad == STF_ISP_PAD_SRC_RAW || pad == STF_ISP_PAD_SRC_SCD_Y)) {
+		int sensor_idx;
+
+		sensor_idx = isp_match_sensor_format_get_index(isp_dev);
+		if (sensor_idx)
+			i = sensor_idx;
+	}
+
+	if (pad != STF_ISP_PAD_SINK)
+		*fmt = *__isp_get_format(isp_dev, cfg, STF_ISP_PAD_SINK, which);
+
+	if (i >= formats->nfmts) {
+		fmt->code = formats->fmts[0].code;
+		bpp = formats->fmts[0].bpp;
+		st_info(ST_ISP, "Use default index 0 format = 0x%x\n", fmt->code);
+	} else {
+		// sink format and raw format must one by one
+		if (pad == STF_ISP_PAD_SRC_RAW || pad == STF_ISP_PAD_SRC_SCD_Y) {
+			fmt->code = formats->fmts[i].code;
+			bpp = formats->fmts[i].bpp;
+			st_info(ST_ISP, "Use mapping format from sink index %d = 0x%x\n",
+					i, fmt->code);
+		} else {
+			fmt->code = code;
+			bpp = formats->fmts[i].bpp;
+			st_info(ST_ISP, "Use input format = 0x%x\n", fmt->code);
+		}
+	}
+
+	switch (pad) {
+	case STF_ISP_PAD_SINK:
+		break;
+	case STF_ISP_PAD_SRC:
+		isp_dev->rect[ISP_COMPOSE].bpp = bpp;
+		break;
+	case STF_ISP_PAD_SRC_SS0:
+		isp_dev->rect[ISP_SCALE_SS0].bpp = bpp;
+		break;
+	case STF_ISP_PAD_SRC_SS1:
+		isp_dev->rect[ISP_SCALE_SS1].bpp = bpp;
+		break;
+	case STF_ISP_PAD_SRC_ITIW:
+	case STF_ISP_PAD_SRC_ITIR:
+		isp_dev->rect[ISP_ITIWS].bpp = bpp;
+		break;
+	case STF_ISP_PAD_SRC_RAW:
+		isp_dev->rect[ISP_CROP].bpp = bpp;
+		break;
+	case STF_ISP_PAD_SRC_SCD_Y:
+		break;
+	}
+}
+
+static int isp_enum_mbus_code(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	const struct isp_format_table *formats;
+
+	if (code->index >= isp_dev->nformats)
+		return -EINVAL;
+	if (code->pad == STF_ISP_PAD_SINK) {
+		formats = &isp_dev->formats[SINK_FORMATS_INDEX];
+		code->code = formats->fmts[code->index].code;
+	} else {
+		struct v4l2_mbus_framefmt *sink_fmt;
+
+		sink_fmt = __isp_get_format(isp_dev, cfg, STF_ISP_PAD_SINK,
+					code->which);
+
+		code->code = sink_fmt->code;
+		if (!code->code)
+			return -EINVAL;
+	}
+	code->flags = 0;
+
+	return 0;
+}
+
+static int isp_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt format;
+
+	if (fse->index != 0)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = 1;
+	format.height = 1;
+	isp_try_format(isp_dev, cfg, fse->pad, &format, fse->which);
+	fse->min_width = format.width;
+	fse->min_height = format.height;
+
+	if (format.code != fse->code)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = -1;
+	format.height = -1;
+	isp_try_format(isp_dev, cfg, fse->pad, &format, fse->which);
+	fse->max_width = format.width;
+	fse->max_height = format.height;
+
+	return 0;
+}
+
+static int isp_get_format(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __isp_get_format(isp_dev, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int isp_set_format(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+	struct v4l2_subdev_selection sel = { 0 };
+	struct v4l2_rect *rect = NULL;
+	int ret;
+
+	st_debug(ST_ISP, "%s pad=%d, code=%x, which=%d\n",
+			__func__, fmt->reserved[0], fmt->format.code, fmt->which);
+	format = __isp_get_format(isp_dev, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&isp_dev->stream_lock);
+	if (isp_dev->stream_count) {
+		fmt->format = *format;
+		if (fmt->reserved[0] != 0) {
+			sel.which = fmt->which;
+			sel.pad = fmt->reserved[0];
+
+			switch (fmt->reserved[0]) {
+			case STF_ISP_PAD_SRC:
+				rect = __isp_get_compose(isp_dev, cfg, fmt->which);
+				break;
+			case STF_ISP_PAD_SRC_SS0:
+			case STF_ISP_PAD_SRC_SS1:
+				rect = __isp_get_scale(isp_dev, cfg, &sel);
+				break;
+			case STF_ISP_PAD_SRC_ITIW:
+			case STF_ISP_PAD_SRC_ITIR:
+				rect = __isp_get_itiws(isp_dev, cfg, fmt->which);
+				break;
+			case STF_ISP_PAD_SRC_RAW:
+			case STF_ISP_PAD_SRC_SCD_Y:
+				rect = __isp_get_crop(isp_dev, cfg, fmt->which);
+				break;
+			default:
+				break;
+			}
+			if (rect != NULL) {
+				fmt->format.width = rect->width;
+				fmt->format.height = rect->height;
+			}
+		}
+		mutex_unlock(&isp_dev->stream_lock);
+		goto out;
+	} else {
+		isp_try_format(isp_dev, cfg, fmt->pad, &fmt->format, fmt->which);
+		*format = fmt->format;
+	}
+	mutex_unlock(&isp_dev->stream_lock);
+
+	/* Propagate the format from sink to source */
+	if (fmt->pad == STF_ISP_PAD_SINK) {
+		/* Reset sink pad compose selection */
+		sel.which = fmt->which;
+		sel.pad = STF_ISP_PAD_SINK;
+		sel.target = V4L2_SEL_TGT_CROP;
+		sel.r.width = fmt->format.width;
+		sel.r.height = fmt->format.height;
+		ret = isp_set_selection(sd, cfg, &sel);
+		if (ret < 0)
+			return ret;
+	}
+
+out:
+	return 0;
+}
+
+static struct v4l2_rect *
+__isp_get_compose(struct stf_isp_dev *isp_dev,
+		  struct v4l2_subdev_pad_config *cfg,
+		  enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_compose(&isp_dev->subdev, cfg,
+						   STF_ISP_PAD_SINK);
+
+
+	return &isp_dev->rect[ISP_COMPOSE].rect;
+}
+
+static struct v4l2_rect *
+__isp_get_crop(struct stf_isp_dev *isp_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_crop(&isp_dev->subdev, cfg,
+						STF_ISP_PAD_SINK);
+
+	return &isp_dev->rect[ISP_CROP].rect;
+}
+
+
+static struct v4l2_rect *
+__isp_get_scale(struct stf_isp_dev *isp_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_selection *sel)
+{
+	int pad;
+
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_compose(&isp_dev->subdev, cfg,
+						STF_ISP_PAD_SINK);
+	if (sel->pad != STF_ISP_PAD_SRC_SS0 && sel->pad != STF_ISP_PAD_SRC_SS1)
+		return NULL;
+
+	pad = sel->pad == STF_ISP_PAD_SRC_SS0 ? ISP_SCALE_SS0 : ISP_SCALE_SS1;
+	return &isp_dev->rect[pad].rect;
+}
+
+static struct v4l2_rect *
+__isp_get_itiws(struct stf_isp_dev *isp_dev,
+		struct v4l2_subdev_pad_config *cfg,
+		enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_crop(&isp_dev->subdev, cfg, STF_ISP_PAD_SINK);
+
+	return &isp_dev->rect[ISP_ITIWS].rect;
+}
+
+static void isp_try_crop(struct stf_isp_dev *isp_dev,
+			    struct v4l2_subdev_pad_config *cfg,
+			    struct v4l2_rect *rect,
+			    enum v4l2_subdev_format_whence which)
+{
+	struct v4l2_mbus_framefmt *fmt;
+
+	fmt = __isp_get_format(isp_dev, cfg, STF_ISP_PAD_SINK, which);
+
+	if (rect->width > fmt->width)
+		rect->width = fmt->width;
+
+	if (rect->width + rect->left > fmt->width)
+		rect->left = fmt->width - rect->width;
+
+	if (rect->height > fmt->height)
+		rect->height = fmt->height;
+
+	if (rect->height + rect->top > fmt->height)
+		rect->top = fmt->height - rect->height;
+
+	if (rect->width < STFCAMSS_FRAME_MIN_WIDTH) {
+		rect->left = 0;
+		rect->width = STFCAMSS_FRAME_MIN_WIDTH;
+	}
+
+	if (rect->height < STFCAMSS_FRAME_MIN_HEIGHT) {
+		rect->top = 0;
+		rect->height = STFCAMSS_FRAME_MIN_HEIGHT;
+	}
+	rect->height &= ~0x1;
+}
+
+static void isp_try_compose(struct stf_isp_dev *isp_dev,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_rect *rect,
+			 enum v4l2_subdev_format_whence which)
+{
+	struct v4l2_rect *crop;
+
+	crop = __isp_get_crop(isp_dev, cfg, which);
+
+	if (rect->width > crop->width)
+		rect->width = crop->width;
+
+	if (rect->height > crop->height)
+		rect->height = crop->height;
+
+	if (crop->width > rect->width * SCALER_RATIO_MAX)
+		rect->width = (crop->width + SCALER_RATIO_MAX - 1) /
+							SCALER_RATIO_MAX;
+
+	if (crop->height > rect->height * SCALER_RATIO_MAX)
+		rect->height = (crop->height + SCALER_RATIO_MAX - 1) /
+							SCALER_RATIO_MAX;
+
+	if (rect->width < STFCAMSS_FRAME_MIN_WIDTH)
+		rect->width = STFCAMSS_FRAME_MIN_WIDTH;
+
+	if (rect->height < STFCAMSS_FRAME_MIN_HEIGHT)
+		rect->height = STFCAMSS_FRAME_MIN_HEIGHT;
+	rect->height &= ~0x1;
+}
+
+static void isp_try_scale(struct stf_isp_dev *isp_dev,
+			    struct v4l2_subdev_pad_config *cfg,
+			    struct v4l2_rect *rect,
+			    enum v4l2_subdev_format_whence which)
+{
+	struct v4l2_rect *compose;
+
+	compose = __isp_get_compose(isp_dev, cfg, which);
+
+	if (rect->width > compose->width)
+		rect->width = compose->width;
+
+	if (rect->width + rect->left > compose->width)
+		rect->left = compose->width - rect->width;
+
+	if (rect->height > compose->height)
+		rect->height = compose->height;
+
+	if (rect->height + rect->top > compose->height)
+		rect->top = compose->height - rect->height;
+
+	if (rect->width < STFCAMSS_FRAME_MIN_WIDTH) {
+		rect->left = 0;
+		rect->width = STFCAMSS_FRAME_MIN_WIDTH;
+	}
+
+	if (rect->height < STFCAMSS_FRAME_MIN_HEIGHT) {
+		rect->top = 0;
+		rect->height = STFCAMSS_FRAME_MIN_HEIGHT;
+	}
+	rect->height &= ~0x1;
+}
+
+static void isp_try_itiws(struct stf_isp_dev *isp_dev,
+			    struct v4l2_subdev_pad_config *cfg,
+			    struct v4l2_rect *rect,
+			    enum v4l2_subdev_format_whence which)
+{
+	struct v4l2_rect *crop;
+
+	crop = __isp_get_crop(isp_dev, cfg, which);
+
+	if (rect->width > crop->width)
+		rect->width = crop->width;
+
+	if (rect->width + rect->left > crop->width)
+		rect->left = crop->width - rect->width;
+
+	if (rect->height > crop->height)
+		rect->height = crop->height;
+
+	if (rect->height + rect->top > crop->height)
+		rect->top = crop->height - rect->height;
+
+	if (rect->width < STFCAMSS_FRAME_MIN_WIDTH) {
+		rect->left = 0;
+		rect->width = STFCAMSS_FRAME_MIN_WIDTH;
+	}
+
+	if (rect->height < STFCAMSS_FRAME_MIN_HEIGHT) {
+		rect->top = 0;
+		rect->height = STFCAMSS_FRAME_MIN_HEIGHT;
+	}
+	rect->height &= ~0x1;
+}
+
+static int isp_get_selection(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_pad_config *cfg,
+			     struct v4l2_subdev_selection *sel)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_subdev_format fmt = { 0 };
+	struct v4l2_rect *rect;
+	int ret;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		fmt.pad = sel->pad;
+		fmt.which = sel->which;
+		ret = isp_get_format(sd, cfg, &fmt);
+		if (ret < 0)
+			return ret;
+
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = fmt.format.width;
+		sel->r.height = fmt.format.height;
+		break;
+
+	case V4L2_SEL_TGT_CROP:
+		rect = __isp_get_crop(isp_dev, cfg, sel->which);
+		if (rect == NULL)
+			return -EINVAL;
+
+		sel->r = *rect;
+		break;
+
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+		if (sel->pad > STF_ISP_PAD_SRC_ITIR)
+			return -EINVAL;
+		rect = __isp_get_crop(isp_dev, cfg, sel->which);
+		if (rect == NULL)
+			return -EINVAL;
+
+		sel->r.left = rect->left;
+		sel->r.top = rect->top;
+		sel->r.width = rect->width;
+		sel->r.height = rect->height;
+		break;
+
+	case V4L2_SEL_TGT_COMPOSE:
+		if (sel->pad > STF_ISP_PAD_SRC_ITIR)
+			return -EINVAL;
+		if (sel->pad == STF_ISP_PAD_SRC_SS0
+			|| sel->pad == STF_ISP_PAD_SRC_SS1) {
+			rect = __isp_get_scale(isp_dev, cfg, sel);
+			if (rect == NULL)
+				return -EINVAL;
+		} else if (sel->pad == STF_ISP_PAD_SRC_ITIW
+			|| sel->pad == STF_ISP_PAD_SRC_ITIR) {
+			rect = __isp_get_itiws(isp_dev, cfg, sel->which);
+			if (rect == NULL)
+				return -EINVAL;
+		} else {
+			rect = __isp_get_compose(isp_dev, cfg, sel->which);
+			if (rect == NULL)
+				return -EINVAL;
+		}
+		sel->r = *rect;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	st_info(ST_ISP, "%s pad = %d, left = %d, %d, %d, %d\n",
+			__func__, sel->pad, sel->r.left, sel->r.top, sel->r.width, sel->r.height);
+	return 0;
+}
+
+static int isp_set_selection(struct v4l2_subdev *sd,
+			     struct v4l2_subdev_pad_config *cfg,
+			     struct v4l2_subdev_selection *sel)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	struct v4l2_rect *rect;
+	int ret = 0;
+
+	if (sel->target == V4L2_SEL_TGT_COMPOSE &&
+			((sel->pad == STF_ISP_PAD_SINK)
+			 || (sel->pad == STF_ISP_PAD_SRC))) {
+		struct v4l2_subdev_format fmt = { 0 };
+		int i;
+
+		rect = __isp_get_compose(isp_dev, cfg, sel->which);
+		if (rect == NULL)
+			return -EINVAL;
+
+		mutex_lock(&isp_dev->stream_lock);
+		if (isp_dev->stream_count) {
+			sel->r = *rect;
+			mutex_unlock(&isp_dev->stream_lock);
+			ret = 0;
+			goto out;
+		} else {
+			isp_try_compose(isp_dev, cfg, &sel->r, sel->which);
+			*rect = sel->r;
+		}
+		mutex_unlock(&isp_dev->stream_lock);
+
+		/* Reset source pad format width and height */
+		fmt.which = sel->which;
+		fmt.pad = STF_ISP_PAD_SRC;
+		ret = isp_get_format(sd, cfg, &fmt);
+		if (ret < 0)
+			return ret;
+
+		fmt.format.width = rect->width;
+		fmt.format.height = rect->height;
+
+		ret = isp_set_format(sd, cfg, &fmt);
+
+		/* Reset scale */
+		for (i = STF_ISP_PAD_SRC_SS0; i <= STF_ISP_PAD_SRC_ITIR; i++) {
+			struct v4l2_subdev_selection scale = { 0 };
+
+			scale.which = sel->which;
+			scale.target = V4L2_SEL_TGT_COMPOSE;
+			scale.r = *rect;
+			scale.pad = i;
+			ret = isp_set_selection(sd, cfg, &scale);
+		}
+	} else if (sel->target == V4L2_SEL_TGT_COMPOSE
+			&& ((sel->pad == STF_ISP_PAD_SRC_SS0)
+				|| (sel->pad == STF_ISP_PAD_SRC_SS1))) {
+		struct v4l2_subdev_format fmt = { 0 };
+
+		rect = __isp_get_scale(isp_dev, cfg, sel);
+		if (rect == NULL)
+			return -EINVAL;
+
+		mutex_lock(&isp_dev->stream_lock);
+		if (isp_dev->stream_count) {
+			sel->r = *rect;
+			mutex_unlock(&isp_dev->stream_lock);
+			ret = 0;
+			goto out;
+		} else {
+			isp_try_scale(isp_dev, cfg, &sel->r, sel->which);
+			*rect = sel->r;
+		}
+		mutex_unlock(&isp_dev->stream_lock);
+
+		/* Reset source pad format width and height */
+		fmt.which = sel->which;
+		fmt.pad = sel->pad;
+		ret = isp_get_format(sd, cfg, &fmt);
+		if (ret < 0)
+			return ret;
+
+		fmt.format.width = rect->width;
+		fmt.format.height = rect->height;
+		ret = isp_set_format(sd, cfg, &fmt);
+	} else if (sel->target == V4L2_SEL_TGT_COMPOSE
+			&& ((sel->pad == STF_ISP_PAD_SRC_ITIW)
+				|| (sel->pad == STF_ISP_PAD_SRC_ITIR))) {
+		struct v4l2_subdev_format fmt = { 0 };
+
+		rect = __isp_get_itiws(isp_dev, cfg, sel->which);
+		if (rect == NULL)
+			return -EINVAL;
+
+		mutex_lock(&isp_dev->stream_lock);
+		if (isp_dev->stream_count) {
+			sel->r = *rect;
+			mutex_unlock(&isp_dev->stream_lock);
+			ret = 0;
+			goto out;
+		} else {
+			isp_try_itiws(isp_dev, cfg, &sel->r, sel->which);
+			*rect = sel->r;
+		}
+		mutex_unlock(&isp_dev->stream_lock);
+
+		/* Reset source pad format width and height */
+		fmt.which = sel->which;
+		fmt.pad = sel->pad;
+		ret = isp_get_format(sd, cfg, &fmt);
+		if (ret < 0)
+			return ret;
+
+		fmt.format.width = rect->width;
+		fmt.format.height = rect->height;
+		ret = isp_set_format(sd, cfg, &fmt);
+	} else if (sel->target == V4L2_SEL_TGT_CROP) {
+		struct v4l2_subdev_selection compose = { 0 };
+		int i;
+
+		rect = __isp_get_crop(isp_dev, cfg, sel->which);
+		if (rect == NULL)
+			return -EINVAL;
+
+		mutex_lock(&isp_dev->stream_lock);
+		if (isp_dev->stream_count) {
+			sel->r = *rect;
+			mutex_unlock(&isp_dev->stream_lock);
+			ret = 0;
+			goto out;
+		} else {
+			isp_try_crop(isp_dev, cfg, &sel->r, sel->which);
+			*rect = sel->r;
+		}
+		mutex_unlock(&isp_dev->stream_lock);
+
+		/* Reset source compose selection */
+		compose.which = sel->which;
+		compose.target = V4L2_SEL_TGT_COMPOSE;
+		compose.r.width = rect->width;
+		compose.r.height = rect->height;
+		compose.pad = STF_ISP_PAD_SINK;
+		ret = isp_set_selection(sd, cfg, &compose);
+
+		/* Reset source pad format width and height */
+		for (i = STF_ISP_PAD_SRC_RAW; i < STF_ISP_PAD_MAX; i++) {
+			struct v4l2_subdev_format fmt = { 0 };
+
+			fmt.which = sel->which;
+			fmt.pad = i;
+			ret = isp_get_format(sd, cfg, &fmt);
+			if (ret < 0)
+				return ret;
+
+			fmt.format.width = rect->width;
+			fmt.format.height = rect->height;
+			ret = isp_set_format(sd, cfg, &fmt);
+		}
+	} else {
+		ret = -EINVAL;
+	}
+
+	st_info(ST_ISP, "%s pad = %d, left = %d, %d, %d, %d\n",
+			__func__, sel->pad, sel->r.left, sel->r.top, sel->r.width, sel->r.height);
+out:
+	return ret;
+}
+
+static int isp_init_formats(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh)
+{
+	struct v4l2_subdev_format format = {
+		.pad = STF_ISP_PAD_SINK,
+		.which = fh ? V4L2_SUBDEV_FORMAT_TRY :
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+		.format = {
+			.code = MEDIA_BUS_FMT_RGB565_2X8_LE,
+			.width = 1920,
+			.height = 1080
+		}
+	};
+
+	return isp_set_format(sd, fh ? fh->pad : NULL, &format);
+}
+
+static int isp_link_setup(struct media_entity *entity,
+			const struct media_pad *local,
+			const struct media_pad *remote, u32 flags)
+{
+	if (flags & MEDIA_LNK_FL_ENABLED)
+		if (media_entity_remote_pad(local))
+			return -EBUSY;
+	return 0;
+}
+
+static int stf_isp_load_setfile(struct stf_isp_dev *isp_dev, char *file_name)
+{
+	struct device *dev = isp_dev->stfcamss->dev;
+	const struct firmware *fw;
+	u8 *buf = NULL;
+	int *regval_num;
+	int ret;
+
+	st_debug(ST_ISP, "%s, file_name %s\n", __func__, file_name);
+	ret = request_firmware(&fw, file_name, dev);
+	if (ret < 0) {
+		st_err(ST_ISP, "firmware request failed (%d)\n", ret);
+		return ret;
+	}
+	buf = devm_kzalloc(dev, fw->size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+	memcpy(buf, fw->data, fw->size);
+
+	mutex_lock(&isp_dev->setfile_lock);
+	if (isp_dev->setfile.state == 1)
+		devm_kfree(dev, isp_dev->setfile.data);
+	isp_dev->setfile.data = buf;
+	isp_dev->setfile.size = fw->size;
+	isp_dev->setfile.state = 1;
+	regval_num = (int *)&buf[fw->size - sizeof(unsigned int)];
+	isp_dev->setfile.settings.regval_num = *regval_num;
+	isp_dev->setfile.settings.regval = (struct regval_t *)buf;
+	mutex_unlock(&isp_dev->setfile_lock);
+
+	st_debug(ST_ISP, "stf_isp setfile loaded size: %zu B, reg_nul: %d\n",
+			fw->size, isp_dev->setfile.settings.regval_num);
+
+	release_firmware(fw);
+	return ret;
+}
+
+static long stf_isp_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+	struct device *dev = isp_dev->stfcamss->dev;
+	int ret = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case VIDIOC_STFISP_LOAD_FW: {
+		struct stfisp_fw_info *fw_info = arg;
+
+		if (IS_ERR(fw_info)) {
+			st_err(ST_ISP, "fw_info failed, params invaild\n");
+			return -EINVAL;
+		}
+
+		ret = stf_isp_load_setfile(isp_dev, fw_info->filename);
+		break;
+	}
+	case VIDIOC_STF_DMABUF_ALLOC:
+	case VIDIOC_STF_DMABUF_FREE:
+		ret = stf_dmabuf_ioctl(dev, cmd, arg);
+		break;
+	case VIDIOC_STFISP_GET_REG:
+		ret = isp_dev->hw_ops->isp_reg_read(isp_dev, arg);
+		break;
+	case VIDIOC_STFISP_SET_REG:
+		ret = isp_dev->hw_ops->isp_reg_write(isp_dev, arg);
+		break;
+	case VIDIOC_STFISP_SHADOW_LOCK:
+		if (atomic_add_unless(&isp_dev->shadow_count, 1, 1))
+			ret = 0;
+		else
+			ret = -EBUSY;
+		st_debug(ST_ISP, "%s, %d, ret = %d\n", __func__, __LINE__, ret);
+		break;
+	case VIDIOC_STFISP_SHADOW_UNLOCK:
+		if (atomic_dec_if_positive(&isp_dev->shadow_count) < 0)
+			ret = -EINVAL;
+		else
+			ret = 0;
+		st_debug(ST_ISP, "%s, %d, ret = %d\n", __func__, __LINE__, ret);
+		break;
+	case VIDIOC_STFISP_SHADOW_UNLOCK_N_TRIGGER:
+		{
+			isp_dev->hw_ops->isp_shadow_trigger(isp_dev);
+			if (atomic_dec_if_positive(&isp_dev->shadow_count) < 0)
+				ret = -EINVAL;
+			else
+				ret = 0;
+			st_debug(ST_ISP, "%s, %d, ret = %d\n", __func__, __LINE__, ret);
+		}
+		break;
+	case VIDIOC_STFISP_SET_USER_CONFIG_ISP:
+		st_debug(ST_ISP, "%s, %d set user_config_isp\n", __func__, __LINE__);
+		user_config_isp = 1;
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+int isp_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct stf_isp_dev *isp_dev = v4l2_get_subdevdata(sd);
+
+	st_debug(ST_ISP, "%s, %d\n", __func__, __LINE__);
+	while (atomic_dec_if_positive(&isp_dev->shadow_count) > 0)
+		st_warn(ST_ISP, "user not unlocked the shadow lock, driver unlock it!\n");
+
+	return 0;
+}
+
+static int stf_isp_subscribe_event(struct v4l2_subdev *sd,
+				   struct v4l2_fh *fh,
+				   struct v4l2_event_subscription *sub)
+{
+	switch (sub->type) {
+	case V4L2_EVENT_SOURCE_CHANGE:
+		return v4l2_src_change_event_subdev_subscribe(sd, fh, sub);
+	case V4L2_EVENT_CTRL:
+		return v4l2_ctrl_subdev_subscribe_event(sd, fh, sub);
+	default:
+		st_debug(ST_ISP, "unspport subscribe_event\n");
+		return -EINVAL;
+	}
+}
+
+static const struct v4l2_subdev_core_ops isp_core_ops = {
+	.s_power = isp_set_power,
+	.ioctl = stf_isp_ioctl,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	// .subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.subscribe_event = stf_isp_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops isp_video_ops = {
+	.s_stream = isp_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops isp_pad_ops = {
+	.enum_mbus_code = isp_enum_mbus_code,
+	.enum_frame_size = isp_enum_frame_size,
+	.get_fmt = isp_get_format,
+	.set_fmt = isp_set_format,
+	.get_selection = isp_get_selection,
+	.set_selection = isp_set_selection,
+};
+
+static const struct v4l2_subdev_ops isp_v4l2_ops = {
+	.core = &isp_core_ops,
+	.video = &isp_video_ops,
+	.pad = &isp_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops isp_v4l2_internal_ops = {
+	.open = isp_init_formats,
+	.close = isp_close,
+};
+
+static const struct media_entity_operations isp_media_ops = {
+	.link_setup = isp_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+int stf_isp_register(struct stf_isp_dev *isp_dev,
+		struct v4l2_device *v4l2_dev)
+{
+	struct v4l2_subdev *sd = &isp_dev->subdev;
+	struct media_pad *pads = isp_dev->pads;
+	int ret;
+
+	v4l2_subdev_init(sd, &isp_v4l2_ops);
+	sd->internal_ops = &isp_v4l2_internal_ops;
+	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+	snprintf(sd->name, ARRAY_SIZE(sd->name), "%s%d",
+		STF_ISP_NAME, 0);
+	v4l2_set_subdevdata(sd, isp_dev);
+
+	ret = isp_init_formats(sd, NULL);
+	if (ret < 0) {
+		st_err(ST_ISP, "Failed to init format: %d\n", ret);
+		return ret;
+	}
+
+	pads[STF_ISP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	pads[STF_ISP_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE;
+	pads[STF_ISP_PAD_SRC_SS0].flags = MEDIA_PAD_FL_SOURCE;
+	pads[STF_ISP_PAD_SRC_SS1].flags = MEDIA_PAD_FL_SOURCE;
+	pads[STF_ISP_PAD_SRC_ITIW].flags = MEDIA_PAD_FL_SOURCE;
+	pads[STF_ISP_PAD_SRC_ITIR].flags = MEDIA_PAD_FL_SOURCE;
+	pads[STF_ISP_PAD_SRC_RAW].flags = MEDIA_PAD_FL_SOURCE;
+	pads[STF_ISP_PAD_SRC_SCD_Y].flags = MEDIA_PAD_FL_SOURCE;
+
+	sd->entity.function = MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+	sd->entity.ops = &isp_media_ops;
+	ret = media_entity_pads_init(&sd->entity, STF_ISP_PAD_MAX, pads);
+	if (ret < 0) {
+		st_err(ST_ISP, "Failed to init media entity: %d\n", ret);
+		return ret;
+	}
+
+	ret = isp_init_controls(isp_dev);
+	if (ret)
+		goto err_sreg;
+
+	ret = v4l2_device_register_subdev(v4l2_dev, sd);
+	if (ret < 0) {
+		st_err(ST_ISP, "Failed to register subdev: %d\n", ret);
+		goto free_ctrls;
+	}
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&isp_dev->ctrls.handler);
+err_sreg:
+	media_entity_cleanup(&sd->entity);
+	return ret;
+}
+
+int stf_isp_unregister(struct stf_isp_dev *isp_dev)
+{
+	v4l2_device_unregister_subdev(&isp_dev->subdev);
+	media_entity_cleanup(&isp_dev->subdev.entity);
+	v4l2_ctrl_handler_free(&isp_dev->ctrls.handler);
+	mutex_destroy(&isp_dev->stream_lock);
+	mutex_destroy(&isp_dev->power_lock);
+	mutex_destroy(&isp_dev->setfile_lock);
+	return 0;
+}
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_isp.h b/drivers/media/platform/starfive/v4l2_driver/stf_isp.h
new file mode 100644
index 000000000000..f53a061ff86b
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_isp.h
@@ -0,0 +1,220 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_ISP_H
+#define STF_ISP_H
+
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/media-entity.h>
+#include <video/stf-vin.h>
+
+#define STF_ISP_NAME "stf_isp"
+#define STF_ISP_SETFILE     "stf_isp0_fw.bin"
+
+#define ISP_SCD_BUFFER_SIZE     (19 * 256 * 4)  // align 128
+#define ISP_YHIST_BUFFER_SIZE   (64 * 4)
+#define ISP_SCD_Y_BUFFER_SIZE   (ISP_SCD_BUFFER_SIZE + ISP_YHIST_BUFFER_SIZE)
+#define ISP_RAW_DATA_BITS       12
+#define SCALER_RATIO_MAX        1  // no compose function
+#define STF_ISP_REG_OFFSET_MAX  0x0FFF
+#define STF_ISP_REG_DELAY_MAX   100
+
+#define ISP_REG_CSIINTS_ADDR    0x00000008
+#define ISP_REG_SENSOR          0x00000014
+#define ISP_REG_DUMP_CFG_0      0x00000024
+#define ISP_REG_DUMP_CFG_1      0x00000028
+#define ISP_REG_SCD_CFG_0       0x00000098
+#define ISP_REG_SCD_CFG_1       0x0000009C
+#define ISP_REG_SC_CFG_1        0x000000BC
+#define ISP_REG_IESHD_ADDR      0x00000A50
+#define ISP_REG_SS0AY           0x00000A94
+#define ISP_REG_SS0AUV          0x00000A98
+#define ISP_REG_SS0S            0x00000A9C
+#define ISP_REG_SS0IW           0x00000AA8
+#define ISP_REG_SS1AY           0x00000AAC
+#define ISP_REG_SS1AUV          0x00000AB0
+#define ISP_REG_SS1S            0x00000AB4
+#define ISP_REG_SS1IW           0x00000AC0
+#define ISP_REG_YHIST_CFG_4     0x00000CD8
+#define ISP_REG_ITIIWSR         0x00000B20
+#define ISP_REG_ITIDWLSR        0x00000B24
+#define ISP_REG_ITIDWYSAR       0x00000B28
+#define ISP_REG_ITIDWUSAR       0x00000B2C
+#define ISP_REG_ITIDRYSAR       0x00000B30
+#define ISP_REG_ITIDRUSAR       0x00000B34
+#define ISP_REG_ITIPDFR         0x00000B38
+#define ISP_REG_ITIDRLSR        0x00000B3C
+#define ISP_REG_ITIBSR          0x00000B40
+#define ISP_REG_ITIAIR          0x00000B44
+#define ISP_REG_ITIDPSR         0x00000B48
+
+/* The output line of a isp controller */
+enum isp_line_id {
+	STF_ISP_LINE_INVALID = -1,
+	STF_ISP_LINE_SRC = 1,
+	STF_ISP_LINE_SRC_SS0 = 2,
+	STF_ISP_LINE_SRC_SS1 = 3,
+	STF_ISP_LINE_SRC_ITIW = 4,
+	STF_ISP_LINE_SRC_ITIR = 5,
+	STF_ISP_LINE_SRC_RAW = 6,
+	STF_ISP_LINE_SRC_SCD_Y = 7,
+	STF_ISP_LINE_MAX = STF_ISP_LINE_SRC_SCD_Y
+};
+
+/* pad id for media framework */
+enum isp_pad_id {
+	STF_ISP_PAD_SINK = 0,
+	STF_ISP_PAD_SRC = 1,
+	STF_ISP_PAD_SRC_SS0 = 2,
+	STF_ISP_PAD_SRC_SS1 = 3,
+	STF_ISP_PAD_SRC_ITIW = 4,
+	STF_ISP_PAD_SRC_ITIR = 5,
+	STF_ISP_PAD_SRC_RAW = 6,
+	STF_ISP_PAD_SRC_SCD_Y = 7,
+	STF_ISP_PAD_MAX = 8
+};
+
+enum {
+	EN_INT_NONE                 = 0,
+	EN_INT_ISP_DONE             = (0x1 << 24),
+	EN_INT_CSI_DONE             = (0x1 << 25),
+	EN_INT_SC_DONE              = (0x1 << 26),
+	EN_INT_LINE_INT             = (0x1 << 27),
+	EN_INT_ALL                  = (0xF << 24),
+};
+
+enum {
+	DVP_SENSOR = 0,
+	CSI_SENSOR,
+};
+
+#define ISP_AWB_OECF_SKIP_FRAME  0
+// 0x0BC [31:30] SEL - sc0 input mux for sc awb
+// 00 : after DEC, 01 : after OBC, 10 : after OECF, 11 : after AWB
+enum scd_type {
+	DEC_TYPE = 0,
+	OBC_TYPE,
+	OECF_TYPE,
+	AWB_TYPE
+};
+
+struct isp_format {
+	u32 code;
+	u8 bpp;
+};
+
+struct isp_format_table {
+	const struct isp_format *fmts;
+	int nfmts;
+};
+
+struct regval_t {
+	u32 addr;
+	u32 val;
+	u32 mask;
+	u32 delay_ms;
+};
+
+struct reg_table {
+	struct regval_t *regval;
+	int regval_num;
+};
+
+struct isp_stream_format {
+	struct v4l2_rect rect;
+	u32 bpp;
+};
+
+struct stf_isp_dev;
+enum subdev_type;
+
+struct isp_hw_ops {
+	int (*isp_clk_enable)(struct stf_isp_dev *isp_dev);
+	int (*isp_clk_disable)(struct stf_isp_dev *isp_dev);
+	int (*isp_reset)(struct stf_isp_dev *isp_dev);
+	int (*isp_config_set)(struct stf_isp_dev *isp_dev);
+	int (*isp_set_format)(struct stf_isp_dev *isp_dev,
+			struct isp_stream_format *crop, u32 mcode,
+			int type);
+			// u32 width, u32 height);
+	int (*isp_stream_set)(struct stf_isp_dev *isp_dev, int on);
+	int (*isp_reg_read)(struct stf_isp_dev *isp_dev, void *arg);
+	int (*isp_reg_write)(struct stf_isp_dev *isp_dev, void *arg);
+	int (*isp_shadow_trigger)(struct stf_isp_dev *isp_dev);
+};
+
+struct isp_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *pixel_rate;
+	struct {
+		struct v4l2_ctrl *auto_exp;
+		struct v4l2_ctrl *exposure;
+	};
+	struct {
+		struct v4l2_ctrl *auto_wb;
+		struct v4l2_ctrl *blue_balance;
+		struct v4l2_ctrl *red_balance;
+	};
+	struct {
+		struct v4l2_ctrl *auto_gain;
+		struct v4l2_ctrl *gain;
+	};
+	struct v4l2_ctrl *brightness;
+	struct v4l2_ctrl *light_freq;
+	struct v4l2_ctrl *saturation;
+	struct v4l2_ctrl *contrast;
+	struct v4l2_ctrl *hue;
+	struct v4l2_ctrl *test_pattern;
+	struct v4l2_ctrl *hflip;
+	struct v4l2_ctrl *vflip;
+};
+
+struct isp_setfile {
+	struct reg_table settings;
+	const u8 *data;
+	unsigned int size;
+	unsigned int state;
+};
+
+enum {
+	ISP_CROP = 0,
+	ISP_COMPOSE,
+	ISP_SCALE_SS0,
+	ISP_SCALE_SS1,
+	ISP_ITIWS,
+	ISP_RECT_MAX
+};
+
+struct stf_isp_dev {
+	enum subdev_type sdev_type;  // must be frist
+	struct stfcamss *stfcamss;
+	struct v4l2_subdev subdev;
+	struct media_pad pads[STF_ISP_PAD_MAX];
+	struct v4l2_mbus_framefmt fmt[STF_ISP_PAD_MAX];
+	struct isp_stream_format rect[ISP_RECT_MAX];
+	const struct isp_format_table *formats;
+	unsigned int nformats;
+	struct isp_hw_ops *hw_ops;
+	struct mutex power_lock;
+	int power_count;
+	struct mutex stream_lock;
+	int stream_count;
+	atomic_t shadow_count;
+
+	struct isp_ctrls ctrls;
+	struct mutex setfile_lock;
+	struct isp_setfile setfile;
+	struct reg_table *context_regs;
+};
+
+extern int stf_isp_subdev_init(struct stfcamss *stfcamss);
+extern int stf_isp_register(struct stf_isp_dev *isp_dev,
+		struct v4l2_device *v4l2_dev);
+extern int stf_isp_unregister(struct stf_isp_dev *isp_dev);
+extern struct isp_hw_ops isp_ops;
+extern void dump_isp_reg(void *__iomem ispbase);
+
+#endif /* STF_ISP_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_isp_hw_ops.c b/drivers/media/platform/starfive/v4l2_driver/stf_isp_hw_ops.c
new file mode 100644
index 000000000000..1e7284a995e7
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_isp_hw_ops.c
@@ -0,0 +1,1552 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ *
+ * linux/drivers/media/platform/starfive/stf_isp.c
+ *
+ * PURPOSE:	This files contains the driver of VPP.
+ */
+#include "stfcamss.h"
+#include <linux/io.h>
+#include <linux/fb.h>
+#include <linux/module.h>
+#include <video/stf-vin.h>
+#include "stf_isp_ioctl.h"
+#include "stf_isp.h"
+#include <linux/delay.h>
+#include <linux/clk.h>
+#define USE_NEW_CONFIG_SETTING
+
+static struct regval_t isp_reg_init_config_list[] = {
+	/* config DC(0040H~0044H) */
+	{0x00000044, 0x00000000, 0, 0},
+	/* config DEC(0030H) */
+	{0x00000030, 0x00000000, 0, 0},
+	/* config OBC(0034H, 02E0H~02FCH) */
+	{0x00000034, 0x000000BB, 0, 0},
+	{0x000002E0, 0x40404040, 0, 0},
+	{0x000002E4, 0x40404040, 0, 0},
+	{0x000002E8, 0x40404040, 0, 0},
+	{0x000002EC, 0x40404040, 0, 0},
+	{0x000002F0, 0x00000000, 0, 0},
+	{0x000002F4, 0x00000000, 0, 0},
+	{0x000002F8, 0x00000000, 0, 0},
+	{0x000002FC, 0x00000000, 0, 0},
+	/* config LCBQ(0074H, 007CH, 0300H~039FH, and 0400H~049FH) */
+	{0x00000074, 0x00009900, 0, 0},
+	{0x0000007C, 0x01E40040, 0, 0},
+	{0x00000300, 0x01000100, 0, 0},
+	{0x00000304, 0x01000100, 0, 0},
+	{0x00000308, 0x01000100, 0, 0},
+	{0x0000030C, 0x01000100, 0, 0},
+	{0x00000310, 0x01000100, 0, 0},
+	{0x00000314, 0x01000100, 0, 0},
+	{0x00000318, 0x01000100, 0, 0},
+	{0x0000031C, 0x01000100, 0, 0},
+	{0x00000320, 0x01000100, 0, 0},
+	{0x00000324, 0x01000100, 0, 0},
+	{0x00000328, 0x01000100, 0, 0},
+	{0x0000032C, 0x01000100, 0, 0},
+	{0x00000330, 0x00000100, 0, 0},
+	{0x00000334, 0x01000100, 0, 0},
+	{0x00000338, 0x01000100, 0, 0},
+	{0x0000033C, 0x01000100, 0, 0},
+	{0x00000340, 0x01000100, 0, 0},
+	{0x00000344, 0x01000100, 0, 0},
+	{0x00000348, 0x01000100, 0, 0},
+	{0x0000034C, 0x01000100, 0, 0},
+	{0x00000350, 0x01000100, 0, 0},
+	{0x00000354, 0x01000100, 0, 0},
+	{0x00000358, 0x01000100, 0, 0},
+	{0x0000035C, 0x01000100, 0, 0},
+	{0x00000360, 0x01000100, 0, 0},
+	{0x00000364, 0x00000100, 0, 0},
+	{0x00000368, 0x01000100, 0, 0},
+	{0x0000036C, 0x01000100, 0, 0},
+	{0x00000370, 0x01000100, 0, 0},
+	{0x00000374, 0x01000100, 0, 0},
+	{0x00000378, 0x01000100, 0, 0},
+	{0x0000037C, 0x01000100, 0, 0},
+	{0x00000380, 0x01000100, 0, 0},
+	{0x00000384, 0x01000100, 0, 0},
+	{0x00000388, 0x01000100, 0, 0},
+	{0x0000038C, 0x01000100, 0, 0},
+	{0x00000390, 0x01000100, 0, 0},
+	{0x00000394, 0x01000100, 0, 0},
+	{0x00000398, 0x00000100, 0, 0},
+	{0x0000039C, 0x01000100, 0, 0},
+	{0x000003A0, 0x01000100, 0, 0},
+	{0x000003A4, 0x01000100, 0, 0},
+	{0x000003A8, 0x01000100, 0, 0},
+	{0x000003AC, 0x01000100, 0, 0},
+	{0x000003B0, 0x01000100, 0, 0},
+	{0x000003B4, 0x01000100, 0, 0},
+	{0x000003B8, 0x01000100, 0, 0},
+	{0x000003BC, 0x01000100, 0, 0},
+	{0x000003C0, 0x01000100, 0, 0},
+	{0x000003C4, 0x01000100, 0, 0},
+	{0x000003C8, 0x01000100, 0, 0},
+	{0x000003CC, 0x00000100, 0, 0},
+	{0x00000400, 0x00000000, 0, 0},
+	{0x00000404, 0x00000000, 0, 0},
+	{0x00000408, 0x00000000, 0, 0},
+	{0x0000040C, 0x00000000, 0, 0},
+	{0x00000410, 0x00000000, 0, 0},
+	{0x00000414, 0x00000000, 0, 0},
+	{0x00000418, 0x00000000, 0, 0},
+	{0x0000041C, 0x00000000, 0, 0},
+	{0x00000420, 0x00000000, 0, 0},
+	{0x00000424, 0x00000000, 0, 0},
+	{0x00000428, 0x00000000, 0, 0},
+	{0x0000042C, 0x00000000, 0, 0},
+	{0x00000430, 0x00000000, 0, 0},
+	{0x00000434, 0x00000000, 0, 0},
+	{0x00000438, 0x00000000, 0, 0},
+	{0x0000043C, 0x00000000, 0, 0},
+	{0x00000440, 0x00000000, 0, 0},
+	{0x00000444, 0x00000000, 0, 0},
+	{0x00000448, 0x00000000, 0, 0},
+	{0x0000044C, 0x00000000, 0, 0},
+	{0x00000450, 0x00000000, 0, 0},
+	{0x00000454, 0x00000000, 0, 0},
+	{0x00000458, 0x00000000, 0, 0},
+	{0x0000045C, 0x00000000, 0, 0},
+	{0x00000460, 0x00000000, 0, 0},
+	{0x00000464, 0x00000000, 0, 0},
+	{0x00000468, 0x00000000, 0, 0},
+	{0x0000046C, 0x00000000, 0, 0},
+	{0x00000470, 0x00000000, 0, 0},
+	{0x00000474, 0x00000000, 0, 0},
+	{0x00000478, 0x00000000, 0, 0},
+	{0x0000047C, 0x00000000, 0, 0},
+	{0x00000480, 0x00000000, 0, 0},
+	{0x00000484, 0x00000000, 0, 0},
+	{0x00000488, 0x00000000, 0, 0},
+	{0x0000048C, 0x00000000, 0, 0},
+	{0x00000490, 0x00000000, 0, 0},
+	{0x00000494, 0x00000000, 0, 0},
+	{0x00000498, 0x00000000, 0, 0},
+	{0x0000049C, 0x00000000, 0, 0},
+	{0x000004A0, 0x00000000, 0, 0},
+	{0x000004A4, 0x00000000, 0, 0},
+	{0x000004A8, 0x00000000, 0, 0},
+	{0x000004AC, 0x00000000, 0, 0},
+	{0x000004B0, 0x00000000, 0, 0},
+	{0x000004B4, 0x00000000, 0, 0},
+	{0x000004B8, 0x00000000, 0, 0},
+	{0x000004BC, 0x00000000, 0, 0},
+	{0x000004C0, 0x00000000, 0, 0},
+	{0x000004C4, 0x00000000, 0, 0},
+	{0x000004C8, 0x00000000, 0, 0},
+	{0x000004CC, 0x00000000, 0, 0},
+	/* config OECF(0100H~027CH) */
+	{0x00000100, 0x00100000, 0, 0},
+	{0x00000104, 0x00400020, 0, 0},
+	{0x00000108, 0x00800060, 0, 0},
+	{0x0000010C, 0x00C000A0, 0, 0},
+	{0x00000110, 0x010000E0, 0, 0},
+	{0x00000114, 0x02000180, 0, 0},
+	{0x00000118, 0x03000280, 0, 0},
+	{0x0000011C, 0x03FE0380, 0, 0},
+	{0x00000120, 0x00100000, 0, 0},
+	{0x00000124, 0x00400020, 0, 0},
+	{0x00000128, 0x00800060, 0, 0},
+	{0x0000012C, 0x00C000A0, 0, 0},
+	{0x00000130, 0x010000E0, 0, 0},
+	{0x00000134, 0x02000180, 0, 0},
+	{0x00000138, 0x03000280, 0, 0},
+	{0x0000013C, 0x03FE0380, 0, 0},
+	{0x00000140, 0x00100000, 0, 0},
+	{0x00000144, 0x00400020, 0, 0},
+	{0x00000148, 0x00800060, 0, 0},
+	{0x0000014C, 0x00C000A0, 0, 0},
+	{0x00000150, 0x010000E0, 0, 0},
+	{0x00000154, 0x02000180, 0, 0},
+	{0x00000158, 0x03000280, 0, 0},
+	{0x0000015C, 0x03FE0380, 0, 0},
+	{0x00000160, 0x00100000, 0, 0},
+	{0x00000164, 0x00400020, 0, 0},
+	{0x00000168, 0x00800060, 0, 0},
+	{0x0000016C, 0x00C000A0, 0, 0},
+	{0x00000170, 0x010000E0, 0, 0},
+	{0x00000174, 0x02000180, 0, 0},
+	{0x00000178, 0x03000280, 0, 0},
+	{0x0000017C, 0x03FE0380, 0, 0},
+	{0x00000180, 0x00100000, 0, 0},
+	{0x00000184, 0x00400020, 0, 0},
+	{0x00000188, 0x00800060, 0, 0},
+	{0x0000018C, 0x00C000A0, 0, 0},
+	{0x00000190, 0x010000E0, 0, 0},
+	{0x00000194, 0x02000180, 0, 0},
+	{0x00000198, 0x03000280, 0, 0},
+	{0x0000019C, 0x03FE0380, 0, 0},
+	{0x000001A0, 0x00100000, 0, 0},
+	{0x000001A4, 0x00400020, 0, 0},
+	{0x000001A8, 0x00800060, 0, 0},
+	{0x000001AC, 0x00C000A0, 0, 0},
+	{0x000001B0, 0x010000E0, 0, 0},
+	{0x000001B4, 0x02000180, 0, 0},
+	{0x000001B8, 0x03000280, 0, 0},
+	{0x000001BC, 0x03FE0380, 0, 0},
+	{0x000001C0, 0x00100000, 0, 0},
+	{0x000001C4, 0x00400020, 0, 0},
+	{0x000001C8, 0x00800060, 0, 0},
+	{0x000001CC, 0x00C000A0, 0, 0},
+	{0x000001D0, 0x010000E0, 0, 0},
+	{0x000001D4, 0x02000180, 0, 0},
+	{0x000001D8, 0x03000280, 0, 0},
+	{0x000001DC, 0x03FE0380, 0, 0},
+	{0x000001E0, 0x00100000, 0, 0},
+	{0x000001E4, 0x00400020, 0, 0},
+	{0x000001E8, 0x00800060, 0, 0},
+	{0x000001EC, 0x00C000A0, 0, 0},
+	{0x000001F0, 0x010000E0, 0, 0},
+	{0x000001F4, 0x02000180, 0, 0},
+	{0x000001F8, 0x03000280, 0, 0},
+	{0x000001FC, 0x03FE0380, 0, 0},
+	{0x00000200, 0x00800080, 0, 0},
+	{0x00000204, 0x00800080, 0, 0},
+	{0x00000208, 0x00800080, 0, 0},
+	{0x0000020C, 0x00800080, 0, 0},
+	{0x00000210, 0x00800080, 0, 0},
+	{0x00000214, 0x00800080, 0, 0},
+	{0x00000218, 0x00800080, 0, 0},
+	{0x0000021C, 0x00800080, 0, 0},
+	{0x00000220, 0x00800080, 0, 0},
+	{0x00000224, 0x00800080, 0, 0},
+	{0x00000228, 0x00800080, 0, 0},
+	{0x0000022C, 0x00800080, 0, 0},
+	{0x00000230, 0x00800080, 0, 0},
+	{0x00000234, 0x00800080, 0, 0},
+	{0x00000238, 0x00800080, 0, 0},
+	{0x0000023C, 0x00800080, 0, 0},
+	{0x00000240, 0x00800080, 0, 0},
+	{0x00000244, 0x00800080, 0, 0},
+	{0x00000248, 0x00800080, 0, 0},
+	{0x0000024C, 0x00800080, 0, 0},
+	{0x00000250, 0x00800080, 0, 0},
+	{0x00000254, 0x00800080, 0, 0},
+	{0x00000258, 0x00800080, 0, 0},
+	{0x0000025C, 0x00800080, 0, 0},
+	{0x00000260, 0x00800080, 0, 0},
+	{0x00000264, 0x00800080, 0, 0},
+	{0x00000268, 0x00800080, 0, 0},
+	{0x0000026C, 0x00800080, 0, 0},
+	{0x00000270, 0x00800080, 0, 0},
+	{0x00000274, 0x00800080, 0, 0},
+	{0x00000278, 0x00800080, 0, 0},
+	{0x0000027C, 0x00800080, 0, 0},
+	/* config OECFHM(03D0H~03E4H) */
+	{0x000003D0, 0x04000000, 0, 0},
+	{0x000003D4, 0x0C000800, 0, 0},
+	{0x000003D8, 0x00000FFF, 0, 0},
+	{0x000003DC, 0x08000800, 0, 0},
+	{0x000003E0, 0x08000800, 0, 0},
+	{0x000003E4, 0x00000800, 0, 0},
+	/* config LCCF(0050H, 0058H, 00E0H~00ECH) */
+	{0x00000050, 0x021C03C0, 0, 0},
+	{0x00000058, 0x0000000B, 0, 0},
+	{0x000000E0, 0x00000000, 0, 0},
+	{0x000000E4, 0x00000000, 0, 0},
+	{0x000000E8, 0x00000000, 0, 0},
+	{0x000000EC, 0x00000000, 0, 0},
+	/* config AWB(0280H~02DCH) */
+	{0x00000280, 0x00000000, 0, 0},
+	{0x00000284, 0x00000000, 0, 0},
+	{0x00000288, 0x00000000, 0, 0},
+	{0x0000028C, 0x00000000, 0, 0},
+	{0x00000290, 0x00000000, 0, 0},
+	{0x00000294, 0x00000000, 0, 0},
+	{0x00000298, 0x00000000, 0, 0},
+	{0x0000029C, 0x00000000, 0, 0},
+	{0x000002A0, 0x00000000, 0, 0},
+	{0x000002A4, 0x00000000, 0, 0},
+	{0x000002A8, 0x00000000, 0, 0},
+	{0x000002AC, 0x00000000, 0, 0},
+	{0x000002B0, 0x00000000, 0, 0},
+	{0x000002B4, 0x00000000, 0, 0},
+	{0x000002B8, 0x00000000, 0, 0},
+	{0x000002BC, 0x00000000, 0, 0},
+	{0x000002C0, 0x00800080, 0, 0},
+	{0x000002C4, 0x00800080, 0, 0},
+	{0x000002C8, 0x00800080, 0, 0},
+	{0x000002CC, 0x00800080, 0, 0},
+	{0x000002D0, 0x00800080, 0, 0},
+	{0x000002D4, 0x00800080, 0, 0},
+	{0x000002D8, 0x00800080, 0, 0},
+	{0x000002DC, 0x00800080, 0, 0},
+	/* config CTC(0A10H) and DBC(0A14H) filter */
+	{0x00000A10, 0x41400040, 0, 0},
+	{0x00000A14, 0x02000200, 0, 0},
+	/* config CFA(0018H, 0A1CH) */
+	{0x00000018, 0x000011BB, 0, 0},
+	{0x00000A1C, 0x00000032, 0, 0},
+	/* config CCM(0C40H~0CA4H) */
+	{0x00000C40, 0x00060000, 0, 0},
+	{0x00000C44, 0x00000000, 0, 0},
+	{0x00000C48, 0x00000000, 0, 0},
+	{0x00000C4C, 0x00000000, 0, 0},
+	{0x00000C50, 0x00000000, 0, 0},
+	{0x00000C54, 0x00000000, 0, 0},
+	{0x00000C58, 0x00000000, 0, 0},
+	{0x00000C5C, 0x00000000, 0, 0},
+	{0x00000C60, 0x00000000, 0, 0},
+	{0x00000C64, 0x00000000, 0, 0},
+	{0x00000C68, 0x00000000, 0, 0},
+	{0x00000C6C, 0x00000000, 0, 0},
+	{0x00000C70, 0x00000080, 0, 0},
+	{0x00000C74, 0x00000000, 0, 0},
+	{0x00000C78, 0x00000000, 0, 0},
+	{0x00000C7C, 0x00000000, 0, 0},
+	{0x00000C80, 0x00000080, 0, 0},
+	{0x00000C84, 0x00000000, 0, 0},
+	{0x00000C88, 0x00000000, 0, 0},
+	{0x00000C8C, 0x00000000, 0, 0},
+	{0x00000C90, 0x00000080, 0, 0},
+	{0x00000C94, 0x00000000, 0, 0},
+	{0x00000C98, 0x00000000, 0, 0},
+	{0x00000C9C, 0x00000000, 0, 0},
+	{0x00000CA0, 0x00000700, 0, 0},
+	{0x00000CA4, 0x00000200, 0, 0},
+	/* config GMARGB(0E00H~0E38H) */
+	{0x00000E00, 0x24000000, 0, 0},
+	{0x00000E04, 0x08000020, 0, 0},
+	{0x00000E08, 0x08000040, 0, 0},
+	{0x00000E0C, 0x08000060, 0, 0},
+	{0x00000E10, 0x08000080, 0, 0},
+	{0x00000E14, 0x080000A0, 0, 0},
+	{0x00000E18, 0x080000C0, 0, 0},
+	{0x00000E1C, 0x080000E0, 0, 0},
+	{0x00000E20, 0x08000100, 0, 0},
+	{0x00000E24, 0x08000180, 0, 0},
+	{0x00000E28, 0x08000200, 0, 0},
+	{0x00000E2C, 0x08000280, 0, 0},
+	{0x00000E30, 0x08000300, 0, 0},
+	{0x00000E34, 0x08000380, 0, 0},
+	{0x00000E38, 0x080003FE, 0, 0},
+	/* config R2Y(0E40H~0E60H) */
+	{0x00000E40, 0x0000004C, 0, 0},
+	{0x00000E44, 0x00000097, 0, 0},
+	{0x00000E48, 0x0000001D, 0, 0},
+	{0x00000E4C, 0x000001D5, 0, 0},
+	{0x00000E50, 0x000001AC, 0, 0},
+	{0x00000E54, 0x00000080, 0, 0},
+	{0x00000E58, 0x00000080, 0, 0},
+	{0x00000E5C, 0x00000194, 0, 0},
+	{0x00000E60, 0x000001EC, 0, 0},
+	/* config YCRV(0F00H~0FFCH) */
+	{0x00000F00, 0x00000000, 0, 0},
+	{0x00000F04, 0x00000010, 0, 0},
+	{0x00000F08, 0x00000020, 0, 0},
+	{0x00000F0C, 0x00000030, 0, 0},
+	{0x00000F10, 0x00000040, 0, 0},
+	{0x00000F14, 0x00000050, 0, 0},
+	{0x00000F18, 0x00000060, 0, 0},
+	{0x00000F1C, 0x00000070, 0, 0},
+	{0x00000F20, 0x00000080, 0, 0},
+	{0x00000F24, 0x00000090, 0, 0},
+	{0x00000F28, 0x000000A0, 0, 0},
+	{0x00000F2C, 0x000000B0, 0, 0},
+	{0x00000F30, 0x000000C0, 0, 0},
+	{0x00000F34, 0x000000D0, 0, 0},
+	{0x00000F38, 0x000000E0, 0, 0},
+	{0x00000F3C, 0x000000F0, 0, 0},
+	{0x00000F40, 0x00000100, 0, 0},
+	{0x00000F44, 0x00000110, 0, 0},
+	{0x00000F48, 0x00000120, 0, 0},
+	{0x00000F4C, 0x00000130, 0, 0},
+	{0x00000F50, 0x00000140, 0, 0},
+	{0x00000F54, 0x00000150, 0, 0},
+	{0x00000F58, 0x00000160, 0, 0},
+	{0x00000F5C, 0x00000170, 0, 0},
+	{0x00000F60, 0x00000180, 0, 0},
+	{0x00000F64, 0x00000190, 0, 0},
+	{0x00000F68, 0x000001A0, 0, 0},
+	{0x00000F6C, 0x000001B0, 0, 0},
+	{0x00000F70, 0x000001C0, 0, 0},
+	{0x00000F74, 0x000001D0, 0, 0},
+	{0x00000F78, 0x000001E0, 0, 0},
+	{0x00000F7C, 0x000001F0, 0, 0},
+	{0x00000F80, 0x00000200, 0, 0},
+	{0x00000F84, 0x00000210, 0, 0},
+	{0x00000F88, 0x00000220, 0, 0},
+	{0x00000F8C, 0x00000230, 0, 0},
+	{0x00000F90, 0x00000240, 0, 0},
+	{0x00000F94, 0x00000250, 0, 0},
+	{0x00000F98, 0x00000260, 0, 0},
+	{0x00000F9C, 0x00000270, 0, 0},
+	{0x00000FA0, 0x00000280, 0, 0},
+	{0x00000FA4, 0x00000290, 0, 0},
+	{0x00000FA8, 0x000002A0, 0, 0},
+	{0x00000FAC, 0x000002B0, 0, 0},
+	{0x00000FB0, 0x000002C0, 0, 0},
+	{0x00000FB4, 0x000002D0, 0, 0},
+	{0x00000FB8, 0x000002E0, 0, 0},
+	{0x00000FBC, 0x000002F0, 0, 0},
+	{0x00000FC0, 0x00000300, 0, 0},
+	{0x00000FC4, 0x00000310, 0, 0},
+	{0x00000FC8, 0x00000320, 0, 0},
+	{0x00000FCC, 0x00000330, 0, 0},
+	{0x00000FD0, 0x00000340, 0, 0},
+	{0x00000FD4, 0x00000350, 0, 0},
+	{0x00000FD8, 0x00000360, 0, 0},
+	{0x00000FDC, 0x00000370, 0, 0},
+	{0x00000FE0, 0x00000380, 0, 0},
+	{0x00000FE4, 0x00000390, 0, 0},
+	{0x00000FE8, 0x000003A0, 0, 0},
+	{0x00000FEC, 0x000003B0, 0, 0},
+	{0x00000FF0, 0x000003C0, 0, 0},
+	{0x00000FF4, 0x000003D0, 0, 0},
+	{0x00000FF8, 0x000003E0, 0, 0},
+	{0x00000FFC, 0x000003F0, 0, 0},
+	/* config Shrp(0E80H~0EE8H) */
+	{0x00000E80, 0x00070F00, 0, 0},
+	{0x00000E84, 0x00180F00, 0, 0},
+	{0x00000E88, 0x00800F00, 0, 0},
+	{0x00000E8C, 0x01000F00, 0, 0},
+	{0x00000E90, 0x00100F00, 0, 0},
+	{0x00000E94, 0x00600F00, 0, 0},
+	{0x00000E98, 0x01000F00, 0, 0},
+	{0x00000E9C, 0x01900F00, 0, 0},
+	{0x00000EA0, 0x00000F00, 0, 0},
+	{0x00000EA4, 0x00000F00, 0, 0},
+	{0x00000EA8, 0x00000F00, 0, 0},
+	{0x00000EAC, 0x00000F00, 0, 0},
+	{0x00000EB0, 0x00000F00, 0, 0},
+	{0x00000EB4, 0x00000F00, 0, 0},
+	{0x00000EB8, 0x00000F00, 0, 0},
+	{0x00000EBC, 0x10000000, 0, 0},
+	{0x00000EC0, 0x10000000, 0, 0},
+	{0x00000EC4, 0x10000000, 0, 0},
+	{0x00000EC8, 0x10000000, 0, 0},
+	{0x00000ECC, 0x10000000, 0, 0},
+	{0x00000ED0, 0x10000000, 0, 0},
+	{0x00000ED4, 0x88000D7C, 0, 0},
+	{0x00000ED8, 0x00C00040, 0, 0},
+	{0x00000EDC, 0xFF000000, 0, 0},
+	{0x00000EE0, 0x00A00040, 0, 0},
+	{0x00000EE4, 0x00000000, 0, 0},
+	{0x00000EE8, 0x00000000, 0, 0},
+	/* config DNYUV(0C00H~0C24H) */
+	{0x00000C00, 0x00777777, 0, 0},
+	{0x00000C04, 0x00007777, 0, 0},
+	{0x00000C08, 0x00777777, 0, 0},
+	{0x00000C0C, 0x00007777, 0, 0},
+	{0x00000C10, 0x00600040, 0, 0},
+	{0x00000C14, 0x00D80090, 0, 0},
+	{0x00000C18, 0x01E60144, 0, 0},
+	{0x00000C1C, 0x00600040, 0, 0},
+	{0x00000C20, 0x00D80090, 0, 0},
+	{0x00000C24, 0x01E60144, 0, 0},
+	/* config SAT(0A30H~0A40H, 0A54H~0A58H) */
+	{0x00000A30, 0x00000100, 0, 0},
+	{0x00000A34, 0x001F0001, 0, 0},
+	{0x00000A38, 0x00000000, 0, 0},
+	{0x00000A3C, 0x00000100, 0, 0},
+	{0x00000A40, 0x00000008, 0, 0},
+	{0x00000A54, 0x04010001, 0, 0},
+	{0x00000A58, 0x03FF0001, 0, 0},
+	/* config OBA(0090H~0094H) */
+	{0x00000090, 0x04380000, 0, 0},
+	{0x00000094, 0x04390780, 0, 0},
+	/* config SC(0098H~009CH, 00B8H~00BCH,
+	 * 00C0H, 0C4H~0D4H, 04D0H~054CH, 5D0H~5D4H)
+	 */
+	{0x0000009C, 0x01000000, 0, 0},
+	{0x000000B8, 0x000C0000, 0, 0},
+	{0x000000BC, 0xC010151D, 0, 0},
+	{0x000000C0, 0x01F1BF08, 0, 0},
+	{0x000000C4, 0xFF00FF00, 0, 0},
+	{0x000000C8, 0xFF00FF00, 0, 0},
+	{0x000000CC, 0xFFFF0000, 0, 0},
+	{0x000000D0, 0xFFFF0000, 0, 0},
+	{0x000000D4, 0xFFFF0000, 0, 0},
+	{0x000000D8, 0x01050107, 0, 0},
+	{0x000004D0, 0x00000000, 0, 0},
+	{0x000004D4, 0x00000000, 0, 0},
+	{0x000004D8, 0x00000000, 0, 0},
+	{0x000004DC, 0x00000000, 0, 0},
+	{0x000004E0, 0x00000000, 0, 0},
+	{0x000004E4, 0x00000000, 0, 0},
+	{0x000004E8, 0x00000000, 0, 0},
+	{0x000004EC, 0x00000000, 0, 0},
+	{0x000004F0, 0x00100000, 0, 0},
+	{0x000004F4, 0x00000000, 0, 0},
+	{0x000004F8, 0x03D20000, 0, 0},
+	{0x000004FC, 0x00000000, 0, 0},
+	{0x00000500, 0x00950000, 0, 0},
+	{0x00000504, 0x00000000, 0, 0},
+	{0x00000508, 0x00253000, 0, 0},
+	{0x0000050C, 0x00000000, 0, 0},
+	{0x00000510, 0x00000000, 0, 0},
+	{0x00000514, 0x00000000, 0, 0},
+	{0x00000518, 0x00000000, 0, 0},
+	{0x0000051C, 0x00000000, 0, 0},
+	{0x00000520, 0x00000000, 0, 0},
+	{0x00000524, 0x00000000, 0, 0},
+	{0x00000528, 0x00000000, 0, 0},
+	{0x0000052C, 0x00000000, 0, 0},
+	{0x00000530, 0x00000000, 0, 0},
+	{0x00000534, 0x00000000, 0, 0},
+	{0x00000538, 0xFFFFFFF0, 0, 0},
+	{0x0000053C, 0x8FFFFFFF, 0, 0},
+	{0x00000540, 0x0000001E, 0, 0},
+	{0x00000544, 0x00000000, 0, 0},
+	{0x00000548, 0x00000000, 0, 0},
+	{0x0000054C, 0xF0F20000, 0, 0},
+	{0x000005D0, 0xFF00FF00, 0, 0},
+	{0x000005D4, 0xFF00FF00, 0, 0},
+	/* config YHIST(0CC8H~0CD8H) */
+	{0x00000CC8, 0x00000000, 0, 0},
+	{0x00000CCC, 0x0437077F, 0, 0},
+	{0x00000CD0, 0x00010002, 0, 0},
+	{0x00000CD4, 0x00000000, 0, 0},
+	/* config CBAR(0600H-0653H) */
+	{0x00000600, 0x043E0782, 0, 0},
+	{0x00000604, 0x00000000, 0, 0},
+	{0x00000608, 0x0437077F, 0, 0},
+	{0x0000060C, 0x00443150, 0, 0},
+	{0x00000610, 0x00000000, 0, 0},
+	{0x00000614, 0x08880888, 0, 0},
+	{0x00000618, 0x02220222, 0, 0},
+	{0x0000061C, 0x04440444, 0, 0},
+	{0x00000620, 0x08880888, 0, 0},
+	{0x00000624, 0x0AAA0AAA, 0, 0},
+	{0x00000628, 0x0CCC0CCC, 0, 0},
+	{0x0000062C, 0x0EEE0EEE, 0, 0},
+	{0x00000630, 0x0FFF0FFF, 0, 0},
+	{0x00000634, 0x08880888, 0, 0},
+	{0x00000638, 0x02220222, 0, 0},
+	{0x0000063C, 0x04440444, 0, 0},
+	{0x00000640, 0x08880888, 0, 0},
+	{0x00000644, 0x0AAA0AAA, 0, 0},
+	{0x00000648, 0x0CCC0CCC, 0, 0},
+	{0x0000064C, 0x0EEE0EEE, 0, 0},
+	{0x00000650, 0x0FFF0FFF, 0, 0},
+	/* config sensor(0014H) */
+	{0x00000014, 0x0000000c, 0, 0},
+	/* config CROP(001CH, 0020H) */
+	{0x0000001C, 0x00000000, 0, 0},
+	{0x00000020, 0x0437077F, 0, 0},
+	/* config isp pileline X/Y size(A0CH) */
+	{0x00000A0C, 0x04380780, 0, 0},
+	/* config CSI dump (24H/28H) */
+	{0x00000028, 0x00030B80, 0, 0},
+	/* Video Output */
+	/* config UO(0A80H~0A90H) */
+	{0x00000A88, 0x00000780, 0, 0},
+	/* NV12 */
+	{0x00000A8C, 0x00000000, 0, 0},
+	/* NV21
+	 *{0x00000A8C, 0x00000020, 0, 0},
+	 */
+	{0x00000A90, 0x00000000, 0, 0},
+	{0x00000A9C, 0x00000780, 0, 0},
+	{0x00000AA0, 0x00000002, 0, 0},
+	{0x00000AA4, 0x00000002, 0, 0},
+	{0x00000AA8, 0x07800438, 0, 0},
+	{0x00000AB4, 0x00000780, 0, 0},
+	{0x00000AB8, 0x00000002, 0, 0},
+	{0x00000ABC, 0x00000002, 0, 0},
+	{0x00000AC0, 0x07800438, 0, 0},
+	{0x00000AC4, 0x00000000, 0, 0},
+	/* config TIL(0B20H~0B48H) */
+	{0x00000B20, 0x04380780, 0, 0},
+	{0x00000B24, 0x00000960, 0, 0},
+	{0x00000B38, 0x00030003, 0, 0},
+	{0x00000B3C, 0x00000960, 0, 0},
+	{0x00000B44, 0x00000000, 0, 0},
+	{0x00000B48, 0x00000000, 0, 0},
+	/* Enable DEC/OBC/OECF/LCCF/AWB/SC/DUMP */
+	{0x00000010, 0x000A00D6, 0x00000000, 0x00},
+	/* Enable CFA/CAR/CCM/GMARGB/R2Y/SHRP/SAT/DNYUV/YCRV/YHIST/CTC/DBC */
+	{0x00000A08, 0x107A01BE, 0x00000000, 0x00},
+};
+
+const struct reg_table isp_reg_init_settings[] = {
+	{isp_reg_init_config_list,
+	ARRAY_SIZE(isp_reg_init_config_list)},
+};
+
+static struct regval_t isp_reg_start_config_list[] = {
+#if defined(ENABLE_SS0_SS1)
+	/* ENABLE UO/SS0/SS1/Multi-Frame and Reset ISP */
+	{0x00000A00, 0x00121802, 0x00000000, 0x0A},
+	/* ENABLE UO/SS0/SS1/Multi-Frame and Leave ISP reset */
+	{0x00000A00, 0x00121800, 0x00000000, 0x0A},
+#else
+	/* ENABLE UO/Multi-Frame and Reset ISP */
+	{0x00000A00, 0x00120002, 0x00000000, 0x0A},
+	/* ENABLE UO/Multi-Frame and Leave ISP reset */
+	{0x00000A00, 0x00120000, 0x00000000, 0x0A},
+#endif
+	/* Config ISP shadow mode as next-vsync */
+	{0x00000A50, 0x00000002, 0x00000000, 0x00},
+#if defined(ENABLE_SS0_SS1)
+	/* ENABLE UO/SS0/SS1/Multi-Frame and Enable ISP */
+	{0x00000A00, 0x00121801, 0x00000000, 0x0A},
+#else
+	/* ENABLE UO/Multi-Frame and Enable ISP */
+	{0x00000A00, 0x00120001, 0x00000000, 0x0A},
+#endif
+	/* Config CSI shadow mode as immediate to fetch current setting */
+	{0x00000008, 0x00010004, 0x00000000, 0x0A},
+	/* Config CSI shadow mode as next-vsync */
+	{0x00000008, 0x00020004, 0x00000000, 0x00},
+	/* Enable CSI */
+	{0x00000000, 0x00000001, 0x00000000, 0x0A},
+};
+
+const struct reg_table isp_reg_start_settings[] = {
+	{isp_reg_start_config_list,
+	ARRAY_SIZE(isp_reg_start_config_list)},
+};
+
+static struct regval_t isp_imx_219_reg_config_list[] = {
+	/* MIPI sensor */
+	{0x00000014, 0x0000000D, 0, 0},
+	/* config CFA(0018H, 0A1CH) */
+	{0x00000A1C, 0x00000032, 0, 0},
+	{0x00000A8C, 0x00000000, 0, 0},
+	{0x00000A90, 0x00000000, 0, 0},
+	/* config R2Y(0E40H~0E60H) */
+	{0x00000E40, 0x0000004C, 0, 0},
+	{0x00000E44, 0x00000097, 0, 0},
+	{0x00000E48, 0x0000001D, 0, 0},
+	{0x00000E4C, 0x000001D5, 0, 0},
+	{0x00000E50, 0x000001AC, 0, 0},
+	{0x00000E54, 0x00000080, 0, 0},
+	{0x00000E58, 0x00000080, 0, 0},
+	{0x00000E5C, 0x00000194, 0, 0},
+	{0x00000E60, 0x000001EC, 0, 0},
+	/* Config AWB(0280H~02DCH). Fixed WB gain for IMX-219 sensor. */
+	{0x00000280, 0x00000000, 0, 0},
+	{0x00000284, 0x00000000, 0, 0},
+	{0x00000288, 0x00000000, 0, 0},
+	{0x0000028C, 0x00000000, 0, 0},
+	{0x00000290, 0x00000000, 0, 0},
+	{0x00000294, 0x00000000, 0, 0},
+	{0x00000298, 0x00000000, 0, 0},
+	{0x0000029C, 0x00000000, 0, 0},
+	{0x000002A0, 0x00000000, 0, 0},
+	{0x000002A4, 0x00000000, 0, 0},
+	{0x000002A8, 0x00000000, 0, 0},
+	{0x000002AC, 0x00000000, 0, 0},
+	{0x000002B0, 0x00000000, 0, 0},
+	{0x000002B4, 0x00000000, 0, 0},
+	{0x000002B8, 0x00000000, 0, 0},
+	{0x000002BC, 0x00000000, 0, 0},
+	{0x000002C0, 0x00F000F0, 0, 0},
+	{0x000002C4, 0x00F000F0, 0, 0},
+	{0x000002C8, 0x00800080, 0, 0},
+	{0x000002CC, 0x00800080, 0, 0},
+	{0x000002D0, 0x00800080, 0, 0},
+	{0x000002D4, 0x00800080, 0, 0},
+	{0x000002D8, 0x00B000B0, 0, 0},
+	{0x000002DC, 0x00B000B0, 0, 0},
+	/* config GMARGB(0E00H~0E38H)
+	 * Gamma RGB 1.9 for IMX-219 sensor
+	 */
+	{0x00000E00, 0x24000000, 0, 0},
+	{0x00000E04, 0x159500A5, 0, 0},
+	{0x00000E08, 0x0F9900EE, 0, 0},
+	{0x00000E0C, 0x0CE40127, 0, 0},
+	{0x00000E10, 0x0B410157, 0, 0},
+	{0x00000E14, 0x0A210181, 0, 0},
+	{0x00000E18, 0x094B01A8, 0, 0},
+	{0x00000E1C, 0x08A401CC, 0, 0},
+	{0x00000E20, 0x081D01EE, 0, 0},
+	{0x00000E24, 0x06B20263, 0, 0},
+	{0x00000E28, 0x05D802C7, 0, 0},
+	{0x00000E2C, 0x05420320, 0, 0},
+	{0x00000E30, 0x04D30370, 0, 0},
+	{0x00000E34, 0x047C03BB, 0, 0},
+	{0x00000E38, 0x043703FF, 0, 0},
+	{0x00000010, 0x00000080, 0, 0},
+	/* Enable CFA/GMARGB/R2Y */
+	{0x00000A08, 0x10000032, 0x0FFFFFFF, 0x00},
+	{0x00000A00, 0x00120002, 0, 0},
+	{0x00000A00, 0x00120000, 0, 0},
+	{0x00000A50, 0x00000002, 0, 0},
+	{0x00000008, 0x00010000, 0, 0},
+	{0x00000008, 0x0002000A, 0, 0},
+	{0x00000000, 0x00000001, 0, 0},
+};
+
+const struct reg_table isp_imx_219_settings[] = {
+	{isp_imx_219_reg_config_list,
+	ARRAY_SIZE(isp_imx_219_reg_config_list)},
+};
+
+static struct regval_t isp_format_reg_list[] = {
+	{0x0000001C, 0x00000000, 0x00000000, 0},
+	{0x00000020, 0x0437077F, 0x00000000, 0},
+	{0x00000A0C, 0x04380780, 0x00000000, 0},
+	{0x00000A88, 0x00000780, 0x00000000, 0},
+	{0x00000018, 0x000011BB, 0x00000000, 0},
+	{0x00000A08, 0x10000000, 0xF0000000, 0},
+	{0x00000028, 0x00030B80, 0x0003FFFF, 0},
+	{0x00000AA8, 0x07800438, 0x00000000, 0},
+	{0x00000A9C, 0x00000780, 0x00000000, 0},
+	{0x00000AC0, 0x07800438, 0x00000000, 0},
+	{0x00000AB4, 0x00000780, 0x00000000, 0},
+	{0x00000B20, 0x04380780, 0x00000000, 0},
+	{0x00000B24, 0x00000960, 0x00000000, 0},
+	{0x00000B3C, 0x00000960, 0x00000000, 0},
+	{0x00000014, 0x00000008, 0x00000000, 0},
+};
+
+const struct reg_table  isp_format_settings[] = {
+	{isp_format_reg_list,
+	ARRAY_SIZE(isp_format_reg_list)},
+};
+
+#if defined(USE_NEW_CONFIG_SETTING)
+#else
+static struct reg_table  *isp_settings = (struct reg_table *)isp_imx_219_settings;
+#endif
+
+static void isp_load_regs(void __iomem *ispbase, const struct reg_table *table)
+{
+	int j;
+	u32 delay_ms, reg_addr, mask, val;
+
+	for (j = 0; j < table->regval_num; j++) {
+		delay_ms = table->regval[j].delay_ms;
+		reg_addr = table->regval[j].addr;
+		val = table->regval[j].val;
+		mask = table->regval[j].mask;
+
+		if (reg_addr % 4
+			|| reg_addr > STF_ISP_REG_OFFSET_MAX
+			|| delay_ms > STF_ISP_REG_DELAY_MAX)
+			continue;
+
+		if (mask)
+			reg_set_bit(ispbase, reg_addr, mask, val);
+		else
+			reg_write(ispbase, reg_addr, val);
+		if (delay_ms)
+			usleep_range(1000 * delay_ms, 1000 * delay_ms + 100);
+	}
+}
+
+static void isp_load_regs_exclude_csi_isp_enable(
+			void __iomem *ispbase,
+			const struct reg_table *table)
+{
+	int j;
+	u32 delay_ms, reg_addr, mask, val;
+
+	for (j = 0; j < table->regval_num; j++) {
+		delay_ms = table->regval[j].delay_ms;
+		reg_addr = table->regval[j].addr;
+		val = table->regval[j].val;
+		mask = table->regval[j].mask;
+
+		if (reg_addr % 4
+			|| reg_addr > STF_ISP_REG_OFFSET_MAX
+			|| delay_ms > STF_ISP_REG_DELAY_MAX
+			|| ((reg_addr == ISP_REG_CSI_INPUT_EN_AND_STATUS) && (val & 0x01))
+			|| ((reg_addr == ISP_REG_ISP_CTRL_0) && (val & 0x01)))
+			continue;
+
+		if (mask)
+			reg_set_bit(ispbase, reg_addr, mask, val);
+		else
+			reg_write(ispbase, reg_addr, val);
+		if (delay_ms)
+			usleep_range(1000 * delay_ms, 1000 * delay_ms + 100);
+	}
+}
+
+static int stf_isp_clk_enable(struct stf_isp_dev *isp_dev)
+{
+	struct stfcamss *stfcamss = isp_dev->stfcamss;
+
+	clk_prepare_enable(stfcamss->sys_clk[STFCLK_WRAPPER_CLK_C].clk);
+	reset_control_deassert(stfcamss->sys_rst[STFRST_WRAPPER_C].rstc);
+	reset_control_deassert(stfcamss->sys_rst[STFRST_WRAPPER_P].rstc);
+
+	return 0;
+}
+
+static int stf_isp_clk_disable(struct stf_isp_dev *isp_dev)
+{
+	struct stfcamss *stfcamss = isp_dev->stfcamss;
+
+	reset_control_assert(stfcamss->sys_rst[STFRST_WRAPPER_C].rstc);
+	reset_control_assert(stfcamss->sys_rst[STFRST_WRAPPER_P].rstc);
+	clk_disable_unprepare(stfcamss->sys_clk[STFCLK_WRAPPER_CLK_C].clk);
+
+	return 0;
+}
+
+static  void __iomem *stf_isp_get_ispbase(struct stf_vin_dev *vin)
+{
+	void __iomem *base = vin->isp_base;
+
+	return base;
+}
+
+static int stf_isp_save_ctx_regs(struct stf_isp_dev *isp_dev)
+{
+	int j;
+	u32 addr, val;
+	void __iomem *ispbase;
+	struct device *dev = isp_dev->stfcamss->dev;
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	if (!isp_dev->context_regs) {
+		int regs_size =
+			sizeof(struct regval_t) * isp_reg_init_settings->regval_num;
+		isp_dev->context_regs =
+			devm_kzalloc(dev, sizeof(struct reg_table), GFP_KERNEL);
+		isp_dev->context_regs->regval =
+			devm_kzalloc(dev, regs_size, GFP_KERNEL);
+		isp_dev->context_regs->regval_num = isp_reg_init_settings->regval_num;
+	}
+
+	if (!isp_dev->context_regs || !isp_dev->context_regs->regval)
+		return -ENOMEM;
+
+	st_debug(ST_ISP, "Saving ISP context registers\n");
+	for (j = 0; j < isp_reg_init_settings->regval_num; j++) {
+		addr = isp_reg_init_settings->regval[j].addr;
+		val = ioread32(ispbase + addr);
+		isp_dev->context_regs->regval[j].addr = addr;
+		isp_dev->context_regs->regval[j].val = val;
+	}
+	st_debug(ST_ISP, "ISP context registers have been saved\n");
+
+	return 0;
+};
+
+static int stf_isp_restore_ctx_regs(struct stf_isp_dev *isp_dev)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+	void __iomem *ispbase;
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	if (isp_dev->context_regs) {
+		isp_load_regs(ispbase, isp_dev->context_regs);
+		st_debug(ST_ISP, "Restored ISP register: isp_reg_init_settings.\n");
+	}
+
+	return 0;
+}
+
+static int stf_isp_reset(struct stf_isp_dev *isp_dev)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+	void __iomem *ispbase;
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	reg_set_bit(ispbase, ISP_REG_ISP_CTRL_0, BIT(1), BIT(1));
+	reg_set_bit(ispbase, ISP_REG_ISP_CTRL_0, BIT(1), 0);
+
+	return 0;
+}
+
+static int stf_isp_config_set(struct stf_isp_dev *isp_dev)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+	void __iomem *ispbase;
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	st_debug(ST_ISP, "%s\n", __func__);
+
+#if defined(USE_NEW_CONFIG_SETTING)
+	mutex_lock(&isp_dev->setfile_lock);
+
+	if (isp_dev->context_regs) {
+		stf_isp_restore_ctx_regs(isp_dev);
+		st_debug(ST_ISP, "%s context regs restore done\n", __func__);
+	} else {
+		isp_load_regs(ispbase, isp_reg_init_settings);
+		st_debug(ST_ISP, "%s isp_reg_init_settings done\n", __func__);
+	}
+	if (isp_dev->setfile.state) {
+		st_info(ST_ISP, "%s, Program extra ISP setting!\n", __func__);
+		isp_load_regs_exclude_csi_isp_enable(ispbase,
+			&isp_dev->setfile.settings);
+	}
+
+	mutex_unlock(&isp_dev->setfile_lock);
+#else
+	mutex_lock(&isp_dev->setfile_lock);
+	if (isp_dev->setfile.state)
+		isp_load_regs(ispbase, &isp_dev->setfile.settings);
+	else
+		isp_load_regs(ispbase, isp_settings);
+	mutex_unlock(&isp_dev->setfile_lock);
+
+	st_debug(ST_ISP, "config 0x%x = 0x%x\n",
+			isp_format_reg_list[0].addr,
+			isp_format_reg_list[0].val);
+	st_debug(ST_ISP, "config 0x%x = 0x%x\n",
+			isp_format_reg_list[1].addr,
+			isp_format_reg_list[1].val);
+	st_debug(ST_ISP, "config 0x%x = 0x%x\n",
+			isp_format_reg_list[2].addr,
+			isp_format_reg_list[2].val);
+	st_debug(ST_ISP, "config 0x%x = 0x%x\n",
+			isp_format_reg_list[3].addr,
+			isp_format_reg_list[3].val);
+#endif
+
+	return 0;
+}
+
+static int stf_isp_set_format(struct stf_isp_dev *isp_dev,
+		struct isp_stream_format *crop_array, u32 mcode,
+		int type)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+	struct stf_dvp_dev *dvp_dev = isp_dev->stfcamss->dvp_dev;
+	struct v4l2_rect *crop = &crop_array[ISP_COMPOSE].rect;
+	u32 bpp = crop_array[ISP_COMPOSE].bpp;
+	void __iomem *ispbase;
+	u32 val, val1;
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	st_debug(ST_ISP, "interface type is %d(%s)\n",
+			type, type == CSI_SENSOR ? "CSI" : "DVP");
+
+	if (type == DVP_SENSOR) {
+		unsigned int flags = dvp_dev->dvp->flags;
+
+		st_debug(ST_ISP, "dvp flags = 0x%x, hsync active is %s, vsync active is %s\n",
+			flags, flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH ? "high" : "low",
+			flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH ? "high" : "low");
+	}
+
+	val = crop->left + (crop->top << 16);
+	isp_format_reg_list[0].addr = ISP_REG_PIC_CAPTURE_START_CFG;
+	isp_format_reg_list[0].val = val;
+
+	val = (crop->width + crop->left - 1)
+		+ ((crop->height + crop->top - 1) << 16);
+	isp_format_reg_list[1].addr = ISP_REG_PIC_CAPTURE_END_CFG;
+	isp_format_reg_list[1].val = val;
+
+	val = crop->width + (crop->height << 16);
+	isp_format_reg_list[2].addr = ISP_REG_PIPELINE_XY_SIZE;
+	isp_format_reg_list[2].val = val;
+
+	isp_format_reg_list[3].addr = ISP_REG_STRIDE;
+	isp_format_reg_list[3].val = ALIGN(crop->width * bpp / 8, STFCAMSS_FRAME_WIDTH_ALIGN_8);
+
+	switch (mcode) {
+	case MEDIA_BUS_FMT_SRGGB10_1X10:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
+		// 3 2 3 2 1 0 1 0 B Gb B Gb Gr R Gr R
+		val = 0x0000EE44;
+		val1 = 0x00000000;
+		break;
+	case MEDIA_BUS_FMT_SGRBG10_1X10:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
+		// 2 3 2 3 0 1 0 1, Gb B Gb B R Gr R Gr
+		val = 0x0000BB11;
+		val1 = 0x20000000;
+		break;
+	case MEDIA_BUS_FMT_SGBRG10_1X10:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
+		// 1 0 1 0 3 2 3 2, Gr R Gr R B Gb B Gb
+		val = 0x000044EE;
+		val1 = 0x30000000;
+		break;
+	case MEDIA_BUS_FMT_SBGGR10_1X10:
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
+		// 0 1 0 1 2 3 2 3 R Gr R Gr Gb B Gb B
+		val = 0x000011BB;
+		val1 = 0x10000000;
+		break;
+	default:
+		st_err(ST_ISP, "UNKNOW format\n");
+		val = 0x000011BB;
+		val1 = 0x10000000;
+		break;
+	}
+
+	isp_format_reg_list[4].addr = ISP_REG_RAW_FORMAT_CFG;
+	isp_format_reg_list[4].val = val;
+
+	isp_format_reg_list[5].addr = ISP_REG_ISP_CTRL_1;
+	isp_format_reg_list[5].val = val1;
+	isp_format_reg_list[5].mask = 0xF0000000;
+
+	st_info(ST_ISP, "src left: %d, top: %d, width = %d, height = %d, bpp = %d\n",
+		crop->left, crop->top, crop->width, crop->height, bpp);
+
+	crop = &crop_array[ISP_CROP].rect;
+	bpp = crop_array[ISP_CROP].bpp;
+	val = ALIGN(crop->width * bpp / 8, STFCAMSS_FRAME_WIDTH_ALIGN_128);
+	isp_format_reg_list[6].addr = ISP_REG_DUMP_CFG_1;
+	isp_format_reg_list[6].val = val | 3 << 16;
+	isp_format_reg_list[6].mask = 0x0003FFFF;
+
+	st_info(ST_ISP, "raw left: %d, top: %d, width = %d, height = %d, bpp = %d\n",
+		crop->left, crop->top, crop->width, crop->height, bpp);
+
+	crop = &crop_array[ISP_SCALE_SS0].rect;
+	bpp = crop_array[ISP_SCALE_SS0].bpp;
+	isp_format_reg_list[7].addr = ISP_REG_SS0IW;
+	isp_format_reg_list[7].val = (crop->width << 16) + crop->height;
+	isp_format_reg_list[8].addr = ISP_REG_SS0S;
+	isp_format_reg_list[8].val = ALIGN(crop->width * bpp / 8, STFCAMSS_FRAME_WIDTH_ALIGN_8);
+
+	st_info(ST_ISP, "ss0 left: %d, top: %d, width = %d, height = %d, bpp = %d\n",
+		crop->left, crop->top, crop->width, crop->height, bpp);
+
+	crop = &crop_array[ISP_SCALE_SS1].rect;
+	bpp = crop_array[ISP_SCALE_SS1].bpp;
+	isp_format_reg_list[9].addr = ISP_REG_SS1IW;
+	isp_format_reg_list[9].val = (crop->width << 16) + crop->height;
+	isp_format_reg_list[10].addr = ISP_REG_SS1S;
+	isp_format_reg_list[10].val = ALIGN(crop->width * bpp / 8, STFCAMSS_FRAME_WIDTH_ALIGN_8);
+
+	crop = &crop_array[ISP_ITIWS].rect;
+	bpp = crop_array[ISP_ITIWS].bpp;
+	isp_format_reg_list[11].addr = ISP_REG_ITIIWSR;
+	isp_format_reg_list[11].val = (crop->height << 16) + crop->width;
+	isp_format_reg_list[12].addr = ISP_REG_ITIDWLSR;
+	isp_format_reg_list[12].val = ALIGN(crop->width * bpp / 8, STFCAMSS_FRAME_WIDTH_ALIGN_8);
+	isp_format_reg_list[13].addr = ISP_REG_ITIDRLSR;
+	isp_format_reg_list[13].val = ALIGN(crop->width * bpp / 8, STFCAMSS_FRAME_WIDTH_ALIGN_8);
+
+	st_info(ST_ISP, "iti left: %d, top: %d, width = %d, height = %d, bpp = %d\n",
+		crop->left, crop->top, crop->width, crop->height, bpp);
+
+	isp_format_reg_list[14].addr = ISP_REG_SENSOR;
+	isp_format_reg_list[14].val = 0x00000000;
+	if (type == DVP_SENSOR) {
+		unsigned int flags = dvp_dev->dvp->flags;
+
+		if (flags & V4L2_MBUS_HSYNC_ACTIVE_HIGH)
+			isp_format_reg_list[14].val |= 0x08;
+		if (flags & V4L2_MBUS_VSYNC_ACTIVE_HIGH)
+			isp_format_reg_list[14].val |= 0x04;
+	} else {
+		isp_format_reg_list[14].val |= 0x01;
+	}
+
+	isp_load_regs(ispbase, isp_format_settings);
+	return 0;
+}
+
+static int stf_isp_stream_set(struct stf_isp_dev *isp_dev, int on)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+
+	void __iomem *ispbase;
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	if (on) {
+#if defined(USE_NEW_CONFIG_SETTING)
+		isp_load_regs(ispbase, isp_reg_start_settings);
+#else
+		reg_set_bit(ispbase, ISP_REG_CSIINTS_ADDR, 0x3FFFF, 0x3000a);
+		reg_set_bit(ispbase, ISP_REG_IESHD_ADDR, BIT(1) | BIT(0), 0x3);
+		reg_set_bit(ispbase, ISP_REG_ISP_CTRL_0, BIT(0), 1);
+#endif //#if defined(USE_NEW_CONFIG_SETTING)
+	} else {
+		/* NOTE: Clear bit 0 of ISP_REG_ISP_CTRL_0 here will get crash. */
+		stf_isp_save_ctx_regs(isp_dev);
+	}
+
+	return 0;
+}
+
+static union reg_buf reg_buf;
+static int stf_isp_reg_read(struct stf_isp_dev *isp_dev, void *arg)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+	void __iomem *ispbase;
+	struct isp_reg_param *reg_param = arg;
+	u32 size;
+	unsigned long r;
+
+	if (reg_param->reg_buf == NULL) {
+		st_err(ST_ISP, "Failed to access register. The pointer is NULL!!!\n");
+		return -EINVAL;
+	}
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	size = 0;
+	switch (reg_param->reg_info.method) {
+	case STF_ISP_REG_METHOD_ONE_REG:
+		break;
+
+	case STF_ISP_REG_METHOD_SERIES:
+		if (reg_param->reg_info.length > STF_ISP_REG_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_BUF_SIZE);
+			return -EINVAL;
+		}
+		break;
+
+	case STF_ISP_REG_METHOD_MODULE:
+		/* This mode is not supported in the V4L2 version. */
+		st_err(ST_ISP, "Reg Read - Failed to access register. The method = \
+			STF_ISP_REG_METHOD_MODULE is not supported!!!\n");
+		return -ENOTTY;
+
+	case STF_ISP_REG_METHOD_TABLE:
+		if (reg_param->reg_info.length > STF_ISP_REG_TBL_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_TBL_BUF_SIZE);
+			return -EINVAL;
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 2;
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE_2:
+		if (reg_param->reg_info.length > STF_ISP_REG_TBL_2_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_TBL_2_BUF_SIZE);
+			return -EINVAL;
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 3;
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE_3:
+		if (reg_param->reg_info.length > STF_ISP_REG_TBL_3_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_TBL_3_BUF_SIZE);
+			return -EINVAL;
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 4;
+		break;
+
+	case STF_ISP_REG_METHOD_SMPL_PACK:
+		st_err(ST_ISP, "Reg Read - Failed to access register. The method = \
+			STF_ISP_REG_METHOD_SMPL_PACK is not supported!!!\n");
+		return -ENOTTY;
+
+	case STF_ISP_REG_METHOD_SOFT_RDMA:
+		// This mode is not supported in the V4L2 version.
+		st_err(ST_ISP, "Reg Read - Failed to access register. The method = \
+			STF_ISP_REG_METHOD_SOFT_RDMA is not supported!!!\n");
+		return -ENOTTY;
+
+	default:
+		st_err(ST_ISP, "Failed to access register. The method=%d \
+			is not supported!!!\n", reg_param->reg_info.method);
+		return -ENOTTY;
+	}
+
+	memset(&reg_buf, 0, sizeof(union reg_buf));
+	if (size) {
+		r = copy_from_user((u8 *)reg_buf.buffer,
+			(u8 *)reg_param->reg_buf->buffer, size);
+		if (r) {
+			st_err(ST_ISP, "Failed to call copy_from_user for the \
+				reg_param->reg_buf value\n");
+			return -EIO;
+		}
+	}
+
+	size = 0;
+	switch (reg_param->reg_info.method) {
+	case STF_ISP_REG_METHOD_ONE_REG:
+		reg_buf.buffer[0] = reg_read(ispbase, reg_param->reg_info.offset);
+		size = sizeof(u32);
+		break;
+
+	case STF_ISP_REG_METHOD_SERIES:
+		for (r = 0; r < reg_param->reg_info.length; r++) {
+			reg_buf.buffer[r] = reg_read(ispbase,
+				reg_param->reg_info.offset + (r * 4));
+		}
+		size = sizeof(u32) * reg_param->reg_info.length;
+		break;
+
+	case STF_ISP_REG_METHOD_MODULE:
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE:
+		for (r = 0; r < reg_param->reg_info.length; r++) {
+			reg_buf.reg_tbl[r].value = reg_read(ispbase,
+				reg_buf.reg_tbl[r].offset);
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 2;
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE_2:
+		for (r = 0; r < reg_param->reg_info.length; r++) {
+			if (reg_buf.reg_tbl2[r].mask) {
+				reg_buf.reg_tbl2[r].value = (reg_read(ispbase,
+					reg_buf.reg_tbl2[r].offset)
+						& reg_buf.reg_tbl2[r].mask);
+			} else {
+				reg_buf.reg_tbl2[r].value = reg_read(ispbase,
+					reg_buf.reg_tbl2[r].offset);
+			}
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 3;
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE_3:
+		for (r = 0; r < reg_param->reg_info.length; r++) {
+			if (reg_buf.reg_tbl3[r].mask) {
+				reg_buf.reg_tbl3[r].value = (reg_read(ispbase,
+					reg_buf.reg_tbl3[r].offset)
+						& reg_buf.reg_tbl3[r].mask);
+			} else {
+				reg_buf.reg_tbl3[r].value = reg_read(ispbase,
+					reg_buf.reg_tbl3[r].offset);
+			}
+			if (reg_buf.reg_tbl3[r].delay_ms) {
+				usleep_range(1000 * reg_buf.reg_tbl3[r].delay_ms,
+					1000 * reg_buf.reg_tbl3[r].delay_ms + 100);
+			}
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 4;
+		break;
+
+	case STF_ISP_REG_METHOD_SMPL_PACK:
+		break;
+
+	case STF_ISP_REG_METHOD_SOFT_RDMA:
+		break;
+
+	default:
+		break;
+	}
+
+	r = copy_to_user((u8 *)reg_param->reg_buf->buffer, (u8 *)reg_buf.buffer,
+		size);
+	if (r) {
+		st_err(ST_ISP, "Failed to call copy_to_user for the \
+			reg_param->buffer value\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int stf_isp_soft_rdma(struct stf_isp_dev *isp_dev, u32 rdma_addr)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+	void __iomem *ispbase;
+	struct isp_rdma_info *rdma_info = NULL;
+	s32 len;
+	u32 offset;
+	int ret = 0;
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	rdma_info = phys_to_virt(rdma_addr);
+	while (1) {
+		if (rdma_info->tag == RDMA_WR_ONE) {
+			reg_write(ispbase, rdma_info->offset, rdma_info->param);
+			rdma_info++;
+		} else if (rdma_info->tag == RDMA_WR_SRL) {
+			offset = rdma_info->offset;
+			len = rdma_info->param;
+			rdma_info++;
+			while (len > 0) {
+				reg_write(ispbase, offset, rdma_info->param);
+				offset += 4;
+				len--;
+				if (len > 0) {
+					reg_write(ispbase, offset, rdma_info->value);
+					len--;
+				}
+				offset += 4;
+				rdma_info++;
+			}
+		} else if (rdma_info->tag == RDMA_LINK) {
+			rdma_info = phys_to_virt(rdma_info->param);
+		} else if (rdma_info->tag == RDMA_SINT) {
+			/* Software not support this command. */
+			rdma_info++;
+		} else if (rdma_info->tag == RDMA_END) {
+			break;
+		} else
+			rdma_info++;
+	}
+
+	return ret;
+}
+
+static int stf_isp_reg_write(struct stf_isp_dev *isp_dev, void *arg)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+	void __iomem *ispbase;
+	struct isp_reg_param *reg_param = arg;
+	struct isp_rdma_info *rdma_info = NULL;
+	s32 len;
+	u32 offset;
+	u32 size;
+	unsigned long r;
+	int ret = 0;
+
+	if ((reg_param->reg_buf == NULL)
+		&& (reg_param->reg_info.method != STF_ISP_REG_METHOD_SOFT_RDMA)) {
+		st_err(ST_ISP, "Failed to access register. \
+			The register buffer pointer is NULL!!!\n");
+		return -EINVAL;
+	}
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	size = 0;
+	switch (reg_param->reg_info.method) {
+	case STF_ISP_REG_METHOD_ONE_REG:
+		size = sizeof(u32);
+		break;
+
+	case STF_ISP_REG_METHOD_SERIES:
+		if (reg_param->reg_info.length > STF_ISP_REG_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_BUF_SIZE);
+			return -EINVAL;
+		}
+		size = sizeof(u32) * reg_param->reg_info.length;
+		break;
+
+	case STF_ISP_REG_METHOD_MODULE:
+		// This mode is not supported in the V4L2 version.
+		st_err(ST_ISP, "Reg Write - Failed to access register. \
+			The method = STF_ISP_REG_METHOD_MODULE is not supported!!!\n");
+		return -ENOTTY;
+
+	case STF_ISP_REG_METHOD_TABLE:
+		if (reg_param->reg_info.length > STF_ISP_REG_TBL_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_TBL_BUF_SIZE);
+			return -EINVAL;
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 2;
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE_2:
+		if (reg_param->reg_info.length > STF_ISP_REG_TBL_2_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_TBL_2_BUF_SIZE);
+			return -EINVAL;
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 3;
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE_3:
+		if (reg_param->reg_info.length > STF_ISP_REG_TBL_3_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_TBL_3_BUF_SIZE);
+			return -EINVAL;
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 4;
+		break;
+
+	case STF_ISP_REG_METHOD_SMPL_PACK:
+		if (reg_param->reg_info.length > STF_ISP_REG_SMPL_PACK_BUF_SIZE) {
+			st_err(ST_ISP, "Failed to access register. \
+				The (length=0x%08X > 0x%08X) is out of size!!!\n",
+				reg_param->reg_info.length, STF_ISP_REG_SMPL_PACK_BUF_SIZE);
+			return -EINVAL;
+		}
+		size = sizeof(u32) * reg_param->reg_info.length * 2;
+		break;
+
+	case STF_ISP_REG_METHOD_SOFT_RDMA:
+		break;
+
+	default:
+		st_err(ST_ISP, "Failed to access register. The method=%d \
+			is not supported!!!\n", reg_param->reg_info.method);
+		return -ENOTTY;
+	}
+
+	memset(&reg_buf, 0, sizeof(union reg_buf));
+	if (size) {
+		r = copy_from_user((u8 *)reg_buf.buffer,
+			(u8 *)reg_param->reg_buf->buffer, size);
+		if (r) {
+			st_err(ST_ISP, "Failed to call copy_from_user for the \
+				reg_param->reg_buf value\n");
+			return -EIO;
+		}
+	}
+
+	switch (reg_param->reg_info.method) {
+	case STF_ISP_REG_METHOD_ONE_REG:
+		reg_write(ispbase, reg_param->reg_info.offset, reg_buf.buffer[0]);
+		break;
+
+	case STF_ISP_REG_METHOD_SERIES:
+		for (r = 0; r < reg_param->reg_info.length; r++) {
+			reg_write(ispbase, reg_param->reg_info.offset + (r * 4),
+				reg_buf.buffer[r]);
+		}
+		break;
+
+	case STF_ISP_REG_METHOD_MODULE:
+		/* This mode is not supported in the V4L2 version. */
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE:
+		for (r = 0; r < reg_param->reg_info.length; r++) {
+			reg_write(ispbase, reg_buf.reg_tbl[r].offset,
+				reg_buf.reg_tbl[r].value);
+		}
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE_2:
+		for (r = 0; r < reg_param->reg_info.length; r++) {
+			if (reg_buf.reg_tbl2[r].mask) {
+				reg_set_bit(ispbase, reg_buf.reg_tbl2[r].offset,
+					reg_buf.reg_tbl2[r].mask, reg_buf.reg_tbl2[r].value);
+			} else {
+				reg_write(ispbase, reg_buf.reg_tbl2[r].offset,
+					reg_buf.reg_tbl2[r].value);
+			}
+		}
+		break;
+
+	case STF_ISP_REG_METHOD_TABLE_3:
+		for (r = 0; r < reg_param->reg_info.length; r++) {
+			if (reg_buf.reg_tbl3[r].mask) {
+				reg_set_bit(ispbase, reg_buf.reg_tbl3[r].offset,
+					reg_buf.reg_tbl3[r].mask, reg_buf.reg_tbl3[r].value);
+			} else {
+				reg_write(ispbase, reg_buf.reg_tbl3[r].offset,
+					reg_buf.reg_tbl3[r].value);
+			}
+			if (reg_buf.reg_tbl3[r].delay_ms) {
+				usleep_range(1000 * reg_buf.reg_tbl3[r].delay_ms,
+					1000 * reg_buf.reg_tbl3[r].delay_ms + 100);
+			}
+		}
+		break;
+
+	case STF_ISP_REG_METHOD_SMPL_PACK:
+		size = reg_param->reg_info.length;
+		rdma_info = &reg_buf.rdma_cmd[0];
+		while (size) {
+			if (rdma_info->tag == RDMA_WR_ONE) {
+				reg_write(ispbase, rdma_info->offset, rdma_info->param);
+				rdma_info++;
+				size--;
+			} else if (rdma_info->tag == RDMA_WR_SRL) {
+				offset = rdma_info->offset;
+				len = rdma_info->param;
+				rdma_info++;
+				size--;
+				while (size && (len > 0)) {
+					reg_write(ispbase, offset, rdma_info->param);
+					offset += 4;
+					len--;
+					if (len > 0) {
+						reg_write(ispbase, offset, rdma_info->value);
+						len--;
+					}
+					offset += 4;
+					rdma_info++;
+					size--;
+				}
+			} else if (rdma_info->tag == RDMA_END) {
+				break;
+			} else {
+				rdma_info++;
+				size--;
+			}
+		}
+		break;
+
+	case STF_ISP_REG_METHOD_SOFT_RDMA:
+		/*
+		 * Simulation the hardware RDMA behavior to debug and verify
+		 * the RDMA chain.
+		 */
+		ret = stf_isp_soft_rdma(isp_dev, reg_param->reg_info.offset);
+		break;
+
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int stf_isp_shadow_trigger(struct stf_isp_dev *isp_dev)
+{
+	struct stf_vin_dev *vin = isp_dev->stfcamss->vin;
+	void __iomem *ispbase;
+
+	ispbase = stf_isp_get_ispbase(vin);
+
+	// shadow update
+	reg_set_bit(ispbase, ISP_REG_CSIINTS_ADDR, (BIT(17) | BIT(16)), 0x30000);
+	reg_set_bit(ispbase, ISP_REG_IESHD_ADDR, (BIT(1) | BIT(0)), 0x3);
+	return 0;
+}
+
+void dump_isp_reg(void *__iomem ispbase)
+{
+	int j;
+	u32 addr, val;
+
+	st_debug(ST_ISP, "DUMP ISP register:\n -- isp_reg_init_settings --\n");
+	for (j = 0; j < isp_reg_init_settings->regval_num; j++) {
+		addr = isp_reg_init_settings->regval[j].addr;
+		val = ioread32(ispbase + addr);
+		st_debug(ST_ISP, "{0x%08x, 0x%08x}\n", addr, val);
+	}
+
+	st_debug(ST_ISP, " --- isp_format_settings ---\n");
+	for (j = 0; j < isp_format_settings->regval_num; j++) {
+		addr = isp_format_settings->regval[j].addr;
+		val = ioread32(ispbase + addr);
+		st_debug(ST_ISP, "{0x%08x, 0x%08x}\n", addr, val);
+	}
+
+	val = ioread32(ispbase + ISP_REG_Y_PLANE_START_ADDR);
+	st_debug(ST_ISP, "-- ISP_REG_Y_PLANE_START_ADDR --\n {0x%08x, 0x%08x}\n",
+		 ISP_REG_Y_PLANE_START_ADDR, val);
+	val = ioread32(ispbase + ISP_REG_UV_PLANE_START_ADDR);
+	st_debug(ST_ISP, "-- ISP_REG_UV_PLANE_START_ADDR --\n {0x%08x, 0x%08x}\n",
+		 ISP_REG_UV_PLANE_START_ADDR, val);
+	val = ioread32(ispbase + ISP_REG_DUMP_CFG_0);
+	st_debug(ST_ISP, "-- ISP_REG_DUMP_CFG_0 --\n {0x%08x, 0x%08x}\n",
+		 ISP_REG_DUMP_CFG_0, val);
+	val = ioread32(ispbase + ISP_REG_DUMP_CFG_1);
+	st_debug(ST_ISP, " --- ISP_REG_DUMP_CFG_1 ---\n {0x%08x, 0x%08x}\n",
+		 ISP_REG_DUMP_CFG_1, val);
+
+	st_debug(ST_ISP, " --- isp_reg_start_settings ---\n");
+	for (j = 0; j < isp_reg_start_settings->regval_num; j++) {
+		addr = isp_reg_start_settings->regval[j].addr;
+		val = ioread32(ispbase + addr);
+		st_debug(ST_ISP, "{0x%08x, 0x%08x}\n", addr, val);
+	}
+}
+
+struct isp_hw_ops isp_ops = {
+	.isp_clk_enable        = stf_isp_clk_enable,
+	.isp_clk_disable       = stf_isp_clk_disable,
+	.isp_reset             = stf_isp_reset,
+	.isp_config_set        = stf_isp_config_set,
+	.isp_set_format        = stf_isp_set_format,
+	.isp_stream_set        = stf_isp_stream_set,
+	.isp_reg_read          = stf_isp_reg_read,
+	.isp_reg_write         = stf_isp_reg_write,
+	.isp_shadow_trigger    = stf_isp_shadow_trigger,
+};
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_isp_ioctl.h b/drivers/media/platform/starfive/v4l2_driver/stf_isp_ioctl.h
new file mode 100644
index 000000000000..5e34b3e9d020
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_isp_ioctl.h
@@ -0,0 +1,131 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_ISP_IOCTL_H
+#define STF_ISP_IOCTL_H
+
+
+#include <media/v4l2-ctrls.h>
+
+
+#define FILENAME_MAX_LEN     30
+
+#define ISP_IOC                         ('V')
+#define STF_ISP_REG_BUF_SIZE            (768)
+#define STF_ISP_REG_TBL_BUF_SIZE        (STF_ISP_REG_BUF_SIZE / 2)
+#define STF_ISP_REG_TBL_2_BUF_SIZE      (STF_ISP_REG_BUF_SIZE / 3)
+#define STF_ISP_REG_TBL_3_BUF_SIZE      (STF_ISP_REG_BUF_SIZE / 4)
+#define STF_ISP_REG_SMPL_PACK_BUF_SIZE  (STF_ISP_REG_BUF_SIZE / 2)
+#define RDMA_WR_ONE                     (0xA0)
+#define RDMA_WR_SRL                     (0xA1)
+#define RDMA_LINK                       (0xA2)
+#define RDMA_SINT                       (0xA3)
+#define RDMA_END                        (0xAF)
+#define ENABLE_SS0_SS1
+
+enum _STF_ISP_IOCTL {
+	STF_ISP_IOCTL_LOAD_FW = BASE_VIDIOC_PRIVATE + 1,
+	STF_ISP_IOCTL_DMABUF_ALLOC,
+	STF_ISP_IOCTL_DMABUF_FREE,
+	STF_ISP_IOCTL_GET_HW_VER,
+	STF_ISP_IOCTL_REG,
+	STF_ISP_IOCTL_SHADOW_LOCK,
+	STF_ISP_IOCTL_SHADOW_UNLOCK,
+	STF_ISP_IOCTL_SHADOW_UNLOCK_N_TRIGGER,
+	STF_ISP_IOCTL_SET_USER_CONFIG_ISP,
+	STF_ISP_IOCTL_MAX
+};
+
+enum _STF_ISP_REG_METHOD {
+	STF_ISP_REG_METHOD_ONE_REG = 0,
+	STF_ISP_REG_METHOD_SERIES,
+	STF_ISP_REG_METHOD_MODULE,
+	STF_ISP_REG_METHOD_TABLE,
+	STF_ISP_REG_METHOD_TABLE_2,
+	STF_ISP_REG_METHOD_TABLE_3,
+	STF_ISP_REG_METHOD_SMPL_PACK,
+	STF_ISP_REG_METHOD_SOFT_RDMA,
+	STF_ISP_REG_METHOD_MAX
+};
+
+
+struct stfisp_fw_info {
+	char __user filename[FILENAME_MAX_LEN];
+};
+
+struct dmabuf_create {
+	__u32 fd;
+	__u32 size;
+	__u32 paddr;
+};
+
+struct isp_rdma_info {
+	u32 param;
+	union {
+		u32 value;
+		struct {
+			u32 offset  : 24;
+			u32 tag     : 8;
+		};
+	};
+};
+
+struct isp_reg_info {
+	/** @brief [in] access method of register */
+	u8 method;
+	/** @brief [in] offset indicated which register will be read/write */
+	u32 offset;
+	/** @brief [in] length for indicated how much register will be read/write */
+	u32 length;
+};
+
+union reg_buf {
+	u32 buffer[STF_ISP_REG_BUF_SIZE];
+	struct {
+		u32 offset;
+		u32 value;
+	} reg_tbl[STF_ISP_REG_TBL_BUF_SIZE];
+	struct {
+		u32 offset;
+		u32 value;
+		u32 mask;
+	} reg_tbl2[STF_ISP_REG_TBL_2_BUF_SIZE];
+	struct {
+		u32 offset;
+		u32 value;
+		u32 mask;
+		u32 delay_ms;
+	} reg_tbl3[STF_ISP_REG_TBL_3_BUF_SIZE];
+	struct isp_rdma_info rdma_cmd[STF_ISP_REG_SMPL_PACK_BUF_SIZE];
+};
+
+struct isp_reg_param {
+	/** @brief [in, out] register read/write information */
+	struct isp_reg_info reg_info;
+	/** @brief [in, out] buffer */
+	union reg_buf *reg_buf;
+};
+
+
+#define VIDIOC_STFISP_LOAD_FW \
+	_IOW(ISP_IOC, STF_ISP_IOCTL_LOAD_FW, struct stfisp_fw_info)
+#define VIDIOC_STF_DMABUF_ALLOC \
+	_IOWR(ISP_IOC, STF_ISP_IOCTL_DMABUF_ALLOC, struct dmabuf_create)
+#define VIDIOC_STF_DMABUF_FREE \
+	_IOWR(ISP_IOC, STF_ISP_IOCTL_DMABUF_FREE, struct dmabuf_create)
+#define VIDIOC_STFISP_GET_REG \
+	_IOWR(ISP_IOC, STF_ISP_IOCTL_REG, struct isp_reg_param)
+#define VIDIOC_STFISP_SET_REG \
+	_IOW(ISP_IOC, STF_ISP_IOCTL_REG, struct isp_reg_param)
+#define VIDIOC_STFISP_SHADOW_LOCK \
+	_IO(ISP_IOC, STF_ISP_IOCTL_SHADOW_LOCK)
+#define VIDIOC_STFISP_SHADOW_UNLOCK \
+	_IO(ISP_IOC, STF_ISP_IOCTL_SHADOW_UNLOCK)
+#define VIDIOC_STFISP_SHADOW_UNLOCK_N_TRIGGER \
+	_IO(ISP_IOC, STF_ISP_IOCTL_SHADOW_UNLOCK_N_TRIGGER)
+#define VIDIOC_STFISP_SET_USER_CONFIG_ISP \
+	_IO(ISP_IOC, STF_ISP_IOCTL_SET_USER_CONFIG_ISP)
+
+
+#endif /* STF_ISP_IOCTL_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_video.c b/drivers/media/platform/starfive/v4l2_driver/stf_video.c
new file mode 100644
index 000000000000..2ce2b78b0b00
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_video.c
@@ -0,0 +1,1551 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include "stfcamss.h"
+#include "stf_video.h"
+#include <media/media-entity.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-mc.h>
+#include <media/videobuf2-dma-sg.h>
+#include <media/videobuf2-vmalloc.h>
+#include <media/videobuf2-dma-contig.h>
+
+static const struct stfcamss_format_info formats_pix_st7110_wr[] = {
+	{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_PIX_FMT_YUYV, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, V4L2_PIX_FMT_RGB565, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 16 } },
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SRGGB8, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 8 } },
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_PIX_FMT_SRGGB10, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_PIX_FMT_SGRBG10, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_PIX_FMT_SGBRG10, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_PIX_FMT_SBGGR10, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
+};
+
+static const struct stfcamss_format_info formats_raw_st7110_isp[] = {
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, V4L2_PIX_FMT_SBGGR12, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, V4L2_PIX_FMT_SRGGB12, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, V4L2_PIX_FMT_SGRBG12, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, V4L2_PIX_FMT_SGBRG12, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
+};
+
+static const struct stfcamss_format_info formats_pix_st7110_isp[] = {
+	// { MEDIA_BUS_FMT_YUYV12_2X12, V4L2_PIX_FMT_NV12M, 2,
+	//  { { 1, 1 }, { 1, 1 } }, { { 1, 1 }, { 1, 1 } }, { 8 , 4 } },
+	{ MEDIA_BUS_FMT_Y12_1X12, V4L2_PIX_FMT_NV12, 1,
+	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
+	{ MEDIA_BUS_FMT_Y12_1X12, V4L2_PIX_FMT_NV21, 1,
+	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
+};
+
+static const struct stfcamss_format_info formats_st7110_isp_iti[] = {
+	//  raw format
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, V4L2_PIX_FMT_SRGGB10, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, V4L2_PIX_FMT_SGRBG10, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, V4L2_PIX_FMT_SGBRG10, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, V4L2_PIX_FMT_SBGGR10, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 10 } },
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, V4L2_PIX_FMT_SRGGB12, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, V4L2_PIX_FMT_SGRBG12, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, V4L2_PIX_FMT_SGBRG12, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, V4L2_PIX_FMT_SBGGR12, 1,
+	  { { 1, 1 } }, { { 1, 1 } }, { 12 } },
+
+	// YUV420
+	{ MEDIA_BUS_FMT_Y12_1X12, V4L2_PIX_FMT_NV12, 1,
+	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
+	{ MEDIA_BUS_FMT_Y12_1X12, V4L2_PIX_FMT_NV21, 1,
+	  { { 1, 1 } }, { { 2, 3 } }, { 8 } },
+
+	// YUV444
+	{ MEDIA_BUS_FMT_YUV8_1X24, V4L2_PIX_FMT_NV24, 1,
+	  { { 1, 1 } }, { { 1, 3 } }, { 8 } },
+	{ MEDIA_BUS_FMT_VUY8_1X24, V4L2_PIX_FMT_NV42, 1,
+	  { { 1, 1 } }, { { 1, 3 } }, { 8 } },
+};
+
+static int video_find_format(u32 code, u32 pixelformat,
+				const struct stfcamss_format_info *formats,
+				unsigned int nformats)
+{
+	int i;
+
+	for (i = 0; i < nformats; i++) {
+		if (formats[i].code == code &&
+			formats[i].pixelformat == pixelformat)
+			return i;
+	}
+
+	for (i = 0; i < nformats; i++)
+		if (formats[i].code == code)
+			return i;
+
+	for (i = 0; i < nformats; i++)
+		if (formats[i].pixelformat == pixelformat)
+			return i;
+
+	return -EINVAL;
+}
+
+static int __video_try_fmt(struct stfcamss_video *video,
+		struct v4l2_format *f, int is_mp)
+{
+	struct v4l2_pix_format *pix;
+	struct v4l2_pix_format_mplane *pix_mp;
+	const struct stfcamss_format_info *fi;
+	u32 width, height;
+	u32 bpl;
+	int i, j;
+
+	st_debug(ST_VIDEO, "%s, fmt.type = 0x%x\n", __func__, f->type);
+	pix = &f->fmt.pix;
+	pix_mp = &f->fmt.pix_mp;
+
+	if (is_mp) {
+		for (i = 0; i < video->nformats; i++)
+			if (pix_mp->pixelformat
+				== video->formats[i].pixelformat)
+				break;
+
+		if (i == video->nformats)
+			i = 0; /* default format */
+
+		fi = &video->formats[i];
+		width = pix_mp->width;
+		height = pix_mp->height;
+
+		memset(pix_mp, 0, sizeof(*pix_mp));
+
+		pix_mp->pixelformat = fi->pixelformat;
+		pix_mp->width = clamp_t(u32, width, STFCAMSS_FRAME_MIN_WIDTH,
+				STFCAMSS_FRAME_MAX_WIDTH);
+		pix_mp->height = clamp_t(u32, height, STFCAMSS_FRAME_MIN_HEIGHT,
+				STFCAMSS_FRAME_MAX_HEIGHT);
+		pix_mp->num_planes = fi->planes;
+		for (j = 0; j < pix_mp->num_planes; j++) {
+			bpl = pix_mp->width / fi->hsub[j].numerator *
+				fi->hsub[j].denominator * fi->bpp[j] / 8;
+			bpl = ALIGN(bpl, video->bpl_alignment);
+			pix_mp->plane_fmt[j].bytesperline = bpl;
+			pix_mp->plane_fmt[j].sizeimage = pix_mp->height /
+				fi->vsub[j].numerator
+				* fi->vsub[j].denominator * bpl;
+		}
+
+		pix_mp->field = V4L2_FIELD_NONE;
+		pix_mp->colorspace = V4L2_COLORSPACE_SRGB;
+		pix_mp->flags = 0;
+		pix_mp->ycbcr_enc =
+			V4L2_MAP_YCBCR_ENC_DEFAULT(pix_mp->colorspace);
+		pix_mp->quantization =
+			V4L2_MAP_QUANTIZATION_DEFAULT(true,
+				pix_mp->colorspace, pix_mp->ycbcr_enc);
+		pix_mp->xfer_func =
+			V4L2_MAP_XFER_FUNC_DEFAULT(pix_mp->colorspace);
+
+		st_info(ST_VIDEO, "w, h = %d, %d, bpp = %d\n", pix_mp->width,
+				pix_mp->height, fi->bpp[0]);
+		st_info(ST_VIDEO, "i = %d, p = %d, s = 0x%x\n", i,
+				pix_mp->num_planes, pix_mp->plane_fmt[0].sizeimage);
+
+	} else {
+		for (i = 0; i < video->nformats; i++)
+			if (pix->pixelformat == video->formats[i].pixelformat)
+				break;
+
+		if (i == video->nformats)
+			i = 0; /* default format */
+
+		fi = &video->formats[i];
+		width = pix->width;
+		height = pix->height;
+
+		memset(pix, 0, sizeof(*pix));
+
+		pix->pixelformat = fi->pixelformat;
+		pix->width = clamp_t(u32, width, STFCAMSS_FRAME_MIN_WIDTH,
+				STFCAMSS_FRAME_MAX_WIDTH);
+		pix->height = clamp_t(u32, height, STFCAMSS_FRAME_MIN_HEIGHT,
+				STFCAMSS_FRAME_MAX_HEIGHT);
+		bpl = pix->width / fi->hsub[0].numerator *
+			fi->hsub[0].denominator * fi->bpp[0] / 8;
+		bpl = ALIGN(bpl, video->bpl_alignment);
+		pix->bytesperline = bpl;
+		pix->sizeimage = pix->height /
+			fi->vsub[0].numerator
+			* fi->vsub[0].denominator * bpl;
+
+		pix->field = V4L2_FIELD_NONE;
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		pix->flags = 0;
+		pix->ycbcr_enc =
+			V4L2_MAP_YCBCR_ENC_DEFAULT(pix->colorspace);
+		pix->quantization =
+			V4L2_MAP_QUANTIZATION_DEFAULT(true,
+				pix->colorspace, pix->ycbcr_enc);
+		pix->xfer_func =
+			V4L2_MAP_XFER_FUNC_DEFAULT(pix->colorspace);
+
+		st_info(ST_VIDEO, "w, h = %d, %d, bpp = %d\n", pix->width,
+				pix->height, fi->bpp[0]);
+		st_info(ST_VIDEO, "i = %d, s = 0x%x\n", i, pix->sizeimage);
+	}
+	return 0;
+}
+
+static int stf_video_init_format(struct stfcamss_video *video, int is_mp)
+{
+	int ret;
+	struct v4l2_format format = {
+		.type = video->type,
+		.fmt.pix = {
+			.width = 1920,
+			.height = 1080,
+			.pixelformat = V4L2_PIX_FMT_RGB565,
+		},
+	};
+
+	ret = __video_try_fmt(video, &format, is_mp);
+
+	if (ret < 0)
+		return ret;
+
+	video->active_fmt = format;
+
+	return 0;
+}
+
+static int video_queue_setup(struct vb2_queue *q,
+	unsigned int *num_buffers, unsigned int *num_planes,
+	unsigned int sizes[], struct device *alloc_devs[])
+{
+	struct stfcamss_video *video = vb2_get_drv_priv(q);
+	const struct v4l2_pix_format *format =
+			&video->active_fmt.fmt.pix;
+	const struct v4l2_pix_format_mplane *format_mp =
+			&video->active_fmt.fmt.pix_mp;
+	unsigned int i;
+
+	st_debug(ST_VIDEO, "%s, planes = %d\n", __func__, *num_planes);
+
+	if (video->is_mp) {
+		if (*num_planes) {
+			if (*num_planes != format_mp->num_planes)
+				return -EINVAL;
+
+			for (i = 0; i < *num_planes; i++)
+				if (sizes[i] <
+					format_mp->plane_fmt[i].sizeimage)
+					return -EINVAL;
+
+			return 0;
+		}
+
+		*num_planes = format_mp->num_planes;
+
+		for (i = 0; i < *num_planes; i++)
+			sizes[i] = format_mp->plane_fmt[i].sizeimage;
+	} else {
+		if (*num_planes) {
+			if (*num_planes != 1)
+				return -EINVAL;
+
+			if (sizes[0] < format->sizeimage)
+				return -EINVAL;
+		}
+
+		*num_planes  = 1;
+		sizes[0] = format->sizeimage;
+		if (!sizes[0])
+			st_err(ST_VIDEO, "%s: error size is zero!!!\n", __func__);
+	}
+	if ((stf_vin_map_isp_pad(video->id, STF_ISP_PAD_SRC)
+		== STF_ISP_PAD_SRC_SCD_Y) &&
+		sizes[0] < ISP_SCD_Y_BUFFER_SIZE) {
+		sizes[0] = ISP_SCD_Y_BUFFER_SIZE;
+	}
+
+	st_info(ST_VIDEO, "%s, planes = %d, size = %d\n",
+			__func__, *num_planes, sizes[0]);
+	return 0;
+}
+
+static int video_buf_init(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct stfcamss_video *video = vb2_get_drv_priv(vb->vb2_queue);
+	struct stfcamss_buffer *buffer =
+		container_of(vbuf, struct stfcamss_buffer, vb);
+	const struct v4l2_pix_format *fmt = &video->active_fmt.fmt.pix;
+	const struct v4l2_pix_format_mplane *fmt_mp =
+				&video->active_fmt.fmt.pix_mp;
+	//struct sg_table *sgt;
+	dma_addr_t *paddr;
+	unsigned int i;
+
+	buffer->sizeimage = 0;
+
+	if (video->is_mp) {
+		for (i = 0; i < fmt_mp->num_planes; i++) {
+			paddr = vb2_plane_cookie(vb, i);
+			buffer->addr[i] = *paddr;
+		buffer->sizeimage += vb2_plane_size(vb, i);
+		}
+
+		if (fmt_mp->num_planes == 1
+			&& (fmt_mp->pixelformat == V4L2_PIX_FMT_NV12
+			|| fmt_mp->pixelformat == V4L2_PIX_FMT_NV21
+			|| fmt_mp->pixelformat == V4L2_PIX_FMT_NV16
+			|| fmt_mp->pixelformat == V4L2_PIX_FMT_NV61))
+			buffer->addr[1] = buffer->addr[0] +
+					fmt_mp->plane_fmt[0].bytesperline *
+					fmt_mp->height;
+	} else {
+		paddr = vb2_plane_cookie(vb, 0);
+		buffer->sizeimage = vb2_plane_size(vb, 0);
+		buffer->addr[0] = *paddr;
+		if (fmt->pixelformat == V4L2_PIX_FMT_NV12
+			|| fmt->pixelformat == V4L2_PIX_FMT_NV21
+			|| fmt->pixelformat == V4L2_PIX_FMT_NV16
+			|| fmt->pixelformat == V4L2_PIX_FMT_NV61)
+			buffer->addr[1] = buffer->addr[0] +
+				fmt->bytesperline *
+				fmt->height;
+	}
+
+	if (stf_vin_map_isp_pad(video->id, STF_ISP_PAD_SRC)
+		== STF_ISP_PAD_SRC_SCD_Y)
+		buffer->addr[1] = buffer->addr[0] + ISP_YHIST_BUFFER_SIZE;
+
+	return 0;
+}
+
+static int video_buf_prepare(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct stfcamss_video *video = vb2_get_drv_priv(vb->vb2_queue);
+	const struct v4l2_pix_format *fmt = &video->active_fmt.fmt.pix;
+	const struct v4l2_pix_format_mplane *fmt_mp =
+					&video->active_fmt.fmt.pix_mp;
+	unsigned int i;
+
+	if (video->is_mp) {
+		for (i = 0; i < fmt_mp->num_planes; i++) {
+			if (fmt_mp->plane_fmt[i].sizeimage
+					> vb2_plane_size(vb, i))
+				return -EINVAL;
+
+			vb2_set_plane_payload(vb, i,
+					fmt_mp->plane_fmt[i].sizeimage);
+		}
+	} else {
+		if (fmt->sizeimage > vb2_plane_size(vb, 0)) {
+			st_err(ST_VIDEO, "sizeimage = %d, plane size = %d\n",
+				fmt->sizeimage, (unsigned int)vb2_plane_size(vb, 0));
+			return -EINVAL;
+		}
+		vb2_set_plane_payload(vb, 0, fmt->sizeimage);
+	}
+
+	vbuf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static void video_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct stfcamss_video *video = vb2_get_drv_priv(vb->vb2_queue);
+	struct stfcamss_buffer *buffer =
+		container_of(vbuf, struct stfcamss_buffer, vb);
+
+	video->ops->queue_buffer(video, buffer);
+}
+
+static int video_mbus_to_pix_mp(const struct v4l2_mbus_framefmt *mbus,
+				struct v4l2_pix_format_mplane *pix,
+				const struct stfcamss_format_info *f,
+				unsigned int alignment)
+{
+	unsigned int i;
+	u32 bytesperline;
+
+	memset(pix, 0, sizeof(*pix));
+	v4l2_fill_pix_format_mplane(pix, mbus);
+	pix->pixelformat = f->pixelformat;
+	pix->num_planes = f->planes;
+	for (i = 0; i < pix->num_planes; i++) {
+		bytesperline = pix->width / f->hsub[i].numerator *
+			f->hsub[i].denominator * f->bpp[i] / 8;
+		bytesperline = ALIGN(bytesperline, alignment);
+		pix->plane_fmt[i].bytesperline = bytesperline;
+		pix->plane_fmt[i].sizeimage = pix->height /
+				f->vsub[i].numerator * f->vsub[i].denominator *
+				bytesperline;
+	}
+
+	return 0;
+}
+
+static int video_mbus_to_pix(const struct v4l2_mbus_framefmt *mbus,
+			struct v4l2_pix_format *pix,
+			const struct stfcamss_format_info *f,
+			unsigned int alignment)
+{
+	u32 bytesperline;
+
+	memset(pix, 0, sizeof(*pix));
+	v4l2_fill_pix_format(pix, mbus);
+	pix->pixelformat = f->pixelformat;
+	bytesperline = pix->width / f->hsub[0].numerator *
+		f->hsub[0].denominator * f->bpp[0] / 8;
+	bytesperline = ALIGN(bytesperline, alignment);
+	pix->bytesperline = bytesperline;
+	pix->sizeimage = pix->height /
+			f->vsub[0].numerator * f->vsub[0].denominator *
+			bytesperline;
+	return 0;
+}
+
+static struct v4l2_subdev *video_remote_subdev(
+		struct stfcamss_video *video, u32 *pad)
+{
+	struct media_pad *remote;
+
+	remote = media_entity_remote_pad(&video->pad);
+
+	if (!remote || !is_media_entity_v4l2_subdev(remote->entity))
+		return NULL;
+
+	if (pad)
+		*pad = remote->index;
+
+	return media_entity_to_v4l2_subdev(remote->entity);
+}
+
+static int video_get_subdev_format(struct stfcamss_video *video,
+		struct v4l2_format *format)
+{
+	struct v4l2_pix_format *pix = &video->active_fmt.fmt.pix;
+	struct v4l2_pix_format_mplane *pix_mp =
+				&video->active_fmt.fmt.pix_mp;
+	struct v4l2_subdev_format fmt;
+	struct v4l2_subdev *subdev;
+	u32 pixelformat;
+	u32 pad;
+	int ret;
+
+	subdev = video_remote_subdev(video, &pad);
+	if (subdev == NULL)
+		return -EPIPE;
+
+	fmt.pad = pad;
+	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+
+	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);
+	if (ret)
+		return ret;
+
+	if (video->is_mp)
+		pixelformat = pix_mp->pixelformat;
+	else
+		pixelformat = pix->pixelformat;
+	ret = video_find_format(fmt.format.code, pixelformat,
+				video->formats, video->nformats);
+	if (ret < 0)
+		return ret;
+
+	format->type = video->type;
+
+	if (video->is_mp)
+		return video_mbus_to_pix_mp(&fmt.format, &format->fmt.pix_mp,
+				&video->formats[ret], video->bpl_alignment);
+	else
+		return video_mbus_to_pix(&fmt.format, &format->fmt.pix,
+				&video->formats[ret], video->bpl_alignment);
+}
+
+static int video_check_format(struct stfcamss_video *video)
+{
+	struct v4l2_pix_format *pix = &video->active_fmt.fmt.pix;
+	struct v4l2_pix_format_mplane *pix_mp =
+				&video->active_fmt.fmt.pix_mp;
+	struct v4l2_format format;
+	struct v4l2_pix_format *sd_pix = &format.fmt.pix;
+	struct v4l2_pix_format_mplane *sd_pix_mp = &format.fmt.pix_mp;
+	int ret;
+
+	if (video->is_mp) {
+		sd_pix_mp->pixelformat = pix_mp->pixelformat;
+		ret = video_get_subdev_format(video, &format);
+		if (ret < 0)
+			return ret;
+
+		if (pix_mp->pixelformat != sd_pix_mp->pixelformat ||
+			pix_mp->height > sd_pix_mp->height ||
+			pix_mp->width > sd_pix_mp->width ||
+			pix_mp->num_planes != sd_pix_mp->num_planes ||
+			pix_mp->field != format.fmt.pix_mp.field) {
+			st_err(ST_VIDEO,
+				"%s, not match:\n"
+				"0x%x 0x%x\n0x%x 0x%x\n0x%x 0x%x\n",
+				__func__,
+				pix_mp->pixelformat, sd_pix_mp->pixelformat,
+				pix_mp->height, sd_pix_mp->height,
+				pix_mp->field, format.fmt.pix_mp.field);
+			return -EPIPE;
+		}
+
+	} else {
+		sd_pix->pixelformat = pix->pixelformat;
+		ret = video_get_subdev_format(video, &format);
+		if (ret < 0)
+			return ret;
+
+		if (pix->pixelformat != sd_pix->pixelformat ||
+			pix->height > sd_pix->height ||
+			pix->width > sd_pix->width ||
+			pix->field != format.fmt.pix.field) {
+			st_err(ST_VIDEO,
+				"%s, not match:\n"
+				"0x%x 0x%x\n0x%x 0x%x\n0x%x 0x%x\n",
+				__func__,
+				pix->pixelformat, sd_pix->pixelformat,
+				pix->height, sd_pix->height,
+				pix->field, format.fmt.pix.field);
+			return -EPIPE;
+		}
+	}
+	return 0;
+}
+
+static int video_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct stfcamss_video *video = vb2_get_drv_priv(q);
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity;
+	struct media_pad *pad;
+	struct v4l2_subdev *subdev;
+	int ret;
+
+	ret = media_pipeline_start(&vdev->entity, &video->stfcamss->pipe);
+	if (ret < 0) {
+		st_err(ST_VIDEO,
+			"Failed to media_pipeline_start: %d\n", ret);
+		return ret;
+	}
+
+	ret = video_check_format(video);
+	if (ret < 0)
+		goto error;
+	entity = &vdev->entity;
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, 1);
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			goto error;
+	}
+	return 0;
+
+error:
+	media_pipeline_stop(&vdev->entity);
+	video->ops->flush_buffers(video, VB2_BUF_STATE_QUEUED);
+	return ret;
+}
+
+static void video_stop_streaming(struct vb2_queue *q)
+{
+	struct stfcamss_video *video = vb2_get_drv_priv(q);
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity;
+	struct media_pad *pad;
+	struct v4l2_subdev *subdev;
+
+	entity = &vdev->entity;
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		v4l2_subdev_call(subdev, video, s_stream, 0);
+	}
+
+	media_pipeline_stop(&vdev->entity);
+	video->ops->flush_buffers(video, VB2_BUF_STATE_ERROR);
+}
+
+static const struct vb2_ops stf_video_vb2_q_ops = {
+	.queue_setup     = video_queue_setup,
+	.wait_prepare    = vb2_ops_wait_prepare,
+	.wait_finish     = vb2_ops_wait_finish,
+	.buf_init        = video_buf_init,
+	.buf_prepare     = video_buf_prepare,
+	.buf_queue       = video_buf_queue,
+	.start_streaming = video_start_streaming,
+	.stop_streaming  = video_stop_streaming,
+};
+
+/* -----------------------------------------------------
+ * V4L2 ioctls
+ */
+
+static int getcrop_pad_id(int video_id)
+{
+	return stf_vin_map_isp_pad(video_id, STF_ISP_PAD_SRC);
+}
+
+static int video_querycap(struct file *file, void *fh,
+			struct v4l2_capability *cap)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+
+	strscpy(cap->driver, "stf camss", sizeof(cap->driver));
+	strscpy(cap->card, "Starfive Camera Subsystem", sizeof(cap->card));
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
+		dev_name(video->stfcamss->dev));
+	return 0;
+}
+
+static int video_get_unique_pixelformat_by_index(struct stfcamss_video *video,
+						int ndx)
+{
+	int i, j, k;
+
+	/* find index "i" of "k"th unique pixelformat in formats array */
+	k = -1;
+	for (i = 0; i < video->nformats; i++) {
+		for (j = 0; j < i; j++) {
+			if (video->formats[i].pixelformat ==
+				video->formats[j].pixelformat)
+				break;
+		}
+
+		if (j == i)
+			k++;
+
+		if (k == ndx)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+static int video_get_pixelformat_by_mbus_code(struct stfcamss_video *video,
+						u32 mcode)
+{
+	int i;
+
+	for (i = 0; i < video->nformats; i++) {
+		if (video->formats[i].code == mcode)
+			return i;
+	}
+
+	return -EINVAL;
+}
+
+static int video_enum_fmt(struct file *file, void *fh, struct v4l2_fmtdesc *f)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+	int i;
+
+	st_debug(ST_VIDEO, "%s:\n0x%x 0x%x\n 0x%x, 0x%x\n0x%x\n",
+		__func__,
+		f->type, video->type,
+		f->index, video->nformats,
+		f->mbus_code);
+
+	if (f->type != video->type)
+		return -EINVAL;
+	if (f->index >= video->nformats)
+		return -EINVAL;
+
+	if (f->mbus_code) {
+		/* Each entry in formats[] table has unique mbus_code */
+		if (f->index > 0)
+			return -EINVAL;
+
+		i = video_get_pixelformat_by_mbus_code(video, f->mbus_code);
+	} else {
+		i = video_get_unique_pixelformat_by_index(video, f->index);
+	}
+
+	if (i < 0)
+		return -EINVAL;
+
+	f->pixelformat = video->formats[i].pixelformat;
+
+	return 0;
+}
+
+static int video_enum_framesizes(struct file *file, void *fh,
+				struct v4l2_frmsizeenum *fsize)
+{
+	struct v4l2_subdev_frame_size_enum fse = {0};
+	struct v4l2_subdev_mbus_code_enum code = {0};
+	struct stfcamss_video *video = video_drvdata(file);
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity = &vdev->entity;
+	struct media_entity *sensor;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	bool support_selection = false;
+	int i;
+	int ret;
+
+	for (i = 0; i < video->nformats; i++) {
+		if (video->formats[i].pixelformat == fsize->pixel_format)
+			break;
+	}
+
+	if (i == video->nformats)
+		return -EINVAL;
+
+	entity = &vdev->entity;
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		if (subdev->ops->pad->set_selection) {
+			support_selection = true;
+			break;
+		}
+	}
+
+	if (support_selection) {
+		if (fsize->index)
+			return -EINVAL;
+		fsize->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
+		fsize->stepwise.min_width = STFCAMSS_FRAME_MIN_WIDTH;
+		fsize->stepwise.max_width = STFCAMSS_FRAME_MAX_WIDTH;
+		fsize->stepwise.min_height = STFCAMSS_FRAME_MIN_HEIGHT;
+		fsize->stepwise.max_height = STFCAMSS_FRAME_MAX_HEIGHT;
+		fsize->stepwise.step_width = 1;
+		fsize->stepwise.step_height = 1;
+	} else {
+		entity = &vdev->entity;
+		sensor = stfcamss_find_sensor(entity);
+		if (!sensor)
+			return -ENOTTY;
+
+		subdev = media_entity_to_v4l2_subdev(sensor);
+		code.index = 0;
+		code.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		ret = v4l2_subdev_call(subdev, pad, enum_mbus_code, NULL, &code);
+		if (ret < 0)
+			return -EINVAL;
+		fse.index = fsize->index;
+		fse.code = code.code;
+		fse.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+		ret = v4l2_subdev_call(subdev, pad, enum_frame_size, NULL, &fse);
+		if (ret < 0)
+			return -EINVAL;
+		fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+		fsize->discrete.width = fse.min_width;
+		fsize->discrete.height = fse.min_height;
+	}
+
+	return 0;
+}
+
+static int video_enum_frameintervals(struct file *file, void *fh,
+				struct v4l2_frmivalenum *fival)
+{
+	int ret = 0;
+	struct stfcamss_video *video = video_drvdata(file);
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity = &vdev->entity;
+	struct media_entity *sensor;
+	struct v4l2_subdev *subdev;
+	struct v4l2_subdev_mbus_code_enum code = {0};
+	struct v4l2_subdev_frame_interval_enum fie = {0};
+
+	sensor = stfcamss_find_sensor(entity);
+	if (!sensor)
+		return -ENOTTY;
+	fie.index = fival->index;
+	fie.width = fival->width;
+	fie.height = fival->height;
+	fie.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+	subdev = media_entity_to_v4l2_subdev(sensor);
+
+	code.index = 0;
+	code.which = V4L2_SUBDEV_FORMAT_ACTIVE;
+
+	/* Don't care about the code, just find by pixelformat */
+	ret = video_find_format(0, fival->pixel_format,
+				video->formats, video->nformats);
+	if (ret < 0)
+		return -EINVAL;
+
+	ret = v4l2_subdev_call(subdev, pad, enum_mbus_code, NULL, &code);
+	if (ret < 0)
+		return -EINVAL;
+
+	fie.code = code.code;
+	ret = v4l2_subdev_call(subdev, pad, enum_frame_interval, NULL, &fie);
+	if (ret < 0)
+		return ret;
+
+	fival->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	fival->discrete = fie.interval;
+
+	return 0;
+}
+
+static int video_g_fmt(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+
+	st_debug(ST_VIDEO, "%s, fmt.type = 0x%x\n", __func__, f->type);
+	st_debug(ST_VIDEO, "%s, active_fmt.type = 0x%x,0x%x\n",
+			__func__, video->active_fmt.type,
+			video->active_fmt.fmt.pix.pixelformat);
+	*f = video->active_fmt;
+	return 0;
+}
+
+static int video_g_fmt_mp(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+
+	st_debug(ST_VIDEO, "%s, fmt.type = 0x%x\n", __func__, f->type);
+	st_debug(ST_VIDEO, "%s, active_fmt.type = 0x%x\n",
+			__func__, video->active_fmt.type);
+	*f = video->active_fmt;
+	return 0;
+}
+
+static int video_entity_s_fmt(struct stfcamss_video *video,
+			struct media_entity *entity,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt, u32 dst_code)
+{
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	struct v4l2_mbus_framefmt *mf = &fmt->format;
+	u32 width, height, code;
+	int ret, index = 0;
+
+	code = mf->code;
+	width = mf->width;
+	height = mf->height;
+	subdev = media_entity_to_v4l2_subdev(entity);
+	while (1) {
+		if (index >= entity->num_pads)
+			break;
+		pad = &entity->pads[index];
+		pad = media_entity_remote_pad(pad);
+		if (pad && is_media_entity_v4l2_subdev(pad->entity)) {
+			fmt->pad = index;
+			if (index)
+				mf->code = dst_code;
+			ret = v4l2_subdev_call(subdev, pad, set_fmt, cfg, fmt);
+			st_warn(ST_VIDEO,
+				"\"%s\":%d pad fmt set to 0x%x %ux%u, dst_code = 0x%x, ret=%d\n",
+				subdev->name, fmt->pad, mf->code,
+				mf->width, mf->height, dst_code, ret);
+			if (mf->code != code ||
+				mf->width != width || mf->height != height) {
+				st_warn(ST_VIDEO,
+					"\"%s\":%d pad fmt has been"
+					" changed to 0x%x %ux%u\n",
+					subdev->name, fmt->pad, mf->code,
+					mf->width, mf->height);
+			}
+			if (index)
+				ret = video_entity_s_fmt(video, pad->entity, cfg, fmt, dst_code);
+		}
+
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		index++;
+	}
+	return ret;
+}
+
+static int video_pipeline_s_fmt(struct stfcamss_video *video,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_format *f)
+{
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity = &vdev->entity;
+	struct v4l2_subdev *subdev;
+	int ret, index;
+	struct v4l2_subdev_format fmt = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.reserved = {getcrop_pad_id(video->id)}
+	};
+	struct v4l2_mbus_framefmt *mf = &fmt.format;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	struct media_entity *sensor;
+	u32 width, height, code;
+	struct media_pad *pad;
+
+	/* pix to mbus format */
+	if (video->is_mp) {
+		index = video_find_format(mf->code,
+					pix_mp->pixelformat,
+					video->formats, video->nformats);
+		if (index < 0)
+			return index;
+		v4l2_fill_mbus_format_mplane(mf, pix_mp);
+		mf->code = video->formats[index].code;
+	} else {
+		index = video_find_format(mf->code,
+					pix->pixelformat,
+					video->formats, video->nformats);
+		if (index < 0)
+			return index;
+		v4l2_fill_mbus_format(mf, pix, video->formats[index].code);
+	}
+	code = mf->code;
+	width = mf->width;
+	height = mf->height;
+	sensor = stfcamss_find_sensor(entity);
+	if (sensor) {
+		subdev = media_entity_to_v4l2_subdev(sensor);
+		ret = v4l2_subdev_call(subdev, pad, set_fmt, cfg, &fmt);
+		st_warn(ST_VIDEO,
+			"\"%s\":%d pad fmt set to 0x%x %ux%u\n",
+			subdev->name, fmt.pad, mf->code,
+			mf->width, mf->height);
+		if (mf->code != code ||
+			mf->width != width || mf->height != height) {
+			st_warn(ST_VIDEO,
+				"\"%s\":%d pad fmt has been"
+				" changed to 0x%x %ux%u\n",
+				subdev->name, fmt.pad, mf->code,
+				mf->width, mf->height);
+		}
+	} else {
+		st_err(ST_VIDEO, "Can't find sensor\n");
+		return -ENOTTY;
+	}
+	/*
+	 * Starting from sensor subdevice, walk within
+	 * pipeline and set format on each subdevice
+	 */
+	sensor = stfcamss_find_sensor(entity);
+	pad = media_entity_remote_pad(&sensor->pads[0]);
+	ret = video_entity_s_fmt(video, pad->entity, cfg, &fmt, code);
+
+	if (ret < 0 && ret != -ENOIOCTLCMD)
+		return ret;
+
+	index = video_find_format(mf->code,
+				video->formats[index].pixelformat,
+				video->formats, video->nformats);
+	st_debug(ST_VIDEO, "%s, code=%x, index=%d\n",
+			__func__, mf->code, index);
+
+	if (index < 0)
+		return index;
+
+	if (video->is_mp)
+		video_mbus_to_pix_mp(mf, pix_mp,
+				&video->formats[index], video->bpl_alignment);
+	else
+		video_mbus_to_pix(mf, pix,
+				&video->formats[index], video->bpl_alignment);
+
+	ret = __video_try_fmt(video, f, video->is_mp);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int video_s_fmt(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+	int ret;
+
+	st_debug(ST_VIDEO, "%s, fmt.type = 0x%x, v4l2fmt=%x\n",
+			__func__, f->type, f->fmt.pix.pixelformat);
+
+	if (vb2_is_busy(&video->vb2_q))
+		return -EBUSY;
+
+	ret = __video_try_fmt(video, f, false);
+	if (ret < 0)
+		return ret;
+
+	ret = video_pipeline_s_fmt(video, NULL, f);
+
+	st_debug(ST_VIDEO, "%s, pixelformat=0x%x, ret=%d\n",
+			__func__, f->fmt.pix.pixelformat, ret);
+	if (ret < 0)
+		return ret;
+
+	video->active_fmt = *f;
+
+	return 0;
+}
+
+static int video_s_fmt_mp(struct file *file, void *fh, struct v4l2_format *f)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+	int ret;
+
+	st_debug(ST_VIDEO, "%s, fmt.type = 0x%x\n", __func__, f->type);
+	if (vb2_is_busy(&video->vb2_q))
+		return -EBUSY;
+
+	ret = __video_try_fmt(video, f, true);
+	if (ret < 0)
+		return ret;
+
+	ret = video_pipeline_s_fmt(video, NULL, f);
+	if (ret < 0)
+		return ret;
+
+	video->active_fmt = *f;
+
+	return 0;
+}
+
+static int video_try_fmt(struct file *file,
+		void *fh, struct v4l2_format *f)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+
+	return __video_try_fmt(video, f, false);
+}
+
+static int video_try_fmt_mp(struct file *file,
+		void *fh, struct v4l2_format *f)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+
+	return __video_try_fmt(video, f, true);
+}
+
+static int video_enum_input(struct file *file, void *fh,
+			struct v4l2_input *input)
+{
+	if (input->index > 0)
+		return -EINVAL;
+
+	strscpy(input->name, "camera", sizeof(input->name));
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+static int video_g_input(struct file *file, void *fh, unsigned int *input)
+{
+	*input = 0;
+
+	return 0;
+}
+
+static int video_s_input(struct file *file, void *fh, unsigned int input)
+{
+	return input == 0 ? 0 : -EINVAL;
+}
+
+static int video_g_parm(struct file *file, void *priv,
+			struct v4l2_streamparm *p)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	int ret, is_support = 0;
+
+	entity = &vdev->entity;
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_g_parm_cap(vdev, subdev, p);
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		if (!ret)
+			is_support = 1;
+	}
+
+	return is_support ? 0 : ret;
+}
+
+static int video_s_parm(struct file *file, void *priv,
+			struct v4l2_streamparm *p)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	struct v4l2_streamparm tmp_p;
+	int ret, is_support = 0;
+
+	entity = &vdev->entity;
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		tmp_p = *p;
+		ret = v4l2_s_parm_cap(vdev, subdev, &tmp_p);
+		if (ret < 0 && ret != -ENOIOCTLCMD)
+			break;
+		if (!ret) {
+			is_support = 1;
+			*p = tmp_p;
+		}
+	}
+
+	return is_support ? 0 : ret;
+}
+
+/* Crop ioctls */
+int video_g_pixelaspect(struct file *file, void *fh,
+			    int buf_type, struct v4l2_fract *aspect)
+{
+	return 0;
+}
+
+int video_g_selection(struct file *file, void *fh,
+			  struct v4l2_selection *s)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	struct v4l2_subdev_selection sel = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.pad = getcrop_pad_id(video->id),
+		.target = s->target,
+		.r = s->r,
+		.flags = s->flags,
+	};
+	int ret;
+
+	st_debug(ST_VIDEO, "%s, target = 0x%x, 0x%x\n",
+			__func__, sel.target, s->target);
+	if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE
+		&& s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
+
+	entity = &vdev->entity;
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, pad, get_selection, NULL, &sel);
+		if (!ret) {
+			s->r = sel.r;
+			s->flags = sel.flags;
+			break;
+		}
+		if (ret != -ENOIOCTLCMD)
+			break;
+	}
+
+	return ret;
+}
+
+int video_s_selection(struct file *file, void *fh,
+			struct v4l2_selection *s)
+{
+	struct stfcamss_video *video = video_drvdata(file);
+	struct video_device *vdev = &video->vdev;
+	struct media_entity *entity;
+	struct v4l2_subdev *subdev;
+	struct media_pad *pad;
+	struct v4l2_subdev_selection sel = {
+		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
+		.pad = getcrop_pad_id(video->id),
+		.target = s->target,
+		.r = s->r,
+		.flags = s->flags,
+	};
+	struct v4l2_pix_format *format = &video->active_fmt.fmt.pix;
+	struct v4l2_pix_format_mplane *format_mp =
+						&video->active_fmt.fmt.pix_mp;
+	int ret;
+
+	st_debug(ST_VIDEO, "%s, target = 0x%x, 0x%x\n",
+			__func__, sel.target, s->target);
+	if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE
+		&& s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		return -EINVAL;
+
+	entity = &vdev->entity;
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, pad, set_selection, NULL, &sel);
+		if (!ret) {
+			s->r = sel.r;
+			s->flags = sel.flags;
+			format->width = s->r.width;
+			format->height = s->r.height;
+			format_mp->width = s->r.width;
+			format_mp->height = s->r.height;
+			ret = __video_try_fmt(video, &video->active_fmt,
+					video->is_mp);
+			if (ret < 0)
+				return ret;
+			break;
+		}
+		if (ret != -ENOIOCTLCMD)
+			break;
+	}
+
+	st_debug(ST_VIDEO, "ret = 0x%x, -EINVAL = 0x%x\n", ret, -EINVAL);
+
+	return ret;
+}
+
+static const struct v4l2_ioctl_ops stf_vid_ioctl_ops = {
+	.vidioc_querycap                = video_querycap,
+	.vidioc_enum_fmt_vid_cap        = video_enum_fmt,
+	.vidioc_enum_framesizes         = video_enum_framesizes,
+	.vidioc_enum_frameintervals     = video_enum_frameintervals,
+	.vidioc_g_fmt_vid_cap           = video_g_fmt,
+	.vidioc_s_fmt_vid_cap           = video_s_fmt,
+	.vidioc_try_fmt_vid_cap         = video_try_fmt,
+	.vidioc_reqbufs                 = vb2_ioctl_reqbufs,
+	.vidioc_querybuf                = vb2_ioctl_querybuf,
+	.vidioc_qbuf                    = vb2_ioctl_qbuf,
+	.vidioc_expbuf                  = vb2_ioctl_expbuf,
+	.vidioc_dqbuf                   = vb2_ioctl_dqbuf,
+	.vidioc_create_bufs             = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf             = vb2_ioctl_prepare_buf,
+	.vidioc_streamon                = vb2_ioctl_streamon,
+	.vidioc_streamoff               = vb2_ioctl_streamoff,
+	.vidioc_enum_input              = video_enum_input,
+	.vidioc_g_input                 = video_g_input,
+	.vidioc_s_input                 = video_s_input,
+	.vidioc_g_parm                  = video_g_parm,
+	.vidioc_s_parm                  = video_s_parm,
+	.vidioc_s_selection             = video_s_selection,
+	.vidioc_g_selection             = video_g_selection,
+};
+
+static const struct v4l2_ioctl_ops stf_vid_ioctl_ops_mp = {
+	.vidioc_querycap                = video_querycap,
+	.vidioc_enum_fmt_vid_cap        = video_enum_fmt,
+	.vidioc_enum_framesizes         = video_enum_framesizes,
+	.vidioc_enum_frameintervals     = video_enum_frameintervals,
+	.vidioc_g_fmt_vid_cap_mplane    = video_g_fmt_mp,
+	.vidioc_s_fmt_vid_cap_mplane    = video_s_fmt_mp,
+	.vidioc_try_fmt_vid_cap_mplane  = video_try_fmt_mp,
+	.vidioc_reqbufs                 = vb2_ioctl_reqbufs,
+	.vidioc_querybuf                = vb2_ioctl_querybuf,
+	.vidioc_qbuf                    = vb2_ioctl_qbuf,
+	.vidioc_expbuf                  = vb2_ioctl_expbuf,
+	.vidioc_dqbuf                   = vb2_ioctl_dqbuf,
+	.vidioc_create_bufs             = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf             = vb2_ioctl_prepare_buf,
+	.vidioc_streamon                = vb2_ioctl_streamon,
+	.vidioc_streamoff               = vb2_ioctl_streamoff,
+	.vidioc_enum_input              = video_enum_input,
+	.vidioc_g_input                 = video_g_input,
+	.vidioc_s_input                 = video_s_input,
+	.vidioc_g_parm                  = video_g_parm,
+	.vidioc_s_parm                  = video_s_parm,
+	.vidioc_s_selection             = video_s_selection,
+	.vidioc_g_selection             = video_g_selection,
+};
+
+static const struct v4l2_ioctl_ops stf_vid_ioctl_ops_out = {
+	.vidioc_querycap                = video_querycap,
+	.vidioc_enum_fmt_vid_out        = video_enum_fmt,
+	.vidioc_enum_framesizes         = video_enum_framesizes,
+	.vidioc_enum_frameintervals     = video_enum_frameintervals,
+	.vidioc_g_fmt_vid_out           = video_g_fmt,
+	.vidioc_s_fmt_vid_out           = video_s_fmt,
+	.vidioc_try_fmt_vid_out         = video_try_fmt,
+	.vidioc_reqbufs                 = vb2_ioctl_reqbufs,
+	.vidioc_querybuf                = vb2_ioctl_querybuf,
+	.vidioc_qbuf                    = vb2_ioctl_qbuf,
+	.vidioc_expbuf                  = vb2_ioctl_expbuf,
+	.vidioc_dqbuf                   = vb2_ioctl_dqbuf,
+	.vidioc_create_bufs             = vb2_ioctl_create_bufs,
+	.vidioc_prepare_buf             = vb2_ioctl_prepare_buf,
+	.vidioc_streamon                = vb2_ioctl_streamon,
+	.vidioc_streamoff               = vb2_ioctl_streamoff,
+};
+
+static int video_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct stfcamss_video *video = video_drvdata(file);
+	struct v4l2_fh *vfh;
+	int ret;
+
+	mutex_lock(&video->lock);
+
+	vfh = kzalloc(sizeof(*vfh), GFP_KERNEL);
+	if (vfh == NULL) {
+		ret = -ENOMEM;
+		goto error_alloc;
+	}
+
+	v4l2_fh_init(vfh, vdev);
+	v4l2_fh_add(vfh);
+
+	file->private_data = vfh;
+
+	if (!video->pm_count) {
+		ret = v4l2_pipeline_pm_get(&vdev->entity);
+		if (ret < 0) {
+			st_err(ST_VIDEO,
+				"Failed to power up pipeline: %d\n", ret);
+			goto error_pm_use;
+		}
+	}
+
+	video->pm_count++;
+
+	mutex_unlock(&video->lock);
+
+	return 0;
+
+error_pm_use:
+	v4l2_fh_release(file);
+error_alloc:
+	mutex_unlock(&video->lock);
+	return ret;
+}
+
+static int video_release(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct stfcamss_video *video = video_drvdata(file);
+
+	vb2_fop_release(file);
+
+	video->pm_count--;
+
+	if (!video->pm_count)
+		v4l2_pipeline_pm_put(&vdev->entity);
+
+	file->private_data = NULL;
+
+	return 0;
+}
+
+static const struct v4l2_file_operations stf_vid_fops = {
+	.owner          = THIS_MODULE,
+	.unlocked_ioctl = video_ioctl2,
+	.open           = video_open,
+	.release        = video_release,
+	.poll           = vb2_fop_poll,
+	.mmap           = vb2_fop_mmap,
+	.read           = vb2_fop_read,
+};
+
+static void stf_video_release(struct video_device *vdev)
+{
+	struct stfcamss_video *video = video_get_drvdata(vdev);
+
+	media_entity_cleanup(&vdev->entity);
+
+	mutex_destroy(&video->q_lock);
+	mutex_destroy(&video->lock);
+}
+
+int stf_video_register(struct stfcamss_video *video,
+			struct v4l2_device *v4l2_dev,
+			const char *name, int is_mp)
+{
+	struct video_device *vdev;
+	struct vb2_queue *q;
+	struct media_pad *pad = &video->pad;
+	int ret;
+	enum isp_pad_id isp_pad;
+
+	vdev = &video->vdev;
+
+	mutex_init(&video->q_lock);
+
+	q = &video->vb2_q;
+	q->drv_priv = video;
+	q->mem_ops = &vb2_dma_contig_memops;
+	q->ops = &stf_video_vb2_q_ops;
+	//q->type = is_mp ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE :
+	//	V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	q->type = video->type;
+	q->io_modes = VB2_DMABUF | VB2_MMAP | VB2_READ;
+	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	q->buf_struct_size = sizeof(struct stfcamss_buffer);
+	q->dev = video->stfcamss->dev;
+	q->lock = &video->q_lock;
+	q->min_buffers_needed = STFCAMSS_MIN_BUFFERS;
+	ret = vb2_queue_init(q);
+	if (ret < 0) {
+		st_err(ST_VIDEO,
+			"Failed to init vb2 queue: %d\n", ret);
+		goto err_vb2_init;
+	}
+
+	pad->flags = MEDIA_PAD_FL_SINK;
+	ret = media_entity_pads_init(&vdev->entity, 1, pad);
+	if (ret < 0) {
+		st_err(ST_VIDEO,
+			"Failed to init video entity: %d\n",
+			ret);
+		goto err_vb2_init;
+	}
+
+	mutex_init(&video->lock);
+
+	isp_pad = stf_vin_map_isp_pad(video->id, STF_ISP_PAD_SRC);
+	if (video->id == VIN_LINE_WR) {
+		video->formats = formats_pix_st7110_wr;
+		video->nformats = ARRAY_SIZE(formats_pix_st7110_wr);
+		video->bpl_alignment = STFCAMSS_FRAME_WIDTH_ALIGN_8;
+	} else if (isp_pad == STF_ISP_PAD_SRC
+		|| isp_pad == STF_ISP_PAD_SRC_SS0
+		|| isp_pad == STF_ISP_PAD_SRC_SS1) {
+		video->formats = formats_pix_st7110_isp;
+		video->nformats = ARRAY_SIZE(formats_pix_st7110_isp);
+		video->bpl_alignment = STFCAMSS_FRAME_WIDTH_ALIGN_8;
+	} else if (isp_pad == STF_ISP_PAD_SRC_ITIW
+		|| isp_pad == STF_ISP_PAD_SRC_ITIR) {
+		video->formats = formats_st7110_isp_iti;
+		video->nformats = ARRAY_SIZE(formats_st7110_isp_iti);
+		video->bpl_alignment = STFCAMSS_FRAME_WIDTH_ALIGN_8;
+	} else { // raw/scdump/yhist
+		video->formats = formats_raw_st7110_isp;
+		video->nformats = ARRAY_SIZE(formats_raw_st7110_isp);
+		video->bpl_alignment = STFCAMSS_FRAME_WIDTH_ALIGN_128;
+	}
+	video->is_mp = is_mp;
+
+	ret = stf_video_init_format(video, is_mp);
+	if (ret < 0) {
+		st_err(ST_VIDEO, "Failed to init format: %d\n", ret);
+		goto err_vid_init_format;
+	}
+
+	vdev->fops = &stf_vid_fops;
+	if (isp_pad == STF_ISP_PAD_SRC_ITIR) {
+		vdev->device_caps = V4L2_CAP_VIDEO_OUTPUT;
+		vdev->vfl_dir = VFL_DIR_TX;
+	} else {
+		vdev->device_caps = is_mp ? V4L2_CAP_VIDEO_CAPTURE_MPLANE :
+			V4L2_CAP_VIDEO_CAPTURE;
+		vdev->vfl_dir = VFL_DIR_RX;
+	}
+	vdev->device_caps |= V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;
+	if (video->type == V4L2_CAP_VIDEO_OUTPUT)
+		vdev->ioctl_ops = &stf_vid_ioctl_ops_out;
+	else
+		vdev->ioctl_ops = is_mp ? &stf_vid_ioctl_ops_mp : &stf_vid_ioctl_ops;
+	vdev->release = stf_video_release;
+	vdev->v4l2_dev = v4l2_dev;
+	vdev->queue = &video->vb2_q;
+	vdev->lock = &video->lock;
+	//strlcpy(vdev->name, name, sizeof(vdev->name));
+	strscpy(vdev->name, name, sizeof(vdev->name));
+
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, video->id);
+	if (ret < 0) {
+		st_err(ST_VIDEO,
+			"Failed to register video device: %d\n",
+			ret);
+		goto err_vid_reg;
+	}
+
+	video_set_drvdata(vdev, video);
+	return 0;
+
+err_vid_reg:
+err_vid_init_format:
+	media_entity_cleanup(&vdev->entity);
+	mutex_destroy(&video->lock);
+err_vb2_init:
+	mutex_destroy(&video->q_lock);
+	return ret;
+}
+
+void stf_video_unregister(struct stfcamss_video *video)
+{
+	vb2_video_unregister_device(&video->vdev);
+}
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_video.h b/drivers/media/platform/starfive/v4l2_driver/stf_video.h
new file mode 100644
index 000000000000..6037d0ec7ac5
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_video.h
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_VIDEO_H
+#define STF_VIDEO_H
+
+#include <linux/mutex.h>
+#include <media/videobuf2-v4l2.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fh.h>
+#include <media/v4l2-ioctl.h>
+
+#define STFCAMSS_FRAME_MIN_WIDTH		64
+#define STFCAMSS_FRAME_MAX_WIDTH		1920
+#define STFCAMSS_FRAME_MIN_HEIGHT		64
+#define STFCAMSS_FRAME_MAX_HEIGHT		1080
+#define STFCAMSS_FRAME_WIDTH_ALIGN_8		8
+#define STFCAMSS_FRAME_WIDTH_ALIGN_128		128
+#define STFCAMSS_MIN_BUFFERS			2
+
+#define STFCAMSS_MAX_ENTITY_NAME_LEN		27
+
+struct stfcamss_buffer {
+	struct vb2_v4l2_buffer vb;
+	dma_addr_t addr[3];
+	struct list_head queue;
+	int sizeimage;
+};
+
+struct stfcamss_video;
+
+struct stfcamss_video_ops {
+	int (*queue_buffer)(struct stfcamss_video *vid,
+			struct stfcamss_buffer *buf);
+	int (*flush_buffers)(struct stfcamss_video *vid,
+			enum vb2_buffer_state state);
+};
+
+struct fract {
+	u8 numerator;
+	u8 denominator;
+};
+
+struct stfcamss_format_info {
+	u32 code;
+	u32 pixelformat;
+	u8 planes;
+	struct fract hsub[3];
+	struct fract vsub[3];
+	u8 bpp[3];
+};
+
+struct stfcamss_video {
+	struct stfcamss *stfcamss;
+	u8 id;
+	struct vb2_queue vb2_q;
+	struct video_device vdev;
+	struct media_pad pad;
+	struct media_pipeline pipe;
+	struct v4l2_format active_fmt;
+	enum v4l2_buf_type type;
+	const struct stfcamss_video_ops *ops;
+	struct mutex lock;
+	struct mutex q_lock;
+	unsigned int bpl_alignment;
+	const struct stfcamss_format_info *formats;
+	unsigned int nformats;
+	unsigned int is_mp;
+	unsigned int pm_count;
+};
+
+int stf_video_register(struct stfcamss_video *video,
+		struct v4l2_device *v4l2_dev, const char *name, int is_mp);
+
+void stf_video_unregister(struct stfcamss_video *video);
+
+#endif /* STF_VIDEO_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_vin.c b/drivers/media/platform/starfive/v4l2_driver/stf_vin.c
new file mode 100644
index 000000000000..128cec27e6f1
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_vin.c
@@ -0,0 +1,1488 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/pm_runtime.h>
+
+#include "stfcamss.h"
+
+#define vin_line_array(ptr_line) \
+		((const struct vin_line (*)[]) &(ptr_line[-(ptr_line->id)]))
+
+#define line_to_vin2_dev(ptr_line) \
+		container_of(vin_line_array(ptr_line), struct stf_vin2_dev, line)
+
+#define VIN_FRAME_DROP_MAX_VAL 90
+#define VIN_FRAME_DROP_MIN_VAL 4
+#define VIN_FRAME_PER_SEC_MAX_VAL 90
+
+/* ISP ctrl need 1 sec to let frames become stable. */
+#define VIN_FRAME_DROP_SEC_FOR_ISP_CTRL 1
+
+
+// #define VIN_TWO_BUFFER
+
+static const struct vin2_format vin2_formats_st7110[] = {
+	{ MEDIA_BUS_FMT_YUYV8_2X8, 16},
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, 16},
+	{ MEDIA_BUS_FMT_SRGGB8_1X8, 8},
+	{ MEDIA_BUS_FMT_SGRBG8_1X8, 8},
+	{ MEDIA_BUS_FMT_SGBRG8_1X8, 8},
+	{ MEDIA_BUS_FMT_SBGGR8_1X8, 8},
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10},
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12},
+	{ MEDIA_BUS_FMT_Y12_1X12, 8},
+	{ MEDIA_BUS_FMT_YUV8_1X24, 8},
+};
+
+static const struct vin2_format isp_formats_st7110_raw[] = {
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12},
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12},
+};
+
+static const struct vin2_format isp_formats_st7110_uo[] = {
+	{ MEDIA_BUS_FMT_Y12_1X12, 8},
+};
+
+static const struct vin2_format isp_formats_st7110_iti[] = {
+	{ MEDIA_BUS_FMT_SRGGB10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGRBG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SGBRG10_1X10, 10},
+	{ MEDIA_BUS_FMT_SBGGR10_1X10, 10},
+	{ MEDIA_BUS_FMT_SRGGB12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGRBG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SGBRG12_1X12, 12},
+	{ MEDIA_BUS_FMT_SBGGR12_1X12, 12},
+	{ MEDIA_BUS_FMT_Y12_1X12, 8},
+	{ MEDIA_BUS_FMT_YUV8_1X24, 8},
+};
+
+static const struct vin2_format_table vin2_formats_table[] = {
+	/* VIN_LINE_WR */
+	{ vin2_formats_st7110, ARRAY_SIZE(vin2_formats_st7110) },
+	/* VIN_LINE_ISP */
+	{ isp_formats_st7110_uo, ARRAY_SIZE(isp_formats_st7110_uo) },
+	/* VIN_LINE_ISP_SS0 */
+	{ isp_formats_st7110_uo, ARRAY_SIZE(isp_formats_st7110_uo) },
+	/* VIN_LINE_ISP_SS1 */
+	{ isp_formats_st7110_uo, ARRAY_SIZE(isp_formats_st7110_uo) },
+	/* VIN_LINE_ISP_ITIW */
+	{ isp_formats_st7110_iti, ARRAY_SIZE(isp_formats_st7110_iti) },
+	/* VIN_LINE_ISP_ITIR */
+	{ isp_formats_st7110_iti, ARRAY_SIZE(isp_formats_st7110_iti) },
+	/* VIN_LINE_ISP_RAW */
+	{ isp_formats_st7110_raw, ARRAY_SIZE(isp_formats_st7110_raw) },
+	/* VIN_LINE_ISP_SCD_Y */
+	{ isp_formats_st7110_raw, ARRAY_SIZE(isp_formats_st7110_raw) },
+};
+
+static void vin_buffer_done(struct vin_line *line, struct vin_params *params);
+static void vin_change_buffer(struct vin_line *line);
+static struct stfcamss_buffer *vin_buf_get_pending(struct vin_output *output);
+static void vin_output_init_addrs(struct vin_line *line);
+static void vin_init_outputs(struct vin_line *line);
+static struct v4l2_mbus_framefmt *
+__vin_get_format(struct vin_line *line,
+		struct v4l2_subdev_pad_config *cfg,
+		unsigned int pad,
+		enum v4l2_subdev_format_whence which);
+
+static char *get_line_subdevname(int line_id)
+{
+	char *name = NULL;
+
+	switch (line_id) {
+	case VIN_LINE_WR:
+		name = "wr";
+		break;
+	case VIN_LINE_ISP:
+		name = "isp0";
+		break;
+	case VIN_LINE_ISP_SS0:
+		name = "isp0_ss0";
+		break;
+	case VIN_LINE_ISP_SS1:
+		name = "isp0_ss1";
+		break;
+	case VIN_LINE_ISP_ITIW:
+		name = "isp0_itiw";
+		break;
+	case VIN_LINE_ISP_ITIR:
+		name = "isp0_itir";
+		break;
+	case VIN_LINE_ISP_RAW:
+		name = "isp0_raw";
+		break;
+	case VIN_LINE_ISP_SCD_Y:
+		name = "isp0_scd_y";
+		break;
+	default:
+		name = "unknow";
+		break;
+	}
+	return name;
+}
+
+static enum isp_line_id stf_vin_map_isp_line(enum vin_line_id line)
+{
+	enum isp_line_id line_id;
+
+	if ((line > VIN_LINE_WR) && (line < VIN_LINE_MAX)) {
+		line_id = line % STF_ISP_LINE_MAX;
+		if (line_id == 0)
+			line_id = STF_ISP_LINE_SRC_SCD_Y;
+	} else
+		line_id = STF_ISP_LINE_INVALID;
+
+	return line_id;
+}
+
+enum isp_pad_id stf_vin_map_isp_pad(enum vin_line_id line, enum isp_pad_id def)
+{
+	enum isp_pad_id pad_id;
+
+	if (line == VIN_LINE_WR)
+		pad_id = STF_ISP_PAD_SINK;
+	else if ((line > VIN_LINE_WR) && (line < VIN_LINE_MAX))
+		pad_id = stf_vin_map_isp_line(line);
+	else
+		pad_id = def;
+
+	return pad_id;
+}
+
+int stf_vin_subdev_init(struct stfcamss *stfcamss)
+{
+	struct stf_vin_dev *vin;
+	struct device *dev = stfcamss->dev;
+	struct stf_vin2_dev *vin_dev = stfcamss->vin_dev;
+	int i, ret = 0;
+
+	vin_dev->stfcamss = stfcamss;
+	vin_dev->hw_ops = &vin_ops;
+	vin_dev->hw_ops->isr_buffer_done = vin_buffer_done;
+	vin_dev->hw_ops->isr_change_buffer = vin_change_buffer;
+
+	vin = stfcamss->vin;
+	atomic_set(&vin_dev->ref_count, 0);
+
+	ret = devm_request_irq(dev,
+			vin->irq, vin_dev->hw_ops->vin_wr_irq_handler,
+			0, "vin_axiwr_irq", vin_dev);
+	if (ret) {
+		st_err(ST_VIN, "failed to request irq\n");
+		goto out;
+	}
+
+	ret = devm_request_irq(dev,
+			vin->isp_irq, vin_dev->hw_ops->vin_isp_irq_handler,
+			0, "vin_isp_irq", vin_dev);
+	if (ret) {
+		st_err(ST_VIN, "failed to request isp irq\n");
+		goto out;
+	}
+
+	st_info(ST_CAMSS, "%s, %d!\n", __func__, __LINE__);
+#ifdef ISP_USE_CSI_AND_SC_DONE_INTERRUPT
+	ret = devm_request_irq(dev,
+			vin->isp_csi_irq, vin_dev->hw_ops->vin_isp_csi_irq_handler,
+			0, "vin_isp_csi_irq", vin_dev);
+	if (ret) {
+		st_err(ST_VIN, "failed to request isp raw irq\n");
+		goto out;
+	}
+
+	ret = devm_request_irq(dev,
+			vin->isp_scd_irq, vin_dev->hw_ops->vin_isp_scd_irq_handler,
+			0, "vin_isp_scd_irq", vin_dev);
+	if (ret) {
+		st_err(ST_VIN, "failed to request isp scd irq\n");
+		goto out;
+	}
+#endif
+
+	ret = devm_request_irq(dev,
+			vin->isp_irq_csiline, vin_dev->hw_ops->vin_isp_irq_csiline_handler,
+			0, "vin_isp_irq_csiline", vin_dev);
+	if (ret) {
+		st_err(ST_VIN, "failed to request isp irq csiline\n");
+		goto out;
+	}
+
+	mutex_init(&vin_dev->power_lock);
+	vin_dev->power_count = 0;
+
+	for (i = 0; i < STF_DUMMY_MODULE_NUMS; i++) {
+		struct dummy_buffer *dummy_buffer = &vin_dev->dummy_buffer[i];
+
+		mutex_init(&dummy_buffer->stream_lock);
+		dummy_buffer->nums = i == 0 ? VIN_DUMMY_BUFFER_NUMS : ISP_DUMMY_BUFFER_NUMS;
+		dummy_buffer->stream_count = 0;
+		dummy_buffer->buffer = devm_kzalloc(dev,
+			dummy_buffer->nums * sizeof(struct vin_dummy_buffer), GFP_KERNEL);
+		atomic_set(&dummy_buffer->frame_skip, 0);
+	}
+
+	for (i = VIN_LINE_WR;
+		i < STF_ISP_LINE_MAX + 1; i++) {
+		struct vin_line *l = &vin_dev->line[i];
+		int is_mp;
+
+		is_mp = i == VIN_LINE_WR ? false : true;
+		is_mp = false;
+		if (stf_vin_map_isp_line(i) == STF_ISP_LINE_SRC_ITIR)
+			l->video_out.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		else
+			l->video_out.type = is_mp ? V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE :
+				V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		l->video_out.stfcamss = stfcamss;
+		l->id = i;
+		l->sdev_type = VIN_DEV_TYPE;
+		l->formats = vin2_formats_table[i].fmts;
+		l->nformats = vin2_formats_table[i].nfmts;
+		spin_lock_init(&l->output_lock);
+
+		mutex_init(&l->stream_lock);
+		l->stream_count = 0;
+		mutex_init(&l->power_lock);
+		l->power_count = 0;
+	}
+
+	return 0;
+out:
+	return ret;
+}
+
+static int vin_set_power(struct v4l2_subdev *sd, int on)
+{
+	struct vin_line *line = v4l2_get_subdevdata(sd);
+	struct stf_vin2_dev *vin_dev = line_to_vin2_dev(line);
+	struct stfcamss *stfcamss = vin_dev->stfcamss;
+
+	mutex_lock(&line->power_lock);
+	if (on) {
+		if (line->power_count == 0)
+			vin_init_outputs(line);
+		line->power_count++;
+	} else {
+		if (line->power_count == 0) {
+			st_err(ST_VIN,
+				"line power off on power_count == 0\n");
+			goto exit_line;
+		}
+		line->power_count--;
+	}
+exit_line:
+	mutex_unlock(&line->power_lock);
+
+	mutex_lock(&vin_dev->power_lock);
+	if (on) {
+		if (vin_dev->power_count == 0) {
+			pm_runtime_get_sync(stfcamss->dev);
+			vin_dev->hw_ops->vin_clk_enable(vin_dev);
+			vin_dev->hw_ops->vin_config_set(vin_dev);
+		}
+		vin_dev->power_count++;
+	} else {
+		if (vin_dev->power_count == 0) {
+			st_err(ST_VIN,
+				"vin_dev power off on power_count == 0\n");
+			goto exit;
+		}
+		if (vin_dev->power_count == 1) {
+			vin_dev->hw_ops->vin_clk_disable(vin_dev);
+			pm_runtime_put_sync(stfcamss->dev);
+		}
+		vin_dev->power_count--;
+	}
+exit:
+
+	mutex_unlock(&vin_dev->power_lock);
+
+	return 0;
+}
+
+static unsigned int get_frame_skip(struct vin_line *line)
+{
+	unsigned int frame_skip = 0;
+	unsigned int isp_ctrl_skip_frames = 0;
+	struct media_entity *sensor;
+	struct v4l2_subdev_frame_interval fi;
+
+	sensor = stfcamss_find_sensor(&line->subdev.entity);
+	if (sensor) {
+		int fps = 0;
+		struct v4l2_subdev *subdev =
+					media_entity_to_v4l2_subdev(sensor);
+
+		if (subdev->ops->video->g_frame_interval) {
+			if (!subdev->ops->video->g_frame_interval(subdev, &fi))
+				fps = fi.interval.denominator;
+
+			if (fps > 0 && fps <= 90)
+				isp_ctrl_skip_frames = fps * VIN_FRAME_DROP_SEC_FOR_ISP_CTRL;
+		}
+		if (!fps)
+			st_debug(ST_VIN, "%s, Failed to get sensor fps !\n", __func__);
+
+		if (isp_ctrl_skip_frames <= VIN_FRAME_DROP_MIN_VAL)
+			isp_ctrl_skip_frames = VIN_FRAME_DROP_MIN_VAL;
+
+		v4l2_subdev_call(subdev, sensor, g_skip_frames, &frame_skip);
+
+		frame_skip += isp_ctrl_skip_frames;
+
+		if (frame_skip > VIN_FRAME_DROP_MAX_VAL)
+			frame_skip = VIN_FRAME_DROP_MAX_VAL;
+		st_debug(ST_VIN, "%s, frame_skip %d\n", __func__, frame_skip);
+	}
+
+	return frame_skip;
+}
+
+static void vin_buf_l2cache_flush(struct vin_output *output)
+{
+	struct stfcamss_buffer *buffer = NULL;
+
+	if (!list_empty(&output->pending_bufs)) {
+		list_for_each_entry(buffer, &output->pending_bufs, queue) {
+			sifive_l2_flush64_range(buffer->addr[0], buffer->sizeimage);
+		}
+	}
+}
+
+static int vin_enable_output(struct vin_line *line)
+{
+	struct vin_output *output = &line->output;
+	unsigned long flags;
+
+	spin_lock_irqsave(&line->output_lock, flags);
+
+	output->state = VIN_OUTPUT_IDLE;
+
+	vin_buf_l2cache_flush(output);
+
+	output->buf[0] = vin_buf_get_pending(output);
+#ifdef VIN_TWO_BUFFER
+	if (line->id == VIN_LINE_WR)
+		output->buf[1] = vin_buf_get_pending(output);
+#endif
+	if (!output->buf[0] && output->buf[1]) {
+		output->buf[0] = output->buf[1];
+		output->buf[1] = NULL;
+	}
+
+	if (output->buf[0])
+		output->state = VIN_OUTPUT_SINGLE;
+
+#ifdef VIN_TWO_BUFFER
+	if (output->buf[1] && line->id == VIN_LINE_WR)
+		output->state = VIN_OUTPUT_CONTINUOUS;
+#endif
+	output->sequence = 0;
+
+	vin_output_init_addrs(line);
+	spin_unlock_irqrestore(&line->output_lock, flags);
+	return 0;
+}
+
+static int vin_disable_output(struct vin_line *line)
+{
+	struct vin_output *output = &line->output;
+	unsigned long flags;
+
+	spin_lock_irqsave(&line->output_lock, flags);
+
+	output->state = VIN_OUTPUT_OFF;
+
+	spin_unlock_irqrestore(&line->output_lock, flags);
+	return 0;
+}
+
+static u32 line_to_dummy_module(struct vin_line *line)
+{
+	u32 dummy_module = 0;
+
+	switch (line->id) {
+	case VIN_LINE_WR:
+		dummy_module = STF_DUMMY_VIN;
+		break;
+	case VIN_LINE_ISP:
+	case VIN_LINE_ISP_SS0:
+	case VIN_LINE_ISP_SS1:
+	case VIN_LINE_ISP_ITIW:
+	case VIN_LINE_ISP_ITIR:
+	case VIN_LINE_ISP_RAW:
+	case VIN_LINE_ISP_SCD_Y:
+		dummy_module = STF_DUMMY_ISP;
+		break;
+	default:
+		dummy_module = STF_DUMMY_VIN;
+		break;
+	}
+
+	return dummy_module;
+}
+
+static int vin_alloc_dummy_buffer(struct stf_vin2_dev *vin_dev,
+		struct v4l2_mbus_framefmt *fmt, int dummy_module)
+{
+	struct device *dev = vin_dev->stfcamss->dev;
+	struct dummy_buffer *dummy_buffer = &vin_dev->dummy_buffer[dummy_module];
+	struct vin_dummy_buffer *buffer = NULL;
+	int ret = 0, i;
+	u32 aligns;
+
+	for (i = 0; i < dummy_buffer->nums; i++) {
+		buffer = &vin_dev->dummy_buffer[dummy_module].buffer[i];
+		buffer->width = fmt->width;
+		buffer->height = fmt->height;
+		buffer->mcode = fmt->code;
+		if (i == STF_VIN_PAD_SINK) {
+			aligns = ALIGN(fmt->width * 4, STFCAMSS_FRAME_WIDTH_ALIGN_8);
+			buffer->buffer_size = PAGE_ALIGN(aligns * fmt->height);
+		} else if (i == STF_ISP_PAD_SRC
+			|| i == STF_ISP_PAD_SRC_SS0
+			|| i == STF_ISP_PAD_SRC_SS1) {
+			aligns = ALIGN(fmt->width, STFCAMSS_FRAME_WIDTH_ALIGN_8);
+			buffer->buffer_size = PAGE_ALIGN(aligns * fmt->height * 3 / 2);
+		} else if (i == STF_ISP_PAD_SRC_ITIW
+			|| i == STF_ISP_PAD_SRC_ITIR) {
+			aligns = ALIGN(fmt->width, STFCAMSS_FRAME_WIDTH_ALIGN_8);
+			buffer->buffer_size = PAGE_ALIGN(aligns * fmt->height * 3);
+		} else if (i == STF_ISP_PAD_SRC_RAW) {
+			aligns = ALIGN(fmt->width * ISP_RAW_DATA_BITS / 8,
+					STFCAMSS_FRAME_WIDTH_ALIGN_128);
+			buffer->buffer_size = PAGE_ALIGN(aligns * fmt->height);
+		} else if (i == STF_ISP_PAD_SRC_SCD_Y)
+			buffer->buffer_size = PAGE_ALIGN(ISP_SCD_Y_BUFFER_SIZE);
+		else
+			continue;
+
+		buffer->vaddr = dma_alloc_coherent(dev, buffer->buffer_size,
+				&buffer->paddr[0], GFP_DMA | GFP_KERNEL);
+
+		if (buffer->vaddr) {
+			if (i == STF_ISP_PAD_SRC
+				|| i == STF_ISP_PAD_SRC_SS0
+				|| i == STF_ISP_PAD_SRC_SS1
+				|| i == STF_ISP_PAD_SRC_ITIW
+				|| i == STF_ISP_PAD_SRC_ITIR)
+				buffer->paddr[1] = (dma_addr_t)(buffer->paddr[0] +
+									aligns * fmt->height);
+			else if (i == STF_ISP_PAD_SRC_SCD_Y)
+				buffer->paddr[1] = (dma_addr_t)(buffer->paddr[0] +
+									ISP_YHIST_BUFFER_SIZE);
+			else
+				st_debug(ST_VIN, "signal plane\n");
+		}
+		{
+			char szPadName[][32] = {
+				"VIN_PAD_SINK",
+				"ISP_PAD_SRC",
+				"ISP_PAD_SRC_SS0",
+				"ISP_PAD_SRC_SS1",
+				"ISP_PAD_SRC_ITIW",
+				"ISP_PAD_SRC_ITIR",
+				"ISP_PAD_SRC_RAW",
+				"ISP_PAD_SRC_SCD_Y",
+				"Unknown Pad"
+			};
+
+			st_debug(ST_VIN, "%s: i = %d(%s) addr[0] = %llx, addr[1] = %llx, size = %u bytes\n",
+				__func__,
+				i,
+				szPadName[i],
+				buffer->paddr[0],
+				buffer->paddr[1],
+				buffer->buffer_size
+				);
+		}
+	}
+
+	return ret;
+}
+
+static void vin_free_dummy_buffer(struct stf_vin2_dev *vin_dev, int dummy_module)
+{
+	struct device *dev = vin_dev->stfcamss->dev;
+	struct dummy_buffer *dummy_buffer = &vin_dev->dummy_buffer[dummy_module];
+	struct vin_dummy_buffer *buffer = NULL;
+	int i;
+
+	for (i = 0; i < dummy_buffer->nums; i++) {
+		buffer = &dummy_buffer->buffer[i];
+		if (buffer->vaddr)
+			dma_free_coherent(dev, buffer->buffer_size,
+						buffer->vaddr, buffer->paddr[0]);
+		memset(buffer, 0, sizeof(struct vin_dummy_buffer));
+	}
+}
+
+static void vin_set_dummy_buffer(struct vin_line *line, u32 pad)
+{
+	struct stf_vin2_dev *vin_dev = line_to_vin2_dev(line);
+	int dummy_module = line_to_dummy_module(line);
+	struct dummy_buffer *dummy_buffer = &vin_dev->dummy_buffer[dummy_module];
+	struct vin_dummy_buffer *buffer = NULL;
+
+	switch (pad) {
+	case STF_VIN_PAD_SINK:
+		if (line->id == VIN_LINE_WR) {
+			buffer = &dummy_buffer->buffer[STF_VIN_PAD_SINK];
+			vin_dev->hw_ops->vin_wr_set_ping_addr(vin_dev, buffer->paddr[0]);
+			vin_dev->hw_ops->vin_wr_set_pong_addr(vin_dev, buffer->paddr[0]);
+		} else {
+			buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC];
+			vin_dev->hw_ops->vin_isp_set_yuv_addr(vin_dev,
+				buffer->paddr[0], buffer->paddr[1]);
+
+			buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_SS0];
+			vin_dev->hw_ops->vin_isp_set_ss0_addr(vin_dev,
+				buffer->paddr[0], buffer->paddr[1]);
+
+			buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_SS1];
+			vin_dev->hw_ops->vin_isp_set_ss1_addr(vin_dev,
+				buffer->paddr[0], buffer->paddr[1]);
+
+			buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_ITIW];
+			vin_dev->hw_ops->vin_isp_set_itiw_addr(vin_dev,
+				buffer->paddr[0], buffer->paddr[1]);
+
+			buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_ITIR];
+			vin_dev->hw_ops->vin_isp_set_itir_addr(vin_dev,
+				buffer->paddr[0], buffer->paddr[1]);
+
+			buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_RAW];
+			vin_dev->hw_ops->vin_isp_set_raw_addr(vin_dev, buffer->paddr[0]);
+
+			buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_SCD_Y];
+			vin_dev->hw_ops->vin_isp_set_scd_addr(vin_dev,
+				buffer->paddr[0], buffer->paddr[1], AWB_TYPE);
+		}
+		break;
+	case STF_ISP_PAD_SRC:
+		buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC];
+		vin_dev->hw_ops->vin_isp_set_yuv_addr(vin_dev,
+			buffer->paddr[0], buffer->paddr[1]);
+		break;
+	case STF_ISP_PAD_SRC_SS0:
+		buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_SS0];
+		vin_dev->hw_ops->vin_isp_set_ss0_addr(vin_dev,
+			buffer->paddr[0], buffer->paddr[1]);
+		break;
+	case STF_ISP_PAD_SRC_SS1:
+		buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_SS1];
+		vin_dev->hw_ops->vin_isp_set_ss1_addr(vin_dev,
+			buffer->paddr[0], buffer->paddr[1]);
+		break;
+	case STF_ISP_PAD_SRC_ITIW:
+		buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_ITIW];
+		vin_dev->hw_ops->vin_isp_set_itiw_addr(vin_dev,
+			buffer->paddr[0], buffer->paddr[1]);
+		break;
+	case STF_ISP_PAD_SRC_ITIR:
+		buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_ITIR];
+		vin_dev->hw_ops->vin_isp_set_itir_addr(vin_dev,
+			buffer->paddr[0], buffer->paddr[1]);
+		break;
+	case STF_ISP_PAD_SRC_RAW:
+		buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_RAW];
+		vin_dev->hw_ops->vin_isp_set_raw_addr(vin_dev, buffer->paddr[0]);
+		break;
+	case STF_ISP_PAD_SRC_SCD_Y:
+		buffer = &dummy_buffer->buffer[STF_ISP_PAD_SRC_SCD_Y];
+		vin_dev->hw_ops->vin_isp_set_scd_addr(vin_dev,
+			buffer->paddr[0], buffer->paddr[1], AWB_TYPE);
+		break;
+	default:
+		break;
+	}
+}
+
+static int vin_set_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct vin_line *line = v4l2_get_subdevdata(sd);
+	struct stf_vin2_dev *vin_dev = line_to_vin2_dev(line);
+	int dummy_module = line_to_dummy_module(line);
+	struct dummy_buffer *dummy_buffer = &vin_dev->dummy_buffer[dummy_module];
+	struct v4l2_mbus_framefmt *fmt;
+
+	st_debug(ST_VIN, "%s, %d\n", __func__, __LINE__);
+	fmt = __vin_get_format(line, NULL, STF_VIN_PAD_SINK, V4L2_SUBDEV_FORMAT_ACTIVE);
+	mutex_lock(&dummy_buffer->stream_lock);
+	if (enable) {
+		if (dummy_buffer->stream_count == 0) {
+			vin_alloc_dummy_buffer(vin_dev, fmt, dummy_module);
+			vin_set_dummy_buffer(line, STF_VIN_PAD_SINK);
+			atomic_set(&dummy_buffer->frame_skip, get_frame_skip(line));
+		}
+		dummy_buffer->stream_count++;
+	} else {
+		if (dummy_buffer->stream_count == 1) {
+			vin_free_dummy_buffer(vin_dev, dummy_module);
+			// set buffer addr to zero
+			vin_set_dummy_buffer(line, STF_VIN_PAD_SINK);
+		} else
+			vin_set_dummy_buffer(line,
+					stf_vin_map_isp_pad(line->id, STF_ISP_PAD_SINK));
+
+		dummy_buffer->stream_count--;
+	}
+	mutex_unlock(&dummy_buffer->stream_lock);
+
+	mutex_lock(&line->stream_lock);
+	if (enable) {
+		if (line->stream_count == 0) {
+			if (line->id == VIN_LINE_WR) {
+				vin_dev->hw_ops->vin_wr_irq_enable(vin_dev, 1);
+				vin_dev->hw_ops->vin_wr_stream_set(vin_dev, 1);
+			}
+		}
+		line->stream_count++;
+	} else {
+		if (line->stream_count == 1) {
+			if (line->id == VIN_LINE_WR) {
+				vin_dev->hw_ops->vin_wr_irq_enable(vin_dev, 0);
+				vin_dev->hw_ops->vin_wr_stream_set(vin_dev, 0);
+			}
+		}
+		line->stream_count--;
+	}
+	mutex_unlock(&line->stream_lock);
+
+	if (enable)
+		vin_enable_output(line);
+	else
+		vin_disable_output(line);
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+__vin_get_format(struct vin_line *line,
+		struct v4l2_subdev_pad_config *cfg,
+		unsigned int pad,
+		enum v4l2_subdev_format_whence which)
+{
+	if (which == V4L2_SUBDEV_FORMAT_TRY)
+		return v4l2_subdev_get_try_format(&line->subdev, cfg, pad);
+	return &line->fmt[pad];
+}
+
+static void vin_try_format(struct vin_line *line,
+				struct v4l2_subdev_pad_config *cfg,
+				unsigned int pad,
+				struct v4l2_mbus_framefmt *fmt,
+				enum v4l2_subdev_format_whence which)
+{
+	unsigned int i;
+
+	switch (pad) {
+	case STF_VIN_PAD_SINK:
+		/* Set format on sink pad */
+
+		for (i = 0; i < line->nformats; i++)
+			if (fmt->code == line->formats[i].code)
+				break;
+
+		/* If not found, use UYVY as default */
+		if (i >= line->nformats)
+			fmt->code = line->formats[0].code;
+
+		fmt->width = clamp_t(u32,
+				fmt->width, STFCAMSS_FRAME_MIN_WIDTH, STFCAMSS_FRAME_MAX_WIDTH);
+		fmt->height = clamp_t(u32,
+				fmt->height, STFCAMSS_FRAME_MIN_HEIGHT, STFCAMSS_FRAME_MAX_HEIGHT);
+
+		fmt->field = V4L2_FIELD_NONE;
+		fmt->colorspace = V4L2_COLORSPACE_SRGB;
+		fmt->flags = 0;
+
+		break;
+
+	case STF_VIN_PAD_SRC:
+		/* Set and return a format same as sink pad */
+		*fmt = *__vin_get_format(line, cfg, STF_VIN_PAD_SINK, which);
+		break;
+	}
+
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+}
+
+static int vin_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct vin_line *line = v4l2_get_subdevdata(sd);
+
+	if (code->index >= line->nformats)
+		return -EINVAL;
+	if (code->pad == STF_VIN_PAD_SINK) {
+		code->code = line->formats[code->index].code;
+	} else {
+		struct v4l2_mbus_framefmt *sink_fmt;
+
+		sink_fmt = __vin_get_format(line, cfg, STF_VIN_PAD_SINK,
+					code->which);
+
+		code->code = sink_fmt->code;
+		if (!code->code)
+			return -EINVAL;
+	}
+	code->flags = 0;
+
+	return 0;
+}
+
+static int vin_enum_frame_size(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct vin_line *line = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt format;
+
+	if (fse->index != 0)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = 1;
+	format.height = 1;
+	vin_try_format(line, cfg, fse->pad, &format, fse->which);
+	fse->min_width = format.width;
+	fse->min_height = format.height;
+
+	if (format.code != fse->code)
+		return -EINVAL;
+
+	format.code = fse->code;
+	format.width = -1;
+	format.height = -1;
+	vin_try_format(line, cfg, fse->pad, &format, fse->which);
+	fse->max_width = format.width;
+	fse->max_height = format.height;
+
+	return 0;
+}
+
+static int vin_get_format(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct vin_line *line = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	format = __vin_get_format(line, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	fmt->format = *format;
+
+	return 0;
+}
+
+static int vin_set_format(struct v4l2_subdev *sd,
+			struct v4l2_subdev_pad_config *cfg,
+			struct v4l2_subdev_format *fmt)
+{
+	struct vin_line *line = v4l2_get_subdevdata(sd);
+	struct v4l2_mbus_framefmt *format;
+
+	st_debug(ST_VIDEO, "%s, pad %d, fmt code  %x\n",
+			__func__, fmt->pad, fmt->format.code);
+
+	format = __vin_get_format(line, cfg, fmt->pad, fmt->which);
+	if (format == NULL)
+		return -EINVAL;
+
+	mutex_lock(&line->stream_lock);
+	if (line->stream_count) {
+		fmt->format = *format;
+		mutex_unlock(&line->stream_lock);
+		goto out;
+	} else {
+		vin_try_format(line, cfg, fmt->pad, &fmt->format, fmt->which);
+		*format = fmt->format;
+	}
+	mutex_unlock(&line->stream_lock);
+
+	if (fmt->pad == STF_VIN_PAD_SINK) {
+		/* Propagate the format from sink to source */
+		format = __vin_get_format(line, cfg, STF_VIN_PAD_SRC,
+					fmt->which);
+
+		*format = fmt->format;
+		vin_try_format(line, cfg, STF_VIN_PAD_SRC, format,
+					fmt->which);
+	}
+
+out:
+	return 0;
+}
+
+static int vin_init_formats(struct v4l2_subdev *sd,
+			struct v4l2_subdev_fh *fh)
+{
+	struct v4l2_subdev_format format = {
+		.pad = STF_VIN_PAD_SINK,
+		.which = fh ? V4L2_SUBDEV_FORMAT_TRY :
+				V4L2_SUBDEV_FORMAT_ACTIVE,
+		.format = {
+			.code = MEDIA_BUS_FMT_RGB565_2X8_LE,
+			.width = 1920,
+			.height = 1080
+		}
+	};
+
+	return vin_set_format(sd, fh ? fh->pad : NULL, &format);
+}
+
+static void vin_output_init_addrs(struct vin_line *line)
+{
+	struct vin_output *output = &line->output;
+	struct stf_vin2_dev *vin_dev = line_to_vin2_dev(line);
+	dma_addr_t ping_addr;
+	dma_addr_t pong_addr;
+	dma_addr_t y_addr, uv_addr;
+
+	output->active_buf = 0;
+
+	if (output->buf[0]) {
+		ping_addr = output->buf[0]->addr[0];
+		y_addr = output->buf[0]->addr[0];
+		uv_addr = output->buf[0]->addr[1];
+	} else
+		return;
+
+	if (output->buf[1])
+		pong_addr = output->buf[1]->addr[0];
+	else
+		pong_addr = ping_addr;
+
+	switch (stf_vin_map_isp_line(line->id)) {
+	case STF_ISP_LINE_SRC:
+		vin_dev->hw_ops->vin_isp_set_yuv_addr(vin_dev,
+			y_addr, uv_addr);
+		break;
+	case STF_ISP_LINE_SRC_SS0:
+		vin_dev->hw_ops->vin_isp_set_ss0_addr(vin_dev,
+			y_addr, uv_addr);
+		break;
+	case STF_ISP_LINE_SRC_SS1:
+		vin_dev->hw_ops->vin_isp_set_ss1_addr(vin_dev,
+			y_addr, uv_addr);
+		break;
+	case STF_ISP_LINE_SRC_ITIW:
+		vin_dev->hw_ops->vin_isp_set_itiw_addr(vin_dev,
+			y_addr, uv_addr);
+		break;
+	case STF_ISP_LINE_SRC_ITIR:
+		vin_dev->hw_ops->vin_isp_set_itir_addr(vin_dev,
+			y_addr, uv_addr);
+		break;
+	case STF_ISP_LINE_SRC_RAW:
+		vin_dev->hw_ops->vin_isp_set_raw_addr(vin_dev, y_addr);
+		break;
+	case STF_ISP_LINE_SRC_SCD_Y:
+		output->frame_skip = ISP_AWB_OECF_SKIP_FRAME;
+		vin_dev->hw_ops->vin_isp_set_scd_addr(vin_dev,
+			y_addr, uv_addr, AWB_TYPE);
+		break;
+	default:
+		if (line->id == VIN_LINE_WR) {
+			vin_dev->hw_ops->vin_wr_set_ping_addr(vin_dev, ping_addr);
+#ifdef VIN_TWO_BUFFER
+			vin_dev->hw_ops->vin_wr_set_pong_addr(vin_dev, pong_addr);
+#else
+			vin_dev->hw_ops->vin_wr_set_pong_addr(vin_dev, ping_addr);
+#endif
+		}
+		break;
+	}
+}
+
+static void vin_init_outputs(struct vin_line *line)
+{
+	struct vin_output *output = &line->output;
+
+	output->state = VIN_OUTPUT_OFF;
+	output->buf[0] = NULL;
+	output->buf[1] = NULL;
+	output->active_buf = 0;
+	INIT_LIST_HEAD(&output->pending_bufs);
+	INIT_LIST_HEAD(&output->ready_bufs);
+}
+
+static void vin_buf_add_ready(struct vin_output *output,
+				struct stfcamss_buffer *buffer)
+{
+	INIT_LIST_HEAD(&buffer->queue);
+	list_add_tail(&buffer->queue, &output->ready_bufs);
+}
+
+static struct stfcamss_buffer *vin_buf_get_ready(struct vin_output *output)
+{
+	struct stfcamss_buffer *buffer = NULL;
+
+	if (!list_empty(&output->ready_bufs)) {
+		buffer = list_first_entry(&output->ready_bufs,
+					struct stfcamss_buffer,
+					queue);
+		list_del(&buffer->queue);
+	}
+
+	return buffer;
+}
+
+static void vin_buf_add_pending(struct vin_output *output,
+				struct stfcamss_buffer *buffer)
+{
+	INIT_LIST_HEAD(&buffer->queue);
+	list_add_tail(&buffer->queue, &output->pending_bufs);
+}
+
+static struct stfcamss_buffer *vin_buf_get_pending(struct vin_output *output)
+{
+	struct stfcamss_buffer *buffer = NULL;
+
+	if (!list_empty(&output->pending_bufs)) {
+		buffer = list_first_entry(&output->pending_bufs,
+					struct stfcamss_buffer,
+					queue);
+		list_del(&buffer->queue);
+	}
+
+	return buffer;
+}
+
+#ifdef UNUSED_CODE
+static void vin_output_checkpending(struct vin_line *line)
+{
+	struct vin_output *output = &line->output;
+
+	if (output->state == VIN_OUTPUT_STOPPING) {
+		/* Release last buffer when hw is idle */
+		if (output->last_buffer) {
+			// vb2_buffer_done(&output->last_buffer->vb.vb2_buf,
+			//		VB2_BUF_STATE_DONE);
+			vin_buf_add_pending(output, output->last_buffer);
+			output->last_buffer = NULL;
+		}
+		output->state = VIN_OUTPUT_IDLE;
+
+		/* Buffers received in stopping state are queued in */
+		/* dma pending queue, start next capture here */
+		output->buf[0] = vin_buf_get_pending(output);
+#ifdef VIN_TWO_BUFFER
+		if (line->id == VIN_LINE_WR)
+			output->buf[1] = vin_buf_get_pending(output);
+#endif
+
+		if (!output->buf[0] && output->buf[1]) {
+			output->buf[0] = output->buf[1];
+			output->buf[1] = NULL;
+		}
+
+		if (output->buf[0])
+			output->state = VIN_OUTPUT_SINGLE;
+
+#ifdef VIN_TWO_BUFFER
+		if (output->buf[1] && line->id == VIN_LINE_WR)
+			output->state = VIN_OUTPUT_CONTINUOUS;
+#endif
+		vin_output_init_addrs(line);
+	}
+}
+#endif
+
+static void vin_buf_update_on_last(struct vin_line *line)
+{
+	struct vin_output *output = &line->output;
+
+	switch (output->state) {
+	case VIN_OUTPUT_CONTINUOUS:
+		output->state = VIN_OUTPUT_SINGLE;
+		output->active_buf = !output->active_buf;
+		break;
+	case VIN_OUTPUT_SINGLE:
+		output->state = VIN_OUTPUT_STOPPING;
+		break;
+	default:
+		st_err_ratelimited(ST_VIN,
+				"Last buff in wrong state! %d\n",
+				output->state);
+		break;
+	}
+}
+
+static void vin_buf_update_on_next(struct vin_line *line)
+{
+	struct vin_output *output = &line->output;
+
+	switch (output->state) {
+	case VIN_OUTPUT_CONTINUOUS:
+		output->active_buf = !output->active_buf;
+		break;
+	case VIN_OUTPUT_SINGLE:
+	default:
+#ifdef VIN_TWO_BUFFER
+		if (line->id == VIN_LINE_WR)
+			st_err_ratelimited(ST_VIN,
+				"Next buf in wrong state! %d\n",
+				output->state);
+#endif
+		break;
+	}
+}
+
+static void vin_buf_update_on_new(struct vin_line *line,
+				struct vin_output *output,
+				struct stfcamss_buffer *new_buf)
+{
+#ifdef VIN_TWO_BUFFER
+	struct stf_vin2_dev *vin_dev = line_to_vin2_dev(line);
+	int inactive_idx;
+#endif
+
+	switch (output->state) {
+	case VIN_OUTPUT_SINGLE:
+#ifdef VIN_TWO_BUFFER
+		int inactive_idx = !output->active_buf;
+
+		if (!output->buf[inactive_idx] && line->id == VIN_LINE_WR) {
+			output->buf[inactive_idx] = new_buf;
+			if (inactive_idx)
+				vin_dev->hw_ops->vin_wr_set_pong_addr(vin_dev,
+						output->buf[1]->addr[0]);
+			else
+				vin_dev->hw_ops->vin_wr_set_ping_addr(vin_dev,
+						output->buf[0]->addr[0]);
+			output->state = VIN_OUTPUT_CONTINUOUS;
+
+		} else {
+			vin_buf_add_pending(output, new_buf);
+			if (line->id == VIN_LINE_WR)
+				st_warn(ST_VIN, "Inactive buffer is busy\n");
+		}
+#else
+		vin_buf_add_pending(output, new_buf);
+#endif
+		break;
+	case VIN_OUTPUT_IDLE:
+		st_warn(ST_VIN,	"Output idle buffer set!\n");
+		if (!output->buf[0]) {
+			output->buf[0] = new_buf;
+			vin_output_init_addrs(line);
+			output->state = VIN_OUTPUT_SINGLE;
+		} else {
+			vin_buf_add_pending(output, new_buf);
+			st_warn(ST_VIN,	"Output idle with buffer set!\n");
+		}
+		break;
+	case VIN_OUTPUT_STOPPING:
+		if (output->last_buffer) {
+			output->buf[output->active_buf] = output->last_buffer;
+			output->last_buffer = NULL;
+		} else
+			st_err(ST_VIN,	"stop state lost lastbuffer!\n");
+		output->state = VIN_OUTPUT_SINGLE;
+		// vin_output_checkpending(line);
+		vin_buf_add_pending(output, new_buf);
+		break;
+	case VIN_OUTPUT_CONTINUOUS:
+	default:
+		vin_buf_add_pending(output, new_buf);
+		break;
+	}
+}
+
+static void vin_buf_flush(struct vin_output *output,
+				enum vb2_buffer_state state)
+{
+	struct stfcamss_buffer *buf;
+	struct stfcamss_buffer *t;
+
+	list_for_each_entry_safe(buf, t, &output->pending_bufs, queue) {
+		vb2_buffer_done(&buf->vb.vb2_buf, state);
+		list_del(&buf->queue);
+	}
+	list_for_each_entry_safe(buf, t, &output->ready_bufs, queue) {
+		vb2_buffer_done(&buf->vb.vb2_buf, state);
+		list_del(&buf->queue);
+	}
+}
+
+static void vin_buffer_done(struct vin_line *line, struct vin_params *params)
+{
+	struct stfcamss_buffer *ready_buf;
+	struct vin_output *output = &line->output;
+	unsigned long flags;
+	u64 ts = ktime_get_ns();
+
+	if (output->state == VIN_OUTPUT_OFF
+		|| output->state == VIN_OUTPUT_RESERVED)
+		return;
+
+	spin_lock_irqsave(&line->output_lock, flags);
+
+	while ((ready_buf = vin_buf_get_ready(output))) {
+		ready_buf->vb.vb2_buf.timestamp = ts;
+		ready_buf->vb.sequence = output->sequence++;
+
+		/* The stf_isp_ctrl currently buffered with mmap,
+		 * which will not update cache by default.
+		 * Flush L2 cache to make sure data is updated.
+		 */
+		if (ready_buf->vb.vb2_buf.memory == VB2_MEMORY_MMAP)
+			sifive_l2_flush64_range(ready_buf->addr[0], ready_buf->sizeimage);
+
+		vb2_buffer_done(&ready_buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
+	}
+
+	spin_unlock_irqrestore(&line->output_lock, flags);
+}
+
+static void vin_change_buffer(struct vin_line *line)
+{
+	struct stfcamss_buffer *ready_buf;
+	struct vin_output *output = &line->output;
+	struct stf_vin2_dev *vin_dev = line_to_vin2_dev(line);
+	dma_addr_t *new_addr;
+	unsigned long flags;
+	u32 active_index;
+	int scd_type;
+
+	if (output->state == VIN_OUTPUT_OFF
+		|| output->state == VIN_OUTPUT_STOPPING
+		|| output->state == VIN_OUTPUT_RESERVED
+		|| output->state == VIN_OUTPUT_IDLE)
+		return;
+
+	spin_lock_irqsave(&line->output_lock, flags);
+
+	active_index = output->active_buf;
+
+	ready_buf = output->buf[active_index];
+	if (!ready_buf) {
+		st_err_ratelimited(ST_VIN,
+					"Missing ready buf %d %d!\n",
+					active_index, output->state);
+		active_index = !active_index;
+		ready_buf = output->buf[active_index];
+		if (!ready_buf) {
+			st_err_ratelimited(ST_VIN,
+					"Missing ready buf 2 %d %d!\n",
+					active_index, output->state);
+			goto out_unlock;
+		}
+	}
+
+	/* Get next buffer */
+	output->buf[active_index] = vin_buf_get_pending(output);
+	if (!output->buf[active_index]) {
+		/* No next buffer - set same address */
+		new_addr = ready_buf->addr;
+		vin_buf_update_on_last(line);
+	} else {
+		new_addr = output->buf[active_index]->addr;
+		vin_buf_update_on_next(line);
+	}
+
+	if (output->state == VIN_OUTPUT_STOPPING)
+		output->last_buffer = ready_buf;
+	else {
+		switch (stf_vin_map_isp_line(line->id)) {
+		case STF_ISP_LINE_SRC:
+			vin_dev->hw_ops->vin_isp_set_yuv_addr(vin_dev,
+				new_addr[0], new_addr[1]);
+			break;
+		case STF_ISP_LINE_SRC_SS0:
+			vin_dev->hw_ops->vin_isp_set_ss0_addr(vin_dev,
+				new_addr[0], new_addr[1]);
+			break;
+		case STF_ISP_LINE_SRC_SS1:
+			vin_dev->hw_ops->vin_isp_set_ss1_addr(vin_dev,
+				new_addr[0], new_addr[1]);
+			break;
+		case STF_ISP_LINE_SRC_ITIW:
+			vin_dev->hw_ops->vin_isp_set_itiw_addr(vin_dev,
+				new_addr[0], new_addr[1]);
+			break;
+		case STF_ISP_LINE_SRC_ITIR:
+			vin_dev->hw_ops->vin_isp_set_itir_addr(vin_dev,
+				new_addr[0], new_addr[1]);
+			break;
+		case STF_ISP_LINE_SRC_RAW:
+			vin_dev->hw_ops->vin_isp_set_raw_addr(vin_dev, new_addr[0]);
+			break;
+		case STF_ISP_LINE_SRC_SCD_Y:
+			scd_type = vin_dev->hw_ops->vin_isp_get_scd_type(vin_dev);
+			ready_buf->vb.flags &= ~(V4L2_BUF_FLAG_PFRAME | V4L2_BUF_FLAG_BFRAME);
+			if (scd_type == AWB_TYPE)
+				ready_buf->vb.flags |= V4L2_BUF_FLAG_PFRAME;
+			else
+				ready_buf->vb.flags |= V4L2_BUF_FLAG_BFRAME;
+			if (!output->frame_skip) {
+				output->frame_skip = ISP_AWB_OECF_SKIP_FRAME;
+				scd_type = scd_type == AWB_TYPE ? OECF_TYPE : AWB_TYPE;
+			} else {
+				output->frame_skip--;
+				scd_type = scd_type == AWB_TYPE ? AWB_TYPE : OECF_TYPE;
+			}
+			vin_dev->hw_ops->vin_isp_set_scd_addr(vin_dev,
+				new_addr[0], new_addr[1], scd_type);
+			break;
+		default:
+			if (line->id == VIN_LINE_WR) {
+#ifdef VIN_TWO_BUFFER
+				if (active_index)
+					vin_dev->hw_ops->vin_wr_set_pong_addr(vin_dev,
+							new_addr[0]);
+				else
+					vin_dev->hw_ops->vin_wr_set_ping_addr(vin_dev,
+							new_addr[0]);
+#else
+				vin_dev->hw_ops->vin_wr_set_ping_addr(vin_dev,
+							new_addr[0]);
+				vin_dev->hw_ops->vin_wr_set_pong_addr(vin_dev,
+							new_addr[0]);
+#endif
+			}
+			break;
+		}
+
+		vin_buf_add_ready(output, ready_buf);
+	}
+
+	spin_unlock_irqrestore(&line->output_lock, flags);
+	return;
+
+out_unlock:
+	spin_unlock_irqrestore(&line->output_lock, flags);
+}
+
+static int vin_queue_buffer(struct stfcamss_video *vid,
+				struct stfcamss_buffer *buf)
+{
+	struct vin_line *line = container_of(vid, struct vin_line, video_out);
+	struct vin_output *output;
+	unsigned long flags;
+
+
+	output = &line->output;
+
+	spin_lock_irqsave(&line->output_lock, flags);
+
+	vin_buf_update_on_new(line, output, buf);
+
+	spin_unlock_irqrestore(&line->output_lock, flags);
+
+	return 0;
+}
+
+static int vin_flush_buffers(struct stfcamss_video *vid,
+				enum vb2_buffer_state state)
+{
+	struct vin_line *line = container_of(vid, struct vin_line, video_out);
+	struct vin_output *output = &line->output;
+	unsigned long flags;
+
+	spin_lock_irqsave(&line->output_lock, flags);
+
+	vin_buf_flush(output, state);
+	if (output->buf[0])
+		vb2_buffer_done(&output->buf[0]->vb.vb2_buf, state);
+
+	if (output->buf[1])
+		vb2_buffer_done(&output->buf[1]->vb.vb2_buf, state);
+
+	if (output->last_buffer) {
+		vb2_buffer_done(&output->last_buffer->vb.vb2_buf, state);
+		output->last_buffer = NULL;
+	}
+	output->buf[0] = output->buf[1] = NULL;
+
+	spin_unlock_irqrestore(&line->output_lock, flags);
+	return 0;
+}
+
+static int vin_link_setup(struct media_entity *entity,
+			const struct media_pad *local,
+			const struct media_pad *remote, u32 flags)
+{
+	if (flags & MEDIA_LNK_FL_ENABLED)
+		if (media_entity_remote_pad(local))
+			return -EBUSY;
+	return 0;
+}
+
+static const struct v4l2_subdev_core_ops vin_core_ops = {
+	.s_power = vin_set_power,
+};
+
+static const struct v4l2_subdev_video_ops vin_video_ops = {
+	.s_stream = vin_set_stream,
+};
+
+static const struct v4l2_subdev_pad_ops vin_pad_ops = {
+	.enum_mbus_code   = vin_enum_mbus_code,
+	.enum_frame_size  = vin_enum_frame_size,
+	.get_fmt          = vin_get_format,
+	.set_fmt          = vin_set_format,
+};
+
+static const struct v4l2_subdev_ops vin_v4l2_ops = {
+	.core = &vin_core_ops,
+	.video = &vin_video_ops,
+	.pad = &vin_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops vin_v4l2_internal_ops = {
+	.open = vin_init_formats,
+};
+
+static const struct stfcamss_video_ops stfcamss_vin_video_ops = {
+	.queue_buffer = vin_queue_buffer,
+	.flush_buffers = vin_flush_buffers,
+};
+
+static const struct media_entity_operations vin_media_ops = {
+	.link_setup = vin_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+int stf_vin_register(struct stf_vin2_dev *vin_dev, struct v4l2_device *v4l2_dev)
+{
+	struct v4l2_subdev *sd;
+	struct stfcamss_video *video_out;
+	struct media_pad *pads;
+	int ret;
+	int i;
+
+	for (i = 0; i < STF_ISP_LINE_MAX + 1; i++) {
+		char name[32];
+		char *sub_name = get_line_subdevname(i);
+		int is_mp;
+
+#ifdef	STF_CAMSS_SKIP_ITI
+		if ((stf_vin_map_isp_line(i) == STF_ISP_LINE_SRC_ITIW) ||
+			(stf_vin_map_isp_line(i) == STF_ISP_LINE_SRC_ITIR))
+			continue;
+#endif
+		is_mp = (stf_vin_map_isp_line(i) == STF_ISP_LINE_SRC) ? true : false;
+		is_mp = false;
+		sd = &vin_dev->line[i].subdev;
+		pads = vin_dev->line[i].pads;
+		video_out = &vin_dev->line[i].video_out;
+		video_out->id = i;
+
+		v4l2_subdev_init(sd, &vin_v4l2_ops);
+		sd->internal_ops = &vin_v4l2_internal_ops;
+		sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+		snprintf(sd->name, ARRAY_SIZE(sd->name), "%s%d_%s",
+			STF_VIN_NAME, 0, sub_name);
+		v4l2_set_subdevdata(sd, &vin_dev->line[i]);
+
+		ret = vin_init_formats(sd, NULL);
+		if (ret < 0) {
+			st_err(ST_VIN, "Failed to init format: %d\n", ret);
+			goto err_init;
+		}
+
+		pads[STF_VIN_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+		pads[STF_VIN_PAD_SRC].flags = MEDIA_PAD_FL_SOURCE;
+
+		sd->entity.function =
+			MEDIA_ENT_F_PROC_VIDEO_PIXEL_FORMATTER;
+		sd->entity.ops = &vin_media_ops;
+		ret = media_entity_pads_init(&sd->entity,
+				STF_VIN_PADS_NUM, pads);
+		if (ret < 0) {
+			st_err(ST_VIN, "Failed to init media entity: %d\n", ret);
+			goto err_init;
+		}
+
+		ret = v4l2_device_register_subdev(v4l2_dev, sd);
+		if (ret < 0) {
+			st_err(ST_VIN, "Failed to register subdev: %d\n", ret);
+			goto err_reg_subdev;
+		}
+
+		video_out->ops = &stfcamss_vin_video_ops;
+		video_out->bpl_alignment = 16 * 8;
+
+		snprintf(name, ARRAY_SIZE(name), "%s_%s%d",
+			sd->name, "video", i);
+		ret = stf_video_register(video_out, v4l2_dev, name, is_mp);
+		if (ret < 0) {
+			st_err(ST_VIN, "Failed to register video node: %d\n",
+					ret);
+			goto err_vid_reg;
+		}
+
+		ret = media_create_pad_link(
+			&sd->entity, STF_VIN_PAD_SRC,
+			&video_out->vdev.entity, 0,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+		if (ret < 0) {
+			st_err(ST_VIN, "Failed to link %s->%s entities: %d\n",
+				sd->entity.name, video_out->vdev.entity.name,
+				ret);
+			goto err_create_link;
+		}
+	}
+
+	return 0;
+
+err_create_link:
+	stf_video_unregister(video_out);
+err_vid_reg:
+	v4l2_device_unregister_subdev(sd);
+err_reg_subdev:
+	media_entity_cleanup(&sd->entity);
+err_init:
+	for (i--; i >= 0; i--) {
+		sd = &vin_dev->line[i].subdev;
+		video_out = &vin_dev->line[i].video_out;
+
+		stf_video_unregister(video_out);
+		v4l2_device_unregister_subdev(sd);
+		media_entity_cleanup(&sd->entity);
+	}
+	return ret;
+}
+
+int stf_vin_unregister(struct stf_vin2_dev *vin_dev)
+{
+	struct v4l2_subdev *sd;
+	struct stfcamss_video *video_out;
+	int i;
+
+	mutex_destroy(&vin_dev->power_lock);
+	for (i = 0; i < STF_DUMMY_MODULE_NUMS; i++)
+		mutex_destroy(&vin_dev->dummy_buffer[i].stream_lock);
+
+	for (i = 0; i < STF_ISP_LINE_MAX + 1; i++) {
+		sd = &vin_dev->line[i].subdev;
+		video_out = &vin_dev->line[i].video_out;
+
+		stf_video_unregister(video_out);
+		v4l2_device_unregister_subdev(sd);
+		media_entity_cleanup(&sd->entity);
+		mutex_destroy(&vin_dev->line[i].stream_lock);
+		mutex_destroy(&vin_dev->line[i].power_lock);
+	}
+	return 0;
+}
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_vin.h b/drivers/media/platform/starfive/v4l2_driver/stf_vin.h
new file mode 100644
index 000000000000..492bffe27d17
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_vin.h
@@ -0,0 +1,180 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STF_VIN_H
+#define STF_VIN_H
+
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+#include <linux/spinlock_types.h>
+#include <video/stf-vin.h>
+#include <linux/platform_device.h>
+
+#include "stf_video.h"
+
+#define STF_VIN_NAME "stf_vin"
+
+#define STF_VIN_PAD_SINK   0
+#define STF_VIN_PAD_SRC    1
+#define STF_VIN_PADS_NUM   2
+
+struct vin2_format {
+	u32 code;
+	u8 bpp;
+};
+
+struct vin2_format_table {
+	const struct vin2_format *fmts;
+	int nfmts;
+};
+
+enum vin_output_state {
+	VIN_OUTPUT_OFF,
+	VIN_OUTPUT_RESERVED,
+	VIN_OUTPUT_SINGLE,
+	VIN_OUTPUT_CONTINUOUS,
+	VIN_OUTPUT_IDLE,
+	VIN_OUTPUT_STOPPING
+};
+
+struct vin_output {
+	int active_buf;
+	struct stfcamss_buffer *buf[2];
+	struct stfcamss_buffer *last_buffer;
+	struct list_head pending_bufs;
+	struct list_head ready_bufs;
+	enum vin_output_state state;
+	unsigned int sequence;
+	unsigned int frame_skip;
+};
+
+/* The vin output lines include all isp controller lines,
+ * and one vin_wr output line.
+ */
+enum vin_line_id {
+	VIN_LINE_NONE = -1,
+	VIN_LINE_WR = 0,
+	VIN_LINE_ISP = 1,
+	VIN_LINE_ISP_SS0 = 2,
+	VIN_LINE_ISP_SS1 = 3,
+	VIN_LINE_ISP_ITIW = 4,
+	VIN_LINE_ISP_ITIR = 5,
+	VIN_LINE_ISP_RAW = 6,
+	VIN_LINE_ISP_SCD_Y = 7,
+	VIN_LINE_MAX = 8,
+};
+
+enum subdev_type;
+
+struct vin_line {
+	enum subdev_type sdev_type;  // must be frist
+	enum vin_line_id id;
+	struct v4l2_subdev subdev;
+	struct media_pad pads[STF_VIN_PADS_NUM];
+	struct v4l2_mbus_framefmt fmt[STF_VIN_PADS_NUM];
+	struct stfcamss_video video_out;
+	struct mutex stream_lock;
+	int stream_count;
+	struct mutex power_lock;
+	int power_count;
+	struct vin_output output;
+	spinlock_t output_lock;
+	const struct vin2_format *formats;
+	unsigned int nformats;
+#ifdef CONFIG_PM_SLEEP
+	int pm_stream_count;
+	int pm_power_count;
+#endif
+};
+
+struct stf_vin2_dev;
+
+struct vin_hw_ops {
+	int (*vin_clk_enable)(struct stf_vin2_dev *vin_dev);
+	int (*vin_clk_disable)(struct stf_vin2_dev *vin_dev);
+	int (*vin_config_set)(struct stf_vin2_dev *vin_dev);
+	int (*vin_wr_stream_set)(struct stf_vin2_dev *vin_dev, int on);
+	void (*vin_wr_irq_enable)(struct stf_vin2_dev *vin_dev, int enable);
+	void (*vin_power_on)(struct stf_vin2_dev *vin_dev, int on);
+	void (*wr_rd_set_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t wr_addr, dma_addr_t rd_addr);
+	void (*vin_wr_set_ping_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t addr);
+	void (*vin_wr_set_pong_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t addr);
+	void (*vin_wr_get_ping_pong_status)(struct stf_vin2_dev *vin_dev);
+	void (*vin_isp_set_yuv_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t y_addr, dma_addr_t uv_addr);
+	void (*vin_isp_set_raw_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t raw_addr);
+	void (*vin_isp_set_ss0_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t y_addr, dma_addr_t uv_addr);
+	void (*vin_isp_set_ss1_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t y_addr, dma_addr_t uv_addr);
+	void (*vin_isp_set_itiw_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t y_addr, dma_addr_t uv_addr);
+	void (*vin_isp_set_itir_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t y_addr, dma_addr_t uv_addr);
+	void (*vin_isp_set_scd_addr)(struct stf_vin2_dev *vin_dev,
+			dma_addr_t yhist_addr,
+			dma_addr_t scd_addr, int scd_type);
+	int (*vin_isp_get_scd_type)(struct stf_vin2_dev *vin_dev);
+	irqreturn_t (*vin_wr_irq_handler)(int irq, void *priv);
+	irqreturn_t (*vin_isp_irq_handler)(int irq, void *priv);
+	irqreturn_t (*vin_isp_csi_irq_handler)(int irq, void *priv);
+	irqreturn_t (*vin_isp_scd_irq_handler)(int irq, void *priv);
+	irqreturn_t (*vin_isp_irq_csiline_handler)(int irq, void *priv);
+	void (*isr_buffer_done)(struct vin_line *line,
+			struct vin_params *params);
+	void (*isr_change_buffer)(struct vin_line *line);
+};
+
+#define ISP_DUMMY_BUFFER_NUMS  STF_ISP_PAD_MAX
+#define VIN_DUMMY_BUFFER_NUMS  1
+
+enum {
+	STF_DUMMY_VIN,
+	STF_DUMMY_ISP,
+	STF_DUMMY_MODULE_NUMS,
+};
+
+struct vin_dummy_buffer {
+	dma_addr_t paddr[3];
+	void *vaddr;
+	u32 buffer_size;
+	u32 width;
+	u32 height;
+	u32 mcode;
+};
+
+struct dummy_buffer {
+	struct vin_dummy_buffer *buffer;
+	u32 nums;
+	struct mutex stream_lock;
+	int stream_count;
+	atomic_t frame_skip;
+};
+
+struct stf_vin2_dev {
+	struct stfcamss *stfcamss;
+	struct vin_line line[VIN_LINE_MAX];
+	struct dummy_buffer dummy_buffer[STF_DUMMY_MODULE_NUMS];
+	struct vin_hw_ops *hw_ops;
+	atomic_t ref_count;
+	struct mutex power_lock;
+	int power_count;
+};
+
+extern void sifive_l2_flush64_range(unsigned long start, unsigned long len);
+extern int stf_vin_subdev_init(struct stfcamss *stfcamss);
+extern int stf_vin_register(struct stf_vin2_dev *vin_dev,
+		struct v4l2_device *v4l2_dev);
+extern int stf_vin_unregister(struct stf_vin2_dev *vin_dev);
+
+extern struct vin_hw_ops vin_ops;
+extern void dump_vin_reg(void *__iomem regbase);
+extern enum isp_pad_id stf_vin_map_isp_pad(enum vin_line_id line,
+		enum isp_pad_id def);
+
+#endif /* STF_VIN_H */
diff --git a/drivers/media/platform/starfive/v4l2_driver/stf_vin_hw_ops.c b/drivers/media/platform/starfive/v4l2_driver/stf_vin_hw_ops.c
new file mode 100644
index 000000000000..aaec27c6e742
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stf_vin_hw_ops.c
@@ -0,0 +1,432 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include "stfcamss.h"
+#include <linux/of_graph.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+static void vin_intr_clear(void __iomem *sysctrl_base)
+{
+	reg_set_bit(sysctrl_base, SYSCONSAIF_SYSCFG_28,
+		U0_VIN_CNFG_AXIWR0_INTR_CLEAN,
+		0x1);
+	reg_set_bit(sysctrl_base, SYSCONSAIF_SYSCFG_28,
+		U0_VIN_CNFG_AXIWR0_INTR_CLEAN,
+		0x0);
+}
+
+static irqreturn_t stf_vin_wr_irq_handler(int irq, void *priv)
+{
+	static struct vin_params params;
+	struct stf_vin2_dev *vin_dev = priv;
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	struct dummy_buffer *dummy_buffer =
+			&vin_dev->dummy_buffer[STF_DUMMY_VIN];
+
+	if (atomic_dec_if_positive(&dummy_buffer->frame_skip) < 0) {
+		vin_dev->hw_ops->isr_change_buffer(&vin_dev->line[VIN_LINE_WR]);
+		vin_dev->hw_ops->isr_buffer_done(&vin_dev->line[VIN_LINE_WR], &params);
+	}
+
+	vin_intr_clear(vin->sysctrl_base);
+
+	return IRQ_HANDLED;
+}
+
+static  void __iomem *stf_vin_get_ispbase(struct stf_vin_dev *vin)
+{
+	void __iomem *base = vin->isp_base;
+
+	return base;
+}
+
+static irqreturn_t stf_vin_isp_irq_handler(int irq, void *priv)
+{
+	static struct vin_params params;
+	struct stf_vin2_dev *vin_dev = priv;
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase;
+	u32 int_status, value;
+
+	ispbase = stf_vin_get_ispbase(vin);
+
+	int_status = reg_read(ispbase, ISP_REG_ISP_CTRL_0);
+
+	if (int_status & BIT(24)) {
+		if ((int_status & BIT(11)))
+			vin_dev->hw_ops->isr_buffer_done(
+				&vin_dev->line[VIN_LINE_ISP_SS0], &params);
+
+		if ((int_status & BIT(12)))
+			vin_dev->hw_ops->isr_buffer_done(
+				&vin_dev->line[VIN_LINE_ISP_SS1], &params);
+
+		if ((int_status & BIT(20)))
+			vin_dev->hw_ops->isr_buffer_done(
+				&vin_dev->line[VIN_LINE_ISP], &params);
+
+		value = reg_read(ispbase, ISP_REG_ITIDPSR);
+		if ((value & BIT(17)))
+			vin_dev->hw_ops->isr_buffer_done(
+				&vin_dev->line[VIN_LINE_ISP_ITIW], &params);
+		if ((value & BIT(16)))
+			vin_dev->hw_ops->isr_buffer_done(
+				&vin_dev->line[VIN_LINE_ISP_ITIR], &params);
+
+#ifndef ISP_USE_CSI_AND_SC_DONE_INTERRUPT
+		if (int_status & BIT(25))
+			vin_dev->hw_ops->isr_buffer_done(
+				&vin_dev->line[VIN_LINE_ISP_RAW], &params);
+
+		if (int_status & BIT(26))
+			vin_dev->hw_ops->isr_buffer_done(
+				&vin_dev->line[VIN_LINE_ISP_SCD_Y], &params);
+
+		/* clear interrupt */
+		reg_write(ispbase, ISP_REG_ISP_CTRL_0, (int_status & ~EN_INT_ALL)
+				| EN_INT_ISP_DONE | EN_INT_CSI_DONE | EN_INT_SC_DONE);
+#else
+		/* clear interrupt */
+		reg_write(ispbase, ISP_REG_ISP_CTRL_0,
+			(int_status & ~EN_INT_ALL) | EN_INT_ISP_DONE);
+#endif
+	} else
+		st_debug(ST_VIN, "%s, Unknown interrupt!!!\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stf_vin_isp_csi_irq_handler(int irq, void *priv)
+{
+	static struct vin_params params;
+	struct stf_vin2_dev *vin_dev = priv;
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase;
+	u32 int_status;
+
+	ispbase = stf_vin_get_ispbase(vin);
+
+	int_status = reg_read(ispbase, ISP_REG_ISP_CTRL_0);
+
+	if (int_status & BIT(25)) {
+		vin_dev->hw_ops->isr_buffer_done(
+			&vin_dev->line[VIN_LINE_ISP_RAW], &params);
+
+		/* clear interrupt */
+		reg_write(ispbase, ISP_REG_ISP_CTRL_0,
+			(int_status & ~EN_INT_ALL) | EN_INT_CSI_DONE);
+	} else
+		st_debug(ST_VIN, "%s, Unknown interrupt!!!\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stf_vin_isp_scd_irq_handler(int irq, void *priv)
+{
+	static struct vin_params params;
+	struct stf_vin2_dev *vin_dev = priv;
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase;
+	u32 int_status;
+
+	ispbase = stf_vin_get_ispbase(vin);
+
+	int_status = reg_read(ispbase, ISP_REG_ISP_CTRL_0);
+
+	if (int_status & BIT(26)) {
+		vin_dev->hw_ops->isr_buffer_done(
+			&vin_dev->line[VIN_LINE_ISP_SCD_Y], &params);
+
+		/* clear interrupt */
+		reg_write(ispbase, ISP_REG_ISP_CTRL_0, (int_status & ~EN_INT_ALL) | EN_INT_SC_DONE);
+	} else
+		st_debug(ST_VIN, "%s, Unknown interrupt!!!\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t stf_vin_isp_irq_csiline_handler(int irq, void *priv)
+{
+	struct stf_vin2_dev *vin_dev = priv;
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	struct stf_isp_dev *isp_dev;
+	void __iomem *ispbase;
+	u32 int_status, value;
+
+	ispbase = stf_vin_get_ispbase(vin);
+
+	isp_dev = vin_dev->stfcamss->isp_dev;
+
+	int_status = reg_read(ispbase, ISP_REG_ISP_CTRL_0);
+	if (int_status & BIT(27)) {
+		struct dummy_buffer *dummy_buffer =
+			&vin_dev->dummy_buffer[STF_DUMMY_ISP];
+
+		if (!atomic_read(&isp_dev->shadow_count)) {
+			if (atomic_dec_if_positive(&dummy_buffer->frame_skip) < 0) {
+				if ((int_status & BIT(11)))
+					vin_dev->hw_ops->isr_change_buffer(
+						&vin_dev->line[VIN_LINE_ISP_SS0]);
+				if ((int_status & BIT(12)))
+					vin_dev->hw_ops->isr_change_buffer(
+						&vin_dev->line[VIN_LINE_ISP_SS1]);
+				if ((int_status & BIT(20)))
+					vin_dev->hw_ops->isr_change_buffer(
+						&vin_dev->line[VIN_LINE_ISP]);
+
+				value = reg_read(ispbase, ISP_REG_ITIDPSR);
+				if ((value & BIT(17)))
+					vin_dev->hw_ops->isr_change_buffer(
+						&vin_dev->line[VIN_LINE_ISP_ITIW]);
+				if ((value & BIT(16)))
+					vin_dev->hw_ops->isr_change_buffer(
+						&vin_dev->line[VIN_LINE_ISP_ITIR]);
+
+				value = reg_read(ispbase, ISP_REG_CSI_MODULE_CFG);
+				if ((value & BIT(19)))
+					vin_dev->hw_ops->isr_change_buffer(
+						&vin_dev->line[VIN_LINE_ISP_RAW]);
+				if ((value & BIT(17)))
+					vin_dev->hw_ops->isr_change_buffer(
+						&vin_dev->line[VIN_LINE_ISP_SCD_Y]);
+			}
+
+			// shadow update
+			reg_set_bit(ispbase, ISP_REG_CSIINTS_ADDR, 0x30000, 0x30000);
+			reg_set_bit(ispbase, ISP_REG_IESHD_ADDR, BIT(1) | BIT(0), 0x3);
+		} else {
+			st_err_ratelimited(ST_VIN,
+				"isp shadow_lock locked. skip this frame\n");
+		}
+
+		/* clear interrupt */
+		reg_write(ispbase, ISP_REG_ISP_CTRL_0,
+			(int_status & ~EN_INT_ALL) | EN_INT_LINE_INT);
+	} else
+		st_debug(ST_VIN, "%s, Unknown interrupt!!!\n", __func__);
+
+	return IRQ_HANDLED;
+}
+
+static int stf_vin_clk_enable(struct stf_vin2_dev *vin_dev)
+{
+	struct stfcamss *stfcamss = vin_dev->stfcamss;
+
+	clk_prepare_enable(stfcamss->sys_clk[STFCLK_PCLK].clk);
+	clk_set_rate(stfcamss->sys_clk[STFCLK_APB_FUNC].clk, 49500000);
+	clk_set_rate(stfcamss->sys_clk[STFCLK_SYS_CLK].clk, 297000000);
+
+	reset_control_deassert(stfcamss->sys_rst[STFRST_PCLK].rstc);
+	reset_control_deassert(stfcamss->sys_rst[STFRST_SYS_CLK].rstc);
+
+	return 0;
+}
+
+
+static int stf_vin_clk_disable(struct stf_vin2_dev *vin_dev)
+{
+	struct stfcamss *stfcamss = vin_dev->stfcamss;
+
+	reset_control_assert(stfcamss->sys_rst[STFRST_PCLK].rstc);
+	reset_control_assert(stfcamss->sys_rst[STFRST_SYS_CLK].rstc);
+
+	clk_disable_unprepare(stfcamss->sys_clk[STFCLK_PCLK].clk);
+
+	return 0;
+}
+
+static int stf_vin_config_set(struct stf_vin2_dev *vin_dev)
+{
+	return 0;
+}
+
+static int stf_vin_wr_stream_set(struct stf_vin2_dev *vin_dev, int on)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+
+	//make the axiwr alway on
+	if (on)
+		reg_set(vin->sysctrl_base, SYSCONSAIF_SYSCFG_20, U0_VIN_CNFG_AXIWR0_EN);
+
+	return 0;
+}
+
+static void stf_vin_wr_irq_enable(struct stf_vin2_dev *vin_dev,
+		int enable)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	unsigned int value = 0;
+
+	if (enable) {
+		value = ~(0x1 << 1);
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_28,
+			U0_VIN_CNFG_AXIWR0_MASK,
+			value);
+	} else {
+		/* clear vin interrupt */
+		value = 0x1 << 1;
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_28,
+			U0_VIN_CNFG_AXIWR0_INTR_CLEAN,
+			0x1);
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_28,
+			U0_VIN_CNFG_AXIWR0_INTR_CLEAN,
+			0x0);
+		reg_set_bit(vin->sysctrl_base, SYSCONSAIF_SYSCFG_28,
+			U0_VIN_CNFG_AXIWR0_MASK,
+			value);
+	}
+}
+
+static void stf_vin_wr_rd_set_addr(struct stf_vin2_dev *vin_dev,
+		dma_addr_t wr_addr, dma_addr_t rd_addr)
+{
+#ifdef UNUSED_CODE
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+
+	/* set the start address*/
+	reg_write(vin->sysctrl_base,
+			SYSCTRL_VIN_WR_START_ADDR, (long)wr_addr);
+	reg_write(vin->sysctrl_base,
+			SYSCTRL_VIN_RD_END_ADDR, (long)rd_addr);
+#endif
+}
+
+void stf_vin_wr_set_ping_addr(struct stf_vin2_dev *vin_dev,
+		dma_addr_t addr)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+
+	/* set the start address */
+	reg_write(vin->sysctrl_base,  SYSCONSAIF_SYSCFG_24, (long)addr);
+}
+
+void stf_vin_wr_set_pong_addr(struct stf_vin2_dev *vin_dev, dma_addr_t addr)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+
+	/* set the start address */
+	reg_write(vin->sysctrl_base, SYSCONSAIF_SYSCFG_32, (long)addr);
+}
+
+void stf_vin_isp_set_yuv_addr(struct stf_vin2_dev *vin_dev,
+				dma_addr_t y_addr, dma_addr_t uv_addr)
+{
+
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase = stf_vin_get_ispbase(vin);
+
+	reg_write(ispbase, ISP_REG_Y_PLANE_START_ADDR, y_addr);
+	reg_write(ispbase, ISP_REG_UV_PLANE_START_ADDR, uv_addr);
+	// reg_set_bit(ispbase, ISP_REG_ISP_CTRL_0, BIT(0), 1);
+}
+
+void stf_vin_isp_set_raw_addr(struct stf_vin2_dev *vin_dev,
+				dma_addr_t raw_addr)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase = stf_vin_get_ispbase(vin);
+
+	reg_write(ispbase, ISP_REG_DUMP_CFG_0, raw_addr);
+}
+
+void stf_vin_isp_set_ss0_addr(struct stf_vin2_dev *vin_dev,
+				dma_addr_t y_addr, dma_addr_t uv_addr)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase = stf_vin_get_ispbase(vin);
+
+	reg_write(ispbase, ISP_REG_SS0AY, y_addr);
+	reg_write(ispbase, ISP_REG_SS0AUV, uv_addr);
+}
+
+void stf_vin_isp_set_ss1_addr(struct stf_vin2_dev *vin_dev,
+				dma_addr_t y_addr, dma_addr_t uv_addr)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase = stf_vin_get_ispbase(vin);
+
+	reg_write(ispbase, ISP_REG_SS1AY, y_addr);
+	reg_write(ispbase, ISP_REG_SS1AUV, uv_addr);
+}
+
+void stf_vin_isp_set_itiw_addr(struct stf_vin2_dev *vin_dev,
+				dma_addr_t y_addr, dma_addr_t uv_addr)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase = stf_vin_get_ispbase(vin);
+
+	reg_write(ispbase, ISP_REG_ITIDWYSAR, y_addr);
+	reg_write(ispbase, ISP_REG_ITIDWUSAR, uv_addr);
+}
+
+void stf_vin_isp_set_itir_addr(struct stf_vin2_dev *vin_dev,
+				dma_addr_t y_addr, dma_addr_t uv_addr)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase = stf_vin_get_ispbase(vin);
+
+	reg_write(ispbase, ISP_REG_ITIDRYSAR, y_addr);
+	reg_write(ispbase, ISP_REG_ITIDRUSAR, uv_addr);
+}
+
+int stf_vin_isp_get_scd_type(struct stf_vin2_dev *vin_dev)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase = stf_vin_get_ispbase(vin);
+
+	return (reg_read(ispbase, ISP_REG_SC_CFG_1) & (0x3 << 30)) >> 30;
+}
+
+void stf_vin_isp_set_scd_addr(struct stf_vin2_dev *vin_dev,
+				dma_addr_t yhist_addr, dma_addr_t scd_addr, int scd_type)
+{
+	struct stf_vin_dev *vin = vin_dev->stfcamss->vin;
+	void __iomem *ispbase = stf_vin_get_ispbase(vin);
+
+	reg_set_bit(ispbase, ISP_REG_SC_CFG_1, 0x3 << 30, scd_type << 30);
+	reg_write(ispbase, ISP_REG_SCD_CFG_0, scd_addr);
+	reg_write(ispbase, ISP_REG_YHIST_CFG_4, yhist_addr);
+}
+
+void dump_vin_reg(void *__iomem regbase)
+{
+	st_debug(ST_VIN, "DUMP VIN register:\n");
+	print_reg(ST_VIN, regbase, 0x00);
+	print_reg(ST_VIN, regbase, 0x04);
+	print_reg(ST_VIN, regbase, 0x08);
+	print_reg(ST_VIN, regbase, 0x0c);
+	print_reg(ST_VIN, regbase, 0x10);
+	print_reg(ST_VIN, regbase, 0x14);
+	print_reg(ST_VIN, regbase, 0x18);
+	print_reg(ST_VIN, regbase, 0x1c);
+	print_reg(ST_VIN, regbase, 0x20);
+	print_reg(ST_VIN, regbase, 0x24);
+	print_reg(ST_VIN, regbase, 0x28);
+}
+
+struct vin_hw_ops vin_ops = {
+	.vin_clk_enable        = stf_vin_clk_enable,
+	.vin_clk_disable       = stf_vin_clk_disable,
+	.vin_config_set        = stf_vin_config_set,
+	.vin_wr_stream_set     = stf_vin_wr_stream_set,
+	.vin_wr_irq_enable     = stf_vin_wr_irq_enable,
+	.wr_rd_set_addr        = stf_vin_wr_rd_set_addr,
+	.vin_wr_set_ping_addr  = stf_vin_wr_set_ping_addr,
+	.vin_wr_set_pong_addr  = stf_vin_wr_set_pong_addr,
+	.vin_isp_set_yuv_addr  = stf_vin_isp_set_yuv_addr,
+	.vin_isp_set_raw_addr  = stf_vin_isp_set_raw_addr,
+	.vin_isp_set_ss0_addr  = stf_vin_isp_set_ss0_addr,
+	.vin_isp_set_ss1_addr  = stf_vin_isp_set_ss1_addr,
+	.vin_isp_set_itiw_addr  = stf_vin_isp_set_itiw_addr,
+	.vin_isp_set_itir_addr  = stf_vin_isp_set_itir_addr,
+	.vin_isp_set_scd_addr  = stf_vin_isp_set_scd_addr,
+	.vin_isp_get_scd_type  = stf_vin_isp_get_scd_type,
+	.vin_wr_irq_handler    = stf_vin_wr_irq_handler,
+	.vin_isp_irq_handler   = stf_vin_isp_irq_handler,
+	.vin_isp_csi_irq_handler   = stf_vin_isp_csi_irq_handler,
+	.vin_isp_scd_irq_handler   = stf_vin_isp_scd_irq_handler,
+	.vin_isp_irq_csiline_handler   = stf_vin_isp_irq_csiline_handler,
+};
diff --git a/drivers/media/platform/starfive/v4l2_driver/stfcamss.c b/drivers/media/platform/starfive/v4l2_driver/stfcamss.c
new file mode 100644
index 000000000000..bb58bca91991
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stfcamss.c
@@ -0,0 +1,1384 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/of_graph.h>
+#include <linux/of_address.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+#include <linux/mfd/syscon.h>
+
+#include <linux/videodev2.h>
+
+#include <media/media-device.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-mc.h>
+#include <media/v4l2-fwnode.h>
+#include <linux/debugfs.h>
+
+#include "stfcamss.h"
+
+#ifdef STF_DEBUG
+unsigned int stdbg_level = ST_DEBUG;
+unsigned int stdbg_mask = 0x7F;
+#else
+unsigned int stdbg_level = ST_ERR;
+unsigned int stdbg_mask = 0x7F;
+#endif
+EXPORT_SYMBOL_GPL(stdbg_level);
+EXPORT_SYMBOL_GPL(stdbg_mask);
+
+static const struct reg_name mem_reg_name[] = {
+	{"csi2rx"},
+	{"vclk"},
+	{"vrst"},
+	{"sctrl"},
+	{"isp"},
+	{"trst"},
+	{"pmu"},
+	{"syscrg"},
+};
+
+static struct clk_bulk_data stfcamss_clocks[] = {
+	{ .id = "clk_apb_func" },
+	{ .id = "clk_pclk" },
+	{ .id = "clk_sys_clk" },
+	{ .id = "clk_wrapper_clk_c" },
+	{ .id = "clk_dvp_inv" },
+	{ .id = "clk_axiwr" },
+	{ .id = "clk_mipi_rx0_pxl" },
+	{ .id = "clk_pixel_clk_if0" },
+	{ .id = "clk_pixel_clk_if1" },
+	{ .id = "clk_pixel_clk_if2" },
+	{ .id = "clk_pixel_clk_if3" },
+	{ .id = "clk_m31dphy_cfgclk_in" },
+	{ .id = "clk_m31dphy_refclk_in" },
+	{ .id = "clk_m31dphy_txclkesc_lan0" },
+	{ .id = "clk_ispcore_2x" },
+	{ .id = "clk_isp_axi" },
+};
+
+static char *stfcamss_resets[] = {
+	"rst_wrapper_p",
+	"rst_wrapper_c",
+	"rst_pclk",
+	"rst_sys_clk",
+	"rst_axird",
+	"rst_axiwr",
+	"rst_pixel_clk_if0",
+	"rst_pixel_clk_if1",
+	"rst_pixel_clk_if2",
+	"rst_pixel_clk_if3",
+	"rst_m31dphy_hw",
+	"rst_m31dphy_b09_always_on",
+	"rst_isp_top_n",
+	"rst_isp_top_axi",
+};
+
+int stfcamss_get_mem_res(struct platform_device *pdev, struct stf_vin_dev *vin)
+{
+	struct device *dev = &pdev->dev;
+	struct resource	*res;
+	char *name;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mem_reg_name); i++) {
+		name = (char *)(&mem_reg_name[i]);
+		res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
+
+		if (!res)
+			return -EINVAL;
+
+		if (!strcmp(name, "csi2rx")) {
+			vin->csi2rx_base = devm_ioremap_resource(dev, res);
+			if (IS_ERR(vin->csi2rx_base))
+				return PTR_ERR(vin->csi2rx_base);
+		} else if (!strcmp(name, "vclk")) {
+			vin->clkgen_base = ioremap(res->start, resource_size(res));
+			if (!vin->clkgen_base)
+				return -ENOMEM;
+		} else if (!strcmp(name, "vrst")) {
+			vin->rstgen_base = devm_ioremap_resource(dev, res);
+			if (IS_ERR(vin->rstgen_base))
+				return PTR_ERR(vin->rstgen_base);
+		} else if (!strcmp(name, "sctrl")) {
+			vin->sysctrl_base = devm_ioremap_resource(dev, res);
+			if (IS_ERR(vin->sysctrl_base))
+				return PTR_ERR(vin->sysctrl_base);
+		} else if (!strcmp(name, "isp")) {
+			vin->isp_base = devm_ioremap_resource(dev, res);
+			if (IS_ERR(vin->isp_base))
+				return PTR_ERR(vin->isp_base);
+		} else if (!strcmp(name, "trst")) {
+			vin->vin_top_rstgen_base = devm_ioremap_resource(dev, res);
+			if (IS_ERR(vin->vin_top_rstgen_base))
+				return PTR_ERR(vin->vin_top_rstgen_base);
+		} else if (!strcmp(name, "pmu")) {
+			vin->pmu_test = ioremap(res->start, resource_size(res));
+			if (!vin->pmu_test)
+				return -ENOMEM;
+		} else if (!strcmp(name, "syscrg")) {
+			vin->sys_crg = ioremap(res->start, resource_size(res));
+			if (!vin->sys_crg)
+				return -ENOMEM;
+		} else {
+			st_err(ST_CAMSS, "Could not match resource name\n");
+		}
+	}
+
+	return 0;
+}
+
+int vin_parse_dt(struct device *dev, struct stf_vin_dev *vin)
+{
+	int ret = 0;
+	struct device_node *np = dev->of_node;
+
+	if (!np)
+		return -EINVAL;
+
+	return ret;
+}
+
+struct media_entity *stfcamss_find_sensor(struct media_entity *entity)
+{
+	struct media_pad *pad;
+
+	while (1) {
+		if (!entity->pads)
+			return NULL;
+
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			return NULL;
+
+		pad = media_entity_remote_pad(pad);
+		if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+			return NULL;
+
+		entity = pad->entity;
+
+		if (entity->function == MEDIA_ENT_F_CAM_SENSOR)
+			return entity;
+	}
+}
+
+static int stfcamss_of_parse_endpoint_node(struct device *dev,
+				struct device_node *node,
+				struct stfcamss_async_subdev *csd)
+{
+	struct v4l2_fwnode_endpoint vep = { { 0 } };
+	struct v4l2_fwnode_bus_parallel *parallel_bus = &vep.bus.parallel;
+	struct v4l2_fwnode_bus_mipi_csi2 *csi2_bus = &vep.bus.mipi_csi2;
+	struct dvp_cfg *dvp = &csd->interface.dvp;
+	struct csi2phy_cfg *csiphy = &csd->interface.csiphy;
+
+	v4l2_fwnode_endpoint_parse(of_fwnode_handle(node), &vep);
+	st_debug(ST_CAMSS, "%s: vep.base.port = 0x%x, id = 0x%x\n",
+			__func__, vep.base.port, vep.base.id);
+
+	csd->port = vep.base.port;
+	switch (csd->port) {
+	case DVP_SENSOR_PORT_NUMBER:
+		st_debug(ST_CAMSS, "%s, flags = 0x%x\n", __func__,
+				parallel_bus->flags);
+		dvp->flags = parallel_bus->flags;
+		dvp->bus_width = parallel_bus->bus_width;
+		dvp->data_shift = parallel_bus->data_shift;
+		break;
+	case CSI2RX_SENSOR_PORT_NUMBER:
+		st_debug(ST_CAMSS, "%s, CSI2 flags = 0x%x\n",
+				__func__, parallel_bus->flags);
+		csiphy->flags = csi2_bus->flags;
+		memcpy(csiphy->data_lanes,
+				csi2_bus->data_lanes, csi2_bus->num_data_lanes);
+		csiphy->clock_lane = csi2_bus->clock_lane;
+		csiphy->num_data_lanes = csi2_bus->num_data_lanes;
+		memcpy(csiphy->lane_polarities,
+				csi2_bus->lane_polarities,
+				csi2_bus->num_data_lanes + 1);
+		break;
+	default:
+		break;
+	};
+
+	return 0;
+}
+
+static int stfcamss_of_parse_ports(struct stfcamss *stfcamss)
+{
+	struct device *dev = stfcamss->dev;
+	struct device_node *node = NULL;
+	struct device_node *remote = NULL;
+	int ret, num_subdevs = 0;
+
+	for_each_endpoint_of_node(dev->of_node, node) {
+		struct stfcamss_async_subdev *csd;
+		struct v4l2_async_subdev *asd;
+
+		if (!of_device_is_available(node))
+			continue;
+
+		remote = of_graph_get_remote_port_parent(node);
+		if (!remote) {
+			st_err(ST_CAMSS, "Cannot get remote parent\n");
+			ret = -EINVAL;
+			goto err_cleanup;
+		}
+
+		asd = v4l2_async_notifier_add_fwnode_subdev(
+			&stfcamss->notifier, of_fwnode_handle(remote),
+			sizeof(*csd));
+		of_node_put(remote);
+		if (IS_ERR(asd)) {
+			ret = PTR_ERR(asd);
+			goto err_cleanup;
+		}
+
+		csd = container_of(asd, struct stfcamss_async_subdev, asd);
+
+		ret = stfcamss_of_parse_endpoint_node(dev, node, csd);
+		if (ret < 0)
+			goto err_cleanup;
+
+		num_subdevs++;
+	}
+
+	return num_subdevs;
+
+err_cleanup:
+	of_node_put(node);
+	return ret;
+}
+
+static int stfcamss_init_subdevices(struct stfcamss *stfcamss)
+{
+	int ret;
+
+	ret = stf_dvp_subdev_init(stfcamss);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to init stf_dvp sub-device: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = stf_csiphy_subdev_init(stfcamss);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to init stf_csiphy sub-device: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = stf_csi_subdev_init(stfcamss);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to init stf_csi sub-device: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = stf_isp_subdev_init(stfcamss);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to init stf_isp sub-device: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = stf_vin_subdev_init(stfcamss);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to init stf_vin sub-device: %d\n",
+			ret);
+		return ret;
+	}
+	return ret;
+}
+
+static int stfcamss_register_subdevices(struct stfcamss *stfcamss)
+{
+	int ret;
+	struct stf_vin2_dev *vin_dev = stfcamss->vin_dev;
+	struct stf_dvp_dev *dvp_dev = stfcamss->dvp_dev;
+	struct stf_csiphy_dev *csiphy_dev = stfcamss->csiphy_dev;
+	struct stf_csi_dev *csi_dev = stfcamss->csi_dev;
+	struct stf_isp_dev *isp_dev = stfcamss->isp_dev;
+
+	ret = stf_dvp_register(dvp_dev, &stfcamss->v4l2_dev);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to register stf dvp%d entity: %d\n",
+			0, ret);
+		goto err_reg_dvp;
+	}
+
+	ret = stf_csiphy_register(csiphy_dev, &stfcamss->v4l2_dev);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to register stf csiphy%d entity: %d\n",
+			0, ret);
+		goto err_reg_csiphy;
+	}
+
+	ret = stf_csi_register(csi_dev, &stfcamss->v4l2_dev);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to register stf csi%d entity: %d\n",
+			0, ret);
+		goto err_reg_csi;
+	}
+
+	ret = stf_isp_register(isp_dev, &stfcamss->v4l2_dev);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to register stf isp%d entity: %d\n",
+			0, ret);
+		goto err_reg_isp;
+	}
+
+	ret = stf_vin_register(vin_dev, &stfcamss->v4l2_dev);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to register vin entity: %d\n",
+			 ret);
+		goto err_reg_vin;
+	}
+
+	ret = media_create_pad_link(
+		&dvp_dev->subdev.entity,
+		STF_DVP_PAD_SRC,
+		&vin_dev->line[VIN_LINE_WR].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->vin entities: %d\n",
+			dvp_dev->subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&csi_dev->subdev.entity,
+		STF_CSI_PAD_SRC,
+		&vin_dev->line[VIN_LINE_WR].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->vin entities: %d\n",
+			csi_dev->subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&csiphy_dev->subdev.entity,
+		STF_CSIPHY_PAD_SRC,
+		&csi_dev->subdev.entity,
+		STF_CSI_PAD_SINK,
+		MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			csiphy_dev->subdev.entity.name,
+			csi_dev->subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SRC,
+		&vin_dev->line[VIN_LINE_ISP].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			isp_dev->subdev.entity.name,
+			vin_dev->line[VIN_LINE_ISP]
+			.subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SRC_SS0,
+		&vin_dev->line[VIN_LINE_ISP_SS0].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			isp_dev->subdev.entity.name,
+			vin_dev->line[VIN_LINE_ISP_SS0]
+			.subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SRC_SS1,
+		&vin_dev->line[VIN_LINE_ISP_SS1].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			isp_dev->subdev.entity.name,
+			vin_dev->line[VIN_LINE_ISP_SS1]
+			.subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+#ifndef	STF_CAMSS_SKIP_ITI
+	ret = media_create_pad_link(
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SRC_ITIW,
+		&vin_dev->line[VIN_LINE_ISP_ITIW].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			isp_dev->subdev.entity.name,
+			vin_dev->line[VIN_LINE_ISP_ITIW]
+			.subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SRC_ITIR,
+		&vin_dev->line[VIN_LINE_ISP_ITIR].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			isp_dev->subdev.entity.name,
+			vin_dev->line[VIN_LINE_ISP_ITIR]
+			.subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+#endif
+
+	ret = media_create_pad_link(
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SRC_RAW,
+		&vin_dev->line[VIN_LINE_ISP_RAW].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			isp_dev->subdev.entity.name,
+			vin_dev->line[VIN_LINE_ISP_RAW]
+			.subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SRC_SCD_Y,
+		&vin_dev->line[VIN_LINE_ISP_SCD_Y].subdev.entity,
+		STF_VIN_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			isp_dev->subdev.entity.name,
+			vin_dev->line[VIN_LINE_ISP_SCD_Y]
+			.subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&dvp_dev->subdev.entity,
+		STF_DVP_PAD_SRC,
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			dvp_dev->subdev.entity.name,
+			isp_dev->subdev.entity.name,
+		ret);
+		goto err_link;
+	}
+
+	ret = media_create_pad_link(
+		&csi_dev->subdev.entity,
+		STF_CSI_PAD_SRC,
+		&isp_dev->subdev.entity,
+		STF_ISP_PAD_SINK,
+		0);
+	if (ret < 0) {
+		st_err(ST_CAMSS,
+			"Failed to link %s->%s entities: %d\n",
+			csi_dev->subdev.entity.name,
+			isp_dev->subdev.entity.name,
+			ret);
+		goto err_link;
+	}
+
+	return ret;
+
+err_link:
+	stf_vin_unregister(stfcamss->vin_dev);
+err_reg_vin:
+	stf_isp_unregister(stfcamss->isp_dev);
+err_reg_isp:
+	stf_csi_unregister(stfcamss->csi_dev);
+err_reg_csi:
+	stf_csiphy_unregister(stfcamss->csiphy_dev);
+err_reg_csiphy:
+	stf_dvp_unregister(stfcamss->dvp_dev);
+err_reg_dvp:
+	return ret;
+}
+
+static void stfcamss_unregister_subdevices(struct stfcamss *stfcamss)
+{
+	stf_dvp_unregister(stfcamss->dvp_dev);
+	stf_csiphy_unregister(stfcamss->csiphy_dev);
+	stf_csi_unregister(stfcamss->csi_dev);
+	stf_isp_unregister(stfcamss->isp_dev);
+	stf_vin_unregister(stfcamss->vin_dev);
+}
+
+static int stfcamss_register_mediadevice_subdevnodes(
+		struct v4l2_async_notifier *async,
+		struct v4l2_subdev *sd)
+{
+	struct stfcamss *stfcamss =
+		container_of(async, struct stfcamss, notifier);
+	int ret;
+
+	if (sd->host_priv) {
+		struct media_entity *sensor = &sd->entity;
+		struct media_entity *input = sd->host_priv;
+		unsigned int i;
+
+		for (i = 0; i < sensor->num_pads; i++) {
+			if (sensor->pads[i].flags & MEDIA_PAD_FL_SOURCE)
+				break;
+		}
+		if (i == sensor->num_pads) {
+			st_err(ST_CAMSS,
+				"No source pad in external entity\n");
+			return -EINVAL;
+		}
+
+		ret = media_create_pad_link(sensor, i,
+			input, STF_PAD_SINK,
+			MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+		if (ret < 0) {
+			st_err(ST_CAMSS,
+				"Failed to link %s->%s entities: %d\n",
+				sensor->name, input->name, ret);
+			return ret;
+		}
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&stfcamss->v4l2_dev);
+	if (ret < 0)
+		return ret;
+
+	if (stfcamss->media_dev.devnode)
+		return ret;
+
+	st_debug(ST_CAMSS, "stfcamss register media device\n");
+	return media_device_register(&stfcamss->media_dev);
+}
+
+static int stfcamss_subdev_notifier_bound(struct v4l2_async_notifier *async,
+					struct v4l2_subdev *subdev,
+					struct v4l2_async_subdev *asd)
+{
+	struct stfcamss *stfcamss =
+		container_of(async, struct stfcamss, notifier);
+	struct stfcamss_async_subdev *csd =
+		container_of(asd, struct stfcamss_async_subdev, asd);
+	enum port_num port = csd->port;
+	struct stf_dvp_dev *dvp_dev = stfcamss->dvp_dev;
+	struct stf_csiphy_dev *csiphy_dev = stfcamss->csiphy_dev;
+
+	switch (port) {
+	case DVP_SENSOR_PORT_NUMBER:
+		dvp_dev->dvp = &csd->interface.dvp;
+		subdev->host_priv = &dvp_dev->subdev.entity;
+		break;
+	case CSI2RX_SENSOR_PORT_NUMBER:
+		csiphy_dev->csiphy = &csd->interface.csiphy;
+		subdev->host_priv = &csiphy_dev->subdev.entity;
+		break;
+	default:
+		break;
+	};
+
+	stfcamss_register_mediadevice_subdevnodes(async, subdev);
+
+	return 0;
+}
+
+#ifdef UNUSED_CODE
+static int stfcamss_subdev_notifier_complete(
+		struct v4l2_async_notifier *async)
+{
+	struct stfcamss *stfcamss =
+		container_of(async, struct stfcamss, notifier);
+	struct v4l2_device *v4l2_dev = &stfcamss->v4l2_dev;
+	struct v4l2_subdev *sd;
+	int ret;
+
+	list_for_each_entry(sd, &v4l2_dev->subdevs, list) {
+		if (sd->host_priv) {
+			struct media_entity *sensor = &sd->entity;
+			struct media_entity *input = sd->host_priv;
+			unsigned int i;
+
+			for (i = 0; i < sensor->num_pads; i++) {
+				if (sensor->pads[i].flags & MEDIA_PAD_FL_SOURCE)
+					break;
+			}
+			if (i == sensor->num_pads) {
+				st_err(ST_CAMSS,
+					"No source pad in external entity\n");
+				return -EINVAL;
+			}
+
+			ret = media_create_pad_link(sensor, i,
+				input, STF_PAD_SINK,
+				MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED);
+			if (ret < 0) {
+				st_err(ST_CAMSS,
+					"Failed to link %s->%s entities: %d\n",
+					sensor->name, input->name, ret);
+				return ret;
+			}
+		}
+	}
+
+	ret = v4l2_device_register_subdev_nodes(&stfcamss->v4l2_dev);
+	if (ret < 0)
+		return ret;
+
+	return media_device_register(&stfcamss->media_dev);
+}
+#endif
+
+static const struct v4l2_async_notifier_operations
+stfcamss_subdev_notifier_ops = {
+	.bound = stfcamss_subdev_notifier_bound,
+};
+
+static const struct media_device_ops stfcamss_media_ops = {
+	.link_notify = v4l2_pipeline_link_notify,
+};
+
+#ifdef CONFIG_DEBUG_FS
+enum module_id {
+	VIN_MODULE = 0,
+	ISP_MODULE,
+	CSI_MODULE,
+	CSIPHY_MODULE,
+	DVP_MODULE,
+	CLK_MODULE,
+};
+
+static enum module_id id_num = ISP_MODULE;
+
+void dump_clk_reg(void __iomem *reg_base)
+{
+	int i;
+
+	st_info(ST_CAMSS, "DUMP Clk register:\n");
+	for (i = 0; i <= CLK_C_ISP_CTRL; i += 4)
+		print_reg(ST_CAMSS, reg_base, i);
+}
+
+static ssize_t vin_debug_read(struct file *file, char __user *user_buf,
+			size_t count, loff_t *ppos)
+{
+	struct device *dev = file->private_data;
+	void __iomem *reg_base;
+	struct stfcamss *stfcamss = dev_get_drvdata(dev);
+	struct stf_vin_dev *vin = stfcamss->vin;
+	struct stf_vin2_dev *vin_dev = stfcamss->vin_dev;
+	struct stf_isp_dev *isp_dev = stfcamss->isp_dev;
+	struct stf_csi_dev *csi0_dev = stfcamss->csi_dev;
+
+	switch (id_num) {
+	case VIN_MODULE:
+	case CSIPHY_MODULE:
+	case DVP_MODULE:
+		mutex_lock(&vin_dev->power_lock);
+		if (vin_dev->power_count > 0) {
+			reg_base = vin->sysctrl_base;
+			dump_vin_reg(reg_base);
+		}
+		mutex_unlock(&vin_dev->power_lock);
+		break;
+	case ISP_MODULE:
+		mutex_lock(&isp_dev->stream_lock);
+		if (isp_dev->stream_count > 0) {
+			reg_base = vin->isp_base;
+			dump_isp_reg(reg_base);
+		}
+		mutex_unlock(&isp_dev->stream_lock);
+		break;
+	case CSI_MODULE:
+		mutex_lock(&csi0_dev->stream_lock);
+		if (csi0_dev->stream_count > 0) {
+			reg_base = vin->csi2rx_base;
+			dump_csi_reg(reg_base);
+		}
+		mutex_unlock(&csi0_dev->stream_lock);
+		break;
+	case CLK_MODULE:
+		mutex_lock(&vin_dev->power_lock);
+		if (vin_dev->power_count > 0) {
+			reg_base = vin->clkgen_base;
+			dump_clk_reg(reg_base);
+		}
+		mutex_unlock(&vin_dev->power_lock);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void set_reg_val(struct stfcamss *stfcamss, int id, u32 offset, u32 val)
+{
+	struct stf_vin_dev *vin = stfcamss->vin;
+	struct stf_vin2_dev *vin_dev = stfcamss->vin_dev;
+	struct stf_isp_dev *isp_dev = stfcamss->isp_dev;
+	struct stf_csi_dev *csi_dev = stfcamss->csi_dev;
+	void __iomem *reg_base;
+
+	switch (id) {
+	case VIN_MODULE:
+	case CSIPHY_MODULE:
+	case DVP_MODULE:
+		mutex_lock(&vin_dev->power_lock);
+		if (vin_dev->power_count > 0) {
+			reg_base = vin->sysctrl_base;
+			print_reg(ST_VIN, reg_base, offset);
+			reg_write(reg_base, offset, val);
+			print_reg(ST_VIN, reg_base, offset);
+		}
+		mutex_unlock(&vin_dev->power_lock);
+		break;
+	case ISP_MODULE:
+		mutex_lock(&isp_dev->stream_lock);
+		if (isp_dev->stream_count > 0) {
+			reg_base = vin->isp_base;
+			print_reg(ST_ISP, reg_base, offset);
+			reg_write(reg_base, offset, val);
+			print_reg(ST_ISP, reg_base, offset);
+		}
+		mutex_unlock(&isp_dev->stream_lock);
+		break;
+	case CSI_MODULE:
+		mutex_lock(&csi_dev->stream_lock);
+		if (csi_dev->stream_count > 0) {
+			reg_base = vin->csi2rx_base;
+			print_reg(ST_CSI, reg_base, offset);
+			reg_write(reg_base, offset, val);
+			print_reg(ST_CSI, reg_base, offset);
+		}
+		mutex_unlock(&csi_dev->stream_lock);
+		break;
+	case CLK_MODULE:
+		mutex_lock(&vin_dev->power_lock);
+		if (vin_dev->power_count > 0) {
+			reg_base = vin->clkgen_base;
+			print_reg(ST_CAMSS, reg_base, offset);
+			reg_write(reg_base, offset, val);
+			print_reg(ST_CAMSS, reg_base, offset);
+		}
+		mutex_unlock(&vin_dev->power_lock);
+		break;
+	default:
+		break;
+
+	}
+}
+
+static u32 atoi(const char *s)
+{
+	u32 ret = 0, d = 0;
+	char ch;
+	int hex = 0;
+
+	if ((*s == '0') && (*(s+1) == 'x')) {
+		hex = 1;
+		s += 2;
+	}
+
+	while (1) {
+		if (!hex) {
+			d = (*s++) - '0';
+			if (d > 9)
+				break;
+			ret *= 10;
+			ret += d;
+		} else {
+			ch = tolower(*s++);
+			if (isdigit(ch))
+				d = ch - '0';
+			else if (islower(ch))
+				d = ch - 'a' + 10;
+			else
+				break;
+			if (d > 15)
+				break;
+			ret *= 16;
+			ret += d;
+		}
+	}
+
+	return ret;
+}
+
+static ssize_t vin_debug_write(struct file *file, const char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct device *dev = file->private_data;
+	struct stfcamss *stfcamss = dev_get_drvdata(dev);
+	char *buf;
+	char *line;
+	char *p;
+	static const char *delims = " \t\r";
+	char *token;
+	u32 offset, val;
+
+	buf = memdup_user_nul(user_buf, min_t(size_t, PAGE_SIZE, count));
+	if (IS_ERR(buf))
+		return PTR_ERR(buf);
+	p = buf;
+	st_debug(ST_CAMSS, "dup buf: %s, len: %lu, count: %lu\n", p, strlen(p), count);
+	while (p && *p) {
+		p = skip_spaces(p);
+		line = strsep(&p, "\n");
+		if (!*line || *line == '#')
+			break;
+		token = strsep(&line, delims);
+		if (!token)
+			goto out;
+		id_num = atoi(token);
+		token = strsep(&line, delims);
+		if (!token)
+			goto out;
+		offset = atoi(token);
+		token = strsep(&line, delims);
+		if (!token)
+			goto out;
+		val = atoi(token);
+	}
+	set_reg_val(stfcamss, id_num, offset, val);
+out:
+	kfree(buf);
+	st_info(ST_CAMSS, "id_num = %d, offset = 0x%x, 0x%x\n", id_num, offset, val);
+	return count;
+}
+
+static const struct file_operations vin_debug_fops = {
+	.open = simple_open,
+	.read = vin_debug_read,
+	.write = vin_debug_write,
+};
+#endif /* CONFIG_DEBUG_FS */
+
+
+static int stfcamss_probe(struct platform_device *pdev)
+{
+	struct stfcamss *stfcamss;
+	struct stf_vin_dev *vin;
+	struct device *dev = &pdev->dev;
+	struct of_phandle_args args;
+	int ret = 0, num_subdevs;
+	struct stf_resets *reset;
+	int i;
+
+	dev_info(dev, "stfcamss probe enter!\n");
+
+	stfcamss = devm_kzalloc(dev, sizeof(struct stfcamss), GFP_KERNEL);
+	if (!stfcamss)
+		return -ENOMEM;
+
+	stfcamss->dvp_dev = devm_kzalloc(dev,
+		sizeof(*stfcamss->dvp_dev), GFP_KERNEL);
+	if (!stfcamss->dvp_dev) {
+		ret = -ENOMEM;
+		goto err_cam;
+	}
+
+	stfcamss->csiphy_dev = devm_kzalloc(dev,
+		sizeof(*stfcamss->csiphy_dev),
+		GFP_KERNEL);
+	if (!stfcamss->csiphy_dev) {
+		ret = -ENOMEM;
+		goto err_cam;
+	}
+
+	stfcamss->csi_dev = devm_kzalloc(dev,
+		sizeof(*stfcamss->csi_dev),
+		GFP_KERNEL);
+	if (!stfcamss->csi_dev) {
+		ret = -ENOMEM;
+		goto err_cam;
+	}
+
+	stfcamss->isp_dev = devm_kzalloc(dev,
+		sizeof(*stfcamss->isp_dev),
+		GFP_KERNEL);
+	if (!stfcamss->isp_dev) {
+		ret = -ENOMEM;
+		goto err_cam;
+	}
+
+	stfcamss->vin_dev = devm_kzalloc(dev,
+		sizeof(*stfcamss->vin_dev),
+		GFP_KERNEL);
+	if (!stfcamss->vin_dev) {
+		ret = -ENOMEM;
+		goto err_cam;
+	}
+
+	stfcamss->vin = devm_kzalloc(dev,
+		sizeof(struct stf_vin_dev),
+		GFP_KERNEL);
+	if (!stfcamss->vin) {
+		ret = -ENOMEM;
+		goto err_cam;
+	}
+
+	vin = stfcamss->vin;
+
+	vin->irq = platform_get_irq(pdev, 0);
+	if (vin->irq <= 0) {
+		st_err(ST_CAMSS, "Could not get irq\n");
+		goto err_cam;
+	}
+
+	vin->isp_irq = platform_get_irq(pdev, 1);
+	if (vin->isp_irq <= 0) {
+		st_err(ST_CAMSS, "Could not get isp irq\n");
+		goto err_cam;
+	}
+
+	vin->isp_csi_irq = platform_get_irq(pdev, 2);
+	if (vin->isp_csi_irq <= 0) {
+		st_err(ST_CAMSS, "Could not get isp csi irq\n");
+		goto err_cam;
+	}
+
+	vin->isp_scd_irq = platform_get_irq(pdev, 3);
+	if (vin->isp_scd_irq <= 0) {
+		st_err(ST_CAMSS, "Could not get isp scd irq\n");
+		goto err_cam;
+	}
+
+	vin->isp_irq_csiline = platform_get_irq(pdev, 4);
+	if (vin->isp_irq_csiline <= 0) {
+		st_err(ST_CAMSS, "Could not get isp irq csiline\n");
+		goto err_cam;
+	}
+
+	pm_runtime_enable(dev);
+
+	stfcamss->nclks = ARRAY_SIZE(stfcamss_clocks);
+	stfcamss->sys_clk = stfcamss_clocks;
+
+	ret = devm_clk_bulk_get(dev, stfcamss->nclks, stfcamss->sys_clk);
+	if (ret) {
+		st_err(ST_CAMSS, "Failed to get clk controls\n");
+		return ret;
+	}
+
+	stfcamss->nrsts = ARRAY_SIZE(stfcamss_resets);
+	stfcamss->sys_rst = devm_kzalloc(dev,
+			stfcamss->nrsts * sizeof(*stfcamss->sys_rst),
+			GFP_KERNEL);
+	if (!stfcamss->sys_rst) {
+		ret = -ENOMEM;
+		goto err_cam;
+	}
+
+	for (i = 0; i < stfcamss->nrsts; i++) {
+		reset = &stfcamss->sys_rst[i];
+
+		reset->rstc = devm_reset_control_get_shared(dev, stfcamss_resets[i]);
+		if (IS_ERR(reset->rstc)) {
+			st_err(ST_CAMSS, "Failed to get %s reset", stfcamss_resets[i]);
+			return PTR_ERR(reset->rstc);
+		}
+
+		reset->name = stfcamss_resets[i];
+	}
+
+	ret = of_parse_phandle_with_fixed_args(dev->of_node,
+			"starfive,aon-syscon", 1, 0, &args);
+	if (ret < 0) {
+		st_err(ST_CAMSS, "Failed to parse starfive,aon-syscon\n");
+		return -EINVAL;
+	}
+
+	stfcamss->stf_aon_syscon = syscon_node_to_regmap(args.np);
+	of_node_put(args.np);
+	if (IS_ERR(stfcamss->stf_aon_syscon))
+		return PTR_ERR(stfcamss->stf_aon_syscon);
+
+	stfcamss->aon_gp_reg = args.args[0];
+
+	ret = stfcamss_get_mem_res(pdev, vin);
+	if (ret) {
+		st_err(ST_CAMSS, "Could not map registers\n");
+		goto err_cam;
+	}
+
+	ret = vin_parse_dt(dev, vin);
+	if (ret)
+		goto err_cam;
+
+	vin->dev = dev;
+	stfcamss->dev = dev;
+	platform_set_drvdata(pdev, stfcamss);
+
+	v4l2_async_notifier_init(&stfcamss->notifier);
+
+	num_subdevs = stfcamss_of_parse_ports(stfcamss);
+	if (num_subdevs < 0) {
+		ret = num_subdevs;
+		goto err_cam_noti;
+	}
+
+	ret = stfcamss_init_subdevices(stfcamss);
+	if (ret < 0) {
+		st_err(ST_CAMSS, "Failed to init subdevice: %d\n", ret);
+		goto err_cam_noti;
+	}
+
+	stfcamss->media_dev.dev = stfcamss->dev;
+	strscpy(stfcamss->media_dev.model, "Starfive Camera Subsystem",
+		sizeof(stfcamss->media_dev.model));
+	strscpy(stfcamss->media_dev.serial, "0123456789ABCDEF",
+		sizeof(stfcamss->media_dev.serial));
+	snprintf(stfcamss->media_dev.bus_info, sizeof(stfcamss->media_dev.bus_info),
+			"%s:%s", dev_bus_name(dev), pdev->name);
+	stfcamss->media_dev.hw_revision = 0x01;
+	stfcamss->media_dev.ops = &stfcamss_media_ops;
+	media_device_init(&stfcamss->media_dev);
+
+	stfcamss->v4l2_dev.mdev = &stfcamss->media_dev;
+
+	ret = v4l2_device_register(stfcamss->dev, &stfcamss->v4l2_dev);
+	if (ret < 0) {
+		st_err(ST_CAMSS, "Failed to register V4L2 device: %d\n", ret);
+		goto err_cam_noti_med;
+	}
+
+	ret = stfcamss_register_subdevices(stfcamss);
+	if (ret < 0) {
+		st_err(ST_CAMSS, "Failed to register subdevice: %d\n", ret);
+		goto err_cam_noti_med_vreg;
+	}
+
+	if (num_subdevs) {
+		stfcamss->notifier.ops = &stfcamss_subdev_notifier_ops;
+		ret = v4l2_async_notifier_register(&stfcamss->v4l2_dev,
+				&stfcamss->notifier);
+		if (ret) {
+			st_err(ST_CAMSS,
+				"Failed to register async subdev nodes: %d\n",
+				ret);
+			goto err_cam_noti_med_vreg_sub;
+		}
+	} else {
+		ret = v4l2_device_register_subdev_nodes(&stfcamss->v4l2_dev);
+		if (ret < 0) {
+			st_err(ST_CAMSS,
+				"Failed to register subdev nodes: %d\n",
+				ret);
+			goto err_cam_noti_med_vreg_sub;
+		}
+
+		ret = media_device_register(&stfcamss->media_dev);
+		if (ret < 0) {
+			st_err(ST_CAMSS, "Failed to register media device: %d\n",
+					ret);
+			goto err_cam_noti_med_vreg_sub_medreg;
+		}
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	stfcamss->debugfs_entry = debugfs_create_dir("stfcamss", NULL);
+	stfcamss->vin_debugfs = debugfs_create_file("stf_vin",
+			0644, stfcamss->debugfs_entry,
+			(void *)dev, &vin_debug_fops);
+	debugfs_create_u32("dbg_level",
+			0644, stfcamss->debugfs_entry,
+			&stdbg_level);
+	debugfs_create_u32("dbg_mask",
+			0644, stfcamss->debugfs_entry,
+			&stdbg_mask);
+#endif
+	dev_info(dev, "stfcamss probe success!\n");
+
+	return 0;
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(stfcamss->vin_debugfs);
+	debugfs_remove_recursive(stfcamss->debugfs_entry);
+	stfcamss->debugfs_entry = NULL;
+#endif
+
+err_cam_noti_med_vreg_sub_medreg:
+err_cam_noti_med_vreg_sub:
+	stfcamss_unregister_subdevices(stfcamss);
+err_cam_noti_med_vreg:
+	v4l2_device_unregister(&stfcamss->v4l2_dev);
+err_cam_noti_med:
+	media_device_cleanup(&stfcamss->media_dev);
+err_cam_noti:
+	v4l2_async_notifier_cleanup(&stfcamss->notifier);
+err_cam:
+	// kfree(stfcamss);
+	return ret;
+}
+
+static int stfcamss_remove(struct platform_device *pdev)
+{
+	struct stfcamss *stfcamss = platform_get_drvdata(pdev);
+
+	dev_info(&pdev->dev, "remove done\n");
+
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove(stfcamss->vin_debugfs);
+	debugfs_remove_recursive(stfcamss->debugfs_entry);
+	stfcamss->debugfs_entry = NULL;
+#endif
+
+	stfcamss_unregister_subdevices(stfcamss);
+	v4l2_device_unregister(&stfcamss->v4l2_dev);
+	media_device_cleanup(&stfcamss->media_dev);
+	pm_runtime_disable(&pdev->dev);
+
+	kfree(stfcamss);
+
+	return 0;
+}
+
+static const struct of_device_id stfcamss_of_match[] = {
+	{ .compatible = "starfive,jh7110-vin" },
+	{ /* end node */ },
+};
+
+MODULE_DEVICE_TABLE(of, stfcamss_of_match);
+
+#ifdef CONFIG_PM_SLEEP
+static int stfcamss_suspend(struct device *dev)
+{
+	struct stfcamss *stfcamss = dev_get_drvdata(dev);
+	struct stf_vin2_dev *vin_dev = stfcamss->vin_dev;
+	struct media_entity *entity;
+	struct media_pad *pad;
+	struct v4l2_subdev *subdev;
+	struct stfcamss_video *video;
+	struct video_device *vdev;
+	int i = 0;
+	int pm_power_count;
+	int pm_stream_count;
+
+	for (i = 0; i < VIN_LINE_MAX; i++) {
+		video = &vin_dev->line[i].video_out;
+		vdev = &vin_dev->line[i].video_out.vdev;
+		vin_dev->line[i].pm_power_count = vin_dev->line[i].power_count;
+		vin_dev->line[i].pm_stream_count = vin_dev->line[i].stream_count;
+		pm_power_count = vin_dev->line[i].pm_power_count;
+		pm_stream_count = vin_dev->line[i].pm_stream_count;
+
+		if (pm_stream_count) {
+			while (pm_stream_count--) {
+				entity = &vdev->entity;
+				while (1) {
+					pad = &entity->pads[0];
+					if (!(pad->flags & MEDIA_PAD_FL_SINK))
+						break;
+
+					pad = media_entity_remote_pad(pad);
+					if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+						break;
+
+					entity = pad->entity;
+					subdev = media_entity_to_v4l2_subdev(entity);
+
+					v4l2_subdev_call(subdev, video, s_stream, 0);
+				}
+			}
+			media_pipeline_stop(&vdev->entity);
+			video->ops->flush_buffers(video, VB2_BUF_STATE_ERROR);
+		}
+
+		if (!pm_power_count)
+			continue;
+
+		v4l2_pipeline_pm_put(&vdev->entity);
+	}
+
+	return pm_runtime_force_suspend(dev);
+}
+
+static int stfcamss_resume(struct device *dev)
+{
+	struct stfcamss *stfcamss = dev_get_drvdata(dev);
+	struct stf_vin2_dev *vin_dev = stfcamss->vin_dev;
+	struct media_entity *entity;
+	struct media_pad *pad;
+	struct v4l2_subdev *subdev;
+	struct stfcamss_video *video;
+	struct video_device *vdev;
+	int i = 0;
+	int pm_power_count;
+	int pm_stream_count;
+	int ret = 0;
+
+	pm_runtime_force_resume(dev);
+
+	for (i = 0; i < VIN_LINE_MAX; i++) {
+		video = &vin_dev->line[i].video_out;
+		vdev = &vin_dev->line[i].video_out.vdev;
+		pm_power_count = vin_dev->line[i].pm_power_count;
+		pm_stream_count = vin_dev->line[i].pm_stream_count;
+
+		if (!pm_power_count)
+			continue;
+
+		ret = v4l2_pipeline_pm_get(&vdev->entity);
+		if (ret < 0)
+			goto err;
+
+		if (pm_stream_count) {
+			ret = media_pipeline_start(&vdev->entity, &video->stfcamss->pipe);
+			if (ret < 0)
+				goto err_pm_put;
+
+			while (pm_stream_count--) {
+				entity = &vdev->entity;
+				while (1) {
+					pad = &entity->pads[0];
+					if (!(pad->flags & MEDIA_PAD_FL_SINK))
+						break;
+
+					pad = media_entity_remote_pad(pad);
+					if (!pad || !is_media_entity_v4l2_subdev(pad->entity))
+						break;
+
+					entity = pad->entity;
+					subdev = media_entity_to_v4l2_subdev(entity);
+
+					ret = v4l2_subdev_call(subdev, video, s_stream, 1);
+					if (ret < 0 && ret != -ENOIOCTLCMD)
+						goto err_pipeline_stop;
+				}
+			}
+		}
+	}
+
+	return 0;
+
+err_pipeline_stop:
+	media_pipeline_stop(&vdev->entity);
+err_pm_put:
+	v4l2_pipeline_pm_put(&vdev->entity);
+err:
+	return ret;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_PM
+static int stfcamss_runtime_suspend(struct device *dev)
+{
+	struct stfcamss *stfcamss = dev_get_drvdata(dev);
+
+	reset_control_assert(stfcamss->sys_rst[STFRST_ISP_TOP_AXI].rstc);
+	reset_control_assert(stfcamss->sys_rst[STFRST_ISP_TOP_N].rstc);
+	clk_disable_unprepare(stfcamss->sys_clk[STFCLK_ISP_AXI].clk);
+	clk_disable_unprepare(stfcamss->sys_clk[STFCLK_ISPCORE_2X].clk);
+
+	return 0;
+}
+
+static int stfcamss_runtime_resume(struct device *dev)
+{
+	struct stfcamss *stfcamss = dev_get_drvdata(dev);
+
+	clk_prepare_enable(stfcamss->sys_clk[STFCLK_ISPCORE_2X].clk);
+	clk_prepare_enable(stfcamss->sys_clk[STFCLK_ISP_AXI].clk);
+	reset_control_deassert(stfcamss->sys_rst[STFRST_ISP_TOP_N].rstc);
+	reset_control_deassert(stfcamss->sys_rst[STFRST_ISP_TOP_AXI].rstc);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static const struct dev_pm_ops stfcamss_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(stfcamss_suspend, stfcamss_resume)
+	SET_RUNTIME_PM_OPS(stfcamss_runtime_suspend, stfcamss_runtime_resume, NULL)
+};
+
+static struct platform_driver stfcamss_driver = {
+	.probe = stfcamss_probe,
+	.remove = stfcamss_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = &stfcamss_pm_ops,
+		.of_match_table = of_match_ptr(stfcamss_of_match),
+	},
+};
+
+static int __init stfcamss_init(void)
+{
+	return platform_driver_register(&stfcamss_driver);
+}
+
+static void __exit stfcamss_cleanup(void)
+{
+	platform_driver_unregister(&stfcamss_driver);
+}
+
+module_init(stfcamss_init);
+//fs_initcall(stfcamss_init);
+module_exit(stfcamss_cleanup);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/starfive/v4l2_driver/stfcamss.h b/drivers/media/platform/starfive/v4l2_driver/stfcamss.h
new file mode 100644
index 000000000000..88ef0b853c1d
--- /dev/null
+++ b/drivers/media/platform/starfive/v4l2_driver/stfcamss.h
@@ -0,0 +1,120 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef STFCAMSS_H
+#define STFCAMSS_H
+
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/reset.h>
+#include <linux/clk.h>
+
+enum sensor_type {
+	SENSOR_VIN,
+	/* need replace sensor */
+	SENSOR_ISP,
+};
+
+enum subdev_type {
+	VIN_DEV_TYPE,
+	ISP_DEV_TYPE,
+};
+
+#include "stf_common.h"
+#include "stf_dvp.h"
+#include "stf_csi.h"
+#include "stf_csiphy.h"
+#include "stf_isp.h"
+#include "stf_vin.h"
+
+#define STF_PAD_SINK   0
+#define STF_PAD_SRC    1
+#define STF_PADS_NUM   2
+
+#define STF_CAMSS_SKIP_ITI
+
+enum port_num {
+	DVP_SENSOR_PORT_NUMBER = 0,
+	CSI2RX_SENSOR_PORT_NUMBER
+};
+
+enum stf_clk_num {
+	STFCLK_APB_FUNC = 0,
+	STFCLK_PCLK,
+	STFCLK_SYS_CLK,
+	STFCLK_WRAPPER_CLK_C,
+	STFCLK_DVP_INV,
+	STFCLK_AXIWR,
+	STFCLK_MIPI_RX0_PXL,
+	STFCLK_PIXEL_CLK_IF0,
+	STFCLK_PIXEL_CLK_IF1,
+	STFCLK_PIXEL_CLK_IF2,
+	STFCLK_PIXEL_CLK_IF3,
+	STFCLK_M31DPHY_CFGCLK_IN,
+	STFCLK_M31DPHY_REFCLK_IN,
+	STFCLK_M31DPHY_TXCLKESC_LAN0,
+	STFCLK_ISPCORE_2X,
+	STFCLK_ISP_AXI,
+	STFCLK_NUM
+};
+
+enum stf_rst_num {
+	STFRST_WRAPPER_P = 0,
+	STFRST_WRAPPER_C,
+	STFRST_PCLK,
+	STFRST_SYS_CLK,
+	STFRST_AXIRD,
+	STFRST_AXIWR,
+	STFRST_PIXEL_CLK_IF0,
+	STFRST_PIXEL_CLK_IF1,
+	STFRST_PIXEL_CLK_IF2,
+	STFRST_PIXEL_CLK_IF3,
+	STFRST_M31DPHY_HW,
+	STFRST_M31DPHY_B09_ALWAYS_ON,
+	STFRST_ISP_TOP_N,
+	STFRST_ISP_TOP_AXI,
+	STFRST_NUM
+};
+
+struct stf_resets {
+	struct reset_control *rstc;
+	char *name;
+};
+
+struct stfcamss {
+	struct stf_vin_dev *vin;  // stfcamss phy res
+	struct v4l2_device v4l2_dev;
+	struct media_device media_dev;
+	struct media_pipeline pipe;
+	struct device *dev;
+	struct stf_vin2_dev *vin_dev;  // subdev
+	struct stf_dvp_dev *dvp_dev;   // subdev
+	struct stf_csi_dev *csi_dev;   // subdev
+	struct stf_csiphy_dev *csiphy_dev;   // subdev
+	struct stf_isp_dev *isp_dev;   // subdev
+	struct v4l2_async_notifier notifier;
+	struct clk_bulk_data *sys_clk;
+	int nclks;
+	struct stf_resets *sys_rst;
+	int nrsts;
+	struct regmap *stf_aon_syscon;
+	uint32_t aon_gp_reg;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_entry;
+	struct dentry *vin_debugfs;
+#endif
+};
+
+struct stfcamss_async_subdev {
+	struct v4l2_async_subdev asd;  // must be first
+	enum port_num port;
+	struct {
+		struct dvp_cfg dvp;
+		struct csi2phy_cfg csiphy;
+	} interface;
+};
+
+extern struct media_entity *stfcamss_find_sensor(struct media_entity *entity);
+
+#endif /* STFCAMSS_H */
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 30ff42fd173e..c6760c9382ba 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -839,6 +839,15 @@ config MMC_DW_HI3798CV200
 	  Synopsys DesignWare Memory Card Interface driver. Select this option
 	  for platforms based on HiSilicon Hi3798CV200 SoC.
 
+config MMC_DW_STARFIVE
+	tristate "StarFive specific extensions for Synopsys DW Memory Card Interface"
+	depends on MMC_DW
+	select MMC_DW_PLTFM
+	help
+	  This selects support for StarFive JH7110 SoC specific extensions to the
+	  Synopsys DesignWare Memory Card Interface driver. Select this option
+	  for platforms based on Starfive JH7110 SoC.
+
 config MMC_DW_K3
 	tristate "K3 specific extensions for Synopsys DW Memory Card Interface"
 	depends on MMC_DW
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 451c25fc2c69..3659fbbf4e60 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -55,6 +55,7 @@ thunderx-mmc-objs := cavium.o cavium-thunderx.o
 obj-$(CONFIG_MMC_CAVIUM_THUNDERX) += thunderx-mmc.o
 obj-$(CONFIG_MMC_DW)		+= dw_mmc.o
 obj-$(CONFIG_MMC_DW_PLTFM)	+= dw_mmc-pltfm.o
+obj-$(CONFIG_MMC_DW_STARFIVE)	+= dw_mmc-starfive.o
 obj-$(CONFIG_MMC_DW_BLUEFIELD)	+= dw_mmc-bluefield.o
 obj-$(CONFIG_MMC_DW_EXYNOS)	+= dw_mmc-exynos.o
 obj-$(CONFIG_MMC_DW_HI3798CV200) += dw_mmc-hi3798cv200.o
diff --git a/drivers/mmc/host/dw_mmc-starfive.c b/drivers/mmc/host/dw_mmc-starfive.c
new file mode 100644
index 000000000000..614cac5adeb6
--- /dev/null
+++ b/drivers/mmc/host/dw_mmc-starfive.c
@@ -0,0 +1,230 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2022 StarFive, Inc <clivia.cai@starfivetech.com>
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING
+ * CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER
+ * FOR THEM TO SAVE TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE
+ * FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+ * CLAIMS ARISING FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE
+ * BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION
+ * WITH THEIR PRODUCTS.
+ */
+
+
+#include <linux/clk.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mmc/host.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+#include "dw_mmc.h"
+#include "dw_mmc-pltfm.h"
+
+#define ALL_INT_CLR		0x1ffff
+#define MAX_DELAY_CHAIN		32
+struct starfive_priv {
+	struct device *dev;
+	struct regmap *reg_syscon;
+	u32 syscon_offset;
+	u32 syscon_shift;
+	u32 syscon_mask;
+};
+
+static unsigned long dw_mci_starfive_caps[] = {
+	MMC_CAP_CMD23,
+	MMC_CAP_CMD23,
+	MMC_CAP_CMD23
+};
+
+static void dw_mci_starfive_set_ios(struct dw_mci *host, struct mmc_ios *ios)
+{
+	int ret;
+	unsigned int clock;
+
+	if (ios->timing == MMC_TIMING_MMC_DDR52 || ios->timing == MMC_TIMING_UHS_DDR50) {
+		clock = (ios->clock > 50000000 && ios->clock <= 52000000) ? 100000000 : ios->clock;
+		ret = clk_set_rate(host->ciu_clk, clock);
+		if (ret)
+			dev_dbg(host->dev, "Use an external frequency divider %uHz\n", ios->clock);
+		host->bus_hz = clk_get_rate(host->ciu_clk);
+	} else {
+		dev_dbg(host->dev, "Using the internal divider\n");
+	}
+}
+
+static int dw_mci_starfive_execute_tuning(struct dw_mci_slot *slot,
+					     u32 opcode)
+{
+	static const int grade  = MAX_DELAY_CHAIN;
+	struct dw_mci *host = slot->host;
+	struct starfive_priv *priv = host->priv;
+	int raise_point = -1, fall_point = -1;
+	int err, prev_err = -1;
+	int found = 0;
+	int i;
+	u32 regval;
+
+	for (i = 0; i < grade; i++) {
+		regval = i << priv->syscon_shift;
+		err = regmap_update_bits(priv->reg_syscon, priv->syscon_offset, priv->syscon_mask, regval);
+		if (err)
+			return err;
+		mci_writel(host, RINTSTS, ALL_INT_CLR);
+
+		err = mmc_send_tuning(slot->mmc, opcode, NULL);
+		if (!err)
+			found = 1;
+
+		if (i > 0) {
+			if (err && !prev_err)
+				fall_point = i - 1;
+			if (!err && prev_err)
+				raise_point = i;
+		}
+
+		if (raise_point != -1 && fall_point != -1)
+			goto tuning_out;
+
+		prev_err = err;
+		err = 0;
+	}
+
+tuning_out:
+	if (found) {
+		if (raise_point == -1)
+			raise_point = 0;
+		if (fall_point == -1)
+			fall_point = grade - 1;
+		if (fall_point < raise_point) {
+			if ((raise_point + fall_point) >
+			    (grade - 1))
+				i = fall_point / 2;
+			else
+				i = (raise_point + grade - 1) / 2;
+		} else {
+			i = (raise_point + fall_point) / 2;
+		}
+
+		regval = i << priv->syscon_shift;
+		err = regmap_update_bits(priv->reg_syscon, priv->syscon_offset, priv->syscon_mask, regval);
+		if (err)
+			return err;
+		dev_dbg(host->dev, "Found valid delay chain! use it [delay=%d]\n", i);
+	} else {
+		dev_err(host->dev, "No valid delay chain! use default\n");
+		err = -EINVAL;
+	}
+
+	mci_writel(host, RINTSTS, ALL_INT_CLR);
+	return err;
+}
+
+static int dw_mci_starfive_parse_dt(struct dw_mci *host)
+{
+	struct of_phandle_args args;
+	struct starfive_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	ret = of_parse_phandle_with_fixed_args(host->dev->of_node,
+						"starfive,sys-syscon", 3, 0, &args);
+	if (ret) {
+		dev_err(host->dev, "Failed to parse starfive,sys-syscon\n");
+		return -EINVAL;
+	}
+
+	priv->reg_syscon = syscon_node_to_regmap(args.np);
+	of_node_put(args.np);
+	if (IS_ERR(priv->reg_syscon))
+		return PTR_ERR(priv->reg_syscon);
+
+	priv->syscon_offset = args.args[0];
+	priv->syscon_shift  = args.args[1];
+	priv->syscon_mask   = args.args[2];
+
+	host->priv = priv;
+
+	return 0;
+}
+
+static const struct dw_mci_drv_data starfive_data = {
+	.caps = dw_mci_starfive_caps,
+	.num_caps = ARRAY_SIZE(dw_mci_starfive_caps),
+	.set_ios = dw_mci_starfive_set_ios,
+	.parse_dt = dw_mci_starfive_parse_dt,
+	.execute_tuning = dw_mci_starfive_execute_tuning,
+};
+
+static const struct of_device_id dw_mci_starfive_match[] = {
+	{ .compatible = "starfive,jh7110-sdio",
+		.data = &starfive_data },
+	{},
+};
+MODULE_DEVICE_TABLE(of, dw_mci_starfive_match);
+
+static int dw_mci_starfive_probe(struct platform_device *pdev)
+{
+	const struct dw_mci_drv_data *drv_data;
+	const struct of_device_id *match;
+	int ret;
+
+	match = of_match_node(dw_mci_starfive_match, pdev->dev.of_node);
+	drv_data = match->data;
+
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+
+	ret = dw_mci_pltfm_register(pdev, drv_data);
+	if (ret) {
+		pm_runtime_disable(&pdev->dev);
+		pm_runtime_set_suspended(&pdev->dev);
+		pm_runtime_put_noidle(&pdev->dev);
+
+		return ret;
+	}
+
+	return 0;
+}
+
+static int dw_mci_starfive_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
+
+	return dw_mci_pltfm_remove(pdev);
+}
+
+static const struct dev_pm_ops dw_mci_starfive_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+	SET_RUNTIME_PM_OPS(dw_mci_runtime_suspend,
+			   dw_mci_runtime_resume, NULL)
+};
+
+static struct platform_driver dw_mci_starfive_driver = {
+	.probe = dw_mci_starfive_probe,
+	.remove = dw_mci_starfive_remove,
+	.driver = {
+		.name = "dwmmc_starfive",
+		.pm   = &dw_mci_starfive_pm_ops,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+		.of_match_table = dw_mci_starfive_match,
+	},
+};
+module_platform_driver(dw_mci_starfive_driver);
+
+MODULE_DESCRIPTION("StarFive JH7110 Specific DW-MSHC Driver Extension");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:dwmmc_starfive");
diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index 13eda0c37f7c..7cab1b86d065 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -219,6 +219,16 @@ config DWMAC_INTEL_PLAT
 	  This selects the Intel platform specific glue layer support for
 	  the stmmac device driver. This driver is used for the Intel Keem Bay
 	  SoC.
+
+config DWMAC_STARFIVE_PLAT
+	tristate "StarFive dwmac support"
+	depends on OF && COMMON_CLK
+	depends on STMMAC_ETH
+	help
+	  Support for ethernet controllers on StarFive SoCs
+
+	  This selects the StarFive platform specific glue layer support for
+	  the stmmac device driver. This driver is used for StarFive SoCs.
 endif
 
 config DWMAC_INTEL
diff --git a/drivers/net/ethernet/stmicro/stmmac/Makefile b/drivers/net/ethernet/stmicro/stmmac/Makefile
index 11ea4569c43d..ed14b6c6d232 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Makefile
+++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_DWMAC_SUNXI)	+= dwmac-sunxi.o
 obj-$(CONFIG_DWMAC_SUN8I)	+= dwmac-sun8i.o
 obj-$(CONFIG_DWMAC_DWC_QOS_ETH)	+= dwmac-dwc-qos-eth.o
 obj-$(CONFIG_DWMAC_INTEL_PLAT)	+= dwmac-intel-plat.o
+obj-$(CONFIG_DWMAC_STARFIVE_PLAT)	+= dwmac-starfive-plat.o
 obj-$(CONFIG_DWMAC_GENERIC)	+= dwmac-generic.o
 obj-$(CONFIG_DWMAC_IMX8)	+= dwmac-imx.o
 stmmac-platform-objs:= stmmac_platform.o
@@ -34,5 +35,5 @@ dwmac-altr-socfpga-objs := altr_tse_pcs.o dwmac-socfpga.o
 
 obj-$(CONFIG_STMMAC_PCI)	+= stmmac-pci.o
 obj-$(CONFIG_DWMAC_INTEL)	+= dwmac-intel.o
-obj-$(CONFIG_DWMAC_LOONGSON)	+= dwmac-loongson.o
+obj-$(CONFIG_DWMAC_STARFIVE_PLAT)	+= dwmac-starfive-plat.o
 stmmac-pci-objs:= stmmac_pci.o
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-starfive-plat.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-starfive-plat.c
new file mode 100644
index 000000000000..b9eb63dc8711
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-starfive-plat.c
@@ -0,0 +1,177 @@
+// SPDX-License-Identifier: GPL-2.0
+/* StarFive DWMAC platform driver
+ *
+ * Copyright(C) 2022 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/of_device.h>
+#include "stmmac_platform.h"
+
+struct starfive_dwmac {
+	struct device *dev;
+	void __iomem *regs;
+	struct clk *clk_tx;
+	struct clk *clk_gtx;
+	struct clk *clk_gtxc;
+	struct reset_control *stmmac_ahb_rst;
+	struct clk *clk_rmii_rtx;
+};
+
+static void starfive_eth_fix_mac_speed(void *priv, unsigned int speed)
+{
+	struct starfive_dwmac *dwmac = priv;
+	unsigned long rate;
+	int err;
+
+	switch (speed) {
+	case SPEED_1000:
+		rate = 125000000;
+		break;
+	case SPEED_100:
+		rate = 25000000;
+		break;
+	case SPEED_10:
+		rate = 2500000;
+		break;
+	default:
+		dev_err(dwmac->dev, "invalid speed %u\n", speed);
+		return;
+	}
+
+	err = clk_set_rate(dwmac->clk_gtx, rate);
+	if (err < 0)
+		dev_err(dwmac->dev, "failed to set tx rate %lu\n", rate);
+
+	err = clk_set_rate(dwmac->clk_rmii_rtx, rate);
+	if (err < 0)
+		dev_err(dwmac->dev, "failed to set rtx rate %lu\n", rate);
+}
+
+static const struct of_device_id starfive_eth_plat_match[] = {
+	{ .compatible = "starfive,dwmac"},
+	{ }
+};
+
+static int starfive_eth_plat_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct plat_stmmacenet_data *plat_dat;
+	struct stmmac_resources stmmac_res;
+	struct starfive_dwmac *dwmac;
+	int err;
+
+	err = stmmac_get_platform_resources(pdev, &stmmac_res);
+	if (err)
+		return err;
+
+	plat_dat = stmmac_probe_config_dt(pdev, &stmmac_res.mac);
+	if (IS_ERR(plat_dat)) {
+		dev_err(&pdev->dev, "dt configuration failed\n");
+		return PTR_ERR(plat_dat);
+	}
+
+	dwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);
+	if (!dwmac)
+		return -ENOMEM;
+
+	dwmac->dev = &pdev->dev;
+	dwmac->regs = stmmac_res.addr;
+
+	if (!is_of_node(dev->fwnode))
+		goto bypass_clk_reset_gpio;
+
+	dwmac->clk_tx = devm_clk_get(&pdev->dev, "tx");
+	if (IS_ERR(dwmac->clk_tx)) {
+		err = PTR_ERR(dwmac->clk_tx);
+		goto err;
+	}
+
+	err = clk_prepare_enable(dwmac->clk_tx);
+	if (err < 0)
+		goto err;
+
+	dwmac->clk_gtx = devm_clk_get(&pdev->dev, "gtx");
+	if (IS_ERR(dwmac->clk_gtx)) {
+		err = PTR_ERR(dwmac->clk_gtx);
+		goto disable_tx;
+	}
+
+	err = clk_prepare_enable(dwmac->clk_gtx);
+	if (err < 0)
+		goto disable_tx;
+
+	dwmac->clk_gtxc = devm_clk_get(&pdev->dev, "gtxc");
+	if (IS_ERR(dwmac->clk_gtxc)) {
+		err = PTR_ERR(dwmac->clk_gtxc);
+		goto disable_gtx;
+	}
+
+	dwmac->clk_rmii_rtx = devm_clk_get(&pdev->dev, "rmii_rtx");
+	if (IS_ERR(dwmac->clk_rmii_rtx)) {
+		err = PTR_ERR(dwmac->clk_rmii_rtx);
+		goto disable_gtx;
+	}
+
+	err = clk_prepare_enable(dwmac->clk_gtxc);
+	if (err < 0)
+		goto disable_gtx;
+
+	dwmac->stmmac_ahb_rst = devm_reset_control_get(&pdev->dev, "ahb");
+	if (IS_ERR(dwmac->stmmac_ahb_rst)) {
+		err = PTR_ERR(dwmac->clk_gtxc);
+		goto disable_gtxc;
+	}
+
+	err = reset_control_deassert(dwmac->stmmac_ahb_rst);
+	if (err < 0)
+		goto disable_gtxc;
+
+	err = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (err)
+		goto err;
+
+bypass_clk_reset_gpio:
+	plat_dat->fix_mac_speed = starfive_eth_fix_mac_speed;
+	plat_dat->init = NULL;
+	plat_dat->bsp_priv = dwmac;
+	return 0;
+
+disable_gtxc:
+	clk_disable_unprepare(dwmac->clk_gtxc);
+disable_gtx:
+	clk_disable_unprepare(dwmac->clk_gtx);
+disable_tx:
+	clk_disable_unprepare(dwmac->clk_tx);
+err:
+	stmmac_remove_config_dt(pdev, plat_dat);
+
+	return err;
+}
+
+static int starfive_eth_plat_remove(struct platform_device *pdev)
+{
+	struct starfive_dwmac *dwmac = get_stmmac_bsp_priv(&pdev->dev);
+
+	reset_control_assert(dwmac->stmmac_ahb_rst);
+	clk_disable_unprepare(dwmac->clk_gtxc);
+	clk_disable_unprepare(dwmac->clk_gtx);
+	clk_disable_unprepare(dwmac->clk_tx);
+
+	return 0;
+}
+
+static struct platform_driver starfive_eth_plat_driver = {
+	.probe  = starfive_eth_plat_probe,
+	.remove = starfive_eth_plat_remove,
+	.driver = {
+		.name			= "starfive-eth-plat",
+		.pm				= &stmmac_pltfr_pm_ops,
+		.of_match_table = starfive_eth_plat_match,
+	},
+};
+
+module_platform_driver(starfive_eth_plat_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("YanHong Wang  <yanhong.wang@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive DWMAC platform driver");
diff --git a/drivers/pci/controller/pcie-plda.c b/drivers/pci/controller/pcie-plda.c
new file mode 100644
index 000000000000..fc5c7ecee628
--- /dev/null
+++ b/drivers/pci/controller/pcie-plda.c
@@ -0,0 +1,1062 @@
+/*
+ * PCIe host controller driver for Starfive JH7110 Soc.
+ *
+ * Based on pcie-altera.c, pcie-altera-msi.c.
+ *
+ * Copyright (C) Shanghai StarFive Technology Co., Ltd.
+ *
+ * Author: ke.zhu@starfivetech.com
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+ * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+ * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+ * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+ * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+ * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/msi.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_pci.h>
+#include <linux/pci.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include "../pci.h"
+
+#define PCIE_BASIC_STATUS		0x018
+#define PCIE_CFGNUM			0x140
+#define IMASK_LOCAL			0x180
+#define ISTATUS_LOCAL			0x184
+#define IMSI_ADDR			0x190
+#define ISTATUS_MSI			0x194
+#define CFG_SPACE			0x1000
+#define GEN_SETTINGS			0x80
+#define PCIE_PCI_IDS			0x9C
+#define PCIE_WINROM			0xFC
+#define PMSG_SUPPORT_RX			0x3F0
+
+#define PCI_MISC			0xB4
+
+#define PLDA_EP_ENABLE			0
+#define PLDA_RP_ENABLE			1
+
+#define IDS_REVISION_ID			0x02
+#define IDS_PCI_TO_PCI_BRIDGE		0x060400
+#define IDS_CLASS_CODE_SHIFT		8
+
+#define PLDA_LINK_UP			1
+#define PLDA_LINK_DOWN			0
+
+#define PLDA_DATA_LINK_ACTIVE		BIT(5)
+#define PREF_MEM_WIN_64_SUPPORT		BIT(3)
+#define PMSG_LTR_SUPPORT		BIT(2)
+#define PDLA_LINK_SPEED_GEN2		BIT(12)
+#define PLDA_FUNCTION_DIS		BIT(15)
+#define PLDA_FUNC_NUM			4
+#define PLDA_PHY_FUNC_SHIFT		9
+#define PHY_KVCO_FINE_TUNE_LEVEL	0x91
+#define PHY_KVCO_FINE_TUNE_SIGNALS	0xc
+
+#define XR3PCI_ATR_AXI4_SLV0		0x800
+#define XR3PCI_ATR_SRC_ADDR_LOW		0x0
+#define XR3PCI_ATR_SRC_ADDR_HIGH	0x4
+#define XR3PCI_ATR_TRSL_ADDR_LOW	0x8
+#define XR3PCI_ATR_TRSL_ADDR_HIGH	0xc
+#define XR3PCI_ATR_TRSL_PARAM		0x10
+#define XR3PCI_ATR_TABLE_OFFSET		0x20
+#define XR3PCI_ATR_MAX_TABLE_NUM	8
+
+#define XR3PCI_ATR_SRC_WIN_SIZE_SHIFT	1
+#define XR3PCI_ATR_SRC_ADDR_MASK	0xfffff000
+#define XR3PCI_ATR_TRSL_ADDR_MASK	0xfffff000
+#define XR3_PCI_ECAM_SIZE		28
+#define XR3PCI_ATR_TRSL_DIR		BIT(22)
+/* IDs used in the XR3PCI_ATR_TRSL_PARAM */
+#define XR3PCI_ATR_TRSLID_PCIE_MEMORY	0x0
+#define XR3PCI_ATR_TRSLID_PCIE_CONFIG	0x1
+
+#define CFGNUM_DEVFN_SHIFT		0
+#define CFGNUM_BUS_SHIFT		8
+#define CFGNUM_BE_SHIFT			16
+#define CFGNUM_FBE_SHIFT		20
+
+#define ECAM_BUS_SHIFT			20
+#define ECAM_DEV_SHIFT			15
+#define ECAM_FUNC_SHIFT			12
+
+#define INT_AXI_POST_ERROR		BIT(16)
+#define INT_AXI_FETCH_ERROR		BIT(17)
+#define INT_AXI_DISCARD_ERROR		BIT(18)
+#define INT_PCIE_POST_ERROR		BIT(20)
+#define INT_PCIE_FETCH_ERROR		BIT(21)
+#define INT_PCIE_DISCARD_ERROR		BIT(22)
+#define INT_ERRORS		(INT_AXI_POST_ERROR | INT_AXI_FETCH_ERROR | \
+				 INT_AXI_DISCARD_ERROR | INT_PCIE_POST_ERROR | \
+				 INT_PCIE_FETCH_ERROR | INT_PCIE_DISCARD_ERROR)
+
+#define INTA_OFFSET		24
+#define INTA			BIT(24)
+#define INTB			BIT(25)
+#define INTC			BIT(26)
+#define INTD			BIT(27)
+#define INT_MSI			BIT(28)
+#define INT_INTX_MASK		(INTA | INTB | INTC | INTD)
+#define INT_MASK		(INT_INTX_MASK | INT_MSI | INT_ERRORS)
+
+#define INT_PCI_MSI_NR		32
+#define LINK_UP_MASK		0xff
+
+#define PERST_DELAY_US		1000
+
+/* system control */
+#define STG_SYSCON_K_RP_NEP_SHIFT		0x8
+#define STG_SYSCON_K_RP_NEP_MASK		0x100
+#define STG_SYSCON_AXI4_SLVL_ARFUNC_MASK	0x7FFF00
+#define STG_SYSCON_AXI4_SLVL_ARFUNC_SHIFT	0x8
+#define STG_SYSCON_AXI4_SLVL_AWFUNC_MASK	0x7FFF
+#define STG_SYSCON_AXI4_SLVL_AWFUNC_SHIFT	0x0
+#define STG_SYSCON_CLKREQ_SHIFT			0x16
+#define STG_SYSCON_CLKREQ_MASK			0x400000
+#define STG_SYSCON_CKREF_SRC_SHIFT		0x12
+#define STG_SYSCON_CKREF_SRC_MASK		0xC0000
+
+#define PCI_DEV(d)		(((d) >> 3) & 0x1f)
+
+/* MSI information */
+struct plda_msi {
+	DECLARE_BITMAP(used, INT_PCI_MSI_NR);
+	struct irq_domain *msi_domain;
+	struct irq_domain *inner_domain;
+	/* Protect bitmap variable */
+	struct mutex lock;
+};
+
+struct plda_pcie {
+	struct platform_device	*pdev;
+	void __iomem		*reg_base;
+	void __iomem		*config_base;
+	struct resource *cfg_res;
+	struct regmap *reg_syscon;
+	struct regmap *reg_phyctrl;
+	u32 stg_arfun;
+	u32 stg_awfun;
+	u32 stg_rp_nep;
+	u32 stg_lnksta;
+	u32 phy_kvco_level;
+	u32 phy_kvco_tune_signals;
+	int			irq;
+	struct irq_domain	*legacy_irq_domain;
+	struct pci_host_bridge  *bridge;
+	struct plda_msi		msi;
+	struct reset_control *resets;
+	struct clk_bulk_data *clks;
+	int num_clks;
+	int atr_table_num;
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *perst_state_def;
+	struct pinctrl_state *perst_state_active;
+};
+
+static inline void plda_writel(struct plda_pcie *pcie, const u32 value,
+			       const u32 reg)
+{
+	writel_relaxed(value, pcie->reg_base + reg);
+}
+
+static inline u32 plda_readl(struct plda_pcie *pcie, const u32 reg)
+{
+	return readl_relaxed(pcie->reg_base + reg);
+}
+
+static bool plda_pcie_hide_rc_bar(struct pci_bus *bus, unsigned int  devfn,
+				  int offset)
+{
+	if (pci_is_root_bus(bus) && (devfn == 0) &&
+	    (offset == PCI_BASE_ADDRESS_0))
+		return true;
+
+	return false;
+}
+
+static int _plda_pcie_config_read(struct plda_pcie *pcie, unsigned char busno,
+				  unsigned int devfn, int where, int size,
+				  u32 *value)
+{
+	void __iomem *addr;
+
+	addr = pcie->config_base;
+	addr += (busno << ECAM_BUS_SHIFT);
+	addr += (PCI_DEV(devfn) << ECAM_DEV_SHIFT);
+	addr += (PCI_FUNC(devfn) << ECAM_FUNC_SHIFT);
+	addr += where;
+
+	if (!addr)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	switch (size) {
+	case 1:
+		*(unsigned char *)value = readb(addr);
+		break;
+	case 2:
+		*(unsigned short *)value = readw(addr);
+		break;
+	case 4:
+		*(unsigned int *)value = readl(addr);
+		break;
+	default:
+		return PCIBIOS_SET_FAILED;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+int _plda_pcie_config_write(struct plda_pcie *pcie, unsigned char busno,
+			    unsigned int devfn, int where, int size, u32 value)
+{
+	void __iomem *addr;
+
+	addr = pcie->config_base;
+	addr += (busno << ECAM_BUS_SHIFT);
+	addr += (PCI_DEV(devfn) << ECAM_DEV_SHIFT);
+	addr += (PCI_FUNC(devfn) << ECAM_FUNC_SHIFT);
+	addr += where;
+
+	if (!addr)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	switch (size) {
+	case 1:
+		writeb(value, addr);
+		break;
+	case 2:
+		writew(value, addr);
+		break;
+	case 4:
+		writel(value, addr);
+		break;
+	default:
+		return PCIBIOS_SET_FAILED;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int plda_pcie_config_read(struct pci_bus *bus, unsigned int devfn,
+				 int where, int size, u32 *value)
+{
+	struct plda_pcie *pcie = bus->sysdata;
+
+	return _plda_pcie_config_read(pcie, bus->number, devfn, where, size,
+				      value);
+}
+
+int plda_pcie_config_write(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 value)
+{
+	struct plda_pcie *pcie = bus->sysdata;
+
+	if (plda_pcie_hide_rc_bar(bus, devfn, where))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	return _plda_pcie_config_write(pcie, bus->number, devfn, where, size,
+				       value);
+}
+
+static void plda_pcie_handle_msi_irq(struct plda_pcie *pcie)
+{
+	struct plda_msi *msi = &pcie->msi;
+	u32 bit;
+	u32 virq;
+	unsigned long status = plda_readl(pcie, ISTATUS_MSI);
+
+	for_each_set_bit(bit, &status, INT_PCI_MSI_NR) {
+		/* Clear interrupts */
+		plda_writel(pcie, 1 << bit, ISTATUS_MSI);
+
+		virq = irq_find_mapping(msi->inner_domain, bit);
+		if (virq) {
+			if (test_bit(bit, msi->used))
+				generic_handle_irq(virq);
+			else
+				dev_err(&pcie->pdev->dev,
+					"Unhandled MSI, MSI%d virq %d\n", bit,
+					virq);
+		} else
+			dev_err(&pcie->pdev->dev, "Unexpected MSI, MSI%d\n",
+				bit);
+
+	}
+	plda_writel(pcie, INT_MSI, ISTATUS_LOCAL);
+}
+
+static void plda_pcie_handle_intx_irq(struct plda_pcie *pcie,
+				      unsigned long status)
+{
+	u32 bit;
+	u32 virq;
+
+	status >>= INTA_OFFSET;
+
+	for_each_set_bit(bit, &status, PCI_NUM_INTX) {
+		/* Clear interrupts */
+		plda_writel(pcie, 1 << (bit + INTA_OFFSET), ISTATUS_LOCAL);
+
+		virq = irq_find_mapping(pcie->legacy_irq_domain, bit);
+		if (virq)
+			generic_handle_irq(virq);
+		else
+			dev_err(&pcie->pdev->dev,
+				"plda_pcie_handle_intx_irq unexpected IRQ, INT%d\n", bit);
+	}
+}
+
+static void plda_pcie_handle_errors_irq(struct plda_pcie *pcie, u32 status)
+{
+	if (status & INT_AXI_POST_ERROR)
+		dev_err(&pcie->pdev->dev, "AXI post error\n");
+	if (status & INT_AXI_FETCH_ERROR)
+		dev_err(&pcie->pdev->dev, "AXI fetch error\n");
+	if (status & INT_AXI_DISCARD_ERROR)
+		dev_err(&pcie->pdev->dev, "AXI discard error\n");
+	if (status & INT_PCIE_POST_ERROR)
+		dev_err(&pcie->pdev->dev, "PCIe post error\n");
+	if (status & INT_PCIE_FETCH_ERROR)
+		dev_err(&pcie->pdev->dev, "PCIe fetch error\n");
+	if (status & INT_PCIE_DISCARD_ERROR)
+		dev_err(&pcie->pdev->dev, "PCIe discard error\n");
+
+	plda_writel(pcie, INT_ERRORS, ISTATUS_LOCAL);
+}
+
+static void plda_pcie_isr(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct plda_pcie *pcie;
+	u32 status;
+
+	chained_irq_enter(chip, desc);
+	pcie = irq_desc_get_handler_data(desc);
+
+	status = plda_readl(pcie, ISTATUS_LOCAL);
+	while ((status = (plda_readl(pcie, ISTATUS_LOCAL) & INT_MASK))) {
+		if (status & INT_INTX_MASK)
+			plda_pcie_handle_intx_irq(pcie, status);
+
+		if (status & INT_MSI)
+			plda_pcie_handle_msi_irq(pcie);
+
+		if (status & INT_ERRORS)
+			plda_pcie_handle_errors_irq(pcie, status);
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+#ifdef CONFIG_PCI_MSI
+static struct irq_chip plda_msi_irq_chip = {
+	.name = "PLDA PCIe MSI",
+	.irq_mask = pci_msi_mask_irq,
+	.irq_unmask = pci_msi_unmask_irq,
+};
+
+static struct msi_domain_info plda_msi_domain_info = {
+	.flags = (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+		  MSI_FLAG_PCI_MSIX),
+	.chip = &plda_msi_irq_chip,
+};
+#endif
+
+static void plda_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)
+{
+	struct plda_pcie *pcie = irq_data_get_irq_chip_data(data);
+	phys_addr_t msi_addr = plda_readl(pcie, IMSI_ADDR);
+
+	msg->address_lo = lower_32_bits(msi_addr);
+	msg->address_hi = upper_32_bits(msi_addr);
+	msg->data = data->hwirq;
+
+	dev_info(&pcie->pdev->dev, "msi#%d address_hi %#x address_lo %#x\n",
+		(int)data->hwirq, msg->address_hi, msg->address_lo);
+}
+
+static int plda_msi_set_affinity(struct irq_data *irq_data,
+				 const struct cpumask *mask, bool force)
+{
+	return -EINVAL;
+}
+
+static struct irq_chip plda_irq_chip = {
+	.name = "PLDA MSI",
+	.irq_compose_msi_msg = plda_compose_msi_msg,
+	.irq_set_affinity = plda_msi_set_affinity,
+};
+
+static int plda_msi_alloc(struct irq_domain *domain, unsigned int virq,
+			  unsigned int nr_irqs, void *args)
+{
+	struct plda_pcie *pcie = domain->host_data;
+	struct plda_msi *msi = &pcie->msi;
+	int bit;
+
+	WARN_ON(nr_irqs != 1);
+	mutex_lock(&msi->lock);
+
+	bit = find_first_zero_bit(msi->used, INT_PCI_MSI_NR);
+	if (bit >= INT_PCI_MSI_NR) {
+		mutex_unlock(&msi->lock);
+		return -ENOSPC;
+	}
+
+	set_bit(bit, msi->used);
+
+	irq_domain_set_info(domain, virq, bit, &plda_irq_chip,
+			    domain->host_data, handle_simple_irq,
+			    NULL, NULL);
+	mutex_unlock(&msi->lock);
+
+	return 0;
+}
+
+static void plda_msi_free(struct irq_domain *domain, unsigned int virq,
+			  unsigned int nr_irqs)
+{
+	struct irq_data *data = irq_domain_get_irq_data(domain, virq);
+	struct plda_pcie *pcie = irq_data_get_irq_chip_data(data);
+	struct plda_msi *msi = &pcie->msi;
+
+	mutex_lock(&msi->lock);
+
+	if (!test_bit(data->hwirq, msi->used))
+		dev_err(&pcie->pdev->dev, "Trying to free unused MSI#%lu\n",
+			data->hwirq);
+	else
+		__clear_bit(data->hwirq, msi->used);
+
+	mutex_unlock(&msi->lock);
+}
+
+static const struct irq_domain_ops dev_msi_domain_ops = {
+	.alloc  = plda_msi_alloc,
+	.free   = plda_msi_free,
+};
+
+static void plda_msi_free_irq_domain(struct plda_pcie *pcie)
+{
+#ifdef CONFIG_PCI_MSI
+	struct plda_msi *msi = &pcie->msi;
+	u32 irq;
+	int i;
+
+	for (i = 0; i < INT_PCI_MSI_NR; i++) {
+		irq = irq_find_mapping(msi->inner_domain, i);
+		if (irq > 0)
+			irq_dispose_mapping(irq);
+	}
+
+	if (msi->msi_domain)
+		irq_domain_remove(msi->msi_domain);
+
+	if (msi->inner_domain)
+		irq_domain_remove(msi->inner_domain);
+#endif
+}
+
+static void plda_pcie_free_irq_domain(struct plda_pcie *pcie)
+{
+	int i;
+	u32 irq;
+
+	/* Disable all interrupts */
+	plda_writel(pcie, 0, IMASK_LOCAL);
+
+	if (pcie->legacy_irq_domain) {
+		for (i = 0; i < PCI_NUM_INTX; i++) {
+			irq = irq_find_mapping(pcie->legacy_irq_domain, i);
+			if (irq > 0)
+				irq_dispose_mapping(irq);
+		}
+		irq_domain_remove(pcie->legacy_irq_domain);
+	}
+
+	if (pci_msi_enabled())
+		plda_msi_free_irq_domain(pcie);
+	irq_set_chained_handler_and_data(pcie->irq, NULL, NULL);
+}
+
+static int plda_pcie_init_msi_irq_domain(struct plda_pcie *pcie)
+{
+#ifdef CONFIG_PCI_MSI
+	struct fwnode_handle *fwn = of_node_to_fwnode(pcie->pdev->dev.of_node);
+	struct plda_msi *msi = &pcie->msi;
+
+	msi->inner_domain = irq_domain_add_linear(NULL, INT_PCI_MSI_NR,
+						  &dev_msi_domain_ops, pcie);
+	if (!msi->inner_domain) {
+		dev_err(&pcie->pdev->dev, "Failed to create dev IRQ domain\n");
+		return -ENOMEM;
+	}
+	msi->msi_domain = pci_msi_create_irq_domain(fwn, &plda_msi_domain_info,
+						    msi->inner_domain);
+	if (!msi->msi_domain) {
+		dev_err(&pcie->pdev->dev, "Failed to create msi IRQ domain\n");
+		irq_domain_remove(msi->inner_domain);
+		return -ENOMEM;
+	}
+#endif
+	return 0;
+}
+
+static int plda_pcie_enable_msi(struct plda_pcie *pcie, struct pci_bus *bus)
+{
+	struct plda_msi *msi = &pcie->msi;
+	u32 reg;
+
+	mutex_init(&msi->lock);
+
+	/* Enable MSI */
+	reg = plda_readl(pcie, IMASK_LOCAL);
+	reg |= INT_MSI;
+	plda_writel(pcie, reg, IMASK_LOCAL);
+	return 0;
+}
+
+static int plda_pcie_intx_map(struct irq_domain *domain, unsigned int irq,
+			      irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);
+	irq_set_chip_data(irq, domain->host_data);
+
+	return 0;
+}
+
+static const struct irq_domain_ops intx_domain_ops = {
+	.map = plda_pcie_intx_map,
+	.xlate = pci_irqd_intx_xlate,
+};
+
+static int plda_pcie_init_irq_domain(struct plda_pcie *pcie)
+{
+	struct device *dev = &pcie->pdev->dev;
+	struct device_node *node = dev->of_node;
+	int ret;
+
+	if (pci_msi_enabled()) {
+		ret = plda_pcie_init_msi_irq_domain(pcie);
+		if (ret != 0)
+			return -ENOMEM;
+	}
+
+	/* Setup INTx */
+	pcie->legacy_irq_domain = irq_domain_add_linear(node, PCI_NUM_INTX,
+					&intx_domain_ops, pcie);
+
+	if (!pcie->legacy_irq_domain) {
+		dev_err(dev, "Failed to get a INTx IRQ domain\n");
+		return -ENOMEM;
+	}
+
+	irq_set_chained_handler_and_data(pcie->irq, plda_pcie_isr, pcie);
+	return 0;
+}
+
+static int plda_pcie_parse_dt(struct plda_pcie *pcie)
+{
+	struct resource *reg_res;
+	struct platform_device *pdev = pcie->pdev;
+	struct of_phandle_args syscon_args, phyctrl_args;
+	int ret;
+
+	reg_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "reg");
+	if (!reg_res) {
+		dev_err(&pdev->dev, "Missing required reg address range\n");
+		return -ENODEV;
+	}
+
+	pcie->reg_base = devm_ioremap_resource(&pdev->dev, reg_res);
+	if (IS_ERR(pcie->reg_base)) {
+		dev_err(&pdev->dev, "Failed to map reg memory\n");
+		return PTR_ERR(pcie->reg_base);
+	}
+
+	pcie->cfg_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "config");
+	if (!pcie->cfg_res) {
+		dev_err(&pdev->dev, "Missing required config address range");
+		return -ENODEV;
+	}
+
+	pcie->config_base = devm_ioremap_resource(&pdev->dev, pcie->cfg_res);
+	if (IS_ERR(pcie->config_base)) {
+		dev_err(&pdev->dev, "Failed to map config memory\n");
+		return PTR_ERR(pcie->config_base);
+	}
+
+	ret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+					       "starfive,phyctrl", 2, 0, &phyctrl_args);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to parse starfive,phyctrl\n");
+		return -EINVAL;
+	}
+
+	if (!of_device_is_compatible(phyctrl_args.np, "starfive,phyctrl"))
+		return -EINVAL;
+	pcie->reg_phyctrl =  device_node_to_regmap(phyctrl_args.np);
+	of_node_put(phyctrl_args.np);
+	if (IS_ERR(pcie->reg_phyctrl))
+		return PTR_ERR(pcie->reg_phyctrl);
+
+	pcie->phy_kvco_level = phyctrl_args.args[0];
+	pcie->phy_kvco_tune_signals = phyctrl_args.args[1];
+
+	pcie->irq = platform_get_irq(pdev, 0);
+	if (pcie->irq <= 0) {
+		dev_err(&pdev->dev, "Failed to get IRQ: %d\n", pcie->irq);
+		return -EINVAL;
+	}
+
+	ret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+					       "starfive,stg-syscon", 4, 0, &syscon_args);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to parse starfive,stg-syscon\n");
+		return -EINVAL;
+	}
+
+	pcie->reg_syscon = syscon_node_to_regmap(syscon_args.np);
+	of_node_put(syscon_args.np);
+	if (IS_ERR(pcie->reg_syscon))
+		return PTR_ERR(pcie->reg_syscon);
+
+	pcie->stg_arfun = syscon_args.args[0];
+	pcie->stg_awfun = syscon_args.args[1];
+	pcie->stg_rp_nep = syscon_args.args[2];
+	pcie->stg_lnksta = syscon_args.args[3];
+
+	/* Clear all interrupts */
+	plda_writel(pcie, 0xffffffff, ISTATUS_LOCAL);
+	plda_writel(pcie, INT_INTX_MASK | INT_ERRORS, IMASK_LOCAL);
+
+	return 0;
+}
+
+static struct pci_ops plda_pcie_ops = {
+	.read           = plda_pcie_config_read,
+	.write          = plda_pcie_config_write,
+};
+
+void plda_set_atr_entry(struct plda_pcie *pcie, phys_addr_t src_addr,
+			phys_addr_t trsl_addr, size_t window_size,
+			int trsl_param)
+{
+	void __iomem *base =
+		pcie->reg_base + XR3PCI_ATR_AXI4_SLV0;
+
+	/* Support AXI4 Slave 0 Address Translation Tables 0-7. */
+	if (pcie->atr_table_num >= XR3PCI_ATR_MAX_TABLE_NUM)
+		pcie->atr_table_num = XR3PCI_ATR_MAX_TABLE_NUM - 1;
+	base +=  XR3PCI_ATR_TABLE_OFFSET * pcie->atr_table_num;
+	pcie->atr_table_num++;
+
+	/* X3PCI_ATR_SRC_ADDR_LOW:
+	 *   - bit 0: enable entry,
+	 *   - bits 1-6: ATR window size: total size in bytes: 2^(ATR_WSIZE + 1)
+	 *   - bits 7-11: reserved
+	 *   - bits 12-31: start of source address
+	 */
+	writel((lower_32_bits(src_addr) & XR3PCI_ATR_SRC_ADDR_MASK) |
+			(fls(window_size) - 1) << XR3PCI_ATR_SRC_WIN_SIZE_SHIFT | 1,
+			base + XR3PCI_ATR_SRC_ADDR_LOW);
+	writel(upper_32_bits(src_addr), base + XR3PCI_ATR_SRC_ADDR_HIGH);
+	writel((lower_32_bits(trsl_addr) & XR3PCI_ATR_TRSL_ADDR_MASK),
+			base + XR3PCI_ATR_TRSL_ADDR_LOW);
+	writel(upper_32_bits(trsl_addr), base + XR3PCI_ATR_TRSL_ADDR_HIGH);
+	writel(trsl_param, base + XR3PCI_ATR_TRSL_PARAM);
+
+	pr_info("ATR entry: 0x%010llx %s 0x%010llx [0x%010llx] (param: 0x%06x)\n",
+	       src_addr, (trsl_param & XR3PCI_ATR_TRSL_DIR) ? "<-" : "->",
+	       trsl_addr, (u64)window_size, trsl_param);
+}
+
+static int plda_pcie_setup_windows(struct plda_pcie *pcie)
+{
+	struct pci_host_bridge *bridge = pcie->bridge;
+	struct resource_entry *entry;
+	u64 pci_addr;
+
+	resource_list_for_each_entry(entry, &bridge->windows) {
+		if (resource_type(entry->res) == IORESOURCE_MEM) {
+			pci_addr = entry->res->start - entry->offset;
+			plda_set_atr_entry(pcie,
+						entry->res->start, pci_addr,
+						resource_size(entry->res),
+						XR3PCI_ATR_TRSLID_PCIE_MEMORY);
+		}
+	}
+
+	return 0;
+}
+
+static int plda_clk_rst_init(struct plda_pcie *pcie)
+{
+	int ret;
+	struct device *dev = &pcie->pdev->dev;
+
+	pcie->num_clks = devm_clk_bulk_get_all(dev, &pcie->clks);
+	if (pcie->num_clks < 0) {
+		dev_err(dev, "Failed to get pcie clocks\n");
+		ret = -ENODEV;
+		goto exit;
+	}
+	ret = clk_bulk_prepare_enable(pcie->num_clks, pcie->clks);
+	if (ret) {
+		dev_err(&pcie->pdev->dev, "Failed to enable clocks\n");
+		goto exit;
+	}
+
+	pcie->resets = devm_reset_control_array_get_exclusive(dev);
+	if (IS_ERR(pcie->resets)) {
+		ret = PTR_ERR(pcie->resets);
+		dev_err(dev, "Failed to get pcie resets");
+		goto err_clk_init;
+	}
+	ret = reset_control_deassert(pcie->resets);
+	goto exit;
+
+err_clk_init:
+	clk_bulk_disable_unprepare(pcie->num_clks, pcie->clks);
+exit:
+	return ret;
+}
+
+static void plda_clk_rst_deinit(struct plda_pcie *pcie)
+{
+	reset_control_assert(pcie->resets);
+	clk_bulk_disable_unprepare(pcie->num_clks, pcie->clks);
+}
+
+int plda_pinctrl_init(struct plda_pcie *pcie)
+{
+	struct device *dev = &pcie->pdev->dev;
+
+	pcie->pinctrl = devm_pinctrl_get(dev);
+	if (IS_ERR_OR_NULL(pcie->pinctrl)) {
+		dev_err(dev, "Getting pinctrl handle failed\n");
+		return -EINVAL;
+	}
+
+	pcie->perst_state_def
+		= pinctrl_lookup_state(pcie->pinctrl, "perst-default");
+	if (IS_ERR_OR_NULL(pcie->perst_state_def)) {
+		dev_err(dev, "Failed to get the perst-default pinctrl handle\n");
+		return -EINVAL;
+	}
+
+	pcie->perst_state_active
+		= pinctrl_lookup_state(pcie->pinctrl, "perst-active");
+	if (IS_ERR_OR_NULL(pcie->perst_state_active)) {
+		dev_err(dev, "Failed to get the perst-active pinctrl handle\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void plda_pcie_hw_init(struct plda_pcie *pcie)
+{
+	unsigned int value;
+	int i, ret;
+	struct device *dev = &pcie->pdev->dev;
+
+	if (pcie->perst_state_active) {
+		ret = pinctrl_select_state(pcie->pinctrl, pcie->perst_state_active);
+		if (ret)
+			dev_err(dev, "Cannot set reset pin to low\n");
+	}
+
+	/* Disable physical functions except #0 */
+	for (i = 1; i < PLDA_FUNC_NUM; i++) {
+		regmap_update_bits(pcie->reg_syscon,
+				pcie->stg_arfun,
+				STG_SYSCON_AXI4_SLVL_ARFUNC_MASK,
+				(i << PLDA_PHY_FUNC_SHIFT) <<
+				STG_SYSCON_AXI4_SLVL_ARFUNC_SHIFT);
+		regmap_update_bits(pcie->reg_syscon,
+				pcie->stg_awfun,
+				STG_SYSCON_AXI4_SLVL_AWFUNC_MASK,
+				(i << PLDA_PHY_FUNC_SHIFT) <<
+				STG_SYSCON_AXI4_SLVL_AWFUNC_SHIFT);
+
+		value = readl(pcie->reg_base + PCI_MISC);
+		value |= PLDA_FUNCTION_DIS;
+		writel(value, pcie->reg_base + PCI_MISC);
+	}
+	regmap_update_bits(pcie->reg_syscon,
+				pcie->stg_arfun,
+				STG_SYSCON_AXI4_SLVL_ARFUNC_MASK,
+				0 << STG_SYSCON_AXI4_SLVL_ARFUNC_SHIFT);
+	regmap_update_bits(pcie->reg_syscon,
+				pcie->stg_awfun,
+				STG_SYSCON_AXI4_SLVL_AWFUNC_MASK,
+				0 << STG_SYSCON_AXI4_SLVL_AWFUNC_SHIFT);
+
+	/* PCIe Multi-PHY PLL KVCO Gain fine tune settings: */
+	regmap_write(pcie->reg_phyctrl, pcie->phy_kvco_level,
+		     PHY_KVCO_FINE_TUNE_LEVEL);
+	regmap_write(pcie->reg_phyctrl, pcie->phy_kvco_tune_signals,
+		     PHY_KVCO_FINE_TUNE_SIGNALS);
+
+	/* Enable root port*/
+	value = readl(pcie->reg_base + GEN_SETTINGS);
+	value |= PLDA_RP_ENABLE;
+	writel(value, pcie->reg_base + GEN_SETTINGS);
+
+	/* PCIe PCI Standard Configuration Identification Settings. */
+	value = (IDS_PCI_TO_PCI_BRIDGE << IDS_CLASS_CODE_SHIFT) | IDS_REVISION_ID;
+	writel(value, pcie->reg_base + PCIE_PCI_IDS);
+
+	/* The LTR message forwarding of PCIe Message Reception was set by core
+	 * as default, but the forward id & addr are also need to be reset.
+	 * If we do not disable LTR message forwarding here, or set a legal
+	 * forwarding address, the kernel will get stuck after this driver probe.
+	 * To workaround, disable the LTR message forwarding support on
+	 * PCIe Message Reception.
+	 */
+	value = readl(pcie->reg_base + PMSG_SUPPORT_RX);
+	value &= ~PMSG_LTR_SUPPORT;
+	writel(value, pcie->reg_base + PMSG_SUPPORT_RX);
+
+	/* Prefetchable memory window 64-bit addressing support */
+	value = readl(pcie->reg_base + PCIE_WINROM);
+	value |= PREF_MEM_WIN_64_SUPPORT;
+	writel(value, pcie->reg_base + PCIE_WINROM);
+
+	/* As the two host bridges in JH7110 soc have the same default
+	 * address translation table, this cause the second root port can't
+	 * access it's host bridge config space correctly.
+	 * To workaround, config the ATR of host bridge config space by SW.
+	 */
+	plda_set_atr_entry(pcie,
+			pcie->cfg_res->start, 0,
+			1 << XR3_PCI_ECAM_SIZE,
+			XR3PCI_ATR_TRSLID_PCIE_CONFIG);
+
+	plda_pcie_setup_windows(pcie);
+
+	/* Ensure that PERST has been asserted for at least 100 ms */
+	msleep(300);
+	if (pcie->perst_state_def) {
+		ret = pinctrl_select_state(pcie->pinctrl, pcie->perst_state_def);
+		if (ret)
+			dev_err(dev, "Cannot set reset pin to high\n");
+	}
+}
+
+static int plda_pcie_is_link_up(struct plda_pcie *pcie)
+{
+	struct device *dev = &pcie->pdev->dev;
+	int ret;
+	u32 stg_reg_val;
+
+	/* 100ms timeout value should be enough for Gen1/2 training */
+	ret = regmap_read_poll_timeout(pcie->reg_syscon,
+					pcie->stg_lnksta,
+					stg_reg_val,
+					stg_reg_val & PLDA_DATA_LINK_ACTIVE,
+					10 * 1000, 100 * 1000);
+
+	/* If the link is down (no device in slot), then exit. */
+	if (ret == -ETIMEDOUT) {
+		dev_info(dev, "Port link down, exit.\n");
+		return PLDA_LINK_DOWN;
+	} else if (ret == 0) {
+		dev_info(dev, "Port link up.\n");
+		return PLDA_LINK_UP;
+	}
+
+	dev_warn(dev, "Read stg_linksta failed.\n");
+	return ret;
+}
+
+static int plda_pcie_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct plda_pcie *pcie;
+	struct pci_bus *bus;
+	struct pci_host_bridge *bridge;
+	int ret;
+
+	pcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);
+	if (!pcie)
+		return -ENOMEM;
+
+	pcie->pdev = pdev;
+	pcie->atr_table_num = 0;
+
+	ret = plda_pcie_parse_dt(pcie);
+	if (ret) {
+		dev_err(&pdev->dev, "Parsing DT failed\n");
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, pcie);
+
+	plda_pinctrl_init(pcie);
+	if (ret) {
+		dev_err(&pdev->dev, "Init pinctrl failed\n");
+		return ret;
+	}
+
+	regmap_update_bits(pcie->reg_syscon,
+				pcie->stg_rp_nep,
+				STG_SYSCON_K_RP_NEP_MASK,
+				1 << STG_SYSCON_K_RP_NEP_SHIFT);
+
+	regmap_update_bits(pcie->reg_syscon,
+				pcie->stg_awfun,
+				STG_SYSCON_CKREF_SRC_MASK,
+				2 << STG_SYSCON_CKREF_SRC_SHIFT);
+
+	regmap_update_bits(pcie->reg_syscon,
+				pcie->stg_awfun,
+				STG_SYSCON_CLKREQ_MASK,
+				1 << STG_SYSCON_CLKREQ_SHIFT);
+
+	ret = plda_clk_rst_init(pcie);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to init pcie clk reset: %d\n", ret);
+		goto exit;
+	}
+
+	ret = plda_pcie_init_irq_domain(pcie);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed creating IRQ Domain\n");
+		goto exit;
+	}
+
+	bridge = devm_pci_alloc_host_bridge(dev, 0);
+	if (!bridge) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+
+	/* Set default bus ops */
+	bridge->ops = &plda_pcie_ops;
+	bridge->sysdata = pcie;
+	pcie->bridge = bridge;
+
+	plda_pcie_hw_init(pcie);
+
+	if (plda_pcie_is_link_up(pcie) == PLDA_LINK_DOWN)
+		goto release;
+
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		ret = plda_pcie_enable_msi(pcie, bus);
+		if (ret < 0) {
+			dev_err(&pdev->dev,	"Failed to enable MSI support: %d\n", ret);
+			goto release;
+		}
+	}
+
+	ret = pci_host_probe(bridge);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to pci host probe: %d\n", ret);
+		goto release;
+	}
+
+exit:
+	return ret;
+
+release:
+	plda_clk_rst_deinit(pcie);
+
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	pci_free_host_bridge(pcie->bridge);
+	devm_kfree(&pdev->dev, pcie);
+	platform_set_drvdata(pdev, NULL);
+
+	return ret;
+}
+
+static int plda_pcie_remove(struct platform_device *pdev)
+{
+	struct plda_pcie *pcie = platform_get_drvdata(pdev);
+
+	plda_pcie_free_irq_domain(pcie);
+	plda_clk_rst_deinit(pcie);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int __maybe_unused plda_pcie_suspend_noirq(struct device *dev)
+{
+	struct plda_pcie *pcie = dev_get_drvdata(dev);
+
+	if (!pcie)
+		return 0;
+
+	clk_bulk_disable_unprepare(pcie->num_clks, pcie->clks);
+
+	return 0;
+}
+
+static int __maybe_unused plda_pcie_resume_noirq(struct device *dev)
+{
+	struct plda_pcie *pcie = dev_get_drvdata(dev);
+	int ret;
+
+	if (!pcie)
+		return 0;
+
+	ret = clk_bulk_prepare_enable(pcie->num_clks, pcie->clks);
+	if (ret)
+		dev_err(dev, "Failed to enable clocks\n");
+
+	return ret;
+}
+
+static const struct dev_pm_ops plda_pcie_pm_ops = {
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(plda_pcie_suspend_noirq,
+				      plda_pcie_resume_noirq)
+};
+#endif
+
+static const struct of_device_id plda_pcie_of_match[] = {
+	{ .compatible = "plda,pci-xpressrich3-axi"},
+	{ .compatible = "starfive,jh7110-pcie"},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, plda_pcie_of_match);
+
+static struct platform_driver plda_pcie_driver = {
+	.driver = {
+		.name = KBUILD_MODNAME,
+		.of_match_table = of_match_ptr(plda_pcie_of_match),
+#ifdef CONFIG_PM_SLEEP
+		.pm = &plda_pcie_pm_ops,
+#endif
+	},
+	.probe = plda_pcie_probe,
+	.remove = plda_pcie_remove,
+};
+module_platform_driver(plda_pcie_driver);
+
+MODULE_DESCRIPTION("StarFive JH7110 PCIe host driver");
+MODULE_AUTHOR("ke.zhu <ke.zhu@starfivetech.com>");
+MODULE_AUTHOR("Mason Huo <mason.huo@starfivetech.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/perf/riscv_pmu_sbi.c b/drivers/perf/riscv_pmu_sbi.c
new file mode 100644
index 000000000000..6abbfedd0aa6
--- /dev/null
+++ b/drivers/perf/riscv_pmu_sbi.c
@@ -0,0 +1,627 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * RISC-V performance counter support.
+ *
+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.
+ *
+ * This code is based on ARM perf event code which is in turn based on
+ * sparc64 and x86 code.
+ */
+
+#define pr_fmt(fmt) "riscv-pmu-sbi: " fmt
+
+#include <linux/mod_devicetable.h>
+#include <linux/perf/riscv_pmu.h>
+#include <linux/platform_device.h>
+
+#include <asm/sbi.h>
+
+union sbi_pmu_ctr_info {
+	unsigned long value;
+	struct {
+		unsigned long csr:12;
+		unsigned long width:6;
+#if __riscv_xlen == 32
+		unsigned long reserved:13;
+#else
+		unsigned long reserved:45;
+#endif
+		unsigned long type:1;
+	};
+};
+
+/**
+ * RISC-V doesn't have hetergenous harts yet. This need to be part of
+ * per_cpu in case of harts with different pmu counters
+ */
+static union sbi_pmu_ctr_info *pmu_ctr_list;
+
+struct sbi_pmu_event_data {
+	union {
+		union {
+			struct hw_gen_event {
+				uint32_t event_code:16;
+				uint32_t event_type:4;
+				uint32_t reserved:12;
+			} hw_gen_event;
+			struct hw_cache_event {
+				uint32_t result_id:1;
+				uint32_t op_id:2;
+				uint32_t cache_id:13;
+				uint32_t event_type:4;
+				uint32_t reserved:12;
+			} hw_cache_event;
+		};
+		uint32_t event_idx;
+	};
+};
+
+static const struct sbi_pmu_event_data pmu_hw_event_map[] = {
+	[PERF_COUNT_HW_CPU_CYCLES]		= {.hw_gen_event = {
+							SBI_PMU_HW_CPU_CYCLES,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_INSTRUCTIONS]		= {.hw_gen_event = {
+							SBI_PMU_HW_INSTRUCTIONS,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_CACHE_REFERENCES]	= {.hw_gen_event = {
+							SBI_PMU_HW_CACHE_REFERENCES,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_CACHE_MISSES]		= {.hw_gen_event = {
+							SBI_PMU_HW_CACHE_MISSES,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_BRANCH_INSTRUCTIONS]	= {.hw_gen_event = {
+							SBI_PMU_HW_BRANCH_INSTRUCTIONS,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_BRANCH_MISSES]		= {.hw_gen_event = {
+							SBI_PMU_HW_BRANCH_MISSES,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_BUS_CYCLES]		= {.hw_gen_event = {
+							SBI_PMU_HW_BUS_CYCLES,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_STALLED_CYCLES_FRONTEND]	= {.hw_gen_event = {
+							SBI_PMU_HW_STALLED_CYCLES_FRONTEND,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_STALLED_CYCLES_BACKEND]	= {.hw_gen_event = {
+							SBI_PMU_HW_STALLED_CYCLES_BACKEND,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+	[PERF_COUNT_HW_REF_CPU_CYCLES]		= {.hw_gen_event = {
+							SBI_PMU_HW_REF_CPU_CYCLES,
+							SBI_PMU_EVENT_TYPE_HW, 0}},
+};
+
+#define C(x) PERF_COUNT_HW_CACHE_##x
+static const struct sbi_pmu_event_data pmu_cache_event_map[PERF_COUNT_HW_CACHE_MAX]
+[PERF_COUNT_HW_CACHE_OP_MAX]
+[PERF_COUNT_HW_CACHE_RESULT_MAX] = {
+	[C(L1D)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_READ), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_READ), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_WRITE), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_WRITE), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_PREFETCH), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_PREFETCH), C(L1D), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+	},
+	[C(L1I)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event =	{C(RESULT_ACCESS),
+					C(OP_READ), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS), C(OP_READ),
+					C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_WRITE), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_WRITE), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_PREFETCH), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_PREFETCH), C(L1I), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+	},
+	[C(LL)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_READ), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_READ), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_WRITE), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_WRITE), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_PREFETCH), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_PREFETCH), C(LL), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+	},
+	[C(DTLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_READ), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_READ), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_WRITE), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_WRITE), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_PREFETCH), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_PREFETCH), C(DTLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+	},
+	[C(ITLB)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_READ), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_READ), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_WRITE), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_WRITE), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_PREFETCH), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_PREFETCH), C(ITLB), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+	},
+	[C(BPU)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_READ), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_READ), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_WRITE), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_WRITE), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_PREFETCH), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_PREFETCH), C(BPU), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+	},
+	[C(NODE)] = {
+		[C(OP_READ)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_READ), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_READ), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_WRITE)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_WRITE), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_WRITE), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+		[C(OP_PREFETCH)] = {
+			[C(RESULT_ACCESS)] = {.hw_cache_event = {C(RESULT_ACCESS),
+					C(OP_PREFETCH), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+			[C(RESULT_MISS)] = {.hw_cache_event = {C(RESULT_MISS),
+					C(OP_PREFETCH), C(NODE), SBI_PMU_EVENT_TYPE_CACHE, 0}},
+		},
+	},
+};
+
+static int pmu_sbi_ctr_get_width(int idx)
+{
+	return pmu_ctr_list[idx].width;
+}
+
+static bool pmu_sbi_ctr_is_fw(int cidx)
+{
+	union sbi_pmu_ctr_info *info;
+
+	info = &pmu_ctr_list[cidx];
+	if (!info)
+		return false;
+
+	return (info->type == SBI_PMU_CTR_TYPE_FW) ? true : false;
+}
+
+static int pmu_sbi_ctr_get_idx(struct perf_event *event)
+{
+	struct hw_perf_event *hwc = &event->hw;
+	struct riscv_pmu *rvpmu = to_riscv_pmu(event->pmu);
+	struct cpu_hw_events *cpuc = this_cpu_ptr(rvpmu->hw_events);
+	struct sbiret ret;
+	int idx;
+	uint64_t cbase = 0;
+	uint64_t cmask = GENMASK_ULL(rvpmu->num_counters - 1, 0);
+	unsigned long cflags = 0;
+
+	if (event->attr.exclude_kernel)
+		cflags |= SBI_PMU_CFG_FLAG_SET_SINH;
+	if (event->attr.exclude_user)
+		cflags |= SBI_PMU_CFG_FLAG_SET_UINH;
+
+	/* retrieve the available counter index */
+	ret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_CFG_MATCH, cbase, cmask,
+			cflags, hwc->event_base, hwc->config, 0);
+	if (ret.error) {
+		pr_debug("Not able to find a counter for event %lx config %llx\n",
+			hwc->event_base, hwc->config);
+		return sbi_err_map_linux_errno(ret.error);
+	}
+
+	idx = ret.value;
+	if (idx >= rvpmu->num_counters || !pmu_ctr_list[idx].value)
+		return -ENOENT;
+
+	/* Additional sanity check for the counter id */
+	if (pmu_sbi_ctr_is_fw(idx)) {
+		if (!test_and_set_bit(idx, cpuc->used_fw_ctrs))
+			return idx;
+	} else {
+		if (!test_and_set_bit(idx, cpuc->used_hw_ctrs))
+			return idx;
+	}
+
+	return -ENOENT;
+}
+
+static void pmu_sbi_ctr_clear_idx(struct perf_event *event)
+{
+
+	struct hw_perf_event *hwc = &event->hw;
+	struct riscv_pmu *rvpmu = to_riscv_pmu(event->pmu);
+	struct cpu_hw_events *cpuc = this_cpu_ptr(rvpmu->hw_events);
+	int idx = hwc->idx;
+
+	if (pmu_sbi_ctr_is_fw(idx))
+		clear_bit(idx, cpuc->used_fw_ctrs);
+	else
+		clear_bit(idx, cpuc->used_hw_ctrs);
+}
+
+static int pmu_event_find_cache(u64 config)
+{
+	unsigned int cache_type, cache_op, cache_result, ret;
+
+	cache_type = (config >>  0) & 0xff;
+	if (cache_type >= PERF_COUNT_HW_CACHE_MAX)
+		return -EINVAL;
+
+	cache_op = (config >>  8) & 0xff;
+	if (cache_op >= PERF_COUNT_HW_CACHE_OP_MAX)
+		return -EINVAL;
+
+	cache_result = (config >> 16) & 0xff;
+	if (cache_result >= PERF_COUNT_HW_CACHE_RESULT_MAX)
+		return -EINVAL;
+
+	ret = pmu_cache_event_map[cache_type][cache_op][cache_result].event_idx;
+
+	return ret;
+}
+
+static bool pmu_sbi_is_fw_event(struct perf_event *event)
+{
+	u32 type = event->attr.type;
+	u64 config = event->attr.config;
+
+	if ((type == PERF_TYPE_RAW) && ((config >> 63) == 1))
+		return true;
+	else
+		return false;
+}
+
+static int pmu_sbi_event_map(struct perf_event *event, u64 *econfig)
+{
+	u32 type = event->attr.type;
+	u64 config = event->attr.config;
+	int bSoftware;
+	u64 raw_config_val;
+	int ret;
+
+	switch (type) {
+	case PERF_TYPE_HARDWARE:
+		if (config >= PERF_COUNT_HW_MAX)
+			return -EINVAL;
+		ret = pmu_hw_event_map[event->attr.config].event_idx;
+		break;
+	case PERF_TYPE_HW_CACHE:
+		ret = pmu_event_find_cache(config);
+		break;
+	case PERF_TYPE_RAW:
+		/*
+		 * As per SBI specification, the upper 16 bits must be unused for
+		 * a raw event. Use the MSB (63b) to distinguish between hardware
+		 * raw event and firmware events.
+		 */
+		bSoftware = config >> 63;
+		raw_config_val = config & RISCV_PMU_RAW_EVENT_MASK;
+		if (bSoftware) {
+			if (raw_config_val < SBI_PMU_FW_MAX)
+				ret = (raw_config_val & 0xFFFF) |
+				      (SBI_PMU_EVENT_TYPE_FW << 16);
+			else
+				return -EINVAL;
+		} else {
+			ret = RISCV_PMU_RAW_EVENT_IDX;
+			*econfig = raw_config_val;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static u64 pmu_sbi_ctr_read(struct perf_event *event)
+{
+	struct hw_perf_event *hwc = &event->hw;
+	int idx = hwc->idx;
+	struct sbiret ret;
+	union sbi_pmu_ctr_info info;
+	u64 val = 0;
+
+	if (pmu_sbi_is_fw_event(event)) {
+		ret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_FW_READ,
+				hwc->idx, 0, 0, 0, 0, 0);
+		if (!ret.error)
+			val = ret.value;
+	} else {
+		info = pmu_ctr_list[idx];
+		val = riscv_pmu_ctr_read_csr(info.csr);
+		if (IS_ENABLED(CONFIG_32BIT))
+			val = ((u64)riscv_pmu_ctr_read_csr(info.csr + 0x80)) << 31 | val;
+	}
+
+	return val;
+}
+
+static void pmu_sbi_ctr_start(struct perf_event *event, u64 ival)
+{
+	struct sbiret ret;
+	struct hw_perf_event *hwc = &event->hw;
+	unsigned long flag = SBI_PMU_START_FLAG_SET_INIT_VALUE;
+
+	ret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_START, hwc->idx,
+			1, flag, ival, ival >> 32, 0);
+	if (ret.error && (ret.error != SBI_ERR_ALREADY_STARTED))
+		pr_err("Starting counter idx %d failed with error %d\n",
+			hwc->idx, sbi_err_map_linux_errno(ret.error));
+}
+
+static void pmu_sbi_ctr_stop(struct perf_event *event, unsigned long flag)
+{
+	struct sbiret ret;
+	struct hw_perf_event *hwc = &event->hw;
+
+	ret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_STOP, hwc->idx, 1, flag, 0, 0, 0);
+	if (ret.error && (ret.error != SBI_ERR_ALREADY_STOPPED) &&
+		flag != SBI_PMU_STOP_FLAG_RESET)
+		pr_err("Stopping counter idx %d failed with error %d\n",
+			hwc->idx, sbi_err_map_linux_errno(ret.error));
+}
+
+static int pmu_sbi_find_num_ctrs(void)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_NUM_COUNTERS, 0, 0, 0, 0, 0, 0);
+	if (!ret.error)
+		return ret.value;
+	else
+		return sbi_err_map_linux_errno(ret.error);
+}
+
+static int pmu_sbi_get_ctrinfo(int nctr)
+{
+	struct sbiret ret;
+	int i, num_hw_ctr = 0, num_fw_ctr = 0;
+	union sbi_pmu_ctr_info cinfo;
+
+	pmu_ctr_list = kcalloc(nctr, sizeof(*pmu_ctr_list), GFP_KERNEL);
+	if (!pmu_ctr_list)
+		return -ENOMEM;
+
+	for (i = 0; i <= nctr; i++) {
+		ret = sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_GET_INFO, i, 0, 0, 0, 0, 0);
+		if (ret.error)
+			/* The logical counter ids are not expected to be contiguous */
+			continue;
+		cinfo.value = ret.value;
+		if (cinfo.type == SBI_PMU_CTR_TYPE_FW)
+			num_fw_ctr++;
+		else
+			num_hw_ctr++;
+		pmu_ctr_list[i].value = cinfo.value;
+	}
+
+	pr_info("%d firmware and %d hardware counters\n", num_fw_ctr, num_hw_ctr);
+
+	return 0;
+}
+
+static int pmu_sbi_starting_cpu(unsigned int cpu, struct hlist_node *node)
+{
+	struct riscv_pmu *pmu = hlist_entry_safe(node, struct riscv_pmu, node);
+
+	/* Enable the access for TIME csr only from the user mode now */
+	csr_write(CSR_SCOUNTEREN, 0x2);
+
+	/* Stop all the counters so that they can be enabled from perf */
+	sbi_ecall(SBI_EXT_PMU, SBI_EXT_PMU_COUNTER_STOP,
+		  0, GENMASK_ULL(pmu->num_counters - 1, 0), 0, 0, 0, 0);
+
+	return 0;
+}
+
+static int pmu_sbi_dying_cpu(unsigned int cpu, struct hlist_node *node)
+{
+	/* Disable all counters access for user mode now */
+	csr_write(CSR_SCOUNTEREN, 0x0);
+
+	return 0;
+}
+
+static uint64_t pmu_sbi_get_pmu_id(void)
+{
+	union sbi_pmu_id {
+		uint64_t value;
+		struct {
+			uint16_t imp:16;
+			uint16_t arch:16;
+			uint32_t vendor:32;
+		};
+	} pmuid;
+
+	pmuid.value = 0;
+	pmuid.vendor = (uint32_t) sbi_get_mvendorid();
+	pmuid.arch = (sbi_get_marchid() >> (63 - 15) & (1 << 15)) | (sbi_get_marchid() & 0x7FFF);
+	pmuid.imp = (sbi_get_mimpid() >> 16);
+
+	return pmuid.value;
+}
+
+static ssize_t pmu_sbi_id_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int len;
+
+	len = sprintf(buf, "0x%llx\n", pmu_sbi_get_pmu_id());
+	if (len <= 0)
+		dev_err(dev, "mydrv: Invalid sprintf len: %dn", len);
+
+	return len;
+}
+
+static DEVICE_ATTR(id, S_IRUGO | S_IWUSR, pmu_sbi_id_show, 0);
+
+static struct attribute *pmu_sbi_attrs[] = {
+	&dev_attr_id.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(pmu_sbi);
+
+static int pmu_sbi_device_probe(struct platform_device *pdev)
+{
+	struct riscv_pmu *pmu = NULL;
+	int num_counters;
+	int ret;
+
+	pr_info("SBI PMU extension is available\n");
+	pmu = riscv_pmu_alloc();
+	if (!pmu)
+		return -ENOMEM;
+
+	num_counters = pmu_sbi_find_num_ctrs();
+	if (num_counters < 0) {
+		pr_err("SBI PMU extension doesn't provide any counters\n");
+		return -ENODEV;
+	}
+
+	/* cache all the information about counters now */
+	if (pmu_sbi_get_ctrinfo(num_counters))
+		return -ENODEV;
+
+	pmu->num_counters = num_counters;
+	pmu->ctr_start = pmu_sbi_ctr_start;
+	pmu->ctr_stop = pmu_sbi_ctr_stop;
+	pmu->event_map = pmu_sbi_event_map;
+	pmu->ctr_get_idx = pmu_sbi_ctr_get_idx;
+	pmu->ctr_get_width = pmu_sbi_ctr_get_width;
+	pmu->ctr_clear_idx = pmu_sbi_ctr_clear_idx;
+	pmu->ctr_read = pmu_sbi_ctr_read;
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &pmu_sbi_group);
+	if (ret) {
+		dev_err(&pdev->dev, "sysfs creation failed\n");
+		return ret;
+	}
+	pdev->dev.groups = pmu_sbi_groups;
+
+#ifndef CONFIG_SOC_STARFIVE
+	ret = cpuhp_state_add_instance(CPUHP_AP_PERF_RISCV_STARTING, &pmu->node);
+	if (ret)
+		return ret;
+#endif
+
+	ret = perf_pmu_register(&pmu->pmu, "cpu", PERF_TYPE_RAW);
+	if (ret) {
+		cpuhp_state_remove_instance(CPUHP_AP_PERF_RISCV_STARTING, &pmu->node);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct platform_driver pmu_sbi_driver = {
+	.probe		= pmu_sbi_device_probe,
+	.driver		= {
+		.name	= RISCV_PMU_PDEV_NAME,
+	},
+};
+
+static int __init pmu_sbi_devinit(void)
+{
+	int ret;
+	struct platform_device *pdev;
+
+	if (sbi_spec_version < sbi_mk_version(0, 3) ||
+	    sbi_probe_extension(SBI_EXT_PMU) <= 0) {
+		return 0;
+	}
+
+	ret = cpuhp_setup_state_multi(CPUHP_AP_PERF_RISCV_STARTING,
+				      "perf/riscv/pmu:starting",
+				      pmu_sbi_starting_cpu, pmu_sbi_dying_cpu);
+	if (ret) {
+		pr_err("CPU hotplug notifier could not be registered: %d\n",
+		       ret);
+		return ret;
+	}
+
+	ret = platform_driver_register(&pmu_sbi_driver);
+	if (ret)
+		return ret;
+
+	pdev = platform_device_register_simple(RISCV_PMU_PDEV_NAME, -1, NULL, 0);
+	if (IS_ERR(pdev)) {
+		platform_driver_unregister(&pmu_sbi_driver);
+		return PTR_ERR(pdev);
+	}
+
+	/* Notify legacy implementation that SBI pmu is available*/
+	riscv_pmu_legacy_skip_init();
+
+	return ret;
+}
+device_initcall(pmu_sbi_devinit)
diff --git a/drivers/phy/m31/7110-m31-dphy.h b/drivers/phy/m31/7110-m31-dphy.h
new file mode 100644
index 000000000000..e346cbdc80ea
--- /dev/null
+++ b/drivers/phy/m31/7110-m31-dphy.h
@@ -0,0 +1,419 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+
+#ifndef __7110_M31_DPHY_H__
+#define __7110_M31_DPHY_H__
+
+#define  AON_POWER_READY_N_WIDTH             0x1U
+#define  AON_POWER_READY_N_SHIFT             0x0U
+#define  AON_POWER_READY_N_MASK              0x1U
+#define  CFG_CKLANE_SET_WIDTH                0x5U
+#define  CFG_CKLANE_SET_SHIFT                0x1U
+#define  CFG_CKLANE_SET_MASK                 0x3EU
+#define  CFG_DATABUS16_SEL_WIDTH             0x1U
+#define  CFG_DATABUS16_SEL_SHIFT             0x6U
+#define  CFG_DATABUS16_SEL_MASK              0x40U
+#define  CFG_DPDN_SWAP_WIDTH                 0x5U
+#define  CFG_DPDN_SWAP_SHIFT                 0x7U
+#define  CFG_DPDN_SWAP_MASK                  0xF80U
+#define  CFG_L0_SWAP_SEL_WIDTH               0x3U
+#define  CFG_L0_SWAP_SEL_SHIFT               0xCU
+#define  CFG_L0_SWAP_SEL_MASK                0x7000U
+#define  CFG_L1_SWAP_SEL_WIDTH               0x3U
+#define  CFG_L1_SWAP_SEL_SHIFT               0xFU
+#define  CFG_L1_SWAP_SEL_MASK                0x38000U
+#define  CFG_L2_SWAP_SEL_WIDTH               0x3U
+#define  CFG_L2_SWAP_SEL_SHIFT               0x12U
+#define  CFG_L2_SWAP_SEL_MASK                0x1C0000U
+#define  CFG_L3_SWAP_SEL_WIDTH               0x3U
+#define  CFG_L3_SWAP_SEL_SHIFT               0x15U
+#define  CFG_L3_SWAP_SEL_MASK                0xE00000U
+#define  CFG_L4_SWAP_SEL_WIDTH               0x3U
+#define  CFG_L4_SWAP_SEL_SHIFT               0x18U
+#define  CFG_L4_SWAP_SEL_MASK                0x7000000U
+#define  MPOSV_31_0__WIDTH                   0x20U
+#define  MPOSV_31_0__SHIFT                   0x0U
+#define  MPOSV_31_0__MASK                    0xFFFFFFFFU
+#define  MPOSV_46_32__WIDTH                  0xFU
+#define  MPOSV_46_32__SHIFT                  0x0U
+#define  MPOSV_46_32__MASK                   0x7FFFU
+#define  RGS_CDTX_PLL_FM_CPLT_WIDTH          0x1U
+#define  RGS_CDTX_PLL_FM_CPLT_SHIFT          0xFU
+#define  RGS_CDTX_PLL_FM_CPLT_MASK           0x8000U
+#define  RGS_CDTX_PLL_FM_OVER_WIDTH          0x1U
+#define  RGS_CDTX_PLL_FM_OVER_SHIFT          0x10U
+#define  RGS_CDTX_PLL_FM_OVER_MASK           0x10000U
+#define  RGS_CDTX_PLL_FM_UNDER_WIDTH         0x1U
+#define  RGS_CDTX_PLL_FM_UNDER_SHIFT         0x11U
+#define  RGS_CDTX_PLL_FM_UNDER_MASK          0x20000U
+#define  RGS_CDTX_PLL_UNLOCK_WIDTH           0x1U
+#define  RGS_CDTX_PLL_UNLOCK_SHIFT           0x12U
+#define  RGS_CDTX_PLL_UNLOCK_MASK            0x40000U
+#define  RG_CDTX_L0N_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L0N_HSTX_RES_SHIFT          0x13U
+#define  RG_CDTX_L0N_HSTX_RES_MASK           0xF80000U
+#define  RG_CDTX_L0P_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L0P_HSTX_RES_SHIFT          0x18U
+#define  RG_CDTX_L0P_HSTX_RES_MASK           0x1F000000U
+
+#define  RG_CDTX_L1N_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L1N_HSTX_RES_SHIFT          0x0U
+#define  RG_CDTX_L1N_HSTX_RES_MASK           0x1FU
+#define  RG_CDTX_L1P_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L1P_HSTX_RES_SHIFT          0x5U
+#define  RG_CDTX_L1P_HSTX_RES_MASK           0x3E0U
+#define  RG_CDTX_L2N_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L2N_HSTX_RES_SHIFT          0xAU
+#define  RG_CDTX_L2N_HSTX_RES_MASK           0x7C00U
+#define  RG_CDTX_L2P_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L2P_HSTX_RES_SHIFT          0xFU
+#define  RG_CDTX_L2P_HSTX_RES_MASK           0xF8000U
+#define  RG_CDTX_L3N_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L3N_HSTX_RES_SHIFT          0x14U
+#define  RG_CDTX_L3N_HSTX_RES_MASK           0x1F00000U
+#define  RG_CDTX_L3P_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L3P_HSTX_RES_SHIFT          0x19U
+#define  RG_CDTX_L3P_HSTX_RES_MASK           0x3E000000U
+
+#define  RG_CDTX_L4N_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L4N_HSTX_RES_SHIFT          0x0U
+#define  RG_CDTX_L4N_HSTX_RES_MASK           0x1FU
+#define  RG_CDTX_L4P_HSTX_RES_WIDTH          0x5U
+#define  RG_CDTX_L4P_HSTX_RES_SHIFT          0x5U
+#define  RG_CDTX_L4P_HSTX_RES_MASK           0x3E0U
+
+#define  RG_CDTX_PLL_FBK_FRA_WIDTH           0x18U
+#define  RG_CDTX_PLL_FBK_FRA_SHIFT           0x0U
+#define  RG_CDTX_PLL_FBK_FRA_MASK            0xFFFFFFU
+
+#define  RG_CDTX_PLL_FBK_INT_WIDTH           0x9U
+#define  RG_CDTX_PLL_FBK_INT_SHIFT           0x0U
+#define  RG_CDTX_PLL_FBK_INT_MASK            0x1FFU
+#define  RG_CDTX_PLL_FM_EN_WIDTH             0x1U
+#define  RG_CDTX_PLL_FM_EN_SHIFT             0x9U
+#define  RG_CDTX_PLL_FM_EN_MASK              0x200U
+#define  RG_CDTX_PLL_LDO_STB_X2_EN_WIDTH     0x1U
+#define  RG_CDTX_PLL_LDO_STB_X2_EN_SHIFT     0xAU
+#define  RG_CDTX_PLL_LDO_STB_X2_EN_MASK      0x400U
+#define  RG_CDTX_PLL_PRE_DIV_WIDTH           0x2U
+#define  RG_CDTX_PLL_PRE_DIV_SHIFT           0xBU
+#define  RG_CDTX_PLL_PRE_DIV_MASK            0x1800U
+#define  RG_CDTX_PLL_SSC_DELTA_WIDTH         0x12U
+#define  RG_CDTX_PLL_SSC_DELTA_SHIFT         0xDU
+#define  RG_CDTX_PLL_SSC_DELTA_MASK          0x7FFFE000U
+
+#define  RG_CDTX_PLL_SSC_DELTA_INIT_WIDTH    0x12U
+#define  RG_CDTX_PLL_SSC_DELTA_INIT_SHIFT    0x0U
+#define  RG_CDTX_PLL_SSC_DELTA_INIT_MASK     0x3FFFFU
+#define  RG_CDTX_PLL_SSC_EN_WIDTH            0x1U
+#define  RG_CDTX_PLL_SSC_EN_SHIFT            0x12U
+#define  RG_CDTX_PLL_SSC_EN_MASK             0x40000U
+#define  RG_CDTX_PLL_SSC_PRD_WIDTH           0xAU
+#define  RG_CDTX_PLL_SSC_PRD_SHIFT           0x13U
+#define  RG_CDTX_PLL_SSC_PRD_MASK            0x1FF80000U
+
+#define  RG_CLANE_HS_CLK_POST_TIME_WIDTH     0x8U
+#define  RG_CLANE_HS_CLK_POST_TIME_SHIFT     0x0U
+#define  RG_CLANE_HS_CLK_POST_TIME_MASK      0xFFU
+#define  RG_CLANE_HS_CLK_PRE_TIME_WIDTH      0x8U
+#define  RG_CLANE_HS_CLK_PRE_TIME_SHIFT      0x8U
+#define  RG_CLANE_HS_CLK_PRE_TIME_MASK       0xFF00U
+#define  RG_CLANE_HS_PRE_TIME_WIDTH          0x8U
+#define  RG_CLANE_HS_PRE_TIME_SHIFT          0x10U
+#define  RG_CLANE_HS_PRE_TIME_MASK           0xFF0000U
+#define  RG_CLANE_HS_TRAIL_TIME_WIDTH        0x8U
+#define  RG_CLANE_HS_TRAIL_TIME_SHIFT        0x18U
+#define  RG_CLANE_HS_TRAIL_TIME_MASK         0xFF000000U
+
+#define  RG_CLANE_HS_ZERO_TIME_WIDTH         0x8U
+#define  RG_CLANE_HS_ZERO_TIME_SHIFT         0x0U
+#define  RG_CLANE_HS_ZERO_TIME_MASK          0xFFU
+#define  RG_DLANE_HS_PRE_TIME_WIDTH          0x8U
+#define  RG_DLANE_HS_PRE_TIME_SHIFT          0x8U
+#define  RG_DLANE_HS_PRE_TIME_MASK           0xFF00U
+#define  RG_DLANE_HS_TRAIL_TIME_WIDTH        0x8U
+#define  RG_DLANE_HS_TRAIL_TIME_SHIFT        0x10U
+#define  RG_DLANE_HS_TRAIL_TIME_MASK         0xFF0000U
+#define  RG_DLANE_HS_ZERO_TIME_WIDTH         0x8U
+#define  RG_DLANE_HS_ZERO_TIME_SHIFT         0x18U
+#define  RG_DLANE_HS_ZERO_TIME_MASK          0xFF000000U
+
+#define  RG_EXTD_CYCLE_SEL_WIDTH             0x3U
+#define  RG_EXTD_CYCLE_SEL_SHIFT             0x0U
+#define  RG_EXTD_CYCLE_SEL_MASK              0x7U
+
+#define  SCFG_C_HS_PRE_ZERO_TIME_WIDTH       0x20U
+#define  SCFG_C_HS_PRE_ZERO_TIME_SHIFT       0x0U
+#define  SCFG_C_HS_PRE_ZERO_TIME_MASK        0xFFFFFFFFU
+
+#define  SCFG_DPHY_SRC_SEL_WIDTH             0x1U
+#define  SCFG_DPHY_SRC_SEL_SHIFT             0x0U
+#define  SCFG_DPHY_SRC_SEL_MASK              0x1U
+#define  SCFG_DSI_TXREADY_ESC_SEL_WIDTH      0x2U
+#define  SCFG_DSI_TXREADY_ESC_SEL_SHIFT      0x1U
+#define  SCFG_DSI_TXREADY_ESC_SEL_MASK       0x6U
+#define  SCFG_PPI_C_READY_SEL_WIDTH          0x2U
+#define  SCFG_PPI_C_READY_SEL_SHIFT          0x3U
+#define  SCFG_PPI_C_READY_SEL_MASK           0x18U
+#define  VCONTROL_WIDTH                      0x5U
+#define  VCONTROL_SHIFT                      0x5U
+#define  VCONTROL_MASK                       0x3E0U
+
+#define  XCFGI_DW00_WIDTH                    0x20U
+#define  XCFGI_DW00_SHIFT                    0x0U
+#define  XCFGI_DW00_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW01_WIDTH                    0x20U
+#define  XCFGI_DW01_SHIFT                    0x0U
+#define  XCFGI_DW01_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW02_WIDTH                    0x20U
+#define  XCFGI_DW02_SHIFT                    0x0U
+#define  XCFGI_DW02_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW03_WIDTH                    0x20U
+#define  XCFGI_DW03_SHIFT                    0x0U
+#define  XCFGI_DW03_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW04_WIDTH                    0x20U
+#define  XCFGI_DW04_SHIFT                    0x0U
+#define  XCFGI_DW04_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW05_WIDTH                    0x20U
+#define  XCFGI_DW05_SHIFT                    0x0U
+#define  XCFGI_DW05_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW06_WIDTH                    0x20U
+#define  XCFGI_DW06_SHIFT                    0x0U
+#define  XCFGI_DW06_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW07_WIDTH                    0x20U
+#define  XCFGI_DW07_SHIFT                    0x0U
+#define  XCFGI_DW07_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW08_WIDTH                    0x20U
+#define  XCFGI_DW08_SHIFT                    0x0U
+#define  XCFGI_DW08_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW09_WIDTH                    0x20U
+#define  XCFGI_DW09_SHIFT                    0x0U
+#define  XCFGI_DW09_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW0A_WIDTH                    0x20U
+#define  XCFGI_DW0A_SHIFT                    0x0U
+#define  XCFGI_DW0A_MASK                     0xFFFFFFFFU
+
+#define  XCFGI_DW0B_WIDTH                    0x20U
+#define  XCFGI_DW0B_SHIFT                    0x0U
+#define  XCFGI_DW0B_MASK                     0xFFFFFFFFU
+
+#define  DBG1_MUX_DOUT_WIDTH                 0x8U
+#define  DBG1_MUX_DOUT_SHIFT                 0x0U
+#define  DBG1_MUX_DOUT_MASK                  0xFFU
+#define  DBG1_MUX_SEL_WIDTH                  0x5U
+#define  DBG1_MUX_SEL_SHIFT                  0x8U
+#define  DBG1_MUX_SEL_MASK                   0x1F00U
+#define  DBG2_MUX_DOUT_WIDTH                 0x8U
+#define  DBG2_MUX_DOUT_SHIFT                 0xDU
+#define  DBG2_MUX_DOUT_MASK                  0x1FE000U
+#define  DBG2_MUX_SEL_WIDTH                  0x5U
+#define  DBG2_MUX_SEL_SHIFT                  0x15U
+#define  DBG2_MUX_SEL_MASK                   0x3E00000U
+#define  REFCLK_IN_SEL_WIDTH                 0x3U
+#define  REFCLK_IN_SEL_SHIFT                 0x1AU
+#define  REFCLK_IN_SEL_MASK                  0x1C000000U
+#define  RESETB_WIDTH                        0x1U
+#define  RESETB_SHIFT                        0x1DU
+#define  RESETB_MASK                         0x20000000U
+
+//aonsys con
+#define AON_GP_REG_WIDTH                                   0x20U
+#define AON_GP_REG_SHIFT                                   0x0U
+#define AON_GP_REG_MASK                                    0xFFFFFFFFU
+
+
+#define M31_DPHY_REFCLK_RESERVED	0
+#define M31_DPHY_REFCLK_12M		1
+#define M31_DPHY_REFCLK_19_2M		2
+#define M31_DPHY_REFCLK_25M		3
+#define M31_DPHY_REFCLK_26M		4
+#define M31_DPHY_REFCLK_27M		5
+#define M31_DPHY_REFCLK_38_4M		6
+#define M31_DPHY_REFCLK_52M		7
+#define M31_DPHY_REFCLK_BUTT		8
+
+#define DPHY_TX_PSW_EN_MASK		(1<<30)
+
+struct m31_dphy_config {
+    int ref_clk;
+    unsigned long bitrate;
+    uint32_t pll_prev_div, pll_fbk_int, pll_fbk_fra, extd_cycle_sel;
+    uint32_t dlane_hs_pre_time, dlane_hs_zero_time, dlane_hs_trail_time;
+    uint32_t clane_hs_pre_time, clane_hs_zero_time, clane_hs_trail_time;
+    uint32_t clane_hs_clk_pre_time, clane_hs_clk_post_time;
+};
+
+#define M31_DPHY_REFCLK         M31_DPHY_REFCLK_12M
+#define M31_DPHY_BITRATE_ALIGN  10000000
+
+
+
+static const struct m31_dphy_config m31_dphy_configs[] = {
+#if (M31_DPHY_REFCLK == M31_DPHY_REFCLK_25M)
+	{25000000,  100000000, 0x1, 0x80, 0x000000, 0x4, 0x10, 0x21, 0x17, 0x07, 0x35, 0x0F, 0x0F, 0x73,},
+	{25000000,  200000000, 0x1, 0x80, 0x000000, 0x3, 0x0C, 0x1B, 0x13, 0x07, 0x35, 0x0F, 0x07, 0x3F,},
+	{25000000,  300000000, 0x1, 0xC0, 0x000000, 0x3, 0x11, 0x25, 0x19, 0x0A, 0x50, 0x15, 0x07, 0x45,},
+	{25000000,  400000000, 0x1, 0x80, 0x000000, 0x2, 0x0A, 0x18, 0x11, 0x07, 0x35, 0x0F, 0x03, 0x25,},
+	{25000000,  500000000, 0x1, 0xA0, 0x000000, 0x2, 0x0C, 0x1D, 0x14, 0x09, 0x42, 0x12, 0x03, 0x28,},
+	{25000000,  600000000, 0x1, 0xC0, 0x000000, 0x2, 0x0E, 0x23, 0x17, 0x0A, 0x50, 0x15, 0x03, 0x2B,},
+	{25000000,  700000000, 0x1, 0x70, 0x000000, 0x1, 0x08, 0x14, 0x0F, 0x06, 0x2F, 0x0E, 0x01, 0x16,},
+	{25000000,  800000000, 0x1, 0x80, 0x000000, 0x1, 0x09, 0x17, 0x10, 0x07, 0x35, 0x0F, 0x01, 0x18,},
+	{25000000,  900000000, 0x1, 0x90, 0x000000, 0x1, 0x0A, 0x19, 0x12, 0x08, 0x3C, 0x10, 0x01, 0x19,},
+	{25000000, 1000000000, 0x1, 0xA0, 0x000000, 0x1, 0x0B, 0x1C, 0x13, 0x09, 0x42, 0x12, 0x01, 0x1B,},
+	{25000000, 1100000000, 0x1, 0xB0, 0x000000, 0x1, 0x0C, 0x1E, 0x15, 0x09, 0x4A, 0x14, 0x01, 0x1D,},
+	{25000000, 1200000000, 0x1, 0xC0, 0x000000, 0x1, 0x0E, 0x20, 0x16, 0x0A, 0x50, 0x15, 0x01, 0x1E,},
+	{25000000, 1300000000, 0x1, 0x68, 0x000000, 0x0, 0x07, 0x12, 0x0D, 0x05, 0x2C, 0x0D, 0x00, 0x0F,},
+	{25000000, 1400000000, 0x1, 0x70, 0x000000, 0x0, 0x07, 0x14, 0x0E, 0x06, 0x2F, 0x0E, 0x00, 0x10,},
+	{25000000, 1500000000, 0x1, 0x78, 0x000000, 0x0, 0x08, 0x14, 0x0F, 0x06, 0x32, 0x0E, 0x00, 0x11,},
+	{25000000, 1600000000, 0x1, 0x80, 0x000000, 0x0, 0x09, 0x15, 0x10, 0x07, 0x35, 0x0F, 0x00, 0x12,},
+	{25000000, 1700000000, 0x1, 0x88, 0x000000, 0x0, 0x09, 0x17, 0x10, 0x07, 0x39, 0x10, 0x00, 0x12,},
+	{25000000, 1800000000, 0x1, 0x90, 0x000000, 0x0, 0x0A, 0x18, 0x11, 0x08, 0x3C, 0x10, 0x00, 0x13,},
+	{25000000, 1900000000, 0x1, 0x98, 0x000000, 0x0, 0x0A, 0x1A, 0x12, 0x08, 0x3F, 0x11, 0x00, 0x14,},
+	{25000000, 2000000000, 0x1, 0xA0, 0x000000, 0x0, 0x0B, 0x1B, 0x13, 0x09, 0x42, 0x12, 0x00, 0x15,},
+	{25000000, 2100000000, 0x1, 0xA8, 0x000000, 0x0, 0x0B, 0x1C, 0x13, 0x09, 0x46, 0x13, 0x00, 0x15,},
+	{25000000, 2200000000, 0x1, 0xB0, 0x000000, 0x0, 0x0C, 0x1D, 0x14, 0x09, 0x4A, 0x14, 0x00, 0x16,},
+	{25000000, 2300000000, 0x1, 0xB8, 0x000000, 0x0, 0x0C, 0x1F, 0x15, 0x0A, 0x4C, 0x14, 0x00, 0x17,},
+	{25000000, 2400000000, 0x1, 0xC0, 0x000000, 0x0, 0x0D, 0x20, 0x16, 0x0A, 0x50, 0x15, 0x00, 0x18,},
+	{25000000, 2500000000, 0x1, 0xC8, 0x000000, 0x0, 0x0E, 0x21, 0x16, 0x0B, 0x53, 0x16, 0x00, 0x18,},
+#elif (M31_DPHY_REFCLK == M31_DPHY_REFCLK_12M)
+     {12000000, 160000000, 0x0, 0x6a, 0xaa<<16|0xaa<<8|0xaa, 0x3, 0xa, 0x17, 0x11, 0x5, 0x2b, 0xd, 0x7, 0x3d,},
+	{12000000, 170000000, 0x0, 0x71, 0x55<<16|0x55<<8|0x55, 0x3, 0xb, 0x18, 0x11, 0x5, 0x2e, 0xd, 0x7, 0x3d,},
+	{12000000, 180000000, 0x0, 0x78, 0x0<<16|0x0<<8|0x0, 0x3, 0xb, 0x19, 0x12, 0x6, 0x30, 0xe, 0x7, 0x3e,},
+	{12000000, 190000000, 0x0, 0x7e, 0xaa<<16|0xaa<<8|0xaa, 0x3, 0xc, 0x1a, 0x12, 0x6, 0x33, 0xe, 0x7, 0x3e,},
+	{12000000, 200000000, 0x0, 0x85, 0x55<<16|0x55<<8|0x55, 0x3, 0xc, 0x1b, 0x13, 0x7, 0x35, 0xf, 0x7, 0x3f,},
+	{12000000, 320000000, 0x0, 0x6a, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0x8, 0x14, 0xf, 0x5, 0x2b, 0xd, 0x3, 0x23,},
+	{12000000, 330000000, 0x0, 0x6e, 0x0<<16|0x0<<8|0x0, 0x2, 0x8, 0x15, 0xf, 0x5, 0x2d, 0xd, 0x3, 0x23,},
+	{12000000, 340000000, 0x0, 0x71, 0x55<<16|0x55<<8|0x55, 0x2, 0x9, 0x15, 0xf, 0x5, 0x2e, 0xd, 0x3, 0x23,},
+	{12000000, 350000000, 0x0, 0x74, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0x9, 0x15, 0x10, 0x6, 0x2f, 0xe, 0x3, 0x24,},
+	{12000000, 360000000, 0x0, 0x78, 0x0<<16|0x0<<8|0x0, 0x2, 0x9, 0x16, 0x10, 0x6, 0x30, 0xe, 0x3, 0x24,},
+	{12000000, 370000000, 0x0, 0x7b, 0x55<<16|0x55<<8|0x55, 0x2, 0x9, 0x17, 0x10, 0x6, 0x32, 0xe, 0x3, 0x24,},
+	{12000000, 380000000, 0x0, 0x7e, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xa, 0x17, 0x10, 0x6, 0x33, 0xe, 0x3, 0x24,},
+	{12000000, 390000000, 0x0, 0x82, 0x0<<16|0x0<<8|0x0, 0x2, 0xa, 0x17, 0x11, 0x6, 0x35, 0xf, 0x3, 0x25,},
+	{12000000, 400000000, 0x0, 0x85, 0x55<<16|0x55<<8|0x55, 0x2, 0xa, 0x18, 0x11, 0x7, 0x35, 0xf, 0x3, 0x25,},
+	{12000000, 410000000, 0x0, 0x88, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xa, 0x19, 0x11, 0x7, 0x37, 0xf, 0x3, 0x25,},
+	{12000000, 420000000, 0x0, 0x8c, 0x0<<16|0x0<<8|0x0, 0x2, 0xa, 0x19, 0x12, 0x7, 0x38, 0x10, 0x3, 0x26,},
+	{12000000, 430000000, 0x0, 0x8f, 0x55<<16|0x55<<8|0x55, 0x2, 0xb, 0x19, 0x12, 0x7, 0x39, 0x10, 0x3, 0x26,},
+	{12000000, 440000000, 0x0, 0x92, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xb, 0x1a, 0x12, 0x7, 0x3b, 0x10, 0x3, 0x26,},
+	{12000000, 450000000, 0x0, 0x96, 0x0<<16|0x0<<8|0x0, 0x2, 0xb, 0x1b, 0x12, 0x8, 0x3c, 0x10, 0x3, 0x26,},
+	{12000000, 460000000, 0x0, 0x99, 0x55<<16|0x55<<8|0x55, 0x2, 0xb, 0x1b, 0x13, 0x8, 0x3d, 0x11, 0x3, 0x27,},
+	{12000000, 470000000, 0x0, 0x9c, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xc, 0x1b, 0x13, 0x8, 0x3e, 0x11, 0x3, 0x27,},
+	{12000000, 480000000, 0x0, 0xa0, 0x0<<16|0x0<<8|0x0, 0x2, 0xc, 0x1c, 0x13, 0x8, 0x40, 0x11, 0x3, 0x27,},
+	{12000000, 490000000, 0x0, 0xa3, 0x55<<16|0x55<<8|0x55, 0x2, 0xc, 0x1d, 0x14, 0x8, 0x42, 0x12, 0x3, 0x28,},
+	{12000000, 500000000, 0x0, 0xa6, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xc, 0x1d, 0x14, 0x9, 0x42, 0x12, 0x3, 0x28,},
+	{12000000, 510000000, 0x0, 0xaa, 0x0<<16|0x0<<8|0x0, 0x2, 0xc, 0x1e, 0x14, 0x9, 0x44, 0x12, 0x3, 0x28,},
+	{12000000, 520000000, 0x0, 0xad, 0x55<<16|0x55<<8|0x55, 0x2, 0xd, 0x1e, 0x15, 0x9, 0x45, 0x13, 0x3, 0x29,},
+	{12000000, 530000000, 0x0, 0xb0, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xd, 0x1e, 0x15, 0x9, 0x47, 0x13, 0x3, 0x29,},
+	{12000000, 540000000, 0x0, 0xb4, 0x0<<16|0x0<<8|0x0, 0x2, 0xd, 0x1f, 0x15, 0x9, 0x48, 0x13, 0x3, 0x29,},
+	{12000000, 550000000, 0x0, 0xb7, 0x55<<16|0x55<<8|0x55, 0x2, 0xd, 0x20, 0x16, 0x9, 0x4a, 0x14, 0x3, 0x2a,},
+	{12000000, 560000000, 0x0, 0xba, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xe, 0x20, 0x16, 0xa, 0x4a, 0x14, 0x3, 0x2a,},
+	{12000000, 570000000, 0x0, 0xbe, 0x0<<16|0x0<<8|0x0, 0x2, 0xe, 0x20, 0x16, 0xa, 0x4c, 0x14, 0x3, 0x2a,},
+	{12000000, 580000000, 0x0, 0xc1, 0x55<<16|0x55<<8|0x55, 0x2, 0xe, 0x21, 0x16, 0xa, 0x4d, 0x14, 0x3, 0x2a,},
+	{12000000, 590000000, 0x0, 0xc4, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xe, 0x22, 0x17, 0xa, 0x4f, 0x15, 0x3, 0x2b,},
+	{12000000, 600000000, 0x0, 0xc8, 0x0<<16|0x0<<8|0x0, 0x2, 0xe, 0x23, 0x17, 0xa, 0x50, 0x15, 0x3, 0x2b,},
+	{12000000, 610000000, 0x0, 0xcb, 0x55<<16|0x55<<8|0x55, 0x2, 0xf, 0x22, 0x17, 0xb, 0x50, 0x15, 0x3, 0x2b,},
+	{12000000, 620000000, 0x0, 0xce, 0xaa<<16|0xaa<<8|0xaa, 0x2, 0xf, 0x23, 0x18, 0xb, 0x52, 0x16, 0x3, 0x2c,},
+	{12000000, 630000000, 0x0, 0x69, 0x0<<16|0x0<<8|0x0, 0x1, 0x7, 0x12, 0xd, 0x5, 0x2a, 0xc, 0x1, 0x15,},
+	{12000000, 640000000, 0x0, 0x6a, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0x7, 0x13, 0xe, 0x5, 0x2b, 0xd, 0x1, 0x16,},
+	{12000000, 650000000, 0x0, 0x6c, 0x55<<16|0x55<<8|0x55, 0x1, 0x7, 0x13, 0xe, 0x5, 0x2c, 0xd, 0x1, 0x16,},
+	{12000000, 660000000, 0x0, 0x6e, 0x0<<16|0x0<<8|0x0, 0x1, 0x7, 0x13, 0xe, 0x5, 0x2d, 0xd, 0x1, 0x16,},
+	{12000000, 670000000, 0x0, 0x6f, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0x8, 0x13, 0xe, 0x5, 0x2d, 0xd, 0x1, 0x16,},
+	{12000000, 680000000, 0x0, 0x71, 0x55<<16|0x55<<8|0x55, 0x1, 0x8, 0x13, 0xe, 0x5, 0x2e, 0xd, 0x1, 0x16,},
+	{12000000, 690000000, 0x0, 0x73, 0x0<<16|0x0<<8|0x0, 0x1, 0x8, 0x14, 0xe, 0x6, 0x2e, 0xd, 0x1, 0x16,},
+	{12000000, 700000000, 0x0, 0x74, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0x8, 0x14, 0xf, 0x6, 0x2f, 0xe, 0x1, 0x16,},
+	{12000000, 710000000, 0x0, 0x76, 0x55<<16|0x55<<8|0x55, 0x1, 0x8, 0x14, 0xf, 0x6, 0x2f, 0xe, 0x1, 0x17,},
+	{12000000, 720000000, 0x0, 0x78, 0x0<<16|0x0<<8|0x0, 0x1, 0x8, 0x15, 0xf, 0x6, 0x30, 0xe, 0x1, 0x17,},
+	{12000000, 730000000, 0x0, 0x79, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0x8, 0x15, 0xf, 0x6, 0x31, 0xe, 0x1, 0x17,},
+	{12000000, 740000000, 0x0, 0x7b, 0x55<<16|0x55<<8|0x55, 0x1, 0x8, 0x15, 0xf, 0x6, 0x32, 0xe, 0x1, 0x17,},
+	{12000000, 750000000, 0x0, 0x7d, 0x0<<16|0x0<<8|0x0, 0x1, 0x8, 0x16, 0xf, 0x6, 0x32, 0xe, 0x1, 0x17,},
+	{12000000, 760000000, 0x0, 0x7e, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0x9, 0x15, 0xf, 0x6, 0x33, 0xe, 0x1, 0x17,},
+	{12000000, 770000000, 0x0, 0x80, 0x55<<16|0x55<<8|0x55, 0x1, 0x9, 0x15, 0x10, 0x6, 0x34, 0xf, 0x1, 0x18,},
+	{12000000, 780000000, 0x0, 0x82, 0x0<<16|0x0<<8|0x0, 0x1, 0x9, 0x16, 0x10, 0x6, 0x35, 0xf, 0x1, 0x18,},
+	{12000000, 790000000, 0x0, 0x83, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0x9, 0x16, 0x10, 0x7, 0x34, 0xf, 0x1, 0x18,},
+	{12000000, 800000000, 0x0, 0x85, 0x55<<16|0x55<<8|0x55, 0x1, 0x9, 0x17, 0x10, 0x7, 0x35, 0xf, 0x1, 0x18,},
+	{12000000, 810000000, 0x0, 0x87, 0x0<<16|0x0<<8|0x0, 0x1, 0x9, 0x17, 0x10, 0x7, 0x36, 0xf, 0x1, 0x18,},
+	{12000000, 820000000, 0x0, 0x88, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0x9, 0x17, 0x10, 0x7, 0x37, 0xf, 0x1, 0x18,},
+	{12000000, 830000000, 0x0, 0x8a, 0x55<<16|0x55<<8|0x55, 0x1, 0x9, 0x18, 0x10, 0x7, 0x37, 0xf, 0x1, 0x18,},
+	{12000000, 840000000, 0x0, 0x8c, 0x0<<16|0x0<<8|0x0, 0x1, 0x9, 0x18, 0x11, 0x7, 0x38, 0x10, 0x1, 0x19,},
+	{12000000, 850000000, 0x0, 0x8d, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0xa, 0x17, 0x11, 0x7, 0x39, 0x10, 0x1, 0x19,},
+	{12000000, 860000000, 0x0, 0x8f, 0x55<<16|0x55<<8|0x55, 0x1, 0xa, 0x18, 0x11, 0x7, 0x39, 0x10, 0x1, 0x19,},
+	{12000000, 870000000, 0x0, 0x91, 0x0<<16|0x0<<8|0x0, 0x1, 0xa, 0x18, 0x11, 0x7, 0x3a, 0x10, 0x1, 0x19,},
+	{12000000, 880000000, 0x0, 0x92, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0xa, 0x18, 0x11, 0x7, 0x3b, 0x10, 0x1, 0x19,},
+	{12000000, 890000000, 0x0, 0x94, 0x55<<16|0x55<<8|0x55, 0x1, 0xa, 0x19, 0x11, 0x7, 0x3c, 0x10, 0x1, 0x19,},
+	{12000000, 900000000, 0x0, 0x96, 0x0<<16|0x0<<8|0x0, 0x1, 0xa, 0x19, 0x12, 0x8, 0x3c, 0x10, 0x1, 0x19,},
+	{12000000, 910000000, 0x0, 0x97, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0xa, 0x19, 0x12, 0x8, 0x3c, 0x11, 0x1, 0x1a,},
+	{12000000, 920000000, 0x0, 0x99, 0x55<<16|0x55<<8|0x55, 0x1, 0xa, 0x1a, 0x12, 0x8, 0x3d, 0x11, 0x1, 0x1a,},
+	{12000000, 930000000, 0x0, 0x9b, 0x0<<16|0x0<<8|0x0, 0x1, 0xa, 0x1a, 0x12, 0x8, 0x3e, 0x11, 0x1, 0x1a,},
+	{12000000, 940000000, 0x0, 0x9c, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0xb, 0x1a, 0x12, 0x8, 0x3e, 0x11, 0x1, 0x1a,},
+	{12000000, 950000000, 0x0, 0x9e, 0x55<<16|0x55<<8|0x55, 0x1, 0xb, 0x1a, 0x12, 0x8, 0x3f, 0x11, 0x1, 0x1a,},
+	{12000000, 960000000, 0x0, 0xa0, 0x0<<16|0x0<<8|0x0, 0x1, 0xb, 0x1a, 0x12, 0x8, 0x40, 0x11, 0x1, 0x1a,},
+	{12000000, 970000000, 0x0, 0xa1, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0xb, 0x1b, 0x13, 0x8, 0x41, 0x12, 0x1, 0x1b,},
+	{12000000, 980000000, 0x0, 0xa3, 0x55<<16|0x55<<8|0x55, 0x1, 0xb, 0x1b, 0x13, 0x8, 0x42, 0x12, 0x1, 0x1b,},
+	{12000000, 990000000, 0x0, 0xa5, 0x0<<16|0x0<<8|0x0, 0x1, 0xb, 0x1b, 0x13, 0x8, 0x42, 0x12, 0x1, 0x1b,},
+	{12000000, 1000000000, 0x0, 0xa6, 0xaa<<16|0xaa<<8|0xaa, 0x1, 0xb, 0x1c, 0x13, 0x9, 0x42, 0x12, 0x1, 0x1b,},
+
+#endif
+};
+
+static inline u32 sf_dphy_get_reg(void* io_addr, u32 shift, u32 mask)
+{
+	//void __iomem *io_addr = ioremap(addr, 0x10000);
+    u32 tmp;
+    tmp = readl(io_addr);
+    tmp = (tmp & mask) >> shift;
+    return tmp;
+}
+
+static inline void sf_dphy_set_reg(void* io_addr, u32 data, u32 shift, u32 mask)
+{
+	//void __iomem *io_addr = ioremap(addr, 0x10000);
+
+    u32 tmp;
+    tmp = readl(io_addr);
+    tmp &= ~mask;
+    tmp |= (data << shift) & mask;
+    writel(tmp, io_addr);
+}
+
+static inline void sf_dphy_assert_rst(void* io_addr, u32 addr_status, u32 mask)
+{
+	//void __iomem *io_addr = ioremap(addr, 0x4);
+
+    void __iomem *io_addr_status = ioremap(addr_status, 0x4);
+
+    u32 tmp;
+    tmp = readl(io_addr);
+    tmp |= mask;
+    writel(tmp,io_addr);
+    do{
+        tmp = readl(io_addr_status);
+    }while((tmp & mask)!=0);
+}
+
+static inline void sf_dphy_clear_rst (void* io_addr, u32 addr_status, u32 mask)
+{
+	//void __iomem *io_addr = ioremap(addr, 0x4);
+
+    void __iomem *io_addr_status = ioremap(addr_status, 0x4);
+
+    u32 tmp;
+    tmp = readl(io_addr);
+    tmp &= ~mask;
+    writel(tmp, io_addr);
+    do{
+        tmp = readl(io_addr_status);
+    }while((tmp & mask) != mask);
+}
+
+#endif /* __7110_M31_DPHY_H__ */
diff --git a/drivers/phy/m31/Kconfig b/drivers/phy/m31/Kconfig
new file mode 100644
index 000000000000..e6e457669e70
--- /dev/null
+++ b/drivers/phy/m31/Kconfig
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Phy drivers for Starfive platforms
+#
+
+config PHY_M31_DPHY_RX0
+	tristate "Starfive M31 MIPI DPHY TX Driver"
+	select GENERIC_PHY_MIPI_DPHY
+	select GENERIC_PHY
+	help
+	  Enable this to support the starfive MIPI  DPHY TX0
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called phy-starfive-dphy-tx0.
+
diff --git a/drivers/phy/m31/Makefile b/drivers/phy/m31/Makefile
new file mode 100644
index 000000000000..7ce3391ac42f
--- /dev/null
+++ b/drivers/phy/m31/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_PHY_M31_DPHY_RX0)     += phy-m31-dphy-tx0.o
+
diff --git a/drivers/phy/m31/phy-m31-dphy-tx0.c b/drivers/phy/m31/phy-m31-dphy-tx0.c
new file mode 100755
index 000000000000..93db18a057cf
--- /dev/null
+++ b/drivers/phy/m31/phy-m31-dphy-tx0.c
@@ -0,0 +1,486 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Rockchip MIPI Synopsys DPHY RX0 driver
+ *
+ * Copyright (C) 2019 Collabora, Ltd.
+ *
+ * Based on:
+ *
+ * drivers/media/platform/rockchip/isp1/mipi_dphy_sy.c
+ * in https://chromium.googlesource.com/chromiumos/third_party/kernel,
+ * chromeos-4.4 branch.
+ *
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd.
+ *   Jacob Chen <jacob2.chen@rock-chips.com>
+ *   Shunqian Zheng <zhengsq@rock-chips.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/phy/phy-mipi-dphy.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include<linux/reset.h>
+
+#include <linux/regulator/consumer.h>
+#include "7110-m31-dphy.h"
+
+//syscfg registers
+#define SCFG_DSI_CSI_SEL	        0x2c
+#define SCFG_PHY_RESETB	            0x30
+#define SCFG_REFCLK_SEL	            0x34
+#define SCFG_DBUS_PW_PLL_SSC_LD0	0x38
+#define SCFG_GRS_CDTX_PLL       	0x3c
+
+#define SCFG_RG_CDTX_PLL_FBK_PRE	0x44
+#define SCFG_RG_CLANE_DLANE_TIME   	0x58
+#define SCFG_RG_CLANE_HS_TIME   	0x58
+
+#define SCFG_RG_EXTD_CYCLE_SEL   	0x5c
+
+#define SCFG_L0N_L0P_HSTX	        0x60
+#define SCFG_L1N_L1P_HSTX	        0x64
+#define SCFG_L2N_L2P_HSTX	        0x68
+#define SCFG_L3N_L3P_HSTX	        0x6c
+#define SCFG_L4N_L4P_HSTX	        0x70
+#define SCFG_LX_SWAP_SEL	        0x78
+
+#define SCFG_HS_PRE_ZERO_T_D	    0xc4
+#define SCFG_TXREADY_SRC_SEL_D	    0xc8
+#define SCFG_HS_PRE_ZERO_T_C	    0xd4
+#define SCFG_TXREADY_SRC_SEL_C	    0xd8
+
+//reg SCFG_LX_SWAP_SEL
+#define	OFFSET_CFG_L0_SWAP_SEL 	0
+#define	OFFSET_CFG_L1_SWAP_SEL 	3
+#define	OFFSET_CFG_L2_SWAP_SEL 	6
+#define	OFFSET_CFG_L3_SWAP_SEL 	9
+#define OFFSET_CFG_L4_SWAP_SEL 	12
+
+//reg SCFG_DBUS_PW_PLL_SSC_LD0
+#define OFFSET_SCFG_CFG_DATABUD16_SEL    0
+#define OFFSET_SCFG_PWRON_READY_N        1
+#define OFFSET_RG_CDTX_PLL_FM_EN         2
+#define OFFSET_SCFG_PLLSSC_EN            3
+#define OFFSET_RG_CDTX_PLL_LDO_STB_X2_EN 4
+
+//reg SCFG_RG_CLANE_DLANE_TIME
+#define OFFSET_DHS_PRE_TIME          8
+#define OFFSET_DHS_TRIAL_TIME        16
+#define OFFSET_DHS_ZERO_TIME         24
+
+//reg SCFG_RG_CLANE_HS_TIME
+#define OFFSET_CHS_PRE_TIME          8
+#define OFFSET_CHS_TRIAL_TIME        16
+#define OFFSET_CHS_ZERO_TIME         24
+
+//dsitx registers
+#define  VID_MCTL_MAIN_DATA_CTL	        0x04
+#define  VID_MCTL_MAIN_PHY_CTL	        0x08
+#define  VID_MCTL_MAIN_EN	            0x0c
+#define  VID_MAIN_CTRL_ADDR    0xb0
+#define  VID_VSIZE1_ADDR       0xb4
+#define  VID_VSIZE2_ADDR       0xb8
+#define  VID_HSIZE1_ADDR       0xc0
+#define  VID_HSIZE2_ADDR       0xc4
+#define  VID_BLKSIZE1_ADDR     0xCC
+#define  VID_BLKSIZE2_ADDR     0xd0
+#define  VID_PCK_TIME_ADDR     0xd8
+#define  VID_DPHY_TIME_ADDR    0xdc
+#define  VID_ERR_COLOR1_ADDR   0xe0
+#define  VID_ERR_COLOR2_ADDR   0xe4
+#define  VID_VPOS_ADDR         0xe8
+#define  VID_HPOS_ADDR         0xec
+#define  VID_MODE_STAT_ADDR    0xf0
+#define  VID_VCA_SET1_ADDR     0xf4
+#define  VID_VCA_SET2_ADDR     0xf8
+
+
+#define  VID_MODE_STAT_CLR_ADDR    0x160
+#define  VID_MODE_STAT_FLAG_ADDR   0x180
+
+#define  TVG_CTRL_ADDR      0x0fc
+#define  TVG_IMG_SIZE_ADDR  0x100
+#define  TVG_COLOR1_ADDR    0x104
+#define  TVG_COLOR1BIT_ADDR 0x108
+#define  TVG_COLOR2_ADDR    0x10c
+#define  TVG_COLOR2BIT_ADDR 0x110
+#define  TVG_STAT_ADDR      0x114
+#define  TVG_STAT_CTRL_ADDR 0x144
+#define  TVG_STAT_CLR_ADDR  0x164
+#define  TVG_STAT_FLAG_ADDR 0x184
+
+#define  DPI_IRQ_EN_ADDR   0x1a0
+#define  DPI_IRQ_CLR_ADDR  0x1a4
+#define  DPI_IRQ_STAT_ADDR 0x1a4
+#define  DPI_CFG_ADDR      0x1ac
+
+
+//sysrst registers
+#define SRST_ASSERT0	    0x00
+#define SRST_STATUS0    	0x04
+/* Definition controller bit for syd rst registers */
+#define BIT_RST_DSI_DPI_PIX		17
+
+struct sf_dphy {
+	struct device *dev;
+	void __iomem *topsys;
+
+	struct clk_bulk_data *clks;
+
+	struct clk *txesc_clk;
+    struct reset_control *sys_rst;
+	struct reset_control *txbytehs_rst;
+
+	void __iomem *aonsys;//7110 aonsys con
+
+	struct phy_configure_opts_mipi_dphy config;
+
+	u8 hsfreq;
+
+	struct regulator *mipitx_1p8;
+	struct regulator *mipitx_0p9;
+
+	struct phy *phy;
+};
+
+static int sf_dphy_clkrst_get(struct device *dev, struct sf_dphy *dphy)
+{
+	dphy->txesc_clk = devm_clk_get(dev, "dphy_txesc");
+	if (IS_ERR(dphy->txesc_clk)) {
+		dev_err(dev, "===txesc_clk get error\n");
+		return PTR_ERR(dphy->txesc_clk);
+	}
+	dphy->sys_rst = reset_control_get_exclusive(dev, "dphy_sys");
+	if (IS_ERR(dphy->sys_rst)) {
+		dev_err(dev, "===sys_rst get error\n");
+		return PTR_ERR(dphy->sys_rst);
+	}
+
+	return 0;
+}
+static int sf_dphy_clkrst_ena_deas(struct device *dev, struct sf_dphy *dphy)
+{
+	int ret = 0;
+
+	ret = clk_prepare_enable(dphy->txesc_clk);
+	if (ret) {
+		dev_err(dev, "failed to prepare/enable txesc_clk\n");
+		return ret;
+    }
+	ret = reset_control_deassert(dphy->sys_rst);
+	if (ret < 0) {
+		dev_err(dev, "failed to deassert sys_rst\n");
+		return ret;
+    }
+
+	return ret;
+}
+
+static int sf_dphy_clkrst_disa_assert(struct device *dev, struct sf_dphy *dphy)
+{
+	int ret = 0;
+
+	ret = reset_control_assert(dphy->sys_rst);
+	if (ret < 0) {
+		dev_err(dev, "failed to assert sys_rst\n");
+		return ret;
+    }
+
+	clk_disable_unprepare(dphy->txesc_clk);
+
+	return ret;
+}
+
+static int is_pll_locked(struct sf_dphy *dphy)
+{
+	int tmp = sf_dphy_get_reg(dphy->topsys + 0x8, RGS_CDTX_PLL_UNLOCK_SHIFT, RGS_CDTX_PLL_UNLOCK_MASK);
+    return !tmp;
+}
+static void reset(int assert, struct sf_dphy *dphy)
+{
+	dev_info(dphy->dev, "1 SET_U0_MIPITX_DPHY_RESETB\n");
+	sf_dphy_set_reg(dphy->topsys + 0x64, (!assert), RESETB_SHIFT, RESETB_MASK);
+	dev_info(dphy->dev, "2 SET_U0_MIPITX_DPHY_RESETB\n");
+
+    if (!assert) {
+		while(!is_pll_locked(dphy));
+		dev_info(dphy->dev, "MIPI dphy-tx # PLL Locked\n");
+	}
+}
+
+static int sys_m31_dphy_tx_configure(struct phy *phy, union phy_configure_opts *opts)
+{
+	struct sf_dphy *dphy;
+	uint32_t bitrate;
+	unsigned long alignment;
+	int i;
+	const struct m31_dphy_config *p;
+	const uint32_t AON_POWER_READY_N_active = 0;
+	dphy = phy_get_drvdata(phy);	
+	//bitrate = 680000000;//1228M 60fps
+	//bitrate = 750000000;//1188M 60fps
+	//  bitrate = 490000000;//1188M 60fps
+	bitrate = opts->mipi_dphy.hs_clk_rate;//1188M 60fps
+	printk("sys_m31_dphy_tx_configure opts->mipi_dphy.hs_clk_rate = %ld\n",opts->mipi_dphy.hs_clk_rate);
+
+
+	sf_dphy_set_reg(dphy->topsys + 0x8, 0x10, RG_CDTX_L0N_HSTX_RES_SHIFT, RG_CDTX_L0N_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0xC, 0x10, RG_CDTX_L0N_HSTX_RES_SHIFT, RG_CDTX_L0N_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0xC, 0x10, RG_CDTX_L2N_HSTX_RES_SHIFT, RG_CDTX_L2N_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0xC, 0x10, RG_CDTX_L3N_HSTX_RES_SHIFT, RG_CDTX_L3N_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0x10, 0x10, RG_CDTX_L4N_HSTX_RES_SHIFT, RG_CDTX_L4N_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0x8, 0x10, RG_CDTX_L0P_HSTX_RES_SHIFT, RG_CDTX_L0P_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0xC, 0x10, RG_CDTX_L1P_HSTX_RES_SHIFT, RG_CDTX_L1P_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0xC, 0x10, RG_CDTX_L2P_HSTX_RES_SHIFT, RG_CDTX_L2P_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0xC, 0x10, RG_CDTX_L3P_HSTX_RES_SHIFT, RG_CDTX_L3P_HSTX_RES_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0x10, 0x10, RG_CDTX_L4P_HSTX_RES_SHIFT, RG_CDTX_L4P_HSTX_RES_MASK);
+
+	dev_info(dphy->dev, "request dphy hs_rate %dMbps\n", bitrate/1000000);
+	if (is_pll_locked(dphy))
+		dev_info(dphy->dev, "Error: MIPI dphy-tx # PLL is not supposed to be LOCKED\n");
+	else
+		dev_info(dphy->dev, "MIPI dphy-tx # PLL is not LOCKED\n");
+
+    alignment = M31_DPHY_BITRATE_ALIGN;
+    if (bitrate % alignment) {
+		bitrate += alignment - (bitrate % alignment);
+    }
+
+    dev_info(dphy->dev, "want dphy hs_rate %dMbps\n", bitrate/1000000);
+
+    p = m31_dphy_configs;
+    for (i = 0; i < ARRAY_SIZE(m31_dphy_configs); i++, p++) {
+		if (p->bitrate == bitrate) {
+			dev_info(dphy->dev, "config dphy hs_rate %dMbps\n", bitrate/1000000);
+
+			sf_dphy_set_reg(dphy->topsys + 0x64, M31_DPHY_REFCLK, REFCLK_IN_SEL_SHIFT, REFCLK_IN_SEL_MASK);
+
+			dev_info(dphy->dev, "MIPI dphy-tx # AON_POWER_READY_N active(%d)\n", AON_POWER_READY_N_active);
+
+
+			sf_dphy_set_reg(dphy->topsys, AON_POWER_READY_N_active, AON_POWER_READY_N_SHIFT, AON_POWER_READY_N_MASK);
+
+			sf_dphy_set_reg(dphy->topsys, 0x0, CFG_L0_SWAP_SEL_SHIFT, CFG_L0_SWAP_SEL_MASK);//Lane setting
+			sf_dphy_set_reg(dphy->topsys, 0x1, CFG_L1_SWAP_SEL_SHIFT, CFG_L1_SWAP_SEL_MASK);
+			sf_dphy_set_reg(dphy->topsys, 0x2, CFG_L2_SWAP_SEL_SHIFT, CFG_L2_SWAP_SEL_MASK);
+			sf_dphy_set_reg(dphy->topsys, 0x3, CFG_L3_SWAP_SEL_SHIFT, CFG_L3_SWAP_SEL_MASK);
+			sf_dphy_set_reg(dphy->topsys, 0x4, CFG_L4_SWAP_SEL_SHIFT, CFG_L4_SWAP_SEL_MASK);
+			//PLL setting
+			sf_dphy_set_reg(dphy->topsys + 0x1c, 0x0, RG_CDTX_PLL_SSC_EN_SHIFT, RG_CDTX_PLL_SSC_EN_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x18, 0x1, RG_CDTX_PLL_LDO_STB_X2_EN_SHIFT, RG_CDTX_PLL_LDO_STB_X2_EN_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x18, 0x1, RG_CDTX_PLL_FM_EN_SHIFT, RG_CDTX_PLL_FM_EN_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x18, p->pll_prev_div, RG_CDTX_PLL_PRE_DIV_SHIFT, RG_CDTX_PLL_PRE_DIV_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x18, p->pll_fbk_int, RG_CDTX_PLL_FBK_INT_SHIFT, RG_CDTX_PLL_FBK_INT_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x14, p->pll_fbk_fra, RG_CDTX_PLL_FBK_FRA_SHIFT, RG_CDTX_PLL_FBK_FRA_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x28, p->extd_cycle_sel, RG_EXTD_CYCLE_SEL_SHIFT, RG_EXTD_CYCLE_SEL_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x24, p->dlane_hs_pre_time, RG_DLANE_HS_PRE_TIME_SHIFT, RG_DLANE_HS_PRE_TIME_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x24, p->dlane_hs_pre_time, RG_DLANE_HS_PRE_TIME_SHIFT, RG_DLANE_HS_PRE_TIME_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x24, p->dlane_hs_zero_time, RG_DLANE_HS_ZERO_TIME_SHIFT, RG_DLANE_HS_ZERO_TIME_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x24, p->dlane_hs_trail_time, RG_DLANE_HS_TRAIL_TIME_SHIFT, RG_DLANE_HS_TRAIL_TIME_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x20, p->clane_hs_pre_time, RG_CLANE_HS_PRE_TIME_SHIFT, RG_CLANE_HS_PRE_TIME_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x24, p->clane_hs_zero_time, RG_CLANE_HS_ZERO_TIME_SHIFT, RG_CLANE_HS_ZERO_TIME_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x20, p->clane_hs_trail_time, RG_CLANE_HS_TRAIL_TIME_SHIFT, RG_CLANE_HS_TRAIL_TIME_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x20, p->clane_hs_clk_pre_time, RG_CLANE_HS_CLK_PRE_TIME_SHIFT, RG_CLANE_HS_CLK_PRE_TIME_MASK);
+			sf_dphy_set_reg(dphy->topsys + 0x20, p->clane_hs_clk_post_time, RG_CLANE_HS_CLK_POST_TIME_SHIFT, RG_CLANE_HS_CLK_POST_TIME_MASK);
+
+			break;
+		}
+	}
+
+	return -ENOTSUPP;
+}
+
+static int sf_dphy_power_on(struct phy *phy)
+{
+
+	struct sf_dphy *dphy = phy_get_drvdata(phy);
+	int ret;
+
+	reset(0, dphy);
+	sf_dphy_set_reg(dphy->topsys + 0x30, 0, SCFG_PPI_C_READY_SEL_SHIFT, SCFG_PPI_C_READY_SEL_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0x30, 0, SCFG_DSI_TXREADY_ESC_SEL_SHIFT, SCFG_DSI_TXREADY_ESC_SEL_MASK);
+	sf_dphy_set_reg(dphy->topsys + 0x2c, 0x30, SCFG_C_HS_PRE_ZERO_TIME_SHIFT, SCFG_C_HS_PRE_ZERO_TIME_MASK);
+
+	ret = sf_dphy_clkrst_ena_deas(dphy->dev, dphy);//clk rst interface enable and deassert
+
+	return 0;
+}
+
+static int sf_dphy_power_off(struct phy *phy)
+{
+	struct sf_dphy *dphy = phy_get_drvdata(phy);
+
+	sf_dphy_clkrst_disa_assert(dphy->dev, dphy);
+	reset(1, dphy);
+	return 0;
+}
+
+static int sf_dphy_init(struct phy *phy)
+{
+	struct sf_dphy *dphy = phy_get_drvdata(phy);
+	uint32_t temp;
+	int ret;
+
+	temp = 0;
+	temp = sf_dphy_get_reg(dphy->aonsys, AON_GP_REG_SHIFT,AON_GP_REG_MASK);
+	dev_info(dphy->dev, "GET_AON_GP_REG\n");
+
+	if (!(temp & DPHY_TX_PSW_EN_MASK)) {
+		temp |= DPHY_TX_PSW_EN_MASK;
+		sf_dphy_set_reg(dphy->aonsys, temp,AON_GP_REG_SHIFT,AON_GP_REG_MASK);
+	}
+	dev_info(dphy->dev, "control ECO\n");
+
+	//pmic turn on
+	ret = regulator_enable(dphy->mipitx_0p9);
+	if (ret) {
+		dev_err(dphy->dev, "Cannot enable mipitx_0p9 regulator\n");
+		//goto err_reg_0p9;
+	}
+	udelay(100);	
+	ret = regulator_enable(dphy->mipitx_1p8);
+	if (ret) {
+		dev_err(dphy->dev, "Cannot enable mipitx_1p8 regulator\n");
+		//goto err_reg_1p8;
+	}
+	udelay(100);
+	//mipi_pmic setting
+
+	return 0;
+}
+
+static int sf_dphy_validate(struct phy *phy, enum phy_mode mode, int submode,
+			union phy_configure_opts *opts)
+{
+	return 0;
+}
+
+static int sf_dphy_set_mode(struct phy *phy, enum phy_mode mode, int submode)
+{
+	return 0;
+}
+
+
+static int sf_dphy_exit(struct phy *phy)
+{
+	struct sf_dphy *dphy = phy_get_drvdata(phy);
+	regulator_disable(dphy->mipitx_0p9);
+	udelay(100);
+	regulator_disable(dphy->mipitx_1p8);
+	udelay(100);
+
+	return 0;
+}
+
+static const struct phy_ops sf_dphy_ops = {
+	.power_on	= sf_dphy_power_on,
+	.power_off	= sf_dphy_power_off,
+	.init		= sf_dphy_init,
+	.exit		= sf_dphy_exit,
+	//.configure	= sf_dphy_configure,
+	.configure	= sys_m31_dphy_tx_configure,
+	.validate  = sf_dphy_validate,
+	.set_mode  = sf_dphy_set_mode,
+	.owner		= THIS_MODULE,
+};
+
+static const struct of_device_id sf_dphy_dt_ids[] = {
+	{
+		.compatible = "m31,mipi-dphy-tx",
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sf_dphy_dt_ids);
+
+static int sf_dphy_probe(struct platform_device *pdev)
+{
+	struct phy_provider *phy_provider;
+	struct sf_dphy *dphy;
+	struct resource *res;
+	int ret;
+
+	dev_info(&pdev->dev, "sf_dphy_probe begin\n");
+	dphy = devm_kzalloc(&pdev->dev, sizeof(*dphy), GFP_KERNEL);
+	if (!dphy)
+		return -ENOMEM;
+	dev_set_drvdata(&pdev->dev, dphy);
+
+	dev_info(&pdev->dev, "===> %s enter, %d \n", __func__, __LINE__);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dphy->topsys = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dphy->topsys))
+		return PTR_ERR(dphy->topsys);
+
+
+	dphy->phy = devm_phy_create(&pdev->dev, NULL, &sf_dphy_ops);
+	if (IS_ERR(dphy->phy)) {
+		dev_err(&pdev->dev, "failed to create phy\n");
+		return PTR_ERR(dphy->phy);
+	}
+	phy_set_drvdata(dphy->phy, dphy);
+
+	dphy->dev = &pdev->dev;
+	// this power switch control bit was added in ECO, check ECO item "aon psw_en" for detail
+	dev_info(dphy->dev, "control ECO\n");
+	dphy->aonsys = ioremap(0x17010000, 0x10000);
+
+	//mipi_pmic setting
+	dphy->mipitx_1p8 = devm_regulator_get(&pdev->dev, "mipi_1p8");
+	if (IS_ERR(dphy->mipitx_1p8))
+		//return PTR_ERR(dphy->mipitx_1p8);
+		return -EPROBE_DEFER;
+
+	dphy->mipitx_0p9 = devm_regulator_get(&pdev->dev, "mipi_0p9");
+	if (IS_ERR(dphy->mipitx_0p9))
+		//return PTR_ERR(dphy->mipitx_0p9);
+		return -EPROBE_DEFER;
+
+	ret = sf_dphy_clkrst_get(&pdev->dev, dphy);
+	if (ret) {
+		dev_err(&pdev->dev, "sf_dphy_clkrst_get\n");
+		//return ret;
+		//goto err_reg_1p8;
+		return -EPROBE_DEFER;
+	}
+
+	phy_provider = devm_of_phy_provider_register(&pdev->dev, of_phy_simple_xlate);
+
+	dev_info(&pdev->dev, "sf_dphy_probe end\n");
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static struct platform_driver sf_dphy_driver = {
+	.probe = sf_dphy_probe,
+	.driver = {
+		.name	= "sf-mipi-dphy-tx",
+		.of_match_table = sf_dphy_dt_ids,
+	},
+};
+
+#if 1
+static int __init sf_dphy_probe_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sf_dphy_driver);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+late_initcall_sync(sf_dphy_probe_init);
+#endif
+
+MODULE_AUTHOR("Ezequiel Garcia <ezequiel@collabora.com>");
+MODULE_DESCRIPTION("sf MIPI  DPHY TX0 driver");
+MODULE_LICENSE("Dual MIT/GPL");
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 815095326e2d..87ff4984b3c6 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -400,6 +400,7 @@ source "drivers/pinctrl/zte/Kconfig"
 source "drivers/pinctrl/meson/Kconfig"
 source "drivers/pinctrl/cirrus/Kconfig"
 source "drivers/pinctrl/visconti/Kconfig"
+source "drivers/pinctrl/starfive/Kconfig"
 
 config PINCTRL_XWAY
 	bool
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index f53933b2ff02..e8a17103d1c5 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -72,3 +72,4 @@ obj-y				+= mediatek/
 obj-$(CONFIG_PINCTRL_ZX)	+= zte/
 obj-y				+= cirrus/
 obj-$(CONFIG_PINCTRL_VISCONTI)	+= visconti/
+obj-$(CONFIG_PINCTRL_STARFIVE)	+= starfive/
\ No newline at end of file
diff --git a/drivers/pinctrl/starfive/Kconfig b/drivers/pinctrl/starfive/Kconfig
new file mode 100644
index 000000000000..d0186cf364aa
--- /dev/null
+++ b/drivers/pinctrl/starfive/Kconfig
@@ -0,0 +1,24 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config PINCTRL_STARFIVE
+	bool "Pinctrl driver for StarFive SoC"
+	depends on OF
+	depends on RISCV || COMPILE_TEST
+	select GENERIC_PINCTRL_GROUPS
+	select GENERIC_PINMUX_FUNCTIONS
+	select GENERIC_PINCONF
+	select GPIOLIB
+	select GPIOLIB_IRQCHIP
+	select OF_GPIO
+	help
+	  Say yes here to support pin control on the StarFive RISC-V SoC.
+	  This also provides an interface to the GPIO pins not used by other
+	  peripherals supporting inputs, outputs, configuring pull-up/pull-down
+	  and interrupts on input changes.
+
+config PINCTRL_STARFIVE_JH7110
+	bool "Pinctrl and GPIO driver for StarFive JH7110 SoC"
+	depends on  PINCTRL_STARFIVE
+	depends on SOC_STARFIVE
+	help
+	  This selects the pinctrl driver for JH7110 starfive.
diff --git a/drivers/pinctrl/starfive/Makefile b/drivers/pinctrl/starfive/Makefile
new file mode 100644
index 000000000000..2ddbffb9166c
--- /dev/null
+++ b/drivers/pinctrl/starfive/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+# Core
+obj-$(CONFIG_PINCTRL_STARFIVE) += pinctrl-starfive.o
+
+# SoC Drivers
+obj-$(CONFIG_PINCTRL_STARFIVE_JH7110)	+= pinctrl-starfive-jh7110.o
\ No newline at end of file
diff --git a/drivers/pinctrl/starfive/pinctrl-starfive-jh7110.c b/drivers/pinctrl/starfive/pinctrl-starfive-jh7110.c
new file mode 100644
index 000000000000..53deaadcffc3
--- /dev/null
+++ b/drivers/pinctrl/starfive/pinctrl-starfive-jh7110.c
@@ -0,0 +1,1808 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Pinctrl / GPIO driver for StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 Shanghai StarFive Technology Co., Ltd.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/gpio/driver.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+
+#include "../core.h"
+#include "../pinconf.h"
+#include "../pinmux.h"
+#include "pinctrl-starfive.h"
+
+/***************sys_iomux***************/
+#define SYS_GPO_DOEN_CFG_BASE_REG			0x0
+#define SYS_GPO_DOEN_CFG_END_REG			0x3c
+
+#define SYS_GPO_DOUT_CFG_BASE_REG			0x40
+#define SYS_GPO_DOUT_CFG_END_REG			0x7c
+
+#define SYS_GPI_DIN_CFG_BASE_REG			0x80
+#define SYS_GPI_DIN_CFG_END_REG				0xd8
+
+/*sys_iomux PIN 0-74 ioconfig reg*/
+#define SYS_GPO_PDA_0_74_CFG_BASE_REG			0x120
+#define SYS_GPO_PDA_0_74_CFG_END_REG			0x248
+
+/*sys_iomux PIN 75-88 gamc1 no ioconfig reg*/
+
+/*sys_iomux PIN 89-94 ioconfig reg*/
+#define SYS_GPO_PDA_89_94_CFG_BASE_REG			0x284
+#define SYS_GPO_PDA_89_94_CFG_END_REG			0x298
+
+//sys_iomux ioconfig reg bit
+#define JH7110_PADCFG_POS	BIT(7)
+#define JH7110_PADCFG_SMT	BIT(6)
+#define JH7110_PADCFG_SLEW	BIT(5)
+#define JH7110_PADCFG_PD	BIT(4)
+#define JH7110_PADCFG_PU	BIT(3)
+#define JH7110_PADCFG_BIAS	(JH7110_PADCFG_PD | JH7110_PADCFG_PU)
+#define JH7110_PADCFG_DS_MASK	GENMASK(2, 1)
+#define JH7110_PADCFG_DS_2MA	(0U << 1)
+#define JH7110_PADCFG_DS_4MA	BIT(1)
+#define JH7110_PADCFG_DS_8MA	(2U << 1)
+#define JH7110_PADCFG_DS_12MA	(3U << 1)
+#define JH7110_PADCFG_IE	BIT(0)
+
+//sys_iomux GPIO CTRL
+#define GPIO_EN						0xdc
+#define GPIO_IS_LOW					0xe0
+#define GPIO_IS_HIGH					0xe4
+#define GPIO_IC_LOW					0xe8
+#define GPIO_IC_HIGH					0xec
+#define GPIO_IBE_LOW					0xf0
+#define GPIO_IBE_HIGH					0xf4
+#define GPIO_IEV_LOW					0xf8
+#define GPIO_IEV_HIGH					0xfc
+#define GPIO_IE_LOW					0x100
+#define GPIO_IE_HIGH					0x104
+//read only
+#define GPIO_RIS_LOW					0x108
+#define GPIO_RIS_HIGH					0x10c
+#define GPIO_MIS_LOW					0x110
+#define GPIO_MIS_HIGH					0x114
+#define GPIO_DIN_LOW					0x118
+#define GPIO_DIN_HIGH					0x11c
+
+#define GPIO_DOEN_X_REG					0x0
+#define GPIO_DOUT_X_REG					0x40
+
+#define GPIO_INPUT_ENABLE_X_REG				0x120
+
+#define MAX_GPIO					64
+/***************sys_iomux***************/
+
+/***************aon_iomux***************/
+#define AON_GPO_DOEN_CFG_BASE_REG			0x0
+#define AON_GPO_DOUT_CFG_BASE_REG			0x4
+#define AON_GPI_DIN_CFG_BASE_REG			0x8
+#define AON_GPIO_DIN_REG				0x2c
+
+//aon_iomux GPIO CTRL
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_3_ADDR		0xc
+#define AON_GPIOEN_0_REG_SHIFT				0x0
+#define AON_GPIOEN_0_REG_MASK				0x1
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_4_ADDR		0x10
+#define AON_GPIOIS_0_REG_SHIFT				0x0
+#define AON_GPIOIS_0_REG_MASK				0xF
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_5_ADDR		0x14
+#define AON_GPIOIC_0_REG_SHIFT				0x0
+#define AON_GPIOIC_0_REG_MASK				0xF
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_6_ADDR		0x18
+#define AON_GPIOIBE_0_REG_SHIFT				0x0
+#define AON_GPIOIBE_0_REG_MASK				0xF
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_7_ADDR		0x1c
+#define AON_GPIOIEV_0_REG_SHIFT				0x0
+#define AON_GPIOIEV_0_REG_MASK				0xF
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_8_ADDR		0x20
+#define AON_GPIOIE_0_REG_SHIFT				0x0
+#define AON_GPIOIE_0_REG_MASK				0xF
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_9_ADDR		0x24
+#define AON_GPIORIS_0_REG_SHIFT				0x0
+#define AON_GPIORIS_0_REG_MASK				0xF
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_10_ADDR		0x28
+#define AON_GPIOMIS_0_REG_SHIFT				0x0
+#define AON_GPIOMIS_0_REG_MASK				0xF
+#define AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_11_ADDR		0x2c
+#define AON_GPIO_IN_SYNC2_0_REG_SHIFT			0x0
+#define AON_GPIO_IN_SYNC2_0_REG_MASK			0xF
+
+
+/* aon_iomux PIN ioconfig reg*/
+#define AON_IOMUX_CFG__SAIF__SYSCFG_48_ADDR		0x30
+#define PADCFG_PAD_TESTEN_POS_WIDTH			0x1
+#define PADCFG_PAD_TESTEN_POS_SHIFT			0x0
+#define PADCFG_PAD_TESTEN_POS_MASK			0x1
+#define AON_IOMUX_CFG__SAIF__SYSCFG_52_ADDR		0x34
+#define PADCFG_PAD_RGPIO0_IE_WIDTH			0x1
+#define PADCFG_PAD_RGPIO0_IE_SHIFT			0x0
+#define PADCFG_PAD_RGPIO0_IE_MASK			0x1
+#define PADCFG_PAD_RGPIO0_DS_WIDTH			0x2
+#define PADCFG_PAD_RGPIO0_DS_SHIFT			0x1
+#define PADCFG_PAD_RGPIO0_DS_MASK			0x6
+#define PADCFG_PAD_RGPIO0_PU_WIDTH			0x1
+#define PADCFG_PAD_RGPIO0_PU_SHIFT			0x3
+#define PADCFG_PAD_RGPIO0_PU_MASK			0x8
+#define PADCFG_PAD_RGPIO0_PD_WIDTH			0x1
+#define PADCFG_PAD_RGPIO0_PD_SHIFT			0x4
+#define PADCFG_PAD_RGPIO0_PD_MASK			0x10
+#define PADCFG_PAD_RGPIO0_SLEW_WIDTH			0x1
+#define PADCFG_PAD_RGPIO0_SLEW_SHIFT			0x5
+#define PADCFG_PAD_RGPIO0_SLEW_MASK			0x20
+#define PADCFG_PAD_RGPIO0_SMT_WIDTH			0x1
+#define PADCFG_PAD_RGPIO0_SMT_SHIFT			0x6
+#define PADCFG_PAD_RGPIO0_SMT_MASK			0x40
+#define PADCFG_PAD_RGPIO0_POS_WIDTH			0x1
+#define PADCFG_PAD_RGPIO0_POS_SHIFT			0x7
+#define PADCFG_PAD_RGPIO0_POS_MASK			0x80
+#define AON_IOMUX_CFG__SAIF__SYSCFG_56_ADDR		0x38
+#define PADCFG_PAD_RGPIO1_IE_WIDTH			0x1
+#define PADCFG_PAD_RGPIO1_IE_SHIFT			0x0
+#define PADCFG_PAD_RGPIO1_IE_MASK			0x1
+#define PADCFG_PAD_RGPIO1_DS_WIDTH			0x2
+#define PADCFG_PAD_RGPIO1_DS_SHIFT			0x1
+#define PADCFG_PAD_RGPIO1_DS_MASK			0x6
+#define PADCFG_PAD_RGPIO1_PU_WIDTH			0x1
+#define PADCFG_PAD_RGPIO1_PU_SHIFT			0x3
+#define PADCFG_PAD_RGPIO1_PU_MASK			0x8
+#define PADCFG_PAD_RGPIO1_PD_WIDTH			0x1
+#define PADCFG_PAD_RGPIO1_PD_SHIFT			0x4
+#define PADCFG_PAD_RGPIO1_PD_MASK			0x10
+#define PADCFG_PAD_RGPIO1_SLEW_WIDTH			0x1
+#define PADCFG_PAD_RGPIO1_SLEW_SHIFT			0x5
+#define PADCFG_PAD_RGPIO1_SLEW_MASK			0x20
+#define PADCFG_PAD_RGPIO1_SMT_WIDTH			0x1
+#define PADCFG_PAD_RGPIO1_SMT_SHIFT			0x6
+#define PADCFG_PAD_RGPIO1_SMT_MASK			0x40
+#define PADCFG_PAD_RGPIO1_POS_WIDTH			0x1
+#define PADCFG_PAD_RGPIO1_POS_SHIFT			0x7
+#define PADCFG_PAD_RGPIO1_POS_MASK			0x80
+#define AON_IOMUX_CFG__SAIF__SYSCFG_60_ADDR		0x3c
+#define PADCFG_PAD_RGPIO2_IE_WIDTH			0x1
+#define PADCFG_PAD_RGPIO2_IE_SHIFT			0x0
+#define PADCFG_PAD_RGPIO2_IE_MASK			0x1
+#define PADCFG_PAD_RGPIO2_DS_WIDTH			0x2
+#define PADCFG_PAD_RGPIO2_DS_SHIFT			0x1
+#define PADCFG_PAD_RGPIO2_DS_MASK			0x6
+#define PADCFG_PAD_RGPIO2_PU_WIDTH			0x1
+#define PADCFG_PAD_RGPIO2_PU_SHIFT			0x3
+#define PADCFG_PAD_RGPIO2_PU_MASK			0x8
+#define PADCFG_PAD_RGPIO2_PD_WIDTH			0x1
+#define PADCFG_PAD_RGPIO2_PD_SHIFT			0x4
+#define PADCFG_PAD_RGPIO2_PD_MASK			0x10
+#define PADCFG_PAD_RGPIO2_SLEW_WIDTH			0x1
+#define PADCFG_PAD_RGPIO2_SLEW_SHIFT			0x5
+#define PADCFG_PAD_RGPIO2_SLEW_MASK			0x20
+#define PADCFG_PAD_RGPIO2_SMT_WIDTH			0x1
+#define PADCFG_PAD_RGPIO2_SMT_SHIFT			0x6
+#define PADCFG_PAD_RGPIO2_SMT_MASK			0x40
+#define PADCFG_PAD_RGPIO2_POS_WIDTH			0x1
+#define PADCFG_PAD_RGPIO2_POS_SHIFT			0x7
+#define PADCFG_PAD_RGPIO2_POS_MASK			0x80
+#define AON_IOMUX_CFG__SAIF__SYSCFG_64_ADDR		0x40
+#define PADCFG_PAD_RGPIO3_IE_WIDTH			0x1
+#define PADCFG_PAD_RGPIO3_IE_SHIFT			0x0
+#define PADCFG_PAD_RGPIO3_IE_MASK			0x1
+#define PADCFG_PAD_RGPIO3_DS_WIDTH			0x2
+#define PADCFG_PAD_RGPIO3_DS_SHIFT			0x1
+#define PADCFG_PAD_RGPIO3_DS_MASK			0x6
+#define PADCFG_PAD_RGPIO3_PU_WIDTH			0x1
+#define PADCFG_PAD_RGPIO3_PU_SHIFT			0x3
+#define PADCFG_PAD_RGPIO3_PU_MASK			0x8
+#define PADCFG_PAD_RGPIO3_PD_WIDTH			0x1
+#define PADCFG_PAD_RGPIO3_PD_SHIFT			0x4
+#define PADCFG_PAD_RGPIO3_PD_MASK			0x10
+#define PADCFG_PAD_RGPIO3_SLEW_WIDTH			0x1
+#define PADCFG_PAD_RGPIO3_SLEW_SHIFT			0x5
+#define PADCFG_PAD_RGPIO3_SLEW_MASK			0x20
+#define PADCFG_PAD_RGPIO3_SMT_WIDTH			0x1
+#define PADCFG_PAD_RGPIO3_SMT_SHIFT			0x6
+#define PADCFG_PAD_RGPIO3_SMT_MASK			0x40
+#define PADCFG_PAD_RGPIO3_POS_WIDTH			0x1
+#define PADCFG_PAD_RGPIO3_POS_SHIFT			0x7
+#define PADCFG_PAD_RGPIO3_POS_MASK			0x80
+#define AON_IOMUX_CFG__SAIF__SYSCFG_68_ADDR		0x44
+#define PADCFG_PAD_RSTN_SMT_WIDTH			0x1
+#define PADCFG_PAD_RSTN_SMT_SHIFT			0x0
+#define PADCFG_PAD_RSTN_SMT_MASK			0x1
+#define PADCFG_PAD_RSTN_POS_WIDTH			0x1
+#define PADCFG_PAD_RSTN_POS_SHIFT			0x1
+#define PADCFG_PAD_RSTN_POS_MASK			0x2
+#define AON_IOMUX_CFG__SAIF__SYSCFG_72_ADDR		0x48
+#define AON_IOMUX_CFG__SAIF__SYSCFG_76_ADDR		0x4c
+#define PADCFG_PAD_RTC_DS_WIDTH				0x2
+#define PADCFG_PAD_RTC_DS_SHIFT				0x0
+#define PADCFG_PAD_RTC_DS_MASK				0x3
+#define AON_IOMUX_CFG__SAIF__SYSCFG_80_ADDR		0x50
+#define AON_IOMUX_CFG__SAIF__SYSCFG_84_ADDR		0x54
+#define PADCFG_PAD_OSC_DS_WIDTH				0x2
+#define PADCFG_PAD_OSC_DS_SHIFT				0x0
+#define PADCFG_PAD_OSC_DS_MASK				0x3
+
+/*aon_iomux PIN 0-5 ioconfig reg*/
+#define AON_GPO_PDA_0_5_CFG_BASE_REG	AON_IOMUX_CFG__SAIF__SYSCFG_48_ADDR
+#define AON_GPO_PDA_0_5_CFG_END_REG	AON_IOMUX_CFG__SAIF__SYSCFG_68_ADDR
+#define AON_GPO_PDA_RTC_CFG_REG		AON_IOMUX_CFG__SAIF__SYSCFG_76_ADDR
+/***************aon_iomux***************/
+
+#define PADCFG_PAD_GMAC_SYSCON_WIDTH			0x2
+#define PADCFG_PAD_GMAC_SYSCON_SHIFT			0x0
+#define PADCFG_PAD_GMAC_SYSCON_MASK			0x3
+
+#define GPO_PDA_CFG_OFFSET				0x4
+
+#define AON_GPIO_INPUT_ENABLE_REG			0x34
+
+#define AON_GPIO_EN_REG		AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_3_ADDR
+#define AON_GPIO_IS_REG		AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_4_ADDR
+#define AON_GPIO_IC_REG		AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_5_ADDR
+#define AON_GPIO_IBE_REG	AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_6_ADDR
+#define AON_GPIO_IEV_REG	AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_7_ADDR
+#define AON_GPIO_IE_REG		AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_8_ADDR
+#define AON_GPIO_RIS_REG	AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_9_ADDR
+#define AON_GPIO_MIS_REG	AON_IOMUX_CFGSAIF__SYSCFG_IOIRQ_10_ADDR
+
+/*one dword include 4 gpios*/
+#define GPIO_NUM_SHIFT					2
+/*8 bits for each gpio*/
+#define GPIO_BYTE_SHIFT					3
+/*gpio index in dword */
+#define GPIO_INDEX_MASK					0x3
+#define GPIO_VAL_MASK					0x7f
+
+#define GPIO_NUM_PER_REG				32
+#define OFFSET_PER_REG					4
+#define SYS_GPIO_NUM					64
+#define AON_GPIO_NUM					4
+
+enum starfive_jh7110_sys_pads {
+	PAD_GPIO0	= 0,
+	PAD_GPIO1	= 1,
+	PAD_GPIO2	= 2,
+	PAD_GPIO3	= 3,
+	PAD_GPIO4	= 4,
+	PAD_GPIO5	= 5,
+	PAD_GPIO6	= 6,
+	PAD_GPIO7	= 7,
+	PAD_GPIO8	= 8,
+	PAD_GPIO9	= 9,
+	PAD_GPIO10	= 10,
+	PAD_GPIO11	= 11,
+	PAD_GPIO12	= 12,
+	PAD_GPIO13	= 13,
+	PAD_GPIO14	= 14,
+	PAD_GPIO15	= 15,
+	PAD_GPIO16	= 16,
+	PAD_GPIO17	= 17,
+	PAD_GPIO18	= 18,
+	PAD_GPIO19	= 19,
+	PAD_GPIO20	= 20,
+	PAD_GPIO21	= 21,
+	PAD_GPIO22	= 22,
+	PAD_GPIO23	= 23,
+	PAD_GPIO24	= 24,
+	PAD_GPIO25	= 25,
+	PAD_GPIO26	= 26,
+	PAD_GPIO27	= 27,
+	PAD_GPIO28	= 28,
+	PAD_GPIO29	= 29,
+	PAD_GPIO30	= 30,
+	PAD_GPIO31	= 31,
+	PAD_GPIO32	= 32,
+	PAD_GPIO33	= 33,
+	PAD_GPIO34	= 34,
+	PAD_GPIO35	= 35,
+	PAD_GPIO36	= 36,
+	PAD_GPIO37	= 37,
+	PAD_GPIO38	= 38,
+	PAD_GPIO39	= 39,
+	PAD_GPIO40	= 40,
+	PAD_GPIO41	= 41,
+	PAD_GPIO42	= 42,
+	PAD_GPIO43	= 43,
+	PAD_GPIO44	= 44,
+	PAD_GPIO45	= 45,
+	PAD_GPIO46	= 46,
+	PAD_GPIO47	= 47,
+	PAD_GPIO48	= 48,
+	PAD_GPIO49	= 49,
+	PAD_GPIO50	= 50,
+	PAD_GPIO51	= 51,
+	PAD_GPIO52	= 52,
+	PAD_GPIO53	= 53,
+	PAD_GPIO54	= 54,
+	PAD_GPIO55	= 55,
+	PAD_GPIO56	= 56,
+	PAD_GPIO57	= 57,
+	PAD_GPIO58	= 58,
+	PAD_GPIO59	= 59,
+	PAD_GPIO60	= 60,
+	PAD_GPIO61	= 61,
+	PAD_GPIO62	= 62,
+	PAD_GPIO63	= 63,
+	PAD_SD0_CLK	= 64,
+	PAD_SD0_CMD	= 65,
+	PAD_SD0_DATA0	= 66,
+	PAD_SD0_DATA1	= 67,
+	PAD_SD0_DATA2	= 68,
+	PAD_SD0_DATA3	= 69,
+	PAD_SD0_DATA4	= 70,
+	PAD_SD0_DATA5	= 71,
+	PAD_SD0_DATA6	= 72,
+	PAD_SD0_DATA7	= 73,
+	PAD_SD0_STRB	= 74,
+	PAD_GMAC1_MDC	= 75,
+	PAD_GMAC1_MDIO	= 76,
+	PAD_GMAC1_RXD0	= 77,
+	PAD_GMAC1_RXD1	= 78,
+	PAD_GMAC1_RXD2	= 79,
+	PAD_GMAC1_RXD3	= 80,
+	PAD_GMAC1_RXDV	= 81,
+	PAD_GMAC1_RXC	= 82,
+	PAD_GMAC1_TXD0	= 83,
+	PAD_GMAC1_TXD1	= 84,
+	PAD_GMAC1_TXD2	= 85,
+	PAD_GMAC1_TXD3	= 86,
+	PAD_GMAC1_TXEN	= 87,
+	PAD_GMAC1_TXC	= 88,
+	PAD_QSPI_SCLK	= 89,
+	PAD_QSPI_CSn0	= 90,
+	PAD_QSPI_DATA0	= 91,
+	PAD_QSPI_DATA1	= 92,
+	PAD_QSPI_DATA2	= 93,
+	PAD_QSPI_DATA3	= 94,
+};
+
+
+/* Pad names for the pinmux subsystem */
+static const struct pinctrl_pin_desc starfive_jh7110_sys_pinctrl_pads[] = {
+	STARFIVE_PINCTRL_PIN(PAD_GPIO0),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO1),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO2),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO3),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO4),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO5),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO6),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO7),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO8),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO9),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO10),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO11),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO12),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO13),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO14),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO15),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO16),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO17),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO18),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO19),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO20),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO21),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO22),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO23),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO24),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO25),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO26),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO27),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO28),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO29),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO30),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO31),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO32),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO33),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO34),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO35),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO36),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO37),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO38),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO39),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO40),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO41),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO42),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO43),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO44),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO45),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO46),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO47),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO48),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO49),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO50),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO51),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO52),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO53),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO54),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO55),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO56),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO57),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO58),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO59),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO60),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO61),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO62),
+	STARFIVE_PINCTRL_PIN(PAD_GPIO63),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_CLK),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_CMD),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_DATA0),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_DATA1),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_DATA2),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_DATA3),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_DATA4),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_DATA5),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_DATA6),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_DATA7),
+	STARFIVE_PINCTRL_PIN(PAD_SD0_STRB),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_MDC),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_MDIO),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_RXD0),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_RXD1),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_RXD2),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_RXD3),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_RXDV),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_RXC),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_TXD0),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_TXD1),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_TXD2),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_TXD3),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_TXEN),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC1_TXC),
+	STARFIVE_PINCTRL_PIN(PAD_QSPI_SCLK),
+	STARFIVE_PINCTRL_PIN(PAD_QSPI_CSn0),
+	STARFIVE_PINCTRL_PIN(PAD_QSPI_DATA0),
+	STARFIVE_PINCTRL_PIN(PAD_QSPI_DATA1),
+	STARFIVE_PINCTRL_PIN(PAD_QSPI_DATA2),
+	STARFIVE_PINCTRL_PIN(PAD_QSPI_DATA3),
+};
+
+enum starfive_jh7110_aon_pads {
+	PAD_TESTEN	= 0,
+	PAD_RGPIO0	= 1,
+	PAD_RGPIO1	= 2,
+	PAD_RGPIO2	= 3,
+	PAD_RGPIO3	= 4,
+	PAD_RSTN	= 5,
+	PAD_GMAC0_MDC	= 6,
+	PAD_GMAC0_MDIO	= 7,
+	PAD_GMAC0_RXD0	= 8,
+	PAD_GMAC0_RXD1	= 9,
+	PAD_GMAC0_RXD2	= 10,
+	PAD_GMAC0_RXD3	= 11,
+	PAD_GMAC0_RXDV	= 12,
+	PAD_GMAC0_RXC	= 13,
+	PAD_GMAC0_TXD0	= 14,
+	PAD_GMAC0_TXD1	= 15,
+	PAD_GMAC0_TXD2	= 16,
+	PAD_GMAC0_TXD3	= 17,
+	PAD_GMAC0_TXEN	= 18,
+	PAD_GMAC0_TXC	= 19,
+};
+
+static const struct pinctrl_pin_desc starfive_jh7110_aon_pinctrl_pads[] = {
+	STARFIVE_PINCTRL_PIN(PAD_TESTEN),
+	STARFIVE_PINCTRL_PIN(PAD_RGPIO0),
+	STARFIVE_PINCTRL_PIN(PAD_RGPIO1),
+	STARFIVE_PINCTRL_PIN(PAD_RGPIO2),
+	STARFIVE_PINCTRL_PIN(PAD_RGPIO3),
+	STARFIVE_PINCTRL_PIN(PAD_RSTN),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_MDC),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_MDIO),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_RXD0),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_RXD1),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_RXD2),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_RXD3),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_RXDV),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_RXC),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_TXD0),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_TXD1),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_TXD2),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_TXD3),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_TXEN),
+	STARFIVE_PINCTRL_PIN(PAD_GMAC0_TXC),
+};
+
+static void pinctrl_write_reg(void __iomem *addr, u32 mask, u32 val)
+{
+	u32 value;
+
+	value = readl_relaxed(addr);
+	value &= ~mask;
+	value |= (val & mask);
+	writel_relaxed(value, addr);
+}
+
+uint32_t pinctrl_get_reg(void __iomem *addr, u32 shift, u32 mask)
+{
+	u32 tmp;
+
+	tmp = readl_relaxed(addr);
+	tmp = (tmp & mask) >> shift;
+	return tmp;
+}
+
+void pinctrl_set_reg(void __iomem *addr, u32 data, u32 shift, u32 mask)
+{
+	u32 tmp;
+
+	tmp = readl_relaxed(addr);
+	tmp &= ~mask;
+	tmp |= (data<<shift) & mask;
+	writel_relaxed(tmp, addr);
+}
+
+static struct starfive_pinctrl *starfive_from_irq_desc(struct irq_desc *desc)
+{
+	struct gpio_chip *gc = irq_desc_get_handler_data(desc);
+
+	return container_of(gc, struct starfive_pinctrl, gc);
+}
+
+static struct starfive_pinctrl *starfive_from_irq_data(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+
+	return container_of(gc, struct starfive_pinctrl, gc);
+}
+
+static int starfive_jh7110_gpio_request(struct gpio_chip *gc, unsigned int gpio)
+{
+	return pinctrl_gpio_request(gc->base + gpio);
+}
+
+static void starfive_jh7110_gpio_free(struct gpio_chip *gc, unsigned int gpio)
+{
+	pinctrl_gpio_free(gc->base + gpio);
+}
+
+static int starfive_jh7110_sys_direction_input(struct gpio_chip *gc,
+							unsigned int offset)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+	unsigned int v;
+
+	if (offset >= gc->ngpio)
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	v = readl_relaxed(chip->padctl_base + GPIO_DOEN_X_REG +
+			(offset & ~0x3));
+	v &= ~(0x3f << ((offset & 0x3) * 8));
+	v |= 1 << ((offset & 0x3) * 8);
+	writel_relaxed(v, chip->padctl_base + GPIO_DOEN_X_REG +
+			(offset & ~0x3));
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int starfive_jh7110_sys_direction_output(struct gpio_chip *gc,
+		unsigned int offset,
+		int value)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+	unsigned int v;
+
+	if (offset >= gc->ngpio)
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	v = readl_relaxed(chip->padctl_base + GPIO_DOEN_X_REG +
+			(offset & ~0x3));
+	v &= ~(0x3f << ((offset & 0x3) * 8));
+	writel_relaxed(v, chip->padctl_base + GPIO_DOEN_X_REG +
+			(offset & ~0x3));
+
+	v = readl_relaxed(chip->padctl_base + GPIO_DOUT_X_REG +
+			(offset & ~0x3));
+	v &= ~(0x7f << ((offset & 0x3) * 8));
+	v |= value << ((offset & 0x3) * 8);
+	writel_relaxed(v, chip->padctl_base + GPIO_DOUT_X_REG +
+			(offset & ~0x3));
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int starfive_jh7110_sys_get_direction(struct gpio_chip *gc,
+		unsigned int offset)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	unsigned int v;
+
+	if (offset >= gc->ngpio)
+		return -EINVAL;
+
+	v = readl_relaxed(chip->padctl_base + GPIO_DOEN_X_REG +
+			(offset & ~0x3));
+	return !!(v & (0x3f << ((offset & 0x3) * 8)));
+}
+
+static int starfive_jh7110_sys_get_value(struct gpio_chip *gc,
+		unsigned int offset)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	int value;
+	int tmp;
+
+	if (offset >= gc->ngpio)
+		return -EINVAL;
+
+	if (offset < GPIO_NUM_PER_REG) {
+		value = readl_relaxed(chip->padctl_base + GPIO_DIN_LOW);
+		tmp = 0;
+	} else {
+		value = readl_relaxed(chip->padctl_base + GPIO_DIN_HIGH);
+		tmp = GPIO_NUM_PER_REG;
+	}
+	return (value >> (offset - tmp)) & 0x1;
+}
+
+static void starfive_jh7110_sys_set_value(struct gpio_chip *gc,
+		unsigned int offset,
+		int value)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+	unsigned int v;
+
+	if (offset >= gc->ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	v = readl_relaxed(chip->padctl_base + GPIO_DOUT_X_REG +
+			(offset & ~0x3));
+	v &= ~(0x7f << ((offset & 0x3) * 8));
+	v |= value << ((offset & 0x3) * 8);
+	writel_relaxed(v, chip->padctl_base + GPIO_DOUT_X_REG +
+			(offset & ~0x3));
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static int starfive_jh7110_sys_set_config(struct gpio_chip *gc,
+					  unsigned int gpio,
+					  unsigned long config)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	u32 arg = pinconf_to_config_argument(config);
+	unsigned long flags;
+	int padcfg_base;
+	u32 value;
+	u32 mask;
+
+	switch (pinconf_to_config_param(config)) {
+	case PIN_CONFIG_BIAS_DISABLE:
+		mask  = JH7110_PADCFG_BIAS;
+		value = 0;
+		break;
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+		if (arg == 0)
+			return -ENOTSUPP;
+		mask  = JH7110_PADCFG_BIAS;
+		value = JH7110_PADCFG_PD;
+		break;
+	case PIN_CONFIG_BIAS_PULL_UP:
+		if (arg == 0)
+			return -ENOTSUPP;
+		mask  = JH7110_PADCFG_BIAS;
+		value = JH7110_PADCFG_PU;
+		break;
+	case PIN_CONFIG_DRIVE_PUSH_PULL:
+		return 0;
+	case PIN_CONFIG_INPUT_ENABLE:
+		mask  = JH7110_PADCFG_IE;
+		value = arg ? JH7110_PADCFG_IE : 0;
+		break;
+	case PIN_CONFIG_INPUT_SCHMITT_ENABLE:
+		mask  = JH7110_PADCFG_SMT;
+		value = arg ? JH7110_PADCFG_SMT : 0;
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	if (gpio < PAD_GMAC1_MDC)
+		padcfg_base = SYS_GPO_PDA_0_74_CFG_BASE_REG;
+	else if (gpio >= PAD_QSPI_SCLK && gpio <= PAD_QSPI_DATA3)
+		padcfg_base = SYS_GPO_PDA_89_94_CFG_BASE_REG;
+	else
+		return 0;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	pinctrl_write_reg(chip->padctl_base + padcfg_base + 4 * gpio,
+			  mask, value);
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int starfive_jh7110_sys_irq_set_type(struct irq_data *d,
+		unsigned int trigger)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *base = sfp->padctl_base +
+			OFFSET_PER_REG * (gpio / GPIO_NUM_PER_REG);
+	u32 mask = BIT(gpio % GPIO_NUM_PER_REG);
+	u32 irq_type, edge_both, polarity;
+	unsigned long flags;
+
+	switch (trigger) {
+	case IRQ_TYPE_LEVEL_HIGH:
+		irq_type  = 0;    /* 0: level triggered */
+		edge_both = 0;    /* 0: ignored */
+		polarity  = 0;    /* 0: high level */
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		irq_type  = 0;    /* 0: level triggered */
+		edge_both = 0;    /* 0: ignored */
+		polarity  = 1;    /* 1: low level */
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		irq_type  = mask; /* 1: edge triggered */
+		edge_both = mask; /* 1: both edges */
+		polarity  = 0;    /* 0: ignored */
+		break;
+	case IRQ_TYPE_EDGE_RISING:
+		irq_type  = mask; /* 1: edge triggered */
+		edge_both = 0;    /* 0: single edge */
+		polarity  = mask; /* 1: rising edge */
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		irq_type  = mask; /* 1: edge triggered */
+		edge_both = 0;    /* 0: single edge */
+		polarity  = 0;    /* 0: falling edge */
+		break;
+	}
+	if (trigger & IRQ_TYPE_EDGE_BOTH)
+		irq_set_handler_locked(d, handle_edge_irq);
+	else
+		irq_set_handler_locked(d, handle_level_irq);
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	irq_type |= readl_relaxed(base + GPIO_IS_LOW) & ~mask;
+	writel_relaxed(irq_type, base + GPIO_IS_LOW);
+	edge_both |= readl_relaxed(base + GPIO_IBE_LOW) & ~mask;
+	writel_relaxed(edge_both, base + GPIO_IBE_LOW);
+	polarity |= readl_relaxed(base + GPIO_IEV_LOW) & ~mask;
+	writel_relaxed(polarity, base + GPIO_IEV_LOW);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+
+	sfp->trigger[gpio] = trigger;
+	return 0;
+}
+
+/* chained_irq_{enter,exit} already mask the parent */
+static void starfive_jh7110_sys_irq_mask(struct irq_data *d)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *ie = sfp->padctl_base + GPIO_IE_LOW +
+			OFFSET_PER_REG * (gpio / GPIO_NUM_PER_REG);
+	u32 mask = BIT(gpio % GPIO_NUM_PER_REG);
+	unsigned long flags;
+	u32 value;
+
+	if (gpio < 0 || gpio >= sfp->gc.ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	value = readl_relaxed(ie) & ~mask;
+	writel_relaxed(value, ie);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+}
+
+static void starfive_jh7110_sys_irq_unmask(struct irq_data *d)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *ie = sfp->padctl_base + GPIO_IE_LOW +
+			OFFSET_PER_REG * (gpio / GPIO_NUM_PER_REG);
+	u32 mask = BIT(gpio % GPIO_NUM_PER_REG);
+	unsigned long flags;
+	u32 value;
+
+	if (gpio < 0 || gpio >= sfp->gc.ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	value = readl_relaxed(ie) | mask;
+	writel_relaxed(value, ie);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+}
+
+static void starfive_jh7110_sys_irq_ack(struct irq_data *d)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *ic = sfp->padctl_base + GPIO_IC_LOW +
+			OFFSET_PER_REG * (gpio / GPIO_NUM_PER_REG);
+	u32 mask = BIT(gpio % GPIO_NUM_PER_REG);
+	unsigned long flags;
+	u32 value;
+
+	if (gpio < 0 || gpio >= sfp->gc.ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	value = readl_relaxed(ic) & ~mask;
+	writel_relaxed(value, ic);
+	writel_relaxed(value | mask, ic);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+}
+
+static void starfive_jh7110_sys_irq_mask_ack(struct irq_data *d)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *ie = sfp->padctl_base + GPIO_IE_LOW +
+			OFFSET_PER_REG * (gpio / GPIO_NUM_PER_REG);
+	void __iomem *ic = sfp->padctl_base + GPIO_IC_LOW +
+			OFFSET_PER_REG * (gpio / GPIO_NUM_PER_REG);
+	u32 mask = BIT(gpio % GPIO_NUM_PER_REG);
+	unsigned long flags;
+	u32 value;
+
+	if (gpio < 0 || gpio >= sfp->gc.ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	value = readl_relaxed(ie) & ~mask;
+	writel_relaxed(value, ie);
+
+	value = readl_relaxed(ic) & ~mask;
+	writel_relaxed(value, ic);
+	writel_relaxed(value | mask, ic);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+}
+
+static struct irq_chip starfive_jh7110_sys_irqchip = {
+	.name		= "starfive_jh7110_sys-gpio",
+	.irq_ack	= starfive_jh7110_sys_irq_ack,
+	.irq_mask_ack	= starfive_jh7110_sys_irq_mask_ack,
+	.irq_set_type	= starfive_jh7110_sys_irq_set_type,
+	.irq_mask	= starfive_jh7110_sys_irq_mask,
+	.irq_unmask	= starfive_jh7110_sys_irq_unmask,
+};
+
+static void starfive_jh7110_sys_irq_handler(struct irq_desc *desc)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_desc(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	unsigned long mis;
+	unsigned int pin;
+
+	chained_irq_enter(chip, desc);
+
+	mis = readl_relaxed(sfp->padctl_base + GPIO_MIS_LOW);
+	for_each_set_bit(pin, &mis, GPIO_NUM_PER_REG)
+		generic_handle_irq(irq_find_mapping(sfp->gc.irq.domain, pin));
+
+	mis = readl_relaxed(sfp->padctl_base + GPIO_MIS_HIGH);
+	for_each_set_bit(pin, &mis, GPIO_NUM_PER_REG)
+		generic_handle_irq(irq_find_mapping(sfp->gc.irq.domain,
+			pin + GPIO_NUM_PER_REG));
+
+	chained_irq_exit(chip, desc);
+}
+
+static int starfive_jh7110_sys_init_hw(struct gpio_chip *gc)
+{
+	struct starfive_pinctrl *sfp = container_of(gc,
+			struct starfive_pinctrl, gc);
+
+	/* mask all GPIO interrupts */
+	writel_relaxed(0, sfp->padctl_base + GPIO_IE_LOW);
+	writel_relaxed(0, sfp->padctl_base + GPIO_IE_HIGH);
+	/* clear edge interrupt flags */
+	writel_relaxed(0U, sfp->padctl_base + GPIO_IC_LOW);
+	writel_relaxed(0U, sfp->padctl_base + GPIO_IC_HIGH);
+	writel_relaxed(~0U, sfp->padctl_base + GPIO_IC_LOW);
+	writel_relaxed(~0U, sfp->padctl_base + GPIO_IC_HIGH);
+	/* enable GPIO interrupts */
+	writel_relaxed(1, sfp->padctl_base + GPIO_EN);
+	return 0;
+}
+
+static int starfive_sys_add_pin_ranges(struct gpio_chip *gc)
+{
+	struct starfive_pinctrl *sfp = container_of(gc,
+			struct starfive_pinctrl, gc);
+
+	sfp->gpios.name = sfp->gc.label;
+	sfp->gpios.base = sfp->gc.base;
+	/*
+	 * sfp->gpios.pin_base depends on the chosen signal group
+	 * and is set in starfive_probe()
+	 */
+	sfp->gpios.npins = SYS_GPIO_NUM;
+	sfp->gpios.gc = &sfp->gc;
+	pinctrl_add_gpio_range(sfp->pctl_dev, &sfp->gpios);
+	return 0;
+}
+
+static int starfive_jh7110_sys_gpio_register(struct platform_device *pdev,
+		struct starfive_pinctrl *pctl)
+{
+	struct device *dev = &pdev->dev;
+	int ret, ngpio;
+	int loop;
+
+	ngpio = SYS_GPIO_NUM;
+
+	pctl->gc.request = starfive_jh7110_gpio_request;
+	pctl->gc.free = starfive_jh7110_gpio_free;
+	pctl->gc.direction_input = starfive_jh7110_sys_direction_input;
+	pctl->gc.direction_output = starfive_jh7110_sys_direction_output;
+	pctl->gc.get_direction = starfive_jh7110_sys_get_direction;
+	pctl->gc.get = starfive_jh7110_sys_get_value;
+	pctl->gc.set = starfive_jh7110_sys_set_value;
+	pctl->gc.set_config = starfive_jh7110_sys_set_config;
+	pctl->gc.add_pin_ranges = starfive_sys_add_pin_ranges;
+	pctl->gc.base = 0;
+	pctl->gc.ngpio = ngpio;
+	pctl->gc.label = dev_name(dev);
+	pctl->gc.parent = dev;
+	pctl->gc.owner = THIS_MODULE;
+	pctl->enabled = 0;
+
+	platform_set_drvdata(pdev, pctl);
+
+	starfive_jh7110_sys_irqchip.parent_device = dev;
+	starfive_jh7110_sys_irqchip.name = pctl->gc.label;
+
+	pctl->gc.irq.chip = &starfive_jh7110_sys_irqchip;
+	pctl->gc.irq.parent_handler = starfive_jh7110_sys_irq_handler;
+	pctl->gc.irq.num_parents = 1;
+	pctl->gc.irq.parents = devm_kcalloc(dev, pctl->gc.irq.num_parents,
+			sizeof(*pctl->gc.irq.parents), GFP_KERNEL);
+	if (!pctl->gc.irq.parents)
+		return -ENOMEM;
+	pctl->gc.irq.default_type = IRQ_TYPE_NONE;
+	pctl->gc.irq.handler = handle_bad_irq;
+	pctl->gc.irq.init_hw = starfive_jh7110_sys_init_hw;
+
+	if (IS_ENABLED(CONFIG_PM))
+		pm_runtime_enable(dev);
+
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0)
+		return ret;
+	pctl->gc.irq.parents[0] = ret;
+
+	ret = devm_gpiochip_add_data(dev, &pctl->gc, pctl);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				"could not register gpiochip\n");
+
+	for (loop = 0; loop < MAX_GPIO; loop++) {
+		unsigned int v;
+
+		v = readl_relaxed(pctl->padctl_base +
+				GPIO_INPUT_ENABLE_X_REG + (loop << 2));
+		v |= 0x1;
+		writel_relaxed(v, pctl->padctl_base +
+				GPIO_INPUT_ENABLE_X_REG + (loop << 2));
+	}
+
+	dev_info(dev, "SiFive GPIO chip registered %d GPIOs\n", ngpio);
+
+	return 0;
+}
+
+static int starfive_jh7110_pinconf_get(struct pinctrl_dev *pctldev,
+		unsigned int pin_id,
+		unsigned long *config)
+{
+	struct starfive_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+	const struct starfive_pin_reg *pin_reg = &pctl->pin_regs[pin_id];
+	u32 value;
+
+	if (pin_reg->io_conf_reg == -1) {
+		dev_err(pctl->dev,
+			"Pin(%s) does not support config function\n",
+			info->pins[pin_id].name);
+		return -EINVAL;
+	}
+
+	value = readl_relaxed(pctl->padctl_base + pin_reg->io_conf_reg);
+	*config = value & 0xff;
+	return 0;
+}
+
+static int starfive_jh7110_pinconf_set(struct pinctrl_dev *pctldev,
+		unsigned int pin_id, unsigned long *configs,
+		unsigned int num_configs)
+{
+	struct starfive_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+	const struct starfive_pin_reg *pin_reg = &pctl->pin_regs[pin_id];
+	int i;
+	u32 value;
+	unsigned long flags;
+
+	if (pin_reg->io_conf_reg == -1) {
+		dev_err(pctl->dev,
+			"Pin(%s) does not support config function\n",
+			info->pins[pin_id].name);
+		return -EINVAL;
+	}
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	for (i = 0; i < num_configs; i++) {
+		value = readl_relaxed(pctl->padctl_base +
+				pin_reg->io_conf_reg);
+		value = value|(configs[i] & 0xFF);
+		writel_relaxed(value, pctl->padctl_base +
+				pin_reg->io_conf_reg);
+	}
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	return 0;
+}
+
+static int starfive_jh7110_sys_pmx_set_one_pin_mux(struct starfive_pinctrl *pctl,
+		struct starfive_pin *pin)
+{
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+	struct starfive_pin_config *pin_config = &pin->pin_config;
+	const struct starfive_pin_reg *pin_reg;
+	unsigned int gpio, pin_id;
+	int i;
+	unsigned long flags;
+	int n, shift;
+
+	gpio = pin->pin_config.gpio_num;
+	pin_id = pin->pin;
+	pin_reg = &pctl->pin_regs[pin_id];
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	if (pin_reg->func_sel_reg != -1) {
+		pinctrl_set_reg(pctl->padctl_base + pin_reg->func_sel_reg,
+			pin_config->pinmux_func, pin_reg->func_sel_shift,
+			pin_reg->func_sel_mask);
+	}
+
+	shift = (gpio & GPIO_INDEX_MASK) << GPIO_BYTE_SHIFT;
+	if (pin_reg->gpo_dout_reg != -1) {
+		pinctrl_write_reg(pctl->padctl_base + pin_reg->gpo_dout_reg,
+				0x7F<<shift, pin_config->gpio_dout<<shift);
+	}
+
+	if (pin_reg->gpo_doen_reg != -1) {
+		pinctrl_write_reg(pctl->padctl_base + pin_reg->gpo_doen_reg,
+				0x3F<<shift, pin_config->gpio_doen<<shift);
+	}
+
+	for (i = 0; i < pin_config->gpio_din_num; i++) {
+		n = pin_config->gpio_din_reg[i] >> 2;
+		shift = (pin_config->gpio_din_reg[i] & 3) << 3;
+		pinctrl_write_reg(pctl->padctl_base + info->din_reg_base + n * 4,
+					0x7F<<shift, (gpio+2)<<shift);
+	}
+
+	if (pin_reg->syscon_reg != -1) {
+		pinctrl_set_reg(pctl->padctl_base + pin_reg->syscon_reg,
+				pin_config->syscon, PADCFG_PAD_GMAC_SYSCON_SHIFT,
+				PADCFG_PAD_GMAC_SYSCON_MASK);
+	}
+
+	if (pin_reg->pad_sel_reg != -1) {
+		pinctrl_set_reg(pctl->padctl_base + pin_reg->pad_sel_reg,
+			pin_config->padmux_func, pin_reg->pad_sel_shift,
+			pin_reg->pad_sel_mask);
+	}
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	return 0;
+}
+
+
+static void starfive_jh7110_sys_parse_pin_config(
+		struct starfive_pinctrl *pctl,
+		unsigned int *pins_id,
+		struct starfive_pin *pin_data,
+		const __be32 *list_p,
+		struct device_node *np)
+{
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+	struct starfive_pin_reg *pin_reg;
+	const __be32 *list = list_p;
+	const __be32 *list_din;
+	int size;
+	int size_din;
+	int pin_size;
+	u32 value;
+	int i;
+	int n;
+
+	pin_size = 4;
+	*pins_id = be32_to_cpu(*list);
+	pin_reg = &pctl->pin_regs[*pins_id];
+	pin_data->pin = *pins_id;
+
+	if (pin_data->pin > PAD_QSPI_DATA3) {
+		dev_err(pctl->dev, "err pin num\n");
+		return;
+	}
+
+	if (pin_data->pin < PAD_GMAC1_MDC) {
+		pin_reg->io_conf_reg = (pin_data->pin * GPO_PDA_CFG_OFFSET)
+			+ SYS_GPO_PDA_0_74_CFG_BASE_REG;
+	} else if (pin_data->pin >= PAD_QSPI_SCLK &&
+		   pin_data->pin <= PAD_QSPI_DATA3) {
+		pin_reg->io_conf_reg =
+			((pin_data->pin - PAD_QSPI_SCLK) * GPO_PDA_CFG_OFFSET)
+			+ SYS_GPO_PDA_89_94_CFG_BASE_REG;
+	}
+
+	if (!of_property_read_u32(np, "starfive,pin-ioconfig", &value))
+		pin_data->pin_config.io_config = value;
+
+	list = of_get_property(np, "starfive,pinmux", &size);
+	if (list) {
+		pin_reg->func_sel_reg = be32_to_cpu(*list++);
+		pin_reg->func_sel_shift = be32_to_cpu(*list++);
+		pin_reg->func_sel_mask = be32_to_cpu(*list++);
+		pin_data->pin_config.pinmux_func = be32_to_cpu(*list++);
+	}
+
+	list = of_get_property(np, "starfive,padmux", &size);
+	if (list) {
+		pin_reg->pad_sel_reg = be32_to_cpu(*list++);
+		pin_reg->pad_sel_shift = be32_to_cpu(*list++);
+		pin_reg->pad_sel_mask = be32_to_cpu(*list++);
+		pin_data->pin_config.padmux_func = be32_to_cpu(*list++);
+	}
+
+	list = of_get_property(np, "starfive,pin-syscon", &size);
+	if (list) {
+		pin_reg->syscon_reg = be32_to_cpu(*list++);
+		pin_data->pin_config.syscon = be32_to_cpu(*list++);
+	}
+
+	if (pin_data->pin < PAD_SD0_CLK) {
+		pin_data->pin_config.gpio_num = pin_data->pin;
+		n = pin_data->pin_config.gpio_num >> GPIO_NUM_SHIFT;
+
+		if (!of_property_read_u32(np, "starfive,pin-gpio-dout", &value)) {
+			pin_data->pin_config.gpio_dout = value;
+			pin_reg->gpo_dout_reg = info->dout_reg_base + n * 4;
+		}
+
+		if (!of_property_read_u32(np, "starfive,pin-gpio-doen", &value)) {
+			pin_data->pin_config.gpio_doen = value;
+			pin_reg->gpo_doen_reg = info->doen_reg_base + n * 4;
+		}
+
+		list_din = of_get_property(np, "starfive,pin-gpio-din", &size_din);
+		if (list_din) {
+			if (!size_din || size_din % pin_size) {
+				dev_err(pctl->dev,
+					"Invalid starfive,pin-gpio-din property in node\n");
+				return;
+			}
+
+			pin_data->pin_config.gpio_din_num = size_din / pin_size;
+			pin_data->pin_config.gpio_din_reg = devm_kcalloc(pctl->dev,
+					pin_data->pin_config.gpio_din_num,
+					sizeof(s32),
+					GFP_KERNEL);
+
+			for (i = 0; i < pin_data->pin_config.gpio_din_num; i++) {
+				value = be32_to_cpu(*list_din++);
+				pin_data->pin_config.gpio_din_reg[i] = value;
+			}
+		}
+	}
+}
+
+static const struct starfive_pinctrl_soc_info starfive_jh7110_sys_pinctrl_info = {
+	.pins = starfive_jh7110_sys_pinctrl_pads,
+	.npins = ARRAY_SIZE(starfive_jh7110_sys_pinctrl_pads),
+	.flags = 1,
+	.dout_reg_base = SYS_GPO_DOUT_CFG_BASE_REG,
+	.doen_reg_base = SYS_GPO_DOEN_CFG_BASE_REG,
+	.din_reg_base = SYS_GPI_DIN_CFG_BASE_REG,
+	.starfive_pinconf_get = starfive_jh7110_pinconf_get,
+	.starfive_pinconf_set = starfive_jh7110_pinconf_set,
+	.starfive_pmx_set_one_pin_mux = starfive_jh7110_sys_pmx_set_one_pin_mux,
+	.starfive_gpio_register = starfive_jh7110_sys_gpio_register,
+	.starfive_pinctrl_parse_pin = starfive_jh7110_sys_parse_pin_config,
+};
+
+static int starfive_jh7110_aon_pmx_set_one_pin_mux(
+					struct starfive_pinctrl *pctl,
+					struct starfive_pin *pin)
+{
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+	struct starfive_pin_config *pin_config = &pin->pin_config;
+	const struct starfive_pin_reg *pin_reg;
+	unsigned int gpio, pin_id;
+	int i;
+	unsigned long flags;
+	int n, shift;
+
+	gpio = pin->pin_config.gpio_num;
+	pin_id = pin->pin;
+	pin_reg = &pctl->pin_regs[pin_id];
+
+	raw_spin_lock_irqsave(&pctl->lock, flags);
+	if (pin_reg->func_sel_reg != -1) {
+		pinctrl_set_reg(pctl->padctl_base + pin_reg->func_sel_reg,
+				pin_config->pinmux_func,
+				pin_reg->func_sel_shift,
+				pin_reg->func_sel_mask);
+	}
+
+	shift = (gpio & GPIO_INDEX_MASK) << GPIO_BYTE_SHIFT;
+	if (pin_reg->gpo_dout_reg != -1) {
+		pinctrl_write_reg(pctl->padctl_base + pin_reg->gpo_dout_reg,
+				0xF << shift,
+				pin_config->gpio_dout<<shift);
+	}
+
+	if (pin_reg->gpo_doen_reg != -1) {
+		pinctrl_write_reg(pctl->padctl_base + pin_reg->gpo_doen_reg,
+				0x7 << shift,
+				pin_config->gpio_doen << shift);
+	}
+
+	for (i = 0; i < pin_config->gpio_din_num; i++) {
+		n = pin_config->gpio_din_reg[i] >> 2;
+		shift = (pin_config->gpio_din_reg[i] & 3) << 3;
+		pinctrl_write_reg(pctl->padctl_base + info->din_reg_base + n * 4,
+				0x7 << shift,
+				(gpio+2) << shift);
+	}
+
+	if (pin_reg->syscon_reg != -1) {
+		pinctrl_set_reg(pctl->padctl_base + pin_reg->syscon_reg,
+				pin_config->syscon,
+				PADCFG_PAD_GMAC_SYSCON_SHIFT,
+				PADCFG_PAD_GMAC_SYSCON_MASK);
+	}
+
+	raw_spin_unlock_irqrestore(&pctl->lock, flags);
+
+	return 0;
+}
+
+
+static void starfive_jh7110_aon_parse_pin_config(
+		struct starfive_pinctrl *pctl, unsigned int *pins_id,
+		struct starfive_pin *pin_data, const __be32 *list_p,
+		struct device_node *np)
+{
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+	struct starfive_pin_reg *pin_reg;
+	const __be32 *list = list_p;
+	const __be32 *list_din;
+	int size;
+	int size_din;
+	int pin_size;
+	u32 value;
+	int i;
+
+	pin_size = 4;
+	*pins_id = be32_to_cpu(*list);
+	pin_reg = &pctl->pin_regs[*pins_id];
+	pin_data->pin = *pins_id;
+
+	if (pin_data->pin > PAD_GMAC0_TXC) {
+		dev_err(pctl->dev, "err pin num\n");
+		return;
+	}
+
+	if (pin_data->pin < PAD_GMAC0_MDC) {
+		pin_reg->io_conf_reg = (pin_data->pin * GPO_PDA_CFG_OFFSET) +
+					AON_GPO_PDA_0_5_CFG_BASE_REG;
+	}
+
+	if (!of_property_read_u32(np, "starfive,pin-ioconfig", &value))
+		pin_data->pin_config.io_config = value;
+
+	list = of_get_property(np, "starfive,pinmux", &size);
+	if (list) {
+		pin_reg->func_sel_reg = be32_to_cpu(*list++);
+		pin_reg->func_sel_shift = be32_to_cpu(*list++);
+		pin_reg->func_sel_mask = be32_to_cpu(*list++);
+		pin_data->pin_config.pinmux_func = be32_to_cpu(*list++);
+	}
+
+	list = of_get_property(np, "starfive,pin-syscon", &size);
+	if (list) {
+		pin_reg->syscon_reg = be32_to_cpu(*list++);
+		pin_data->pin_config.syscon = be32_to_cpu(*list++);
+	}
+
+	if ((pin_data->pin >= PAD_RGPIO0) && (pin_data->pin <= PAD_RGPIO3)) {
+		pin_data->pin_config.gpio_num = pin_data->pin - 1;
+		pin_reg->gpo_dout_reg = info->dout_reg_base;
+		pin_reg->gpo_doen_reg = info->doen_reg_base;
+
+		if (!of_property_read_u32(np, "starfive,pin-gpio-dout", &value))
+			pin_data->pin_config.gpio_dout = value;
+
+		if (!of_property_read_u32(np, "starfive,pin-gpio-doen", &value))
+			pin_data->pin_config.gpio_doen = value;
+
+		list_din = of_get_property(np, "starfive,pin-gpio-din", &size_din);
+		if (list_din) {
+			if (!size_din || size_din % pin_size) {
+				dev_err(pctl->dev,
+					"Invalid starfive,pin-gpio-din property in node\n");
+				return;
+			}
+			pin_data->pin_config.gpio_din_num = size_din / pin_size;
+			pin_data->pin_config.gpio_din_reg = devm_kcalloc(pctl->dev,
+					pin_data->pin_config.gpio_din_num,
+					sizeof(s32),
+					GFP_KERNEL);
+			for (i = 0; i < pin_data->pin_config.gpio_din_num; i++) {
+				value = be32_to_cpu(*list_din++);
+				pin_data->pin_config.gpio_din_reg[i] = value;
+			}
+		}
+	}
+}
+
+static int starfive_jh7110_aon_direction_input(struct gpio_chip *gc,
+		unsigned int offset)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+	unsigned int v;
+
+
+	if (offset < 0 || offset >= gc->ngpio)
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	v = readl_relaxed(chip->padctl_base + AON_GPO_DOEN_CFG_BASE_REG);
+	v &= ~(0x07 << ((offset & 0x3) * 8));
+	v |= 1 << ((offset & 0x3) * 8);
+	writel_relaxed(v, chip->padctl_base + AON_GPO_DOEN_CFG_BASE_REG);
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int starfive_jh7110_aon_direction_output(struct gpio_chip *gc,
+		unsigned int offset,
+		int value)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+	unsigned int v;
+
+	if (offset < 0 || offset >= gc->ngpio)
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	v = readl_relaxed(chip->padctl_base + AON_GPO_DOEN_CFG_BASE_REG);
+	v &= ~(0x07 << ((offset & 0x3) * 8));
+	writel_relaxed(v, chip->padctl_base + AON_GPO_DOEN_CFG_BASE_REG);
+
+	v = readl_relaxed(chip->padctl_base + AON_GPO_DOUT_CFG_BASE_REG);
+	v &= ~(0x0f << ((offset & 0x3) * 8));
+	v |= value << ((offset & 0x3) * 8);
+	writel_relaxed(v, chip->padctl_base + AON_GPO_DOUT_CFG_BASE_REG);
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+
+	return 0;
+}
+
+static int starfive_jh7110_aon_get_direction(struct gpio_chip *gc,
+		unsigned int offset)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	unsigned int v;
+
+	if (offset < 0 || offset >= gc->ngpio)
+		return -EINVAL;
+
+	v = readl_relaxed(chip->padctl_base + AON_GPO_DOEN_CFG_BASE_REG);
+	return !!(v & (0x07 << ((offset & 0x3) * 8)));
+}
+
+static int starfive_jh7110_aon_get_value(struct gpio_chip *gc,
+		unsigned int offset)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	int value;
+
+	if (offset < 0 || offset >= gc->ngpio)
+		return -EINVAL;
+
+	value = readl_relaxed(chip->padctl_base + AON_GPIO_DIN_REG);
+	return (value >> offset) & 0x1;
+}
+
+static void starfive_jh7110_aon_set_value(struct gpio_chip *gc,
+		unsigned int offset, int value)
+{
+	struct starfive_pinctrl *chip = gpiochip_get_data(gc);
+	unsigned long flags;
+	unsigned int v;
+
+	if (offset < 0 || offset >= gc->ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&chip->lock, flags);
+	v = readl_relaxed(chip->padctl_base + AON_GPO_DOUT_CFG_BASE_REG);
+	v &= ~(0x0f << ((offset & 0x3) * 8));
+	v |= value << ((offset & 0x3) * 8);
+	writel_relaxed(v, chip->padctl_base + AON_GPO_DOUT_CFG_BASE_REG);
+	raw_spin_unlock_irqrestore(&chip->lock, flags);
+}
+
+static void starfive_jh7110_aon_irq_handler(struct irq_desc *desc)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_desc(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	unsigned long mis;
+	unsigned int pin;
+
+	chained_irq_enter(chip, desc);
+
+	mis = readl_relaxed(sfp->padctl_base + AON_GPIO_MIS_REG);
+	for_each_set_bit(pin, &mis, 4)
+		generic_handle_irq(irq_find_mapping(sfp->gc.irq.domain, pin));
+
+	chained_irq_exit(chip, desc);
+}
+
+static int starfive_jh7110_aon_init_hw(struct gpio_chip *gc)
+{
+	struct starfive_pinctrl *sfp = container_of(gc,
+			struct starfive_pinctrl, gc);
+
+	/* mask all GPIO interrupts */
+	writel_relaxed(0, sfp->padctl_base + AON_GPIO_IE_REG);
+	/* clear edge interrupt flags */
+	writel_relaxed(0x00U, sfp->padctl_base + AON_GPIO_IC_REG);
+	writel_relaxed(0x0fU, sfp->padctl_base + AON_GPIO_IC_REG);
+	/* enable GPIO interrupts */
+	writel_relaxed(1, sfp->padctl_base + AON_GPIO_EN_REG);
+	return 0;
+}
+
+static int starfive_jh7110_aon_irq_set_type(struct irq_data *d,
+		unsigned int trigger)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *base = sfp->padctl_base;
+	u32 mask = BIT(gpio);
+	u32 irq_type, edge_both, polarity;
+	unsigned long flags;
+
+	switch (trigger) {
+	case IRQ_TYPE_LEVEL_HIGH:
+		irq_type  = 0;    /* 0: level triggered */
+		edge_both = 0;    /* 0: ignored */
+		polarity  = 0;    /* 0: high level */
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		irq_type  = 0;    /* 0: level triggered */
+		edge_both = 0;    /* 0: ignored */
+		polarity  = 1;    /* 1: low level */
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		irq_type  = mask; /* 1: edge triggered */
+		edge_both = mask; /* 1: both edges */
+		polarity  = 0;    /* 0: ignored */
+		break;
+	case IRQ_TYPE_EDGE_RISING:
+		irq_type  = mask; /* 1: edge triggered */
+		edge_both = 0;    /* 0: single edge */
+		polarity  = mask; /* 1: rising edge */
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		irq_type  = mask; /* 1: edge triggered */
+		edge_both = 0;    /* 0: single edge */
+		polarity  = 0;    /* 0: falling edge */
+		break;
+	}
+	if (trigger & IRQ_TYPE_EDGE_BOTH)
+		irq_set_handler_locked(d, handle_edge_irq);
+	else
+		irq_set_handler_locked(d, handle_level_irq);
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	irq_type |= readl_relaxed(base + AON_GPIO_IS_REG) & ~mask;
+	writel_relaxed(irq_type, base + AON_GPIO_IS_REG);
+	edge_both |= readl_relaxed(base + AON_GPIO_IBE_REG) & ~mask;
+	writel_relaxed(edge_both, base + AON_GPIO_IBE_REG);
+	polarity |= readl_relaxed(base + AON_GPIO_IEV_REG) & ~mask;
+	writel_relaxed(polarity, base + AON_GPIO_IEV_REG);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+
+	sfp->trigger[gpio] = trigger;
+	return 0;
+}
+
+static void starfive_jh7110_aon_irq_mask(struct irq_data *d)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *ie = sfp->padctl_base + AON_GPIO_IE_REG;
+	u32 mask = BIT(gpio);
+	unsigned long flags;
+	u32 value;
+
+	if (gpio < 0 || gpio >= sfp->gc.ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	value = readl_relaxed(ie) & ~mask;
+	writel_relaxed(value, ie);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+}
+
+static void starfive_jh7110_aon_irq_unmask(struct irq_data *d)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *ie = sfp->padctl_base + AON_GPIO_IE_REG;
+	u32 mask = BIT(gpio);
+	unsigned long flags;
+	u32 value;
+
+	if (gpio < 0 || gpio >= sfp->gc.ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	value = readl_relaxed(ie) | mask;
+	writel_relaxed(value, ie);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+}
+
+static void starfive_jh7110_aon_irq_ack(struct irq_data *d)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *ic = sfp->padctl_base + AON_GPIO_IC_REG;
+	u32 mask = BIT(gpio);
+	unsigned long flags;
+	u32 value;
+
+	if (gpio < 0 || gpio >= sfp->gc.ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	value = readl_relaxed(ic) & ~mask;
+	writel_relaxed(value, ic);
+	writel_relaxed(value | mask, ic);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+}
+
+static void starfive_jh7110_aon_irq_mask_ack(struct irq_data *d)
+{
+	struct starfive_pinctrl *sfp = starfive_from_irq_data(d);
+	irq_hw_number_t gpio = irqd_to_hwirq(d);
+	void __iomem *ie = sfp->padctl_base + AON_GPIO_IE_REG;
+	void __iomem *ic = sfp->padctl_base + AON_GPIO_IC_REG;
+	u32 mask = BIT(gpio);
+	unsigned long flags;
+	u32 value;
+
+	if (gpio < 0 || gpio >= sfp->gc.ngpio)
+		return;
+
+	raw_spin_lock_irqsave(&sfp->lock, flags);
+	value = readl_relaxed(ie) & ~mask;
+	writel_relaxed(value, ie);
+
+	value = readl_relaxed(ic) & ~mask;
+	writel_relaxed(value, ic);
+	writel_relaxed(value | mask, ic);
+	raw_spin_unlock_irqrestore(&sfp->lock, flags);
+}
+
+static struct irq_chip starfive_jh7110_aon_irqchip = {
+	.name		= "starfive_jh7110_aon-gpio",
+	.irq_ack	= starfive_jh7110_aon_irq_ack,
+	.irq_mask_ack	= starfive_jh7110_aon_irq_mask_ack,
+	.irq_set_type	= starfive_jh7110_aon_irq_set_type,
+	.irq_mask	= starfive_jh7110_aon_irq_mask,
+	.irq_unmask	= starfive_jh7110_aon_irq_unmask,
+};
+
+static int starfive_aon_add_pin_ranges(struct gpio_chip *gc)
+{
+	struct starfive_pinctrl *sfp = container_of(gc,
+			struct starfive_pinctrl, gc);
+
+	sfp->gpios.name = sfp->gc.label;
+	sfp->gpios.base = sfp->gc.base;
+	/*
+	 * sfp->gpios.pin_base depends on the chosen signal group
+	 * and is set in starfive_probe()
+	 */
+	sfp->gpios.npins = AON_GPIO_NUM;
+	sfp->gpios.gc = &sfp->gc;
+	pinctrl_add_gpio_range(sfp->pctl_dev, &sfp->gpios);
+	return 0;
+}
+
+static int starfive_jh7110_aon_gpio_register(struct platform_device *pdev,
+		struct starfive_pinctrl *pctl)
+{
+	struct device *dev = &pdev->dev;
+	int ret, ngpio;
+	int loop;
+
+	ngpio = AON_GPIO_NUM;
+
+	pctl->gc.direction_input = starfive_jh7110_aon_direction_input;
+	pctl->gc.direction_output = starfive_jh7110_aon_direction_output;
+	pctl->gc.get_direction = starfive_jh7110_aon_get_direction;
+	pctl->gc.get = starfive_jh7110_aon_get_value;
+	pctl->gc.set = starfive_jh7110_aon_set_value;
+	pctl->gc.add_pin_ranges = starfive_aon_add_pin_ranges;
+	pctl->gc.base = 64;
+	pctl->gc.ngpio = ngpio;
+	pctl->gc.label = dev_name(dev);
+	pctl->gc.parent = dev;
+	pctl->gc.owner = THIS_MODULE;
+
+	pctl->enabled = 0;
+
+	platform_set_drvdata(pdev, pctl);
+
+	starfive_jh7110_aon_irqchip.parent_device = dev;
+	starfive_jh7110_aon_irqchip.name = pctl->gc.label;
+
+	pctl->gc.irq.chip = &starfive_jh7110_aon_irqchip;
+	pctl->gc.irq.parent_handler = starfive_jh7110_aon_irq_handler;
+	pctl->gc.irq.num_parents = 1;
+	pctl->gc.irq.parents = devm_kcalloc(dev, pctl->gc.irq.num_parents,
+			sizeof(*pctl->gc.irq.parents), GFP_KERNEL);
+	if (!pctl->gc.irq.parents)
+		return -ENOMEM;
+	pctl->gc.irq.default_type = IRQ_TYPE_NONE;
+	pctl->gc.irq.handler = handle_bad_irq;
+	pctl->gc.irq.init_hw = starfive_jh7110_aon_init_hw;
+
+	if (IS_ENABLED(CONFIG_PM))
+		pm_runtime_enable(dev);
+
+	ret = platform_get_irq(pdev, 0);
+	if (ret < 0)
+		return ret;
+	pctl->gc.irq.parents[0] = ret;
+
+	ret = devm_gpiochip_add_data(dev, &pctl->gc, pctl);
+	if (ret)
+		return dev_err_probe(dev, ret, "could not register gpiochip\n");
+
+	for (loop = 0; loop < ngpio; loop++) {
+		unsigned int v;
+
+		v = readl_relaxed(pctl->padctl_base +
+				AON_GPIO_INPUT_ENABLE_REG + (loop << 2));
+		v |= 0x1;
+		writel_relaxed(v, pctl->padctl_base +
+				AON_GPIO_INPUT_ENABLE_REG + (loop << 2));
+	}
+
+	dev_info(dev, "SiFive GPIO chip registered %d GPIOs\n", ngpio);
+
+	return 0;
+}
+
+static const struct starfive_pinctrl_soc_info starfive_jh7110_aon_pinctrl_info = {
+	.pins = starfive_jh7110_aon_pinctrl_pads,
+	.npins = ARRAY_SIZE(starfive_jh7110_aon_pinctrl_pads),
+	.flags = 1,
+	.dout_reg_base = AON_GPO_DOUT_CFG_BASE_REG,
+	.doen_reg_base = AON_GPO_DOEN_CFG_BASE_REG,
+	.din_reg_base = AON_GPI_DIN_CFG_BASE_REG,
+	.starfive_pinconf_get = starfive_jh7110_pinconf_get,
+	.starfive_pinconf_set = starfive_jh7110_pinconf_set,
+	.starfive_pmx_set_one_pin_mux = starfive_jh7110_aon_pmx_set_one_pin_mux,
+	.starfive_gpio_register = starfive_jh7110_aon_gpio_register,
+	.starfive_pinctrl_parse_pin = starfive_jh7110_aon_parse_pin_config,
+};
+
+static const struct of_device_id starfive_jh7110_pinctrl_of_match[] = {
+	{
+		.compatible = "starfive,jh7110-sys-pinctrl",
+		.data = &starfive_jh7110_sys_pinctrl_info,
+	},
+	{
+		.compatible = "starfive,jh7110-aon-pinctrl",
+		.data = &starfive_jh7110_aon_pinctrl_info,
+	},
+	{ /* sentinel */ }
+};
+
+static int starfive_jh7110_pinctrl_probe(struct platform_device *pdev)
+{
+	const struct starfive_pinctrl_soc_info *pinctrl_info;
+
+	pinctrl_info = of_device_get_match_data(&pdev->dev);
+	if (!pinctrl_info)
+		return -ENODEV;
+
+	return starfive_pinctrl_probe(pdev, pinctrl_info);
+}
+
+static int __maybe_unused starfive_pinctrl_suspend(struct device *dev)
+{
+	struct starfive_pinctrl *pctl = dev_get_drvdata(dev);
+	u8 i;
+
+	for (i = 0 ; i < SYS_REG_SUSPENDED_NUM ; i++)
+		pctl->sys_reg_suspended[i] = readl_relaxed(pctl->padctl_base +
+							   SYS_GPO_DOEN_CFG_BASE_REG +
+							   OFFSET_PER_REG * i);
+
+	for (i = 0 ; i < AON_REG_SUSPENDED_NUM ; i++)
+		pctl->aon_reg_suspended[i] = readl_relaxed(pctl->padctl_base +
+							   AON_GPO_DOEN_CFG_BASE_REG +
+							   OFFSET_PER_REG * i);
+
+	return pinctrl_force_sleep(pctl->pctl_dev);
+}
+
+static int __maybe_unused starfive_pinctrl_resume(struct device *dev)
+{
+	struct starfive_pinctrl *pctl = dev_get_drvdata(dev);
+	u8 i;
+
+	for (i = 0 ; i < SYS_REG_SUSPENDED_NUM ; i++)
+		writel_relaxed(pctl->sys_reg_suspended[i],
+			       pctl->padctl_base + SYS_GPO_DOEN_CFG_BASE_REG + OFFSET_PER_REG * i);
+
+	for (i = 0 ; i < AON_REG_SUSPENDED_NUM ; i++)
+		writel_relaxed(pctl->aon_reg_suspended[i],
+			       pctl->padctl_base + AON_GPO_DOEN_CFG_BASE_REG + OFFSET_PER_REG * i);
+
+	return pinctrl_force_default(pctl->pctl_dev);
+}
+
+const struct dev_pm_ops starfive_pinctrl_pm_ops = {
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(starfive_pinctrl_suspend,
+				     starfive_pinctrl_resume)
+};
+
+static struct platform_driver starfive_jh7110_pinctrl_driver = {
+	.driver = {
+		.name = "starfive_jh7110-pinctrl",
+		.pm = &starfive_pinctrl_pm_ops,
+		.of_match_table = of_match_ptr(starfive_jh7110_pinctrl_of_match),
+	},
+	.probe = starfive_jh7110_pinctrl_probe,
+};
+
+static int __init starfive_jh7110_pinctrl_init(void)
+{
+	return platform_driver_register(&starfive_jh7110_pinctrl_driver);
+}
+arch_initcall(starfive_jh7110_pinctrl_init);
+
+MODULE_DESCRIPTION("Pinctrl driver for StarFive JH7110 SoC");
+MODULE_AUTHOR("jenny.zhang <jenny.zhang@starfivetech.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/starfive/pinctrl-starfive.c b/drivers/pinctrl/starfive/pinctrl-starfive.c
new file mode 100644
index 000000000000..dc2218a0af42
--- /dev/null
+++ b/drivers/pinctrl/starfive/pinctrl-starfive.c
@@ -0,0 +1,481 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Pinctrl / GPIO driver for StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 Shanghai StarFive Technology Co., Ltd.
+ */
+
+#include <linux/clk.h>
+#include <linux/gpio/driver.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/reset.h>
+
+#include "../core.h"
+#include "../pinctrl-utils.h"
+#include "../pinconf.h"
+#include "../pinmux.h"
+#include "pinctrl-starfive.h"
+
+
+static inline const struct group_desc *starfive_pinctrl_find_group_by_name(
+				struct pinctrl_dev *pctldev,
+				const char *name)
+{
+	const struct group_desc *grp = NULL;
+	int i;
+
+	for (i = 0; i < pctldev->num_groups; i++) {
+		grp = pinctrl_generic_get_group(pctldev, i);
+		if (grp && !strcmp(grp->name, name))
+			break;
+	}
+
+	return grp;
+}
+
+static void starfive_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,
+			unsigned int offset)
+{
+	seq_printf(s, "%s", dev_name(pctldev->dev));
+}
+
+static int starfive_dt_node_to_map(struct pinctrl_dev *pctldev,
+			struct device_node *np,
+			struct pinctrl_map **maps, unsigned int *num_maps)
+{
+	struct starfive_pinctrl *sfp = pinctrl_dev_get_drvdata(pctldev);
+	struct device *dev = sfp->gc.parent;
+	const struct starfive_pinctrl_soc_info *info = sfp->info;
+	struct starfive_pin *pin_data;
+	struct device_node *child;
+	struct pinctrl_map *map;
+	struct group_desc *grp;
+	const char **pgnames;
+	const char *grpname;
+	int ngroups;
+	int nmaps;
+	int ret;
+	int *pins_id;
+	int psize, pin_size;
+	int size = 0;
+	int offset = 0;
+	const __be32 *list;
+	int i, child_num_pins;
+
+	nmaps = 0;
+	ngroups = 0;
+	pin_size = STARFIVE_PINS_SIZE;
+
+	for_each_child_of_node(np, child) {
+		list = of_get_property(child, "starfive,pins", &psize);
+		if (!list) {
+			dev_err(sfp->dev,
+				"no starfive,pins and pins property in node %pOF\n", np);
+			return -EINVAL;
+		}
+		size += psize;
+	}
+
+	if (!size || size % pin_size) {
+		dev_err(sfp->dev,
+			"Invalid starfive,pins or pins property in node %pOF\n", np);
+		return -EINVAL;
+	}
+
+	nmaps = size / pin_size * 2;
+	ngroups = size / pin_size;
+
+	pgnames = devm_kcalloc(dev, ngroups, sizeof(*pgnames), GFP_KERNEL);
+	if (!pgnames)
+		return -ENOMEM;
+
+	map = kcalloc(nmaps, sizeof(*map), GFP_KERNEL);
+	if (!map)
+		return -ENOMEM;
+
+	grp = devm_kzalloc(sfp->dev, sizeof(struct group_desc),
+				   GFP_KERNEL);
+	if (!grp) {
+		of_node_put(child);
+		return -ENOMEM;
+	}
+
+	grp->data = devm_kcalloc(sfp->dev,
+				 ngroups, sizeof(struct starfive_pin),
+				 GFP_KERNEL);
+	grp->pins = devm_kcalloc(sfp->dev,
+				 ngroups, sizeof(int),
+				 GFP_KERNEL);
+	if (!grp->pins || !grp->data)
+		return -ENOMEM;
+
+	nmaps = 0;
+	ngroups = 0;
+	mutex_lock(&sfp->mutex);
+
+	for_each_child_of_node(np, child) {
+		grpname = devm_kasprintf(dev, GFP_KERNEL, "%pOFn.%pOFn", np, child);
+		if (!grpname) {
+			ret = -ENOMEM;
+			goto put_child;
+		}
+
+		pgnames[ngroups++] = grpname;
+
+		map[nmaps].type = PIN_MAP_TYPE_MUX_GROUP;
+		map[nmaps].data.mux.function = np->name;
+		map[nmaps].data.mux.group = grpname;
+		nmaps += 1;
+
+
+		list = of_get_property(child, "starfive,pins", &psize);
+		if (!list) {
+			dev_err(sfp->dev,
+				"no starfive,pins and pins property in node %pOF\n", np);
+			goto put_child;
+		}
+		child_num_pins = psize / pin_size;
+		grp->name = grpname;
+		grp->num_pins = child_num_pins;
+		for (i = 0; i < child_num_pins; i++) {
+			pin_data = &((struct starfive_pin *)(grp->data))[i + offset];
+			pins_id =  &(grp->pins)[i + offset];
+
+			if (!info->starfive_pinctrl_parse_pin) {
+				dev_err(sfp->dev,
+						"pinmux ops lacks necessary functions\n");
+				goto put_child;
+			}
+
+			info->starfive_pinctrl_parse_pin(sfp,
+					pins_id, pin_data, list, child);
+
+			map[nmaps].type = PIN_MAP_TYPE_CONFIGS_PIN;
+			map[nmaps].data.configs.group_or_pin =
+						pin_get_name(pctldev, pin_data->pin);
+			map[nmaps].data.configs.configs =
+						&pin_data->pin_config.io_config;
+			map[nmaps].data.configs.num_configs = 1;
+			nmaps += 1;
+
+			list++;
+		}
+		offset += i;
+
+		ret = pinctrl_generic_add_group(pctldev,
+				grpname, pins_id, child_num_pins, pin_data);
+		if (ret < 0) {
+			dev_err(dev, "error adding group %s: %d\n", grpname, ret);
+			goto put_child;
+		}
+	}
+
+	ret = pinmux_generic_add_function(pctldev, np->name, pgnames, ngroups, NULL);
+	if (ret < 0) {
+		dev_err(dev, "error adding function %s: %d\n", np->name, ret);
+		goto free_map;
+	}
+
+	*maps = map;
+	*num_maps = nmaps;
+	mutex_unlock(&sfp->mutex);
+	return 0;
+
+put_child:
+	of_node_put(child);
+free_map:
+	pinctrl_utils_free_map(pctldev, map, nmaps);
+	mutex_unlock(&sfp->mutex);
+	return ret;
+}
+
+static void starfive_dt_free_map(struct pinctrl_dev *pctldev,
+				struct pinctrl_map *map, unsigned int num_maps)
+{
+	kfree(map);
+}
+
+static const struct pinctrl_ops starfive_pctrl_ops = {
+	.get_groups_count = pinctrl_generic_get_group_count,
+	.get_group_name = pinctrl_generic_get_group_name,
+	.get_group_pins = pinctrl_generic_get_group_pins,
+	.pin_dbg_show = starfive_pin_dbg_show,
+	.dt_node_to_map = starfive_dt_node_to_map,
+	.dt_free_map = starfive_dt_free_map,
+};
+
+
+static int starfive_pmx_set(struct pinctrl_dev *pctldev, unsigned int selector,
+			unsigned int group)
+{
+	struct starfive_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+	struct function_desc *func;
+	struct group_desc *grp;
+	struct starfive_pin *pin;
+	unsigned int npins;
+	int i, err;
+
+	grp = pinctrl_generic_get_group(pctldev, group);
+	if (!grp)
+		return -EINVAL;
+
+	func = pinmux_generic_get_function(pctldev, selector);
+	if (!func)
+		return -EINVAL;
+
+	npins = grp->num_pins;
+
+	dev_dbg(pctl->dev, "enable function %s group %s\n",
+		func->name, grp->name);
+
+	for (i = 0; i < npins; i++) {
+		pin = &((struct starfive_pin *)(grp->data))[i];
+		if (info->starfive_pmx_set_one_pin_mux) {
+			err = info->starfive_pmx_set_one_pin_mux(pctl, pin);
+			if (err)
+				return err;
+		}
+	}
+
+	return 0;
+}
+
+const struct pinmux_ops starfive_pmx_ops = {
+	.get_functions_count = pinmux_generic_get_function_count,
+	.get_function_name = pinmux_generic_get_function_name,
+	.get_function_groups = pinmux_generic_get_function_groups,
+	.set_mux = starfive_pmx_set,
+};
+
+
+static int starfive_pinconf_get(struct pinctrl_dev *pctldev,
+				unsigned int pin_id, unsigned long *config)
+{
+	struct starfive_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+
+	if (info->starfive_pinconf_get)
+		return info->starfive_pinconf_get(pctldev, pin_id, config);
+
+	return 0;
+}
+
+static int starfive_pinconf_set(struct pinctrl_dev *pctldev,
+				unsigned int pin_id, unsigned long *configs,
+				unsigned int num_configs)
+{
+	struct starfive_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct starfive_pinctrl_soc_info *info = pctl->info;
+
+
+	if (info->starfive_pinconf_set)
+		return info->starfive_pinconf_set(pctldev, pin_id,
+				configs, num_configs);
+	return 0;
+}
+
+static void starfive_pinconf_dbg_show(struct pinctrl_dev *pctldev,
+				struct seq_file *s, unsigned int pin_id)
+{
+	struct starfive_pinctrl *pctl = pinctrl_dev_get_drvdata(pctldev);
+	const struct starfive_pin_reg *pin_reg;
+	unsigned long config;
+	int ret;
+
+	pin_reg = &pctl->pin_regs[pin_id];
+	if (pin_reg->io_conf_reg == -1) {
+		seq_puts(s, "N/A");
+		return;
+	}
+
+	ret = starfive_pinconf_get(pctldev, pin_id, &config);
+	if (ret)
+		return;
+	seq_printf(s, "0x%lx", config);
+}
+
+static void starfive_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,
+				struct seq_file *s, unsigned int group)
+{
+	struct group_desc *grp;
+	unsigned long config;
+	const char *name;
+	int i, ret;
+
+	if (group >= pctldev->num_groups)
+		return;
+
+	seq_puts(s, "\n");
+	grp = pinctrl_generic_get_group(pctldev, group);
+	if (!grp)
+		return;
+
+	for (i = 0; i < grp->num_pins; i++) {
+		struct starfive_pin *pin = &((struct starfive_pin *)(grp->data))[i];
+
+		name = pin_get_name(pctldev, pin->pin);
+		ret = starfive_pinconf_get(pctldev, pin->pin, &config);
+		if (ret)
+			return;
+		seq_printf(s, "  %s: 0x%lx\n", name, config);
+	}
+}
+
+static const struct pinconf_ops starfive_pinconf_ops = {
+	.pin_config_get = starfive_pinconf_get,
+	.pin_config_set = starfive_pinconf_set,
+	.pin_config_dbg_show = starfive_pinconf_dbg_show,
+	.pin_config_group_dbg_show = starfive_pinconf_group_dbg_show,
+};
+
+static void starfive_disable_clock(void *data)
+{
+	clk_disable_unprepare(data);
+}
+
+int starfive_pinctrl_probe(struct platform_device *pdev,
+		      const struct starfive_pinctrl_soc_info *info)
+{
+	struct device *dev = &pdev->dev;
+	struct pinctrl_desc *starfive_pinctrl_desc;
+	struct starfive_pinctrl *pctl;
+	struct resource *res;
+	struct reset_control *rst;
+	struct clk *clk;
+	int ret, i;
+	u32 value;
+
+	if (!info || !info->pins || !info->npins) {
+		dev_err(&pdev->dev, "wrong pinctrl info\n");
+		return -EINVAL;
+	}
+
+	pctl = devm_kzalloc(&pdev->dev, sizeof(*pctl), GFP_KERNEL);
+	if (!pctl)
+		return -ENOMEM;
+
+	pctl->pin_regs = devm_kmalloc_array(&pdev->dev, info->npins,
+					     sizeof(*pctl->pin_regs),
+					     GFP_KERNEL);
+	if (!pctl->pin_regs)
+		return -ENOMEM;
+
+	for (i = 0; i < info->npins; i++) {
+		pctl->pin_regs[i].io_conf_reg = -1;
+		pctl->pin_regs[i].gpo_dout_reg = -1;
+		pctl->pin_regs[i].gpo_doen_reg = -1;
+		pctl->pin_regs[i].func_sel_reg = -1;
+		pctl->pin_regs[i].syscon_reg = -1;
+		pctl->pin_regs[i].pad_sel_reg = -1;
+	}
+
+	pctl->padctl_base = devm_platform_ioremap_resource_byname(pdev, "control");
+	if (IS_ERR(pctl->padctl_base))
+		return PTR_ERR(pctl->padctl_base);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "gpio");
+	if (res) {
+		pctl->gpio_base = devm_ioremap_resource(dev, res);
+		if (IS_ERR(pctl->gpio_base))
+			return PTR_ERR(pctl->gpio_base);
+	}
+
+	clk = devm_clk_get_optional(dev, NULL);
+	if (IS_ERR(clk))
+		return dev_err_probe(dev, PTR_ERR(clk), "could not get clock\n");
+
+	rst = devm_reset_control_get_exclusive(dev, NULL);
+	if (IS_ERR(rst))
+		return dev_err_probe(dev, PTR_ERR(rst), "could not get reset\n");
+
+	if (clk) {
+		ret = clk_prepare_enable(clk);
+		if (ret)
+			return dev_err_probe(dev, ret, "could not enable clock\n");
+
+		ret = devm_add_action_or_reset(dev, starfive_disable_clock, clk);
+		if (ret)
+			return ret;
+	}
+
+	/*
+	 * We don't want to assert reset and risk undoing pin muxing for the
+	 * early boot serial console, but let's make sure the reset line is
+	 * deasserted in case someone runs a really minimal bootloader.
+	 */
+	ret = reset_control_deassert(rst);
+	if (ret)
+		return dev_err_probe(dev, ret, "could not deassert reset\n");
+
+	if (info->starfive_iopad_sel_func) {
+		ret = info->starfive_iopad_sel_func(pdev, pctl, value);
+		if (ret)
+			return ret;
+	}
+
+	starfive_pinctrl_desc = devm_kzalloc(&pdev->dev, sizeof(*starfive_pinctrl_desc),
+					GFP_KERNEL);
+	if (!starfive_pinctrl_desc)
+		return -ENOMEM;
+
+	raw_spin_lock_init(&pctl->lock);
+
+	starfive_pinctrl_desc->name = dev_name(&pdev->dev);
+	starfive_pinctrl_desc->pins = info->pins;
+	starfive_pinctrl_desc->npins = info->npins;
+	starfive_pinctrl_desc->pctlops = &starfive_pctrl_ops;
+	starfive_pinctrl_desc->pmxops = &starfive_pmx_ops;
+	starfive_pinctrl_desc->confops = &starfive_pinconf_ops;
+	starfive_pinctrl_desc->owner = THIS_MODULE;
+
+	mutex_init(&pctl->mutex);
+
+	pctl->info = info;
+	pctl->dev = &pdev->dev;
+	platform_set_drvdata(pdev, pctl);
+	pctl->gc.parent = dev;
+	ret = devm_pinctrl_register_and_init(&pdev->dev,
+					     starfive_pinctrl_desc, pctl,
+					     &pctl->pctl_dev);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"could not register starfive pinctrl driver\n");
+		return ret;
+	}
+
+	ret = pinctrl_enable(pctl->pctl_dev);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"pin controller failed to start\n");
+		return ret;
+	}
+
+	if (info->starfive_gpio_register) {
+		ret = info->starfive_gpio_register(pdev, pctl);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"starfive_gpio_register failed to register\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(starfive_pinctrl_probe);
+
+MODULE_DESCRIPTION("Pinctrl driver for StarFive JH7110 SoC");
+MODULE_AUTHOR("jenny.zhang <jenny.zhang@starfivetech.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/starfive/pinctrl-starfive.h b/drivers/pinctrl/starfive/pinctrl-starfive.h
new file mode 100644
index 000000000000..19539b814128
--- /dev/null
+++ b/drivers/pinctrl/starfive/pinctrl-starfive.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Pinctrl / GPIO driver for StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 Shanghai StarFive Technology Co., Ltd.
+ */
+
+#ifndef __DRIVERS_PINCTRL_STARFIVE_H
+#define __DRIVERS_PINCTRL_STARFIVE_H
+
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/pinctrl/pinmux.h>
+
+#define MAX_GPIO				64
+
+#define STARFIVE_PINS_SIZE			4
+
+#define STARFIVE_USE_SCU			BIT(0)
+
+#define SYS_REG_SUSPENDED_NUM			174
+#define AON_REG_SUSPENDED_NUM			37
+
+struct platform_device;
+
+extern const struct pinmux_ops starfive_pmx_ops;
+
+struct starfive_pin_config {
+	unsigned long io_config;
+	u32 pinmux_func;
+	u32 gpio_num;
+	u32 gpio_dout;
+	u32 gpio_doen;
+	u32 gpio_din_num;
+	s32 *gpio_din_reg;
+	s32 syscon;
+	s32 padmux_func;
+};
+
+struct starfive_pin {
+	unsigned int pin;
+	struct starfive_pin_config pin_config;
+};
+
+struct starfive_pin_reg {
+	s32 io_conf_reg;
+	s32 gpo_dout_reg;
+	s32 gpo_doen_reg;
+	s32 func_sel_reg;
+	s32 func_sel_shift;
+	s32 func_sel_mask;
+	s32 syscon_reg;
+	s32 pad_sel_reg;
+	s32 pad_sel_shift;
+	s32 pad_sel_mask;
+};
+
+struct starfive_iopad_sel_func_inf {
+	unsigned int padctl_gpio_base;
+	unsigned int padctl_gpio0;
+};
+
+struct starfive_pinctrl {
+	struct device *dev;
+	struct pinctrl_dev *pctl_dev;
+	void __iomem *padctl_base;
+	void __iomem *gpio_base;
+	unsigned int padctl_gpio_base;
+	unsigned int padctl_gpio0;
+	const struct starfive_pinctrl_soc_info *info;
+	struct starfive_pin_reg *pin_regs;
+	unsigned int group_index;
+
+	struct mutex mutex;
+	raw_spinlock_t lock;
+
+	struct gpio_chip gc;
+	struct pinctrl_gpio_range gpios;
+	unsigned long enabled;
+	unsigned int trigger[MAX_GPIO];
+
+	u32 sys_reg_suspended[SYS_REG_SUSPENDED_NUM];
+	u32 aon_reg_suspended[AON_REG_SUSPENDED_NUM];
+};
+
+struct starfive_pinctrl_soc_info {
+	const struct pinctrl_pin_desc *pins;
+	unsigned int npins;
+	unsigned int flags;
+
+	/*gpio dout/doen/din register*/
+	unsigned int dout_reg_base;
+	unsigned int dout_reg_offset;
+	unsigned int doen_reg_base;
+	unsigned int doen_reg_offset;
+	unsigned int din_reg_base;
+	unsigned int din_reg_offset;
+
+	/* sel-function */
+	int (*starfive_iopad_sel_func)(struct platform_device *pdev,
+					struct starfive_pinctrl *ipctl,
+					unsigned int func_id);
+	/* generic pinconf */
+	int (*starfive_pinconf_get)(struct pinctrl_dev *pctldev, unsigned int pin_id,
+			       unsigned long *config);
+	int (*starfive_pinconf_set)(struct pinctrl_dev *pctldev,
+				unsigned int pin_id, unsigned long *configs,
+				unsigned int num_configs);
+
+	/* generic pinmux */
+	int (*starfive_pmx_set_one_pin_mux)(struct starfive_pinctrl *ipctl,
+				struct starfive_pin *pin);
+	/* gpio chip */
+	int (*starfive_gpio_register)(struct platform_device *pdev,
+				struct starfive_pinctrl *ipctl);
+	void (*starfive_pinctrl_parse_pin)(struct starfive_pinctrl *ipctl,
+					unsigned int *pins_id, struct starfive_pin *pin_data,
+					const __be32 *list_p,
+					struct device_node *np);
+};
+
+#define	STARFIVE_PINCTRL_PIN(pin) PINCTRL_PIN(pin, #pin)
+
+int starfive_pinctrl_probe(struct platform_device *pdev,
+			const struct starfive_pinctrl_soc_info *info);
+
+#endif /* __DRIVERS_PINCTRL_STARFIVE_H */
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 63be5362fd3a..4f36bcd18c2a 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -428,6 +428,16 @@ config PWM_SIFIVE
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-sifive.
 
+config PWM_STARFIVE_PTC
+	tristate "Starfive PWM PTC support"
+	depends on OF
+	depends on COMMON_CLK
+	help
+	  Generic PWM framework driver for Starfive SoCs.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-starfive-ptc.
+
 config PWM_SL28CPLD
 	tristate "Kontron sl28cpld PWM support"
 	depends on MFD_SL28CPLD || COMPILE_TEST
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index cbdcd55d69ee..64256fc7c70e 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -40,6 +40,7 @@ obj-$(CONFIG_PWM_RENESAS_TPU)	+= pwm-renesas-tpu.o
 obj-$(CONFIG_PWM_ROCKCHIP)	+= pwm-rockchip.o
 obj-$(CONFIG_PWM_SAMSUNG)	+= pwm-samsung.o
 obj-$(CONFIG_PWM_SIFIVE)	+= pwm-sifive.o
+obj-$(CONFIG_PWM_STARFIVE_PTC)  += pwm-starfive-ptc.o
 obj-$(CONFIG_PWM_SL28CPLD)	+= pwm-sl28cpld.o
 obj-$(CONFIG_PWM_SPEAR)		+= pwm-spear.o
 obj-$(CONFIG_PWM_SPRD)		+= pwm-sprd.o
diff --git a/drivers/pwm/pwm-starfive-ptc.c b/drivers/pwm/pwm-starfive-ptc.c
new file mode 100644
index 000000000000..0874bbb49aa6
--- /dev/null
+++ b/drivers/pwm/pwm-starfive-ptc.c
@@ -0,0 +1,314 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * PWM driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2018 StarFive Technology Co., Ltd.
+ */
+
+#include <dt-bindings/pwm/pwm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/io.h>
+
+/* how many parameters can be transferred to ptc */
+#define OF_PWM_N_CELLS			3
+
+/* max channel of pwm */
+#define MAX_PWM				8
+
+/* PTC Register offsets */
+#define REG_RPTC_CNTR			0x0
+#define REG_RPTC_HRC			0x4
+#define REG_RPTC_LRC			0x8
+#define REG_RPTC_CTRL			0xC
+
+/* Bit for PWM clock */
+#define BIT_PWM_CLOCK_EN		31
+
+/* Bit for clock gen soft reset */
+#define BIT_CLK_GEN_SOFT_RESET		13
+
+#define NS_PER_SECOND			1000000000
+#define DEFAULT_FREQ_HZ			2000000
+
+/*
+ * Access PTC register (cntr hrc lrc and ctrl),
+ * need to replace PWM_BASE_ADDR
+ */
+#define REG_PTC_BASE_ADDR_SUB(base, N)	\
+((base) + (((N) > 3) ? (((N) % 4) * 0x10 + (1 << 15)) : ((N) * 0x10)))
+#define REG_PTC_RPTC_CNTR(base, N)	(REG_PTC_BASE_ADDR_SUB(base, N))
+#define REG_PTC_RPTC_HRC(base, N)	(REG_PTC_BASE_ADDR_SUB(base, N) + 0x4)
+#define REG_PTC_RPTC_LRC(base, N)	(REG_PTC_BASE_ADDR_SUB(base, N) + 0x8)
+#define REG_PTC_RPTC_CTRL(base, N)	(REG_PTC_BASE_ADDR_SUB(base, N) + 0xC)
+
+/* PTC_RPTC_CTRL */
+#define PTC_EN      BIT(0)
+#define PTC_ECLK    BIT(1)
+#define PTC_NEC     BIT(2)
+#define PTC_OE      BIT(3)
+#define PTC_SIGNLE  BIT(4)
+#define PTC_INTE    BIT(5)
+#define PTC_INT     BIT(6)
+#define PTC_CNTRRST BIT(7)
+#define PTC_CAPTE   BIT(8)
+
+struct starfive_pwm_ptc_device {
+	struct pwm_chip		chip;
+	struct clk		*clk;
+	struct reset_control	*rst;
+	void __iomem		*regs;
+	int			irq;
+	/*pwm apb clock frequency*/
+	unsigned int		approx_freq;
+};
+
+static inline struct starfive_pwm_ptc_device *
+		chip_to_starfive_ptc(struct pwm_chip *c)
+{
+	return container_of(c, struct starfive_pwm_ptc_device, chip);
+}
+
+static void starfive_pwm_ptc_get_state(struct pwm_chip *chip,
+				       struct pwm_device *dev,
+				       struct pwm_state *state)
+{
+	struct starfive_pwm_ptc_device *pwm = chip_to_starfive_ptc(chip);
+	u32 data_lrc, data_hrc, data_ctrl;
+	u32 pwm_clk_ns = 0;
+
+	pm_runtime_get_sync(chip->dev);
+
+	data_lrc = ioread32(REG_PTC_RPTC_LRC(pwm->regs, dev->hwpwm));
+	data_hrc = ioread32(REG_PTC_RPTC_HRC(pwm->regs, dev->hwpwm));
+	data_ctrl = ioread32(REG_PTC_RPTC_CTRL(pwm->regs, dev->hwpwm));
+
+	pwm_clk_ns = NS_PER_SECOND / pwm->approx_freq;
+
+	state->period = data_lrc * pwm_clk_ns;
+	state->duty_cycle = data_hrc * pwm_clk_ns;
+	state->polarity = PWM_POLARITY_NORMAL;
+	state->enabled = (data_ctrl & PTC_EN) ? true : false;
+
+	pm_runtime_put(chip->dev);
+}
+
+static int starfive_pwm_ptc_apply(struct pwm_chip *chip,
+				  struct pwm_device *dev,
+				  struct pwm_state *state)
+{
+	struct starfive_pwm_ptc_device *pwm = chip_to_starfive_ptc(chip);
+	u32 data_hrc = 0;
+	u32 data_lrc = 0;
+	u32 period_data = 0;
+	u32 duty_data = 0;
+	s64 multi = pwm->approx_freq;
+	s64 div = NS_PER_SECOND;
+	void __iomem *reg_addr;
+	u32 val;
+
+	if (state->enabled) {
+		if (!pwm_is_enabled(dev)) {
+			pm_runtime_get_sync(chip->dev);
+			reg_addr = REG_PTC_RPTC_CTRL(pwm->regs, dev->hwpwm);
+			val = ioread32(reg_addr);
+			iowrite32(val | PTC_EN | PTC_OE, reg_addr);
+		}
+	} else if (pwm_is_enabled(dev)) {
+		reg_addr = REG_PTC_RPTC_CTRL(pwm->regs, dev->hwpwm);
+		val = ioread32(reg_addr);
+		iowrite32(val & ~(PTC_EN | PTC_OE), reg_addr);
+		pm_runtime_put(chip->dev);
+		return 0;
+	} else {
+		return 0;
+	}
+
+	if (state->duty_cycle > state->period)
+		state->duty_cycle = state->period;
+
+	while (multi % 10 == 0 && div % 10 == 0 && multi > 0 && div > 0) {
+		multi /= 10;
+		div /= 10;
+	}
+
+	period_data = (u32)(state->period * multi / div);
+	if (abs(period_data * div / multi - state->period)
+	    > abs((period_data + 1) * div / multi - state->period) ||
+	    (state->period > 0 && period_data == 0))
+		period_data += 1;
+
+	duty_data = (u32)(state->duty_cycle * multi / div);
+	if (abs(duty_data * div / multi - state->duty_cycle)
+	    > abs((duty_data + 1) * div / multi - state->duty_cycle) ||
+	    (state->duty_cycle > 0 && duty_data == 0))
+		duty_data += 1;
+
+	if (state->polarity == PWM_POLARITY_NORMAL)
+		data_hrc = period_data - duty_data;
+	else
+		data_hrc = duty_data;
+
+	data_lrc = period_data;
+
+	reg_addr = REG_PTC_RPTC_HRC(pwm->regs, dev->hwpwm);
+	iowrite32(data_hrc, reg_addr);
+
+	reg_addr = REG_PTC_RPTC_LRC(pwm->regs, dev->hwpwm);
+	iowrite32(data_lrc, reg_addr);
+
+	reg_addr = REG_PTC_RPTC_CNTR(pwm->regs, dev->hwpwm);
+	iowrite32(0, reg_addr);
+
+	return 0;
+}
+
+static const struct pwm_ops starfive_pwm_ptc_ops = {
+	.get_state	= starfive_pwm_ptc_get_state,
+	.apply		= (void *)starfive_pwm_ptc_apply,
+	.owner		= THIS_MODULE,
+};
+
+static int starfive_pwm_ptc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = pdev->dev.of_node;
+	struct starfive_pwm_ptc_device *pwm;
+	struct pwm_chip *chip;
+	struct resource *res;
+	unsigned int clk_apb_freq;
+	int ret;
+
+	pwm = devm_kzalloc(dev, sizeof(*pwm), GFP_KERNEL);
+	if (!pwm)
+		return -ENOMEM;
+
+	chip = &pwm->chip;
+	chip->dev = dev;
+	chip->ops = &starfive_pwm_ptc_ops;
+
+	chip->of_pwm_n_cells = OF_PWM_N_CELLS;
+	chip->base = -1;
+
+	ret = of_property_read_u32(node, "starfive,npwm", &chip->npwm);
+	if (ret < 0 || chip->npwm > MAX_PWM)
+		chip->npwm = MAX_PWM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pwm->regs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(pwm->regs)) {
+		dev_err(dev, "Unable to map IO resources\n");
+		return PTR_ERR(pwm->regs);
+	}
+
+	pwm->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(pwm->clk)) {
+		dev_err(dev, "Unable to get pwm clock\n");
+		return PTR_ERR(pwm->clk);
+	}
+	pwm->rst = devm_reset_control_get_exclusive(dev, NULL);
+	if (IS_ERR(pwm->rst)) {
+		dev_err(dev, "Unable to get pwm reset\n");
+		return PTR_ERR(pwm->rst);
+	}
+
+	ret = of_property_read_u32(node, "starfive,approx-freq",
+				   &clk_apb_freq);
+	if (!ret)
+		pwm->approx_freq = clk_apb_freq;
+	else
+		pwm->approx_freq = DEFAULT_FREQ_HZ;
+
+	clk_apb_freq = (unsigned int)clk_get_rate(pwm->clk);
+	if (!clk_apb_freq)
+		dev_warn(dev,
+			 "get pwm apb clock rate failed.\n");
+	else
+		pwm->approx_freq = clk_apb_freq;
+
+	ret = pwmchip_add(chip);
+	if (ret < 0) {
+		dev_err(dev, "cannot register PTC: %d\n", ret);
+		clk_disable_unprepare(pwm->clk);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, pwm);
+
+	pm_runtime_enable(dev);
+
+	return 0;
+}
+
+static int starfive_pwm_ptc_remove(struct platform_device *dev)
+{
+	struct starfive_pwm_ptc_device *pwm = platform_get_drvdata(dev);
+	struct pwm_chip *chip = &pwm->chip;
+
+	pwmchip_remove(chip);
+
+	pm_runtime_force_suspend(&dev->dev);
+
+	return 0;
+}
+
+#if defined(CONFIG_PM) || defined(CONFIG_PM_SLEEP)
+static int __maybe_unused starfive_pwm_runtime_suspend(struct device *dev)
+{
+	struct starfive_pwm_ptc_device *pwm = dev_get_drvdata(dev);
+
+	dev_dbg(dev, "starfive pwm runtime suspending..");
+	reset_control_assert(pwm->rst);
+	clk_disable_unprepare(pwm->clk);
+
+	return 0;
+}
+
+static int __maybe_unused starfive_pwm_runtime_resume(struct device *dev)
+{
+	struct starfive_pwm_ptc_device *pwm = dev_get_drvdata(dev);
+	int ret;
+
+	dev_dbg(dev, "starfive pwm runtime resuming..");
+	ret = clk_prepare_enable(pwm->clk);
+	if (ret)
+		dev_err(dev,
+			"Failed to resume pwm clock, %d\n", ret);
+	reset_control_deassert(pwm->rst);
+	return ret;
+}
+#endif
+
+static const struct dev_pm_ops starfive_pwm_pm_ops = {
+	SET_RUNTIME_PM_OPS(starfive_pwm_runtime_suspend,
+			   starfive_pwm_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+				pm_runtime_force_resume)
+};
+
+static const struct of_device_id starfive_pwm_ptc_of_match[] = {
+	{ .compatible = "starfive,jh7110-pwm" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, starfive_pwm_ptc_of_match);
+
+static struct platform_driver starfive_pwm_ptc_driver = {
+	.probe = starfive_pwm_ptc_probe,
+	.remove = starfive_pwm_ptc_remove,
+	.driver = {
+		.name = "pwm-starfive-ptc",
+		.of_match_table = of_match_ptr(starfive_pwm_ptc_of_match),
+		.pm = &starfive_pwm_pm_ops,
+	},
+};
+module_platform_driver(starfive_pwm_ptc_driver);
+
+MODULE_AUTHOR("Jenny Zhang <jenny.zhang@starfivetech.com>");
+MODULE_AUTHOR("Hal Feng <hal.feng@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive PWM PTC driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
index 020a00d6696b..f91eb45e8fb7 100644
--- a/drivers/regulator/Kconfig
+++ b/drivers/regulator/Kconfig
@@ -999,6 +999,16 @@ config REGULATOR_SLG51000
 	  The SLG51000 is seven compact and customizable low dropout
 	  regulators.
 
+config REGULATOR_STARFIVE_JH7110
+	tristate "Starfive JH7110 PMIC"
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  Say y here to select this option to enable the power regulator of
+	  Starfive JH7110 PMIC.
+	  This driver supports the control of different power rails of device
+	  through regulator interface.
+
 config REGULATOR_STM32_BOOSTER
 	tristate "STMicroelectronics STM32 BOOSTER"
 	depends on ARCH_STM32 || COMPILE_TEST
diff --git a/drivers/regulator/Makefile b/drivers/regulator/Makefile
index 6ebae516258e..e60f20238dc5 100644
--- a/drivers/regulator/Makefile
+++ b/drivers/regulator/Makefile
@@ -123,6 +123,7 @@ obj-$(CONFIG_REGULATOR_S5M8767) += s5m8767.o
 obj-$(CONFIG_REGULATOR_SC2731) += sc2731-regulator.o
 obj-$(CONFIG_REGULATOR_SKY81452) += sky81452-regulator.o
 obj-$(CONFIG_REGULATOR_SLG51000) += slg51000-regulator.o
+obj-$(CONFIG_REGULATOR_STARFIVE_JH7110) += starfive-jh7110-regulator.o
 obj-$(CONFIG_REGULATOR_STM32_BOOSTER) += stm32-booster.o
 obj-$(CONFIG_REGULATOR_STM32_VREFBUF) += stm32-vrefbuf.o
 obj-$(CONFIG_REGULATOR_STM32_PWR) += stm32-pwr.o
diff --git a/drivers/regulator/starfive-jh7110-regulator.c b/drivers/regulator/starfive-jh7110-regulator.c
new file mode 100644
index 000000000000..b6cace268674
--- /dev/null
+++ b/drivers/regulator/starfive-jh7110-regulator.c
@@ -0,0 +1,126 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2022 Starfive Technology Co., Ltd.
+ * Author: Mason Huo <mason.huo@starfivetech.com>
+ */
+
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/regulator/jh7110.h>
+#include <linux/slab.h>
+
+#define JH7110_PM_POWER_SW_0		0x80
+#define JH7110_PM_POWER_SW_1		0x81
+#define ENABLE_MASK(id)			BIT(id)
+
+
+static const struct regmap_config jh7110_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = JH7110_PM_POWER_SW_1,
+	.cache_type = REGCACHE_FLAT,
+};
+
+static const struct regulator_ops jh7110_ldo_ops = {
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
+};
+
+#define JH7110_LDO(_id, _name, en_reg, en_mask) \
+{\
+	.name = (_name),\
+	.ops = &jh7110_ldo_ops,\
+	.of_match = of_match_ptr(_name),\
+	.regulators_node = of_match_ptr("regulators"),\
+	.type = REGULATOR_VOLTAGE,\
+	.id = JH7110_ID_##_id,\
+	.owner = THIS_MODULE,\
+	.enable_reg = JH7110_PM_POWER_SW_##en_reg,\
+	.enable_mask = ENABLE_MASK(en_mask),\
+}
+
+static const struct regulator_desc jh7110_regulators[] = {
+	JH7110_LDO(LDO_REG1, "hdmi_1p8", 0, 0),
+	JH7110_LDO(LDO_REG2, "mipitx_1p8", 0, 1),
+	JH7110_LDO(LDO_REG3, "mipirx_1p8", 0, 2),
+	JH7110_LDO(LDO_REG4, "hdmi_0p9", 0, 3),
+	JH7110_LDO(LDO_REG5, "mipitx_0p9", 0, 4),
+	JH7110_LDO(LDO_REG6, "mipirx_0p9", 0, 5),
+	JH7110_LDO(LDO_REG7, "sdio_vdd", 1, 0),
+};
+
+static int jh7110_i2c_probe(struct i2c_client *i2c)
+{
+	struct regulator_config config = { };
+	struct regulator_dev *rdev;
+	struct regulator_init_data *init_data;
+	struct regmap *regmap;
+	int i, ret;
+
+	regmap = devm_regmap_init_i2c(i2c, &jh7110_regmap_config);
+	if (IS_ERR(regmap)) {
+		ret = PTR_ERR(regmap);
+		dev_err(&i2c->dev, "Failed to allocate register map: %d\n",
+			ret);
+		return ret;
+	}
+
+	init_data = of_get_regulator_init_data(&i2c->dev, i2c->dev.of_node, NULL);
+	if (!init_data)
+		return -ENOMEM;
+	config.init_data = init_data;
+
+	for (i = 0; i < JH7110_MAX_REGULATORS; i++) {
+		config.dev = &i2c->dev;
+		config.regmap = regmap;
+
+		rdev = devm_regulator_register(&i2c->dev,
+			&jh7110_regulators[i], &config);
+		if (IS_ERR(rdev)) {
+			dev_err(&i2c->dev,
+				"Failed to register JH7110 regulator\n");
+			return PTR_ERR(rdev);
+		}
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id jh7110_i2c_id[] = {
+	{"jh7110_evb_reg", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, jh7110_i2c_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id jh7110_dt_ids[] = {
+	{ .compatible = "starfive,jh7110-evb-regulator",
+	  .data = &jh7110_i2c_id[0] },
+	{},
+};
+MODULE_DEVICE_TABLE(of, jh7110_dt_ids);
+#endif
+
+static struct i2c_driver jh7110_regulator_driver = {
+	.driver = {
+		.name = "jh7110-evb-regulator",
+		.of_match_table = of_match_ptr(jh7110_dt_ids),
+	},
+	.probe_new = jh7110_i2c_probe,
+	.id_table = jh7110_i2c_id,
+};
+
+module_i2c_driver(jh7110_regulator_driver);
+
+MODULE_AUTHOR("Mason Huo <mason.huo@starfivetech.com>");
+MODULE_DESCRIPTION("Regulator device driver for Starfive JH7110");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index 147543ad303f..7dd5bd7ed68f 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -247,6 +247,7 @@ config RESET_ZYNQ
 	help
 	  This enables the reset controller driver for Xilinx Zynq SoCs.
 
+source "drivers/reset/starfive/Kconfig"
 source "drivers/reset/sti/Kconfig"
 source "drivers/reset/hisilicon/Kconfig"
 source "drivers/reset/tegra/Kconfig"
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index 16947610cc3b..dc7ffc10f43f 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-y += core.o
 obj-y += hisilicon/
+obj-y += starfive/
 obj-$(CONFIG_ARCH_STI) += sti/
 obj-$(CONFIG_ARCH_TEGRA) += tegra/
 obj-$(CONFIG_RESET_A10SR) += reset-a10sr.o
diff --git a/drivers/reset/starfive/Kconfig b/drivers/reset/starfive/Kconfig
new file mode 100644
index 000000000000..734b327201e1
--- /dev/null
+++ b/drivers/reset/starfive/Kconfig
@@ -0,0 +1,6 @@
+config RESET_STARFIVE_JH7110
+	bool "StarFive JH7110 Reset Driver"
+	depends on SOC_STARFIVE || COMPILE_TEST
+	default SOC_STARFIVE
+	help
+	  This enables the reset controller driver for the StarFive JH7110 SoC.
diff --git a/drivers/reset/starfive/Makefile b/drivers/reset/starfive/Makefile
new file mode 100644
index 000000000000..a5b06a2cac87
--- /dev/null
+++ b/drivers/reset/starfive/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_RESET_STARFIVE_JH7110) += reset-starfive-jh7110.o
diff --git a/drivers/reset/starfive/reset-starfive-jh7110.c b/drivers/reset/starfive/reset-starfive-jh7110.c
new file mode 100644
index 000000000000..aa1145f4ef27
--- /dev/null
+++ b/drivers/reset/starfive/reset-starfive-jh7110.c
@@ -0,0 +1,273 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Reset driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2021 samin <samin.guo@starfivetech.com>
+ */
+
+#include <linux/bitmap.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/spinlock.h>
+
+#include <dt-bindings/reset/starfive-jh7110.h>
+
+/* register offsets */
+#define AONCRG_RESET_ASSERT	0x38
+#define ISPCRG_RESET_ASSERT	0x38
+#define VOUTCRG_RESET_ASSERT	0x48
+#define STGCRG_RESET_ASSERT	0x74
+#define AONCRG_RESET_STATUS	0x3C
+#define ISPCRG_RESET_STATUS	0x3C
+#define VOUTCRG_RESET_STATUS	0x4C
+#define STGCRG_RESET_STATUS	0x78
+
+#define SYSCRG_RESET_ASSERT0	0x2F8
+#define SYSCRG_RESET_ASSERT1	0x2FC
+#define SYSCRG_RESET_ASSERT2	0x300
+#define SYSCRG_RESET_ASSERT3	0x304
+#define SYSCRG_RESET_STATUS0	0x308
+#define SYSCRG_RESET_STATUS1	0x30C
+#define SYSCRG_RESET_STATUS2	0x310
+#define SYSCRG_RESET_STATUS3	0x314
+
+struct reset_assert_t {
+	void *__iomem reg_assert;
+	void *__iomem reg_status;
+};
+
+enum JH7110_RESET_CRG_GROUP {
+	SYSCRG_0 = 0,
+	SYSCRG_1,
+	SYSCRG_2,
+	SYSCRG_3,
+	STGCRG,
+	AONCRG,
+	ISPCRG,
+	VOUTCRG,
+};
+
+struct jh7110_reset {
+	struct reset_controller_dev rcdev;
+	/* protect registers against concurrent read-modify-write */
+	spinlock_t lock;
+	void __iomem *syscrg;
+	void __iomem *stgcrg;
+	void __iomem *aoncrg;
+	void __iomem *ispcrg;
+	void __iomem *voutcrg;
+};
+
+static inline struct jh7110_reset *
+jh7110_reset_from(struct reset_controller_dev *rcdev)
+{
+	return container_of(rcdev, struct jh7110_reset, rcdev);
+}
+
+static int jh7110_get_reset(struct jh7110_reset *data,
+				struct reset_assert_t *reset,
+				unsigned long group)
+{
+	switch (group) {
+	case SYSCRG_0:
+		reset->reg_assert = data->syscrg + SYSCRG_RESET_ASSERT0;
+		reset->reg_status = data->syscrg + SYSCRG_RESET_STATUS0;
+		break;
+	case SYSCRG_1:
+		reset->reg_assert = data->syscrg + SYSCRG_RESET_ASSERT1;
+		reset->reg_status = data->syscrg + SYSCRG_RESET_STATUS1;
+		break;
+	case SYSCRG_2:
+		reset->reg_assert = data->syscrg + SYSCRG_RESET_ASSERT2;
+		reset->reg_status = data->syscrg + SYSCRG_RESET_STATUS2;
+		break;
+	case SYSCRG_3:
+		reset->reg_assert = data->syscrg + SYSCRG_RESET_ASSERT3;
+		reset->reg_status = data->syscrg + SYSCRG_RESET_STATUS3;
+		break;
+	case STGCRG:
+		reset->reg_assert = data->stgcrg + STGCRG_RESET_ASSERT;
+		reset->reg_status = data->stgcrg + STGCRG_RESET_STATUS;
+		break;
+	case AONCRG:
+		reset->reg_assert = data->aoncrg + AONCRG_RESET_ASSERT;
+		reset->reg_status = data->aoncrg + AONCRG_RESET_STATUS;
+		break;
+	case ISPCRG:
+		reset->reg_assert = data->ispcrg + ISPCRG_RESET_ASSERT;
+		reset->reg_status = data->ispcrg + ISPCRG_RESET_STATUS;
+		break;
+	case VOUTCRG:
+		reset->reg_assert = data->voutcrg + VOUTCRG_RESET_ASSERT;
+		reset->reg_status = data->voutcrg + VOUTCRG_RESET_STATUS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int jh7110_reset_update(struct reset_controller_dev *rcdev,
+			       unsigned long id, bool assert)
+{
+	struct jh7110_reset *data = jh7110_reset_from(rcdev);
+	struct reset_assert_t reset;
+	void __iomem *reg_assert, *reg_status;
+	unsigned long group, flags;
+	u32 mask, value, done = 0;
+	int ret;
+
+	group = id / 32;
+	mask =  BIT(id % 32);
+	jh7110_get_reset(data, &reset, group);
+	reg_assert = reset.reg_assert;
+	reg_status = reset.reg_status;
+
+	if (!assert)
+		done ^= mask;
+
+	spin_lock_irqsave(&data->lock, flags);
+
+	value = readl(reg_assert);
+	if (assert)
+		value |= mask;
+	else
+		value &= ~mask;
+	writel(value, reg_assert);
+
+	/* if the associated clock is gated, deasserting might otherwise hang forever */
+	ret = readl_poll_timeout_atomic(reg_status, value, (value & mask) == done, 0, 1000);
+	if (ret)
+		dev_warn(rcdev->dev, "id:%ld group:%ld, mask:%#x assert:%#llx status:%#llx ret:%d\n",
+				id, group, mask, (u64)reg_assert, (u64)reg_status, ret);
+
+	spin_unlock_irqrestore(&data->lock, flags);
+	return ret;
+}
+
+static int jh7110_reset_assert(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	return jh7110_reset_update(rcdev, id, true);
+}
+
+static int jh7110_reset_deassert(struct reset_controller_dev *rcdev,
+				 unsigned long id)
+{
+	return jh7110_reset_update(rcdev, id, false);
+}
+
+static int jh7110_reset_reset(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	int ret;
+
+	ret = jh7110_reset_assert(rcdev, id);
+	if (ret)
+		return ret;
+
+	return jh7110_reset_deassert(rcdev, id);
+}
+
+static int jh7110_reset_status(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	struct jh7110_reset *data = jh7110_reset_from(rcdev);
+	struct reset_assert_t reset;
+	unsigned long group;
+	u32 mask, val;
+
+	group = id / 32;
+	mask =  BIT(id % 32);
+	jh7110_get_reset(data, &reset, group);
+	val = readl(reset.reg_status);
+
+	return !(val & mask);
+}
+
+static const struct reset_control_ops jh7110_reset_ops = {
+	.assert		= jh7110_reset_assert,
+	.deassert	= jh7110_reset_deassert,
+	.reset		= jh7110_reset_reset,
+	.status		= jh7110_reset_status,
+};
+
+static void __iomem *platform_ioremap_iomem_byname(struct platform_device *pdev,
+						const char *name)
+{
+	struct resource *res;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
+	if (!res) {
+		dev_err(&pdev->dev, "get %s io base fail.\n", name);
+		return NULL;
+	}
+
+	return  ioremap(res->start, resource_size(res));
+}
+
+int __init reset_starfive_jh7110_generic_probe(struct platform_device *pdev,
+						unsigned int nr_resets)
+{
+	struct jh7110_reset *data;
+	struct device *dev = &pdev->dev;
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	dev->driver_data = data;
+
+	data->syscrg =  platform_ioremap_iomem_byname(pdev, "syscrg");
+	if (IS_ERR(data->syscrg))
+		return PTR_ERR(data->syscrg);
+
+	data->stgcrg =  platform_ioremap_iomem_byname(pdev, "stgcrg");
+	if (IS_ERR(data->stgcrg))
+		return PTR_ERR(data->stgcrg);
+
+	data->aoncrg =  platform_ioremap_iomem_byname(pdev, "aoncrg");
+	if (IS_ERR(data->aoncrg))
+		return PTR_ERR(data->aoncrg);
+
+	data->ispcrg =  platform_ioremap_iomem_byname(pdev, "ispcrg");
+	if (IS_ERR(data->ispcrg))
+		return PTR_ERR(data->ispcrg);
+
+	data->voutcrg =  platform_ioremap_iomem_byname(pdev, "voutcrg");
+	if (IS_ERR(data->voutcrg))
+		return PTR_ERR(data->voutcrg);
+
+	data->rcdev.ops = &jh7110_reset_ops;
+	data->rcdev.owner = THIS_MODULE;
+	data->rcdev.nr_resets = nr_resets;
+	data->rcdev.dev = &pdev->dev;
+	data->rcdev.of_node = pdev->dev.of_node;
+	spin_lock_init(&data->lock);
+
+	return devm_reset_controller_register(dev, &data->rcdev);
+}
+EXPORT_SYMBOL_GPL(reset_starfive_jh7110_generic_probe);
+
+static int __init jh7110_reset_probe(struct platform_device *pdev)
+{
+	return reset_starfive_jh7110_generic_probe(pdev, RSTN_JH7110_RESET_END);
+}
+
+static const struct of_device_id jh7110_reset_dt_ids[] = {
+	{ .compatible = "starfive,jh7110-reset" },
+	{ /* sentinel */ }
+};
+
+static struct platform_driver jh7110_reset_driver = {
+	.driver = {
+		.name = "jh7110-reset",
+		.of_match_table = jh7110_reset_dt_ids,
+		.suppress_bind_attrs = true,
+	},
+};
+builtin_platform_driver_probe(jh7110_reset_driver, jh7110_reset_probe);
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index d5512b18a3ae..d1f6086c6943 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1320,6 +1320,14 @@ config RTC_DRV_CROS_EC
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-cros-ec.
 
+config RTC_DRV_STARFIVE
+	tristate "StarFive 32.768k-RTC"
+	depends on SOC_STARFIVE
+	depends on OF
+	help
+	  If you say Y here you will get support for the RTC found on
+	  StarFive SOCS.
+
 comment "on-CPU RTC drivers"
 
 config RTC_DRV_ASM9260
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index fd1d53e789b7..aa07d9a22b1f 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -163,6 +163,7 @@ obj-$(CONFIG_RTC_DRV_SIRFSOC)	+= rtc-sirfsoc.o
 obj-$(CONFIG_RTC_DRV_SNVS)	+= rtc-snvs.o
 obj-$(CONFIG_RTC_DRV_SPEAR)	+= rtc-spear.o
 obj-$(CONFIG_RTC_DRV_STARFIRE)	+= rtc-starfire.o
+obj-$(CONFIG_RTC_DRV_STARFIVE)  += rtc-starfive.o
 obj-$(CONFIG_RTC_DRV_STK17TA8)	+= rtc-stk17ta8.o
 obj-$(CONFIG_RTC_DRV_ST_LPC)	+= rtc-st-lpc.o
 obj-$(CONFIG_RTC_DRV_STM32) 	+= rtc-stm32.o
diff --git a/drivers/rtc/rtc-starfive.c b/drivers/rtc/rtc-starfive.c
new file mode 100644
index 000000000000..a3a3dfbc3ccb
--- /dev/null
+++ b/drivers/rtc/rtc-starfive.c
@@ -0,0 +1,743 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * RTC driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+
+#include <asm/delay.h>
+#include <linux/bcd.h>
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/iopoll.h>
+#include <linux/platform_device.h>
+#include <linux/rtc.h>
+
+/* Registers */
+#define SFT_RTC_CFG		0x00
+#define SFT_RTC_SW_CAL_VALUE	0x04
+#define SFT_RTC_HW_CAL_CFG	0x08
+#define SFT_RTC_CMP_CFG		0x0C
+#define SFT_RTC_IRQ_EN		0x10
+#define SFT_RTC_IRQ_EVEVT	0x14
+#define SFT_RTC_IRQ_STATUS	0x18
+#define SFT_RTC_CAL_VALUE	0x24
+#define SFT_RTC_CFG_TIME	0x28
+#define SFT_RTC_CFG_DATE	0x2C
+#define SFT_RTC_ACT_TIME	0x34
+#define SFT_RTC_ACT_DATE	0x38
+#define SFT_RTC_TIME		0x3C
+#define SFT_RTC_DATE		0x40
+#define SFT_RTC_TIME_LATCH	0x44
+#define SFT_RTC_DATE_LATCH	0x48
+
+/* RTC_CFG */
+#define RTC_CFG_ENABLE_SHIFT	0  /* RW: RTC Enable. */
+#define RTC_CFG_CAL_EN_HW_SHIFT	1  /* RW: Enable of hardware calibretion. */
+#define RTC_CFG_CAL_SEL_SHIFT	2  /* RW: select the hw/sw calibretion mode.*/
+#define RTC_CFG_HOUR_MODE_SHIFT	3  /* RW: time hour mode. 24h|12h */
+
+/* RTC_SW_CAL_VALUE */
+#define RTC_SW_CAL_VALUE_MASK	GENMASK(15, 0)
+#define RTC_SW_CAL_MAX		RTC_SW_CAL_VALUE_MASK
+#define RTC_SW_CAL_MIN		0
+#define RTC_TICKS_PER_SEC	32768		/* Number of ticks per second */
+#define RTC_PPB_MULT		1000000000LL	/* Multiplier for ppb conversions */
+
+/* RTC_HW_CAL_CFG */
+#define RTC_HW_CAL_REF_SEL_SHIFT	0
+#define RTC_HW_CAL_FRQ_SEL_SHIFT	1
+
+/* IRQ_EN/IRQ_EVEVT/IRQ_STATUS */
+#define RTC_IRQ_CAL_START	BIT(0)
+#define RTC_IRQ_CAL_FINISH	BIT(1)
+#define RTC_IRQ_CMP		BIT(2)
+#define RTC_IRQ_1SEC		BIT(3)
+#define RTC_IRQ_ALAEM		BIT(4)
+#define RTC_IRQ_EVT_UPDATE_PSE	BIT(31)	/* WO: Enable of update time&&date, IRQ_EVEVT only */
+#define RTC_IRQ_ALL		(RTC_IRQ_CAL_START \
+				| RTC_IRQ_CAL_FINISH \
+				| RTC_IRQ_CMP \
+				| RTC_IRQ_1SEC \
+				| RTC_IRQ_ALAEM)
+
+/* CAL_VALUE */
+#define RTC_CAL_VALUE_MASK	GENMASK(15, 0)
+
+/* CFG_TIME/ACT_TIME/RTC_TIME */
+#define TIME_SEC_MASK		GENMASK(6, 0)
+#define TIME_MIN_MASK		GENMASK(13, 7)
+#define TIME_HOUR_MASK		GENMASK(20, 14)
+
+/* CFG_DATE/ACT_DATE/RTC_DATE */
+#define DATE_DAY_MASK		GENMASK(5, 0)
+#define DATE_MON_MASK		GENMASK(10, 6)
+#define DATE_YEAR_MASK		GENMASK(18, 11)
+
+#define INT_TIMEOUT_US		180
+
+enum RTC_HOUR_MODE {
+	RTC_HOUR_MODE_12H = 0,
+	RTC_HOUR_MODE_24H = 1
+};
+
+enum RTC_CAL_MODE {
+	RTC_CAL_MODE_SW = 0,
+	RTC_CAL_MODE_HW = 1
+};
+
+enum RTC_HW_CAL_REF_MODE {
+	RTC_CAL_CLK_REF = 0,
+	RTC_CAL_CLK_MARK = 1
+};
+
+static const unsigned long refclk_list[] = {
+	1000000,
+	2000000,
+	4000000,
+	5927000,
+	6000000,
+	7200000,
+	8000000,
+	10250000,
+	11059200,
+	12000000,
+	12288000,
+	13560000,
+	16000000,
+	19200000,
+	20000000,
+	22118000,
+	24000000,
+	24567000,
+	25000000,
+	26000000,
+	27000000,
+	30000000,
+	32000000,
+	33868800,
+	36000000,
+	36860000,
+	40000000,
+	44000000,
+	50000000,
+	54000000,
+	28224000,
+	28000000,
+};
+
+struct sft_rtc {
+	struct rtc_device *rtc_dev;
+	struct completion cal_done;
+	struct completion onesec_done;
+	struct clk *pclk;
+	struct clk *cal_clk;
+	struct reset_control *rst_array;
+	int hw_cal_map;
+	void __iomem *regs;
+	int rtc_irq;
+	int ms_pulse_irq;
+	int one_sec_pulse_irq;
+};
+
+static inline void sft_rtc_set_enabled(struct sft_rtc *srtc, bool enabled)
+{
+	u32 val;
+
+	if (enabled) {
+		val = readl(srtc->regs + SFT_RTC_CFG);
+		val |= BIT(RTC_CFG_ENABLE_SHIFT);
+		writel(val, srtc->regs + SFT_RTC_CFG);
+	} else {
+		val = readl(srtc->regs + SFT_RTC_CFG);
+		val &= ~BIT(RTC_CFG_ENABLE_SHIFT);
+		writel(val, srtc->regs + SFT_RTC_CFG);
+	}
+}
+
+static inline bool sft_rtc_get_enabled(struct sft_rtc *srtc)
+{
+	return !!(readl(srtc->regs + SFT_RTC_CFG) & BIT(RTC_CFG_ENABLE_SHIFT));
+}
+
+static inline void sft_rtc_set_mode(struct sft_rtc *srtc, enum RTC_HOUR_MODE mode)
+{
+	u32 val;
+
+	val = readl(srtc->regs + SFT_RTC_CFG);
+	val |= mode << RTC_CFG_HOUR_MODE_SHIFT;
+	writel(val, srtc->regs + SFT_RTC_CFG);
+}
+
+static inline int sft_rtc_irq_enable(struct sft_rtc *srtc, u32 irq, bool enable)
+{
+	u32 val;
+
+	if (!(irq & RTC_IRQ_ALL))
+		return -EINVAL;
+
+	if (enable) {
+		val = readl(srtc->regs + SFT_RTC_IRQ_EN);
+		val |= irq;
+		writel(val, srtc->regs + SFT_RTC_IRQ_EN);
+	} else {
+		val = readl(srtc->regs + SFT_RTC_IRQ_EN);
+		val &= ~irq;
+		writel(val, srtc->regs + SFT_RTC_IRQ_EN);
+	}
+	return 0;
+}
+
+static inline void
+sft_rtc_set_cal_hw_enable(struct sft_rtc *srtc, bool enable)
+{
+	u32 val;
+
+	if (enable) {
+		val = readl(srtc->regs + SFT_RTC_CFG);
+		val |= BIT(RTC_CFG_CAL_EN_HW_SHIFT);
+		writel(val, srtc->regs + SFT_RTC_CFG);
+	} else {
+		val = readl(srtc->regs + SFT_RTC_CFG);
+		val &= ~BIT(RTC_CFG_CAL_EN_HW_SHIFT);
+		writel(val, srtc->regs + SFT_RTC_CFG);
+	}
+}
+
+static inline void
+sft_rtc_set_cal_mode(struct sft_rtc *srtc, enum RTC_CAL_MODE mode)
+{
+	u32 val;
+
+	val = readl(srtc->regs + SFT_RTC_CFG);
+	val |= mode << RTC_CFG_CAL_SEL_SHIFT;
+	writel(val, srtc->regs + SFT_RTC_CFG);
+}
+
+static int sft_rtc_get_hw_calclk(struct device *dev, unsigned long freq)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(refclk_list); i++)
+		if (refclk_list[i] == freq)
+			return i;
+
+	dev_err(dev, "refclk: %ldHz do not support.\n", freq);
+	return -EINVAL;
+}
+
+static inline void sft_rtc_reg2time(struct rtc_time *tm, u32 reg)
+{
+	tm->tm_hour = bcd2bin(FIELD_GET(TIME_HOUR_MASK, reg));
+	tm->tm_min = bcd2bin(FIELD_GET(TIME_MIN_MASK, reg));
+	tm->tm_sec = bcd2bin(FIELD_GET(TIME_SEC_MASK, reg));
+}
+
+static inline void sft_rtc_reg2date(struct rtc_time *tm, u32 reg)
+{
+	tm->tm_year = bcd2bin(FIELD_GET(DATE_YEAR_MASK, reg)) + 100;
+	tm->tm_mon = bcd2bin(FIELD_GET(DATE_MON_MASK, reg)) - 1;
+	tm->tm_mday = bcd2bin(FIELD_GET(DATE_DAY_MASK, reg));
+}
+
+static inline u32 sft_rtc_time2reg(struct rtc_time *tm)
+{
+	return	FIELD_PREP(TIME_HOUR_MASK, bin2bcd(tm->tm_hour)) |
+		FIELD_PREP(TIME_MIN_MASK, bin2bcd(tm->tm_min)) |
+		FIELD_PREP(TIME_SEC_MASK, bin2bcd(tm->tm_sec));
+}
+
+static inline u32 sft_rtc_date2reg(struct rtc_time *tm)
+{
+	return	FIELD_PREP(DATE_YEAR_MASK, bin2bcd(tm->tm_year - 100)) |
+		FIELD_PREP(DATE_MON_MASK, bin2bcd(tm->tm_mon + 1)) |
+		FIELD_PREP(DATE_DAY_MASK, bin2bcd(tm->tm_mday));
+}
+
+static inline void sft_rtc_update_pulse(struct sft_rtc *srtc)
+{
+	u32 val;
+
+	val = readl(srtc->regs + SFT_RTC_IRQ_EVEVT);
+	val |= RTC_IRQ_EVT_UPDATE_PSE;
+	writel(val, srtc->regs + SFT_RTC_IRQ_EVEVT);
+}
+
+static irqreturn_t sft_rtc_irq_handler(int irq, void *data)
+{
+	struct sft_rtc *srtc = data;
+	struct timerqueue_node *next;
+	u32 irq_flags = 0;
+	u32 irq_mask = 0;
+	u32 val;
+	int ret = 0;
+
+	val = readl(srtc->regs + SFT_RTC_IRQ_EVEVT);
+	if (val & RTC_IRQ_CAL_START)
+		irq_mask |= RTC_IRQ_CAL_START;
+
+	if (val & RTC_IRQ_CAL_FINISH) {
+		irq_mask |= RTC_IRQ_CAL_FINISH;
+		complete(&srtc->cal_done);
+	}
+
+	if (val & RTC_IRQ_CMP)
+		irq_mask |= RTC_IRQ_CMP;
+
+	if (val & RTC_IRQ_1SEC) {
+		irq_flags |= RTC_PF;
+		irq_mask |= RTC_IRQ_1SEC;
+		complete(&srtc->onesec_done);
+	}
+
+	if (val & RTC_IRQ_ALAEM) {
+		irq_flags |= RTC_AF;
+		irq_mask |= RTC_IRQ_ALAEM;
+
+		next = timerqueue_getnext(&srtc->rtc_dev->timerqueue);
+		if (next == &srtc->rtc_dev->aie_timer.node)
+			dev_info(&srtc->rtc_dev->dev, "alarm expires");
+	}
+
+	writel(irq_mask, srtc->regs + SFT_RTC_IRQ_EVEVT);
+
+	/* Wait interrupt flag clear */
+	ret = readl_poll_timeout_atomic(srtc->regs + SFT_RTC_IRQ_EVEVT, val,
+					(val & irq_mask) == 0, 0, INT_TIMEOUT_US);
+	if (ret)
+		dev_warn(&srtc->rtc_dev->dev, "fail to clear rtc interrupt flag\n");
+
+	if (irq_flags)
+		rtc_update_irq(srtc->rtc_dev, 1, irq_flags | RTC_IRQF);
+
+	return IRQ_HANDLED;
+}
+
+static int sft_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+	u32 val;
+	int irq_1sec_state_start, irq_1sec_state_end;
+
+	/* If the RTC is disabled, assume the values are invalid */
+	if (!sft_rtc_get_enabled(srtc))
+		return -EINVAL;
+
+	irq_1sec_state_start =
+		(readl(srtc->regs + SFT_RTC_IRQ_STATUS) & RTC_IRQ_1SEC) == 0 ? 0 : 1;
+
+read_again:
+	val = readl(srtc->regs + SFT_RTC_TIME);
+	sft_rtc_reg2time(tm, val);
+
+	val = readl(srtc->regs + SFT_RTC_DATE);
+	sft_rtc_reg2date(tm, val);
+
+	if (irq_1sec_state_start == 0) {
+		irq_1sec_state_end =
+			(readl(srtc->regs + SFT_RTC_IRQ_STATUS) & RTC_IRQ_1SEC) == 0 ? 0 : 1;
+		if (irq_1sec_state_end == 1) {
+			irq_1sec_state_start = 1;
+			goto read_again;
+		}
+	}
+
+	return 0;
+}
+
+static int sft_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+	u32 val;
+	int ret;
+
+	val = sft_rtc_time2reg(tm);
+	writel(val, srtc->regs + SFT_RTC_CFG_TIME);
+
+	val = sft_rtc_date2reg(tm);
+	writel(val, srtc->regs + SFT_RTC_CFG_DATE);
+
+	/* Update pulse */
+	sft_rtc_update_pulse(srtc);
+
+	/* Ensure that data is fully written */
+	ret = wait_for_completion_interruptible_timeout(&srtc->onesec_done,
+							usecs_to_jiffies(120));
+	if (ret) {
+		dev_warn(dev,
+			 "rtc wait for completion interruptible timeout.\n");
+	}
+	return 0;
+}
+
+static int sft_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+
+	return sft_rtc_irq_enable(srtc, RTC_IRQ_ALAEM, enabled);
+}
+
+static int sft_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+	u32 val;
+
+	val = readl(srtc->regs + SFT_RTC_ACT_TIME);
+	sft_rtc_reg2time(&alarm->time, val);
+
+	val = readl(srtc->regs + SFT_RTC_ACT_DATE);
+	sft_rtc_reg2date(&alarm->time, val);
+
+	return 0;
+}
+
+static int sft_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+	u32 val;
+
+	sft_rtc_alarm_irq_enable(dev, 0);
+
+	val = sft_rtc_time2reg(&alarm->time);
+	writel(val, srtc->regs + SFT_RTC_ACT_TIME);
+
+	val = sft_rtc_date2reg(&alarm->time);
+	writel(val, srtc->regs + SFT_RTC_ACT_DATE);
+
+	sft_rtc_alarm_irq_enable(dev, alarm->enabled);
+
+	return 0;
+}
+
+static int sft_rtc_get_offset(struct device *dev, long *offset)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+	s64 tmp;
+	u32 val;
+
+	val = readl(srtc->regs + SFT_RTC_CAL_VALUE)
+			& RTC_SW_CAL_VALUE_MASK;
+	val += 1;
+	/*
+	 * the adjust val range is [0x0000-0xffff],
+	 * the default val is 0x7fff (32768-1),mapping offset=0 ;
+	 */
+	tmp = (s64)val - RTC_TICKS_PER_SEC;
+	tmp *= RTC_PPB_MULT;
+	tmp = div_s64(tmp, RTC_TICKS_PER_SEC);
+
+	/* Offset value operates in negative way, so swap sign */
+	*offset = -tmp;
+
+	return 0;
+}
+
+static int sft_rtc_set_offset(struct device *dev, long offset)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+	s64 tmp;
+	u32 val;
+
+	tmp = offset * RTC_TICKS_PER_SEC;
+	tmp = div_s64(tmp, RTC_PPB_MULT);
+
+	tmp = RTC_TICKS_PER_SEC - tmp;
+	tmp -= 1;
+	if (tmp > RTC_SW_CAL_MAX || tmp < RTC_SW_CAL_MIN) {
+		dev_err(dev, "offset is out of range.\n");
+		return -EINVAL;
+	}
+
+	val = tmp & RTC_SW_CAL_VALUE_MASK;
+	/* set software calibration value */
+	writel(val, srtc->regs + SFT_RTC_SW_CAL_VALUE);
+
+	/* set CFG_RTC-cal_sel to select calibretion by software. */
+	sft_rtc_set_cal_mode(srtc, RTC_CAL_MODE_SW);
+
+	return 0;
+}
+
+static __maybe_unused int
+sft_rtc_hw_adjustment(struct device *dev, unsigned int enable)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+	u32 val;
+
+	if (srtc->hw_cal_map <= 0) {
+		dev_err(dev, "fail to get cal-clock-freq.\n");
+		return -EFAULT;
+	}
+
+	if (enable) {
+		sft_rtc_irq_enable(srtc, RTC_IRQ_CAL_FINISH, true);
+
+		/* Set reference clock frequency value */
+		val = readl(srtc->regs + SFT_RTC_HW_CAL_CFG);
+		val |= (srtc->hw_cal_map << RTC_HW_CAL_FRQ_SEL_SHIFT);
+		writel(val, srtc->regs + SFT_RTC_HW_CAL_CFG);
+
+		/* Set CFG_RTC-cal_sel to select calibretion by hardware. */
+		sft_rtc_set_cal_mode(srtc, RTC_CAL_MODE_HW);
+
+		/* Set CFG_RTC-cal_en_hw to launch hardware calibretion.*/
+		sft_rtc_set_cal_hw_enable(srtc, true);
+
+		wait_for_completion_interruptible_timeout(&srtc->cal_done,
+							  usecs_to_jiffies(100));
+
+		sft_rtc_irq_enable(srtc, RTC_IRQ_CAL_FINISH, false);
+	} else {
+		sft_rtc_set_cal_mode(srtc, RTC_CAL_MODE_SW);
+		sft_rtc_set_cal_hw_enable(srtc, false);
+	}
+
+	return 0;
+}
+
+static int sft_rtc_get_cal_clk(struct device *dev, struct sft_rtc *srtc)
+{
+	struct device_node *np = dev->of_node;
+	unsigned long cal_clk_freq;
+	u32 freq;
+	int ret;
+
+	srtc->cal_clk = devm_clk_get(dev, "cal_clk");
+	if (IS_ERR(srtc->cal_clk))
+		return PTR_ERR(srtc->cal_clk);
+
+	clk_prepare_enable(srtc->cal_clk);
+
+	cal_clk_freq = clk_get_rate(srtc->cal_clk);
+	if (!cal_clk_freq) {
+		dev_warn(dev,
+			 "get rate failed, next try to get from dts.\n");
+		ret = of_property_read_u32(np, "rtc,cal-clock-freq", &freq);
+		if (!ret) {
+			cal_clk_freq = (u64)freq;
+		} else {
+			dev_err(dev,
+				"Need rtc,cal-clock-freq define in dts.\n");
+			goto err_disable_cal_clk;
+		}
+	}
+
+	srtc->hw_cal_map = sft_rtc_get_hw_calclk(dev, cal_clk_freq);
+	if (srtc->hw_cal_map < 0) {
+		ret = srtc->hw_cal_map;
+		goto err_disable_cal_clk;
+	}
+
+	return 0;
+
+err_disable_cal_clk:
+	clk_disable_unprepare(srtc->cal_clk);
+
+	return ret;
+}
+
+static int sft_rtc_get_irq(struct platform_device *pdev, struct sft_rtc *srtc)
+{
+	int ret;
+
+	srtc->rtc_irq = platform_get_irq_byname(pdev, "rtc");
+	if (srtc->rtc_irq < 0)
+		return -EINVAL;
+
+	ret = devm_request_irq(&pdev->dev, srtc->rtc_irq,
+			       sft_rtc_irq_handler, 0,
+				KBUILD_MODNAME, srtc);
+	if (ret)
+		dev_err(&pdev->dev, "Failed to request interrupt, %d\n", ret);
+
+	return ret;
+}
+
+static const struct rtc_class_ops starfive_rtc_ops = {
+	.read_time		= sft_rtc_read_time,
+	.set_time		= sft_rtc_set_time,
+	.read_alarm		= sft_rtc_read_alarm,
+	.set_alarm		= sft_rtc_set_alarm,
+	.alarm_irq_enable	= sft_rtc_alarm_irq_enable,
+	.set_offset		= sft_rtc_set_offset,
+	.read_offset		= sft_rtc_get_offset,
+};
+
+static int sft_rtc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sft_rtc *srtc;
+	struct rtc_time tm;
+	struct irq_desc *desc;
+	int ret;
+
+	srtc = devm_kzalloc(dev, sizeof(*srtc), GFP_KERNEL);
+	if (!srtc)
+		return -ENOMEM;
+
+	srtc->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(srtc->regs))
+		return PTR_ERR(srtc->regs);
+
+	srtc->pclk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(srtc->pclk)) {
+		ret = PTR_ERR(srtc->pclk);
+		dev_err(dev,
+			"Failed to retrieve the peripheral clock, %d\n", ret);
+		return ret;
+	}
+
+	srtc->rst_array = devm_reset_control_array_get_exclusive(dev);
+	if (IS_ERR(srtc->rst_array)) {
+		ret = PTR_ERR(srtc->rst_array);
+		dev_err(dev,
+			"Failed to retrieve the rtc reset, %d\n", ret);
+		return ret;
+	}
+
+	init_completion(&srtc->cal_done);
+	init_completion(&srtc->onesec_done);
+
+	ret = clk_prepare_enable(srtc->pclk);
+	if (ret) {
+		dev_err(dev,
+			"Failed to enable the peripheral clock, %d\n", ret);
+		return ret;
+	}
+
+	ret = sft_rtc_get_cal_clk(dev, srtc);
+	if (ret)
+		goto err_disable_pclk;
+
+	ret = reset_control_deassert(srtc->rst_array);
+	if (ret) {
+		dev_err(dev,
+			"Failed to deassert rtc resets, %d\n", ret);
+		goto err_disable_cal_clk;
+	}
+
+	ret = sft_rtc_get_irq(pdev, srtc);
+	if (ret)
+		goto err_disable_cal_clk;
+
+	srtc->rtc_dev = devm_rtc_allocate_device(dev);
+	if (IS_ERR(srtc->rtc_dev))
+		return PTR_ERR(srtc->rtc_dev);
+
+	platform_set_drvdata(pdev, srtc);
+
+	/* The RTC supports 01.01.2001 - 31.12.2099 */
+	srtc->rtc_dev->range_min = mktime64(2001,  1,  1,  0,  0,  0);
+	srtc->rtc_dev->range_max = mktime64(2099, 12, 31, 23, 59, 59);
+
+	srtc->rtc_dev->ops = &starfive_rtc_ops;
+	device_init_wakeup(dev, true);
+
+	desc = irq_to_desc(srtc->rtc_irq);
+	irq_desc_get_chip(desc)->flags = IRQCHIP_SKIP_SET_WAKE;
+
+	/* Always use 24-hour mode and keep the RTC values */
+	sft_rtc_set_mode(srtc, RTC_HOUR_MODE_24H);
+
+	sft_rtc_set_enabled(srtc, true);
+
+	if (device_property_read_bool(dev, "rtc,hw-adjustment"))
+		sft_rtc_hw_adjustment(dev, true);
+
+	/*
+	 * If rtc time is out of supported range, reset it to the minimum time.
+	 * notice that, actual year = 1900 + tm.tm_year
+	 *              actual month = 1 + tm.tm_mon
+	 */
+	sft_rtc_read_time(dev, &tm);
+	if (tm.tm_year < 101 || tm.tm_year > 199 || tm.tm_mon < 0 || tm.tm_mon > 11 ||
+	    tm.tm_mday < 1 || tm.tm_mday > 31 || tm.tm_hour < 0 || tm.tm_hour > 23 ||
+	    tm.tm_min < 0 || tm.tm_min > 59 || tm.tm_sec < 0 || tm.tm_sec > 59) {
+		rtc_time64_to_tm(srtc->rtc_dev->range_min, &tm);
+		sft_rtc_set_time(dev, &tm);
+	}
+
+	ret = rtc_register_device(srtc->rtc_dev);
+	if (ret)
+		goto err_disable_wakeup;
+
+	return 0;
+
+err_disable_wakeup:
+	device_init_wakeup(dev, false);
+
+err_disable_cal_clk:
+	clk_disable_unprepare(srtc->cal_clk);
+
+err_disable_pclk:
+	clk_disable_unprepare(srtc->pclk);
+
+	return ret;
+}
+
+static int sft_rtc_remove(struct platform_device *pdev)
+{
+	struct sft_rtc *srtc = platform_get_drvdata(pdev);
+
+	sft_rtc_alarm_irq_enable(&pdev->dev, 0);
+	device_init_wakeup(&pdev->dev, 0);
+
+	clk_disable_unprepare(srtc->pclk);
+	clk_disable_unprepare(srtc->cal_clk);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int sft_rtc_suspend(struct device *dev)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(srtc->rtc_irq);
+
+	return 0;
+}
+
+static int sft_rtc_resume(struct device *dev)
+{
+	struct sft_rtc *srtc = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		disable_irq_wake(srtc->rtc_irq);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(sft_rtc_pm_ops, sft_rtc_suspend, sft_rtc_resume);
+
+static const struct of_device_id sft_rtc_of_match[] = {
+	{ .compatible = "starfive,jh7110-rtc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sft_rtc_of_match);
+
+static struct platform_driver starfive_rtc_driver = {
+	.driver = {
+		.name = "starfive-rtc",
+		.of_match_table = sft_rtc_of_match,
+		.pm   = &sft_rtc_pm_ops,
+	},
+	.probe = sft_rtc_probe,
+	.remove = sft_rtc_remove,
+};
+module_platform_driver(starfive_rtc_driver);
+
+MODULE_AUTHOR("Samin Guo <samin.guo@starfivetech.com>");
+MODULE_AUTHOR("Hal Feng <hal.feng@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive RTC driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:starfive-rtc");
diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index 425ab6f7e375..82d2c22e0915 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -15,6 +15,7 @@ source "drivers/soc/renesas/Kconfig"
 source "drivers/soc/rockchip/Kconfig"
 source "drivers/soc/samsung/Kconfig"
 source "drivers/soc/sifive/Kconfig"
+source "drivers/soc/starfive/Kconfig"
 source "drivers/soc/sunxi/Kconfig"
 source "drivers/soc/tegra/Kconfig"
 source "drivers/soc/ti/Kconfig"
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index 36452bed86ef..3eca3ed19ca3 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -20,7 +20,8 @@ obj-y				+= qcom/
 obj-y				+= renesas/
 obj-$(CONFIG_ARCH_ROCKCHIP)	+= rockchip/
 obj-$(CONFIG_SOC_SAMSUNG)	+= samsung/
-obj-$(CONFIG_SOC_SIFIVE)	+= sifive/
+obj-y				+= sifive/
+obj-$(CONFIG_SOC_STARFIVE)	+= starfive/
 obj-y				+= sunxi/
 obj-$(CONFIG_ARCH_TEGRA)	+= tegra/
 obj-y				+= ti/
diff --git a/drivers/soc/sifive/Kconfig b/drivers/soc/sifive/Kconfig
index 58cf8c40d08d..629c5410a800 100644
--- a/drivers/soc/sifive/Kconfig
+++ b/drivers/soc/sifive/Kconfig
@@ -1,10 +1,24 @@
 # SPDX-License-Identifier: GPL-2.0
 
-if SOC_SIFIVE
+if SOC_SIFIVE || SOC_STARFIVE
 
 config SIFIVE_L2
 	bool "Sifive L2 Cache controller"
 	help
 	  Support for the L2 cache controller on SiFive platforms.
 
+config SIFIVE_L2_FLUSH
+	bool "Support Level 2 Cache Controller Flush operation of SiFive Soc"
+
+if SIFIVE_L2_FLUSH
+
+config SIFIVE_L2_FLUSH_START
+	hex "Level 2 Cache Flush operation start"
+	default 0x40000000
+
+config SIFIVE_L2_FLUSH_SIZE
+	hex "Level 2 Cache Flush operation size"
+	default 0x400000000
+
+endif
 endif
diff --git a/drivers/soc/sifive/sifive_l2_cache.c b/drivers/soc/sifive/sifive_l2_cache.c
index 44d7e1951da3..f42f3c07d27d 100644
--- a/drivers/soc/sifive/sifive_l2_cache.c
+++ b/drivers/soc/sifive/sifive_l2_cache.c
@@ -25,12 +25,15 @@
 #define SIFIVE_L2_DATECCFAIL_HIGH 0x164
 #define SIFIVE_L2_DATECCFAIL_COUNT 0x168
 
+#define SIFIVE_L2_FLUSH64 0x200
+
 #define SIFIVE_L2_CONFIG 0x00
 #define SIFIVE_L2_WAYENABLE 0x08
 #define SIFIVE_L2_ECCINJECTERR 0x40
 
 #define SIFIVE_L2_MAX_ECCINTR 3
 
+#define SIFIVE_L2_FLUSH64_LINE_LEN 64
 static void __iomem *l2_base;
 static int g_irq[SIFIVE_L2_MAX_ECCINTR];
 static struct riscv_cacheinfo_ops l2_cache_ops;
@@ -93,6 +96,7 @@ static void l2_config_read(void)
 
 static const struct of_device_id sifive_l2_ids[] = {
 	{ .compatible = "sifive,fu540-c000-ccache" },
+	{ .compatible = "sifive,fu740-c000-ccache" },
 	{ /* end of table */ },
 };
 
@@ -110,6 +114,41 @@ int unregister_sifive_l2_error_notifier(struct notifier_block *nb)
 }
 EXPORT_SYMBOL_GPL(unregister_sifive_l2_error_notifier);
 
+#ifdef CONFIG_SIFIVE_L2_FLUSH
+void sifive_l2_flush64_range(unsigned long start, unsigned long len)
+{
+	unsigned long line;
+
+	if (!l2_base) {
+		pr_warn("L2CACHE: base addr invalid, skipping flush\n");
+		return;
+	}
+
+	/* TODO: if (len == 0), skipping flush or going on? */
+	if (!len) {
+		pr_debug("L2CACHE: flush64 range @ 0x%lx(len:0)\n", start);
+		return;
+	}
+
+	/* make sure the address is in the range */
+	if (start < CONFIG_SIFIVE_L2_FLUSH_START ||
+	   (start + len) > (CONFIG_SIFIVE_L2_FLUSH_START +
+			     CONFIG_SIFIVE_L2_FLUSH_SIZE)) {
+		pr_warn("L2CACHE: flush64 out of range: %lx(%lx), skip flush\n",
+			start, len);
+		return;
+	}
+
+	mb();	/* sync */
+	for (line = start; line < start + len;
+	     line += SIFIVE_L2_FLUSH64_LINE_LEN) {
+		writeq(line, l2_base + SIFIVE_L2_FLUSH64);
+		mb();
+	}
+}
+EXPORT_SYMBOL_GPL(sifive_l2_flush64_range);
+#endif
+
 static int l2_largest_wayenabled(void)
 {
 	return readl(l2_base + SIFIVE_L2_WAYENABLE) & 0xFF;
diff --git a/drivers/soc/starfive/Kconfig b/drivers/soc/starfive/Kconfig
new file mode 100644
index 000000000000..cf6643f08d9c
--- /dev/null
+++ b/drivers/soc/starfive/Kconfig
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+
+config STARFIVE_PMU
+	bool "Support PMU for StarFive Soc"
+	depends on PM && (SOC_STARFIVE || COMPILE_TEST)
+	select PM_GENERIC_DOMAINS
+	help
+	  Say y here to enable power domain support.
diff --git a/drivers/soc/starfive/Makefile b/drivers/soc/starfive/Makefile
new file mode 100644
index 000000000000..296eb75fa5ea
--- /dev/null
+++ b/drivers/soc/starfive/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_STARFIVE_PMU)	+= jh7110_pmu.o
diff --git a/drivers/soc/starfive/jh7110_pmu.c b/drivers/soc/starfive/jh7110_pmu.c
new file mode 100755
index 000000000000..1d5072d6f2c8
--- /dev/null
+++ b/drivers/soc/starfive/jh7110_pmu.c
@@ -0,0 +1,380 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * JH7110 Power Domain Controller Driver
+ *
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+
+#include <dt-bindings/power/jh7110-power.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/pm_domain.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+/* register define */
+#define HW_EVENT_TURN_ON_MASK		0x04
+#define HW_EVENT_TURN_OFF_MASK		0x08
+#define SW_TURN_ON_POWER_MODE		0x0C
+#define SW_TURN_OFF_POWER_MODE		0x10
+#define SW_ENCOURAGE			0x44
+#define PMU_INT_MASK			0x48
+#define PCH_BYPASS			0x4C
+#define PCH_PSTATE			0x50
+#define PCH_TIMEOUT			0x54
+#define LP_TIMEOUT			0x58
+#define HW_TURN_ON_MODE			0x5C
+#define CURR_POWER_MODE			0x80
+#define PMU_EVENT_STATUS		0x88
+#define PMU_INT_STATUS			0x8C
+
+/* sw encourage cfg */
+#define SW_MODE_ENCOURAGE_EN_LO		0x05
+#define SW_MODE_ENCOURAGE_EN_HI		0x50
+#define SW_MODE_ENCOURAGE_DIS_LO	0x0A
+#define SW_MODE_ENCOURAGE_DIS_HI	0xA0
+#define SW_MODE_ENCOURAGE_ON		0xFF
+
+/* pmu int status */
+#define PMU_INT_SEQ_DONE		BIT(0)
+#define PMU_INT_HW_REQ			BIT(1)
+#define PMU_INT_SW_FAIL			GENMASK(3, 2)
+#define PMU_INT_HW_FAIL			GENMASK(5, 4)
+#define PMU_INT_PCH_FAIL		GENMASK(8, 6)
+#define PMU_INT_FAIL_MASK		(PMU_INT_SW_FAIL | \
+					PMU_INT_HW_FAIL | \
+					PMU_INT_PCH_FAIL)
+#define PMU_INT_ALL_MASK		(PMU_INT_SEQ_DONE | \
+					PMU_INT_HW_REQ | \
+					PMU_INT_FAIL_MASK)
+
+#define DELAY_US			10
+#define TIMEOUT_US			100000
+
+struct jh7110_power_dev {
+	struct generic_pm_domain genpd;
+	struct jh7110_pmu *power;
+	uint32_t mask;
+};
+
+struct jh7110_pmu {
+	void __iomem *base;
+	spinlock_t lock;
+	int irq;
+	struct device *pdev;
+	struct jh7110_power_dev *dev;
+	struct genpd_onecell_data genpd_data;
+	struct generic_pm_domain **genpd;
+};
+
+struct jh7110_pmu_data {
+	const char * const name;
+	uint8_t bit;
+	unsigned int flags;
+};
+
+static void __iomem *pmu_base;
+
+static inline void pmu_writel(u32 val, u32 offset)
+{
+	writel(val, pmu_base + offset);
+}
+
+void starfive_pmu_hw_event_turn_off_mask(u32 mask)
+{
+	pmu_writel(mask, HW_EVENT_TURN_OFF_MASK);
+}
+EXPORT_SYMBOL(starfive_pmu_hw_event_turn_off_mask);
+
+static int jh7110_pmu_get_state(struct jh7110_power_dev *pmd, bool *is_on)
+{
+	struct jh7110_pmu *pmu = pmd->power;
+
+	if (!pmd->mask) {
+		*is_on = false;
+		return -EINVAL;
+	}
+
+	*is_on = __raw_readl(pmu->base + CURR_POWER_MODE) & pmd->mask;
+
+	return 0;
+}
+
+static int jh7110_pmu_set_state(struct jh7110_power_dev *pmd, bool on)
+{
+	struct jh7110_pmu *pmu = pmd->power;
+	unsigned long flags;
+	uint32_t val;
+	uint32_t mode;
+	uint32_t encourage_lo;
+	uint32_t encourage_hi;
+	bool is_on;
+	int ret;
+
+	if (!pmd->mask)
+		return -EINVAL;
+
+	ret = jh7110_pmu_get_state(pmd, &is_on);
+	if (ret)
+		dev_info(pmu->pdev, "unable to get current state for %s\n",
+				pmd->genpd.name);
+	if (is_on == on) {
+		dev_info(pmu->pdev, "pm domain [%s] is already %sable status.\n",
+				pmd->genpd.name, on ? "en" : "dis");
+		return 0;
+	}
+
+	spin_lock_irqsave(&pmu->lock, flags);
+
+	if (on) {
+		mode = SW_TURN_ON_POWER_MODE;
+		encourage_lo = SW_MODE_ENCOURAGE_EN_LO;
+		encourage_hi = SW_MODE_ENCOURAGE_EN_HI;
+	} else {
+		mode = SW_TURN_OFF_POWER_MODE;
+		encourage_lo = SW_MODE_ENCOURAGE_DIS_LO;
+		encourage_hi = SW_MODE_ENCOURAGE_DIS_HI;
+	}
+
+	__raw_writel(pmd->mask, pmu->base + mode);
+
+	/* write SW_ENCOURAGE to make the configuration take effect */
+	__raw_writel(SW_MODE_ENCOURAGE_ON, pmu->base + SW_ENCOURAGE);
+	__raw_writel(encourage_lo, pmu->base + SW_ENCOURAGE);
+	__raw_writel(encourage_hi, pmu->base + SW_ENCOURAGE);
+
+	spin_unlock_irqrestore(&pmu->lock, flags);
+
+	if (on) {
+		ret = readl_poll_timeout_atomic(pmu->base + CURR_POWER_MODE, val,
+						val & pmd->mask, DELAY_US,
+						TIMEOUT_US);
+		if (ret) {
+			dev_err(pmu->pdev, "%s power_on failed", pmd->genpd.name);
+			return -ETIMEDOUT;
+		}
+	} else {
+		ret = readl_poll_timeout_atomic(pmu->base + CURR_POWER_MODE, val,
+						!(val & pmd->mask), DELAY_US,
+						TIMEOUT_US);
+		if (ret) {
+			dev_err(pmu->pdev, "%s power_off failed", pmd->genpd.name);
+			return -ETIMEDOUT;
+		}
+	}
+
+	return 0;
+}
+
+static int jh7110_pmu_on(struct generic_pm_domain *genpd)
+{
+	struct jh7110_power_dev *pmd = container_of(genpd,
+		struct jh7110_power_dev, genpd);
+
+	return jh7110_pmu_set_state(pmd, true);
+}
+
+static int jh7110_pmu_off(struct generic_pm_domain *genpd)
+{
+	struct jh7110_power_dev *pmd = container_of(genpd,
+		struct jh7110_power_dev, genpd);
+
+	return jh7110_pmu_set_state(pmd, false);
+}
+
+static void starfive_pmu_int_enable(struct jh7110_pmu *pmu, u32 mask, bool enable)
+{
+	u32 val = __raw_readl(pmu->base + PMU_INT_MASK);
+
+	if (enable)
+		val &= ~mask;
+	else
+		val |= mask;
+
+	__raw_writel(val, pmu->base + PMU_INT_MASK);
+}
+
+static irqreturn_t starfive_pmu_interrupt(int irq, void *data)
+{
+	struct jh7110_pmu *pmu = data;
+	unsigned long flags;
+	u32 val;
+
+	spin_lock_irqsave(&pmu->lock, flags);
+	val = __raw_readl(pmu->base + PMU_INT_STATUS);
+
+	if (val & PMU_INT_SEQ_DONE)
+		dev_dbg(pmu->pdev, "sequence done.\n");
+	if (val & PMU_INT_HW_REQ)
+		dev_dbg(pmu->pdev, "hardware encourage requestion.\n");
+	if (val & PMU_INT_SW_FAIL)
+		dev_err(pmu->pdev, "software encourage fail.\n");
+	if (val & PMU_INT_HW_FAIL)
+		dev_err(pmu->pdev, "hardware encourage fail.\n");
+	if (val & PMU_INT_PCH_FAIL)
+		dev_err(pmu->pdev, "p-channel fail event.\n");
+
+	/* clear interrupts */
+	__raw_writel(val, pmu->base + PMU_INT_STATUS);
+	__raw_writel(val, pmu->base + PMU_EVENT_STATUS);
+
+	spin_unlock_irqrestore(&pmu->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int jh7110_pmu_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct resource *res;
+	const struct jh7110_pmu_data *entry, *table;
+	struct jh7110_pmu *pmu;
+	unsigned int i;
+	uint8_t max_bit = 0;
+	int ret;
+
+	pmu = devm_kzalloc(dev, sizeof(*pmu), GFP_KERNEL);
+	if (!pmu)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pmu_base = pmu->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(pmu->base))
+		return PTR_ERR(pmu->base);
+
+	/* initialize pmu interrupt  */
+	pmu->irq = platform_get_irq(pdev, 0);
+	if (pmu->irq < 0)
+		return pmu->irq;
+
+	ret = devm_request_irq(dev, pmu->irq, starfive_pmu_interrupt,
+			       0, pdev->name, pmu);
+	if (ret)
+		dev_err(dev, "request irq failed.\n");
+
+	table = of_device_get_match_data(dev);
+	if (!table)
+		return -EINVAL;
+
+	pmu->pdev = dev;
+	pmu->genpd_data.num_domains = 0;
+	i = 0;
+	for (entry = table; entry->name; entry++) {
+		max_bit = max(max_bit, entry->bit);
+		i++;
+	}
+
+	if (!i)
+		return -ENODEV;
+
+	pmu->genpd_data.num_domains = max_bit + 1;
+
+	pmu->dev = devm_kcalloc(dev, pmu->genpd_data.num_domains,
+				  sizeof(struct jh7110_power_dev),
+				  GFP_KERNEL);
+	if (!pmu->dev)
+		return -ENOMEM;
+
+	pmu->genpd = devm_kcalloc(dev, pmu->genpd_data.num_domains,
+				    sizeof(struct generic_pm_domain *),
+				    GFP_KERNEL);
+	if (!pmu->genpd)
+		return -ENOMEM;
+
+	pmu->genpd_data.domains = pmu->genpd;
+
+	i = 0;
+	for (entry = table; entry->name; entry++) {
+		struct jh7110_power_dev *pmd = &pmu->dev[i];
+		bool is_on;
+
+		pmd->power = pmu;
+		pmd->mask = BIT(entry->bit);
+		pmd->genpd.name = entry->name;
+		pmd->genpd.flags = entry->flags;
+
+		ret = jh7110_pmu_get_state(pmd, &is_on);
+		if (ret)
+			dev_warn(dev, "unable to get current state for %s\n",
+				 pmd->genpd.name);
+
+		pmd->genpd.power_on = jh7110_pmu_on;
+		pmd->genpd.power_off = jh7110_pmu_off;
+
+		pm_genpd_init(&pmd->genpd, NULL, !is_on);
+		pmu->genpd[entry->bit] = &pmd->genpd;
+
+		i++;
+	}
+
+	spin_lock_init(&pmu->lock);
+	starfive_pmu_int_enable(pmu, PMU_INT_ALL_MASK & ~PMU_INT_PCH_FAIL, true);
+
+	ret = of_genpd_add_provider_onecell(np, &pmu->genpd_data);
+	if (ret) {
+		dev_err(dev, "failed to register genpd driver: %d\n", ret);
+		return ret;
+	}
+
+	dev_info(dev, "registered %u power domains\n", i);
+
+	return 0;
+}
+
+static const struct jh7110_pmu_data jh7110_power_domains[] = {
+	{
+		.name = "SYSTOP",
+		.bit = JH7110_PD_SYSTOP,
+		.flags = GENPD_FLAG_ALWAYS_ON,
+	}, {
+		.name = "CPU",
+		.bit = JH7110_PD_CPU,
+		.flags = GENPD_FLAG_ALWAYS_ON,
+	}, {
+		.name = "GPUA",
+		.bit = JH7110_PD_GPUA,
+	}, {
+		.name = "VDEC",
+		.bit = JH7110_PD_VDEC,
+	}, {
+		.name = "VOUT",
+		.bit = JH7110_PD_VOUT,
+	}, {
+		.name = "ISP",
+		.bit = JH7110_PD_ISP,
+	}, {
+		.name = "VENC",
+		.bit = JH7110_PD_VENC,
+	}, {
+		.name = "GPUB",
+		.bit = JH7110_PD_GPUB,
+	}, {
+		/* sentinel */
+	},
+};
+
+static const struct of_device_id jh7110_pmu_of_match[] = {
+	{
+		.compatible = "starfive,jh7110-pmu",
+		.data = &jh7110_power_domains,
+	}, {
+		/* sentinel */
+	}
+};
+
+static struct platform_driver jh7110_pmu_driver = {
+	.driver = {
+		.name = "jh7110-pmu",
+		.of_match_table = jh7110_pmu_of_match,
+	},
+	.probe  = jh7110_pmu_probe,
+};
+builtin_platform_driver(jh7110_pmu_driver);
+
+MODULE_AUTHOR("Walker Chen <walker.chen@linux.starfivetech.com>");
+MODULE_DESCRIPTION("Starfive JH7110 Power Domain Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 1bc68c0547c1..820a480a6779 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -203,7 +203,7 @@ config SPI_CADENCE
 
 config SPI_CADENCE_QUADSPI
 	tristate "Cadence Quad SPI controller"
-	depends on OF && (ARM || ARM64 || COMPILE_TEST)
+	depends on OF && (ARM || ARM64 || RISCV || COMPILE_TEST)
 	help
 	  Enable support for the Cadence Quad SPI Flash controller.
 
@@ -620,6 +620,14 @@ config SPI_PL022
 	  controller. If you have an embedded system with an AMBA(R)
 	  bus and a PL022 controller, say Y or M here.
 
+config SPI_PL022_STARFIVE
+	tristate "ARM AMBA PL022 SSP controller on StarFive SoC platform"
+	depends on ARM_AMBA && SOC_STARFIVE
+	default n if SPI_PL022
+	help
+	  Say 'Y' or 'M' here if you are building for StarFive SoCs platforms
+	  that contain AMBA(R) PrimeCell PL022 SSP controller core.
+
 config SPI_PPC4xx
 	tristate "PPC4xx SPI Controller"
 	depends on PPC32 && 4xx
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index e1f88bd47ded..507d5ff4255b 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -87,6 +87,7 @@ obj-$(CONFIG_SPI_ORION)			+= spi-orion.o
 obj-$(CONFIG_SPI_PIC32)			+= spi-pic32.o
 obj-$(CONFIG_SPI_PIC32_SQI)		+= spi-pic32-sqi.o
 obj-$(CONFIG_SPI_PL022)			+= spi-pl022.o
+obj-$(CONFIG_SPI_PL022_STARFIVE)	+= spi-pl022-starfive.o
 obj-$(CONFIG_SPI_PPC4xx)		+= spi-ppc4xx.o
 spi-pxa2xx-platform-objs		:= spi-pxa2xx.o spi-pxa2xx-dma.o
 obj-$(CONFIG_SPI_PXA2XX)		+= spi-pxa2xx-platform.o
diff --git a/drivers/spi/spi-pl022-starfive.c b/drivers/spi/spi-pl022-starfive.c
new file mode 100644
index 000000000000..dd68ee34098c
--- /dev/null
+++ b/drivers/spi/spi-pl022-starfive.c
@@ -0,0 +1,2874 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * A driver for the ARM PL022 PrimeCell SSP/SPI bus master.
+ *
+ * Copyright (C) 2008-2012 ST-Ericsson AB
+ * Copyright (C) 2006 STMicroelectronics Pvt. Ltd.
+ *
+ * Author: Linus Walleij <linus.walleij@stericsson.com>
+ *
+ * Initial version inspired by:
+ *	linux-2.6.17-rc3-mm1/drivers/spi/pxa2xx_spi.c
+ * Initial adoption to PL022 by:
+ *      Sachin Verma <sachin.verma@st.com>
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/pl022.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/pm_runtime.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/reset.h>
+#include <linux/platform_device.h>
+#include <linux/clk/clk-conf.h>
+#include <linux/pm_domain.h>
+
+/*
+ * This macro is used to define some register default values.
+ * reg is masked with mask, the OR:ed with an (again masked)
+ * val shifted sb steps to the left.
+ */
+#define SSP_WRITE_BITS(reg, val, mask, sb) \
+	((reg) = (((reg) & ~(mask)) | (((val)<<(sb)) & (mask))))
+
+/*
+ * This macro is also used to define some default values.
+ * It will just shift val by sb steps to the left and mask
+ * the result with mask.
+ */
+#define GEN_MASK_BITS(val, mask, sb) \
+	(((val)<<(sb)) & (mask))
+
+#define DRIVE_TX		0
+#define DO_NOT_DRIVE_TX		1
+
+#define DO_NOT_QUEUE_DMA	0
+#define QUEUE_DMA		1
+
+#define RX_TRANSFER		1
+#define TX_TRANSFER		2
+
+/*
+ * Macros to access SSP Registers with their offsets
+ */
+#define SSP_CR0(r)	(r + 0x000)
+#define SSP_CR1(r)	(r + 0x004)
+#define SSP_DR(r)	(r + 0x008)
+#define SSP_SR(r)	(r + 0x00C)
+#define SSP_CPSR(r)	(r + 0x010)
+#define SSP_IMSC(r)	(r + 0x014)
+#define SSP_RIS(r)	(r + 0x018)
+#define SSP_MIS(r)	(r + 0x01C)
+#define SSP_ICR(r)	(r + 0x020)
+#define SSP_DMACR(r)	(r + 0x024)
+#define SSP_CSR(r)	(r + 0x030) /* vendor extension */
+#define SSP_ITCR(r)	(r + 0x080)
+#define SSP_ITIP(r)	(r + 0x084)
+#define SSP_ITOP(r)	(r + 0x088)
+#define SSP_TDR(r)	(r + 0x08C)
+
+#define SSP_PID0(r)	(r + 0xFE0)
+#define SSP_PID1(r)	(r + 0xFE4)
+#define SSP_PID2(r)	(r + 0xFE8)
+#define SSP_PID3(r)	(r + 0xFEC)
+
+#define SSP_CID0(r)	(r + 0xFF0)
+#define SSP_CID1(r)	(r + 0xFF4)
+#define SSP_CID2(r)	(r + 0xFF8)
+#define SSP_CID3(r)	(r + 0xFFC)
+
+/*
+ * SSP Control Register 0  - SSP_CR0
+ */
+#define SSP_CR0_MASK_DSS	(0x0FUL << 0)
+#define SSP_CR0_MASK_FRF	(0x3UL << 4)
+#define SSP_CR0_MASK_SPO	(0x1UL << 6)
+#define SSP_CR0_MASK_SPH	(0x1UL << 7)
+#define SSP_CR0_MASK_SCR	(0xFFUL << 8)
+
+/*
+ * The ST version of this block moves som bits
+ * in SSP_CR0 and extends it to 32 bits
+ */
+#define SSP_CR0_MASK_DSS_ST	(0x1FUL << 0)
+#define SSP_CR0_MASK_HALFDUP_ST	(0x1UL << 5)
+#define SSP_CR0_MASK_CSS_ST	(0x1FUL << 16)
+#define SSP_CR0_MASK_FRF_ST	(0x3UL << 21)
+
+/*
+ * SSP Control Register 0  - SSP_CR1
+ */
+#define SSP_CR1_MASK_LBM	(0x1UL << 0)
+#define SSP_CR1_MASK_SSE	(0x1UL << 1)
+#define SSP_CR1_MASK_MS		(0x1UL << 2)
+#define SSP_CR1_MASK_SOD	(0x1UL << 3)
+
+/*
+ * The ST version of this block adds some bits
+ * in SSP_CR1
+ */
+#define SSP_CR1_MASK_RENDN_ST	(0x1UL << 4)
+#define SSP_CR1_MASK_TENDN_ST	(0x1UL << 5)
+#define SSP_CR1_MASK_MWAIT_ST	(0x1UL << 6)
+#define SSP_CR1_MASK_RXIFLSEL_ST (0x7UL << 7)
+#define SSP_CR1_MASK_TXIFLSEL_ST (0x7UL << 10)
+/* This one is only in the PL023 variant */
+#define SSP_CR1_MASK_FBCLKDEL_ST (0x7UL << 13)
+
+/*
+ * SSP Status Register - SSP_SR
+ */
+#define SSP_SR_MASK_TFE		(0x1UL << 0) /* Transmit FIFO empty */
+#define SSP_SR_MASK_TNF		(0x1UL << 1) /* Transmit FIFO not full */
+#define SSP_SR_MASK_RNE		(0x1UL << 2) /* Receive FIFO not empty */
+#define SSP_SR_MASK_RFF		(0x1UL << 3) /* Receive FIFO full */
+#define SSP_SR_MASK_BSY		(0x1UL << 4) /* Busy Flag */
+
+/*
+ * SSP Clock Prescale Register  - SSP_CPSR
+ */
+#define SSP_CPSR_MASK_CPSDVSR	(0xFFUL << 0)
+
+/*
+ * SSP Interrupt Mask Set/Clear Register - SSP_IMSC
+ */
+#define SSP_IMSC_MASK_RORIM (0x1UL << 0) /* Receive Overrun Interrupt mask */
+#define SSP_IMSC_MASK_RTIM  (0x1UL << 1) /* Receive timeout Interrupt mask */
+#define SSP_IMSC_MASK_RXIM  (0x1UL << 2) /* Receive FIFO Interrupt mask */
+#define SSP_IMSC_MASK_TXIM  (0x1UL << 3) /* Transmit FIFO Interrupt mask */
+
+/*
+ * SSP Raw Interrupt Status Register - SSP_RIS
+ */
+/* Receive Overrun Raw Interrupt status */
+#define SSP_RIS_MASK_RORRIS		(0x1UL << 0)
+/* Receive Timeout Raw Interrupt status */
+#define SSP_RIS_MASK_RTRIS		(0x1UL << 1)
+/* Receive FIFO Raw Interrupt status */
+#define SSP_RIS_MASK_RXRIS		(0x1UL << 2)
+/* Transmit FIFO Raw Interrupt status */
+#define SSP_RIS_MASK_TXRIS		(0x1UL << 3)
+
+/*
+ * SSP Masked Interrupt Status Register - SSP_MIS
+ */
+/* Receive Overrun Masked Interrupt status */
+#define SSP_MIS_MASK_RORMIS		(0x1UL << 0)
+/* Receive Timeout Masked Interrupt status */
+#define SSP_MIS_MASK_RTMIS		(0x1UL << 1)
+/* Receive FIFO Masked Interrupt status */
+#define SSP_MIS_MASK_RXMIS		(0x1UL << 2)
+/* Transmit FIFO Masked Interrupt status */
+#define SSP_MIS_MASK_TXMIS		(0x1UL << 3)
+
+/*
+ * SSP Interrupt Clear Register - SSP_ICR
+ */
+/* Receive Overrun Raw Clear Interrupt bit */
+#define SSP_ICR_MASK_RORIC		(0x1UL << 0)
+/* Receive Timeout Clear Interrupt bit */
+#define SSP_ICR_MASK_RTIC		(0x1UL << 1)
+
+/*
+ * SSP DMA Control Register - SSP_DMACR
+ */
+/* Receive DMA Enable bit */
+#define SSP_DMACR_MASK_RXDMAE		(0x1UL << 0)
+/* Transmit DMA Enable bit */
+#define SSP_DMACR_MASK_TXDMAE		(0x1UL << 1)
+
+/*
+ * SSP Chip Select Control Register - SSP_CSR
+ * (vendor extension)
+ */
+#define SSP_CSR_CSVALUE_MASK		(0x1FUL << 0)
+
+/*
+ * SSP Integration Test control Register - SSP_ITCR
+ */
+#define SSP_ITCR_MASK_ITEN		(0x1UL << 0)
+#define SSP_ITCR_MASK_TESTFIFO		(0x1UL << 1)
+
+/*
+ * SSP Integration Test Input Register - SSP_ITIP
+ */
+#define ITIP_MASK_SSPRXD		 (0x1UL << 0)
+#define ITIP_MASK_SSPFSSIN		 (0x1UL << 1)
+#define ITIP_MASK_SSPCLKIN		 (0x1UL << 2)
+#define ITIP_MASK_RXDMAC		 (0x1UL << 3)
+#define ITIP_MASK_TXDMAC		 (0x1UL << 4)
+#define ITIP_MASK_SSPTXDIN		 (0x1UL << 5)
+
+/*
+ * SSP Integration Test output Register - SSP_ITOP
+ */
+#define ITOP_MASK_SSPTXD		 (0x1UL << 0)
+#define ITOP_MASK_SSPFSSOUT		 (0x1UL << 1)
+#define ITOP_MASK_SSPCLKOUT		 (0x1UL << 2)
+#define ITOP_MASK_SSPOEn		 (0x1UL << 3)
+#define ITOP_MASK_SSPCTLOEn		 (0x1UL << 4)
+#define ITOP_MASK_RORINTR		 (0x1UL << 5)
+#define ITOP_MASK_RTINTR		 (0x1UL << 6)
+#define ITOP_MASK_RXINTR		 (0x1UL << 7)
+#define ITOP_MASK_TXINTR		 (0x1UL << 8)
+#define ITOP_MASK_INTR			 (0x1UL << 9)
+#define ITOP_MASK_RXDMABREQ		 (0x1UL << 10)
+#define ITOP_MASK_RXDMASREQ		 (0x1UL << 11)
+#define ITOP_MASK_TXDMABREQ		 (0x1UL << 12)
+#define ITOP_MASK_TXDMASREQ		 (0x1UL << 13)
+
+/*
+ * SSP Test Data Register - SSP_TDR
+ */
+#define TDR_MASK_TESTDATA		(0xFFFFFFFF)
+
+/*
+ * Message State
+ * we use the spi_message.state (void *) pointer to
+ * hold a single state value, that's why all this
+ * (void *) casting is done here.
+ */
+#define STATE_START			((void *) 0)
+#define STATE_RUNNING			((void *) 1)
+#define STATE_DONE			((void *) 2)
+#define STATE_ERROR			((void *) -1)
+#define STATE_TIMEOUT			((void *) -2)
+
+/*
+ * SSP State - Whether Enabled or Disabled
+ */
+#define SSP_DISABLED			(0)
+#define SSP_ENABLED			(1)
+
+/*
+ * SSP DMA State - Whether DMA Enabled or Disabled
+ */
+#define SSP_DMA_DISABLED		(0)
+#define SSP_DMA_ENABLED			(1)
+
+/*
+ * SSP Clock Defaults
+ */
+#define SSP_DEFAULT_CLKRATE 0x2
+#define SSP_DEFAULT_PRESCALE 0x40
+
+/*
+ * SSP Clock Parameter ranges
+ */
+#define CPSDVR_MIN 0x02
+#define CPSDVR_MAX 0xFE
+#define SCR_MIN 0x00
+#define SCR_MAX 0xFF
+
+/*
+ * SSP Interrupt related Macros
+ */
+#define DEFAULT_SSP_REG_IMSC  0x0UL
+#define DISABLE_ALL_INTERRUPTS DEFAULT_SSP_REG_IMSC
+#define ENABLE_ALL_INTERRUPTS ( \
+	SSP_IMSC_MASK_RORIM | \
+	SSP_IMSC_MASK_RTIM | \
+	SSP_IMSC_MASK_RXIM | \
+	SSP_IMSC_MASK_TXIM \
+)
+
+#define CLEAR_ALL_INTERRUPTS  0x3
+
+#define SPI_POLLING_TIMEOUT 1000
+
+/*
+ * The type of reading going on in this chip
+ */
+enum ssp_reading {
+	READING_NULL,
+	READING_U8,
+	READING_U16,
+	READING_U32
+};
+
+/*
+ * The type of writing going on in this chip
+ */
+enum ssp_writing {
+	WRITING_NULL,
+	WRITING_U8,
+	WRITING_U16,
+	WRITING_U32
+};
+
+/**
+ * struct vendor_data - vendor-specific config parameters
+ * for PL022 derivates
+ * @fifodepth: depth of FIFOs (both)
+ * @max_bpw: maximum number of bits per word
+ * @unidir: supports unidirection transfers
+ * @extended_cr: 32 bit wide control register 0 with extra
+ * features and extra features in CR1 as found in the ST variants
+ * @pl023: supports a subset of the ST extensions called "PL023"
+ * @loopback: supports loopback mode
+ * @internal_cs_ctrl: supports chip select control register
+ */
+struct vendor_data {
+	int fifodepth;
+	int max_bpw;
+	bool unidir;
+	bool extended_cr;
+	bool pl023;
+	bool loopback;
+	bool internal_cs_ctrl;
+};
+
+/**
+ * struct pl022 - This is the private SSP driver data structure
+ * @adev: AMBA device model hookup
+ * @vendor: vendor data for the IP block
+ * @phybase: the physical memory where the SSP device resides
+ * @virtbase: the virtual memory where the SSP is mapped
+ * @clk: outgoing clock "SPICLK" for the SPI bus
+ * @master: SPI framework hookup
+ * @master_info: controller-specific data from machine setup
+ * @pump_transfers: Tasklet used in Interrupt Transfer mode
+ * @cur_msg: Pointer to current spi_message being processed
+ * @cur_transfer: Pointer to current spi_transfer
+ * @cur_chip: pointer to current clients chip(assigned from controller_state)
+ * @next_msg_cs_active: the next message in the queue has been examined
+ *  and it was found that it uses the same chip select as the previous
+ *  message, so we left it active after the previous transfer, and it's
+ *  active already.
+ * @tx: current position in TX buffer to be read
+ * @tx_end: end position in TX buffer to be read
+ * @rx: current position in RX buffer to be written
+ * @rx_end: end position in RX buffer to be written
+ * @read: the type of read currently going on
+ * @write: the type of write currently going on
+ * @exp_fifo_level: expected FIFO level
+ * @rx_lev_trig: receive FIFO watermark level which triggers IRQ
+ * @tx_lev_trig: transmit FIFO watermark level which triggers IRQ
+ * @dma_rx_channel: optional channel for RX DMA
+ * @dma_tx_channel: optional channel for TX DMA
+ * @sgt_rx: scattertable for the RX transfer
+ * @sgt_tx: scattertable for the TX transfer
+ * @dummypage: a dummy page used for driving data on the bus with DMA
+ * @dma_running: indicates whether DMA is in operation
+ * @cur_cs: current chip select (gpio)
+ * @chipselects: list of chipselects (gpios)
+ */
+struct pl022 {
+	struct amba_device		*adev;
+	struct vendor_data		*vendor;
+	resource_size_t			phybase;
+	void __iomem			*virtbase;
+	struct clk			*clk;
+	struct reset_control		*rst;
+	struct spi_master		*master;
+	struct pl022_ssp_controller	*master_info;
+	/* Message per-transfer pump */
+	struct tasklet_struct		pump_transfers;
+	struct spi_message		*cur_msg;
+	struct spi_transfer		*cur_transfer;
+	struct chip_data		*cur_chip;
+	bool				next_msg_cs_active;
+	void				*tx;
+	void				*tx_end;
+	void				*rx;
+	void				*rx_end;
+	enum ssp_reading		read;
+	enum ssp_writing		write;
+	u32				exp_fifo_level;
+	enum ssp_rx_level_trig		rx_lev_trig;
+	enum ssp_tx_level_trig		tx_lev_trig;
+	/* DMA settings */
+#ifdef CONFIG_DMA_ENGINE
+	struct dma_chan			*dma_rx_channel;
+	struct dma_chan			*dma_tx_channel;
+	struct sg_table			sgt_rx;
+	struct sg_table			sgt_tx;
+	char				*dummypage;
+	bool				dma_running;
+#endif
+	int cur_cs;
+	int *chipselects;
+};
+
+/**
+ * struct chip_data - To maintain runtime state of SSP for each client chip
+ * @cr0: Value of control register CR0 of SSP - on later ST variants this
+ *       register is 32 bits wide rather than just 16
+ * @cr1: Value of control register CR1 of SSP
+ * @dmacr: Value of DMA control Register of SSP
+ * @cpsr: Value of Clock prescale register
+ * @n_bytes: how many bytes(power of 2) reqd for a given data width of client
+ * @enable_dma: Whether to enable DMA or not
+ * @read: function ptr to be used to read when doing xfer for this chip
+ * @write: function ptr to be used to write when doing xfer for this chip
+ * @cs_control: chip select callback provided by chip
+ * @xfer_type: polling/interrupt/DMA
+ *
+ * Runtime state of the SSP controller, maintained per chip,
+ * This would be set according to the current message that would be served
+ */
+struct chip_data {
+	u32 cr0;
+	u16 cr1;
+	u16 dmacr;
+	u16 cpsr;
+	u8 n_bytes;
+	bool enable_dma;
+	enum ssp_reading read;
+	enum ssp_writing write;
+	void (*cs_control)(u32 command);
+	int xfer_type;
+};
+
+/**
+ * null_cs_control - Dummy chip select function
+ * @command: select/delect the chip
+ *
+ * If no chip select function is provided by client this is used as dummy
+ * chip select
+ */
+static void null_cs_control(u32 command)
+{
+	pr_debug("pl022: dummy chip select control, CS=0x%x\n", command);
+}
+
+/**
+ * internal_cs_control - Control chip select signals via SSP_CSR.
+ * @pl022: SSP driver private data structure
+ * @command: select/delect the chip
+ *
+ * Used on controller with internal chip select control via SSP_CSR register
+ * (vendor extension). Each of the 5 LSB in the register controls one chip
+ * select signal.
+ */
+static void internal_cs_control(struct pl022 *pl022, u32 command)
+{
+	u32 tmp;
+
+	tmp = readw(SSP_CSR(pl022->virtbase));
+	if (command == SSP_CHIP_SELECT)
+		tmp &= ~BIT(pl022->cur_cs);
+	else
+		tmp |= BIT(pl022->cur_cs);
+	writew(tmp, SSP_CSR(pl022->virtbase));
+}
+
+static void pl022_cs_control(struct pl022 *pl022, u32 command)
+{
+	if (pl022->vendor->internal_cs_ctrl)
+		internal_cs_control(pl022, command);
+	else if (gpio_is_valid(pl022->cur_cs))
+		gpio_set_value(pl022->cur_cs, command);
+	else
+		pl022->cur_chip->cs_control(command);
+}
+
+/**
+ * giveback - current spi_message is over, schedule next message and call
+ * callback of this message. Assumes that caller already
+ * set message->status; dma and pio irqs are blocked
+ * @pl022: SSP driver private data structure
+ */
+static void giveback(struct pl022 *pl022)
+{
+	struct spi_transfer *last_transfer;
+
+	pl022->next_msg_cs_active = false;
+
+	last_transfer = list_last_entry(&pl022->cur_msg->transfers,
+					struct spi_transfer, transfer_list);
+
+	/* Delay if requested before any change in chip select */
+	/*
+	 * FIXME: This runs in interrupt context.
+	 * Is this really smart?
+	 */
+	spi_transfer_delay_exec(last_transfer);
+
+	if (!last_transfer->cs_change) {
+		struct spi_message *next_msg;
+
+		/*
+		 * cs_change was not set. We can keep the chip select
+		 * enabled if there is message in the queue and it is
+		 * for the same spi device.
+		 *
+		 * We cannot postpone this until pump_messages, because
+		 * after calling msg->complete (below) the driver that
+		 * sent the current message could be unloaded, which
+		 * could invalidate the cs_control() callback...
+		 */
+		/* get a pointer to the next message, if any */
+		next_msg = spi_get_next_queued_message(pl022->master);
+
+		/*
+		 * see if the next and current messages point
+		 * to the same spi device.
+		 */
+		if (next_msg && next_msg->spi != pl022->cur_msg->spi)
+			next_msg = NULL;
+		if (!next_msg || pl022->cur_msg->state == STATE_ERROR)
+			pl022_cs_control(pl022, SSP_CHIP_DESELECT);
+		else
+			pl022->next_msg_cs_active = true;
+
+	}
+
+	pl022->cur_msg = NULL;
+	pl022->cur_transfer = NULL;
+	pl022->cur_chip = NULL;
+
+	/* disable the SPI/SSP operation */
+	writew((readw(SSP_CR1(pl022->virtbase)) &
+		(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));
+
+	spi_finalize_current_message(pl022->master);
+}
+
+/**
+ * flush - flush the FIFO to reach a clean state
+ * @pl022: SSP driver private data structure
+ */
+static int flush(struct pl022 *pl022)
+{
+	unsigned long limit = loops_per_jiffy << 1;
+
+	dev_dbg(&pl022->adev->dev, "%s\n", __func__);
+	do {
+		while (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
+			readw(SSP_DR(pl022->virtbase));
+	} while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_BSY) && limit--);
+
+	pl022->exp_fifo_level = 0;
+
+	return limit;
+}
+
+/**
+ * restore_state - Load configuration of current chip
+ * @pl022: SSP driver private data structure
+ */
+static void restore_state(struct pl022 *pl022)
+{
+	struct chip_data *chip = pl022->cur_chip;
+
+	if (pl022->vendor->extended_cr)
+		writel(chip->cr0, SSP_CR0(pl022->virtbase));
+	else
+		writew(chip->cr0, SSP_CR0(pl022->virtbase));
+	writew(chip->cr1, SSP_CR1(pl022->virtbase));
+	writew(chip->dmacr, SSP_DMACR(pl022->virtbase));
+	writew(chip->cpsr, SSP_CPSR(pl022->virtbase));
+	writew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(pl022->virtbase));
+	writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
+}
+
+/*
+ * Default SSP Register Values
+ */
+#define DEFAULT_SSP_REG_CR0 ( \
+	GEN_MASK_BITS(SSP_DATA_BITS_12, SSP_CR0_MASK_DSS, 0)	| \
+	GEN_MASK_BITS(SSP_INTERFACE_MOTOROLA_SPI, SSP_CR0_MASK_FRF, 4) | \
+	GEN_MASK_BITS(SSP_CLK_POL_IDLE_LOW, SSP_CR0_MASK_SPO, 6) | \
+	GEN_MASK_BITS(SSP_CLK_SECOND_EDGE, SSP_CR0_MASK_SPH, 7) | \
+	GEN_MASK_BITS(SSP_DEFAULT_CLKRATE, SSP_CR0_MASK_SCR, 8) \
+)
+
+/* ST versions have slightly different bit layout */
+#define DEFAULT_SSP_REG_CR0_ST ( \
+	GEN_MASK_BITS(SSP_DATA_BITS_12, SSP_CR0_MASK_DSS_ST, 0)	| \
+	GEN_MASK_BITS(SSP_MICROWIRE_CHANNEL_FULL_DUPLEX, SSP_CR0_MASK_HALFDUP_ST, 5) | \
+	GEN_MASK_BITS(SSP_CLK_POL_IDLE_LOW, SSP_CR0_MASK_SPO, 6) | \
+	GEN_MASK_BITS(SSP_CLK_SECOND_EDGE, SSP_CR0_MASK_SPH, 7) | \
+	GEN_MASK_BITS(SSP_DEFAULT_CLKRATE, SSP_CR0_MASK_SCR, 8) | \
+	GEN_MASK_BITS(SSP_BITS_8, SSP_CR0_MASK_CSS_ST, 16)	| \
+	GEN_MASK_BITS(SSP_INTERFACE_MOTOROLA_SPI, SSP_CR0_MASK_FRF_ST, 21) \
+)
+
+/* The PL023 version is slightly different again */
+#define DEFAULT_SSP_REG_CR0_ST_PL023 ( \
+	GEN_MASK_BITS(SSP_DATA_BITS_12, SSP_CR0_MASK_DSS_ST, 0)	| \
+	GEN_MASK_BITS(SSP_CLK_POL_IDLE_LOW, SSP_CR0_MASK_SPO, 6) | \
+	GEN_MASK_BITS(SSP_CLK_SECOND_EDGE, SSP_CR0_MASK_SPH, 7) | \
+	GEN_MASK_BITS(SSP_DEFAULT_CLKRATE, SSP_CR0_MASK_SCR, 8) \
+)
+
+#define DEFAULT_SSP_REG_CR1 ( \
+	GEN_MASK_BITS(LOOPBACK_DISABLED, SSP_CR1_MASK_LBM, 0) | \
+	GEN_MASK_BITS(SSP_DISABLED, SSP_CR1_MASK_SSE, 1) | \
+	GEN_MASK_BITS(SSP_MASTER, SSP_CR1_MASK_MS, 2) | \
+	GEN_MASK_BITS(DO_NOT_DRIVE_TX, SSP_CR1_MASK_SOD, 3) \
+)
+
+/* ST versions extend this register to use all 16 bits */
+#define DEFAULT_SSP_REG_CR1_ST ( \
+	DEFAULT_SSP_REG_CR1 | \
+	GEN_MASK_BITS(SSP_RX_MSB, SSP_CR1_MASK_RENDN_ST, 4) | \
+	GEN_MASK_BITS(SSP_TX_MSB, SSP_CR1_MASK_TENDN_ST, 5) | \
+	GEN_MASK_BITS(SSP_MWIRE_WAIT_ZERO, SSP_CR1_MASK_MWAIT_ST, 6) |\
+	GEN_MASK_BITS(SSP_RX_1_OR_MORE_ELEM, SSP_CR1_MASK_RXIFLSEL_ST, 7) | \
+	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, SSP_CR1_MASK_TXIFLSEL_ST, 10) \
+)
+
+/*
+ * The PL023 variant has further differences: no loopback mode, no microwire
+ * support, and a new clock feedback delay setting.
+ */
+#define DEFAULT_SSP_REG_CR1_ST_PL023 ( \
+	GEN_MASK_BITS(SSP_DISABLED, SSP_CR1_MASK_SSE, 1) | \
+	GEN_MASK_BITS(SSP_MASTER, SSP_CR1_MASK_MS, 2) | \
+	GEN_MASK_BITS(DO_NOT_DRIVE_TX, SSP_CR1_MASK_SOD, 3) | \
+	GEN_MASK_BITS(SSP_RX_MSB, SSP_CR1_MASK_RENDN_ST, 4) | \
+	GEN_MASK_BITS(SSP_TX_MSB, SSP_CR1_MASK_TENDN_ST, 5) | \
+	GEN_MASK_BITS(SSP_RX_1_OR_MORE_ELEM, SSP_CR1_MASK_RXIFLSEL_ST, 7) | \
+	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, SSP_CR1_MASK_TXIFLSEL_ST, 10) | \
+	GEN_MASK_BITS(SSP_FEEDBACK_CLK_DELAY_NONE, SSP_CR1_MASK_FBCLKDEL_ST, 13) \
+)
+
+#define DEFAULT_SSP_REG_CPSR ( \
+	GEN_MASK_BITS(SSP_DEFAULT_PRESCALE, SSP_CPSR_MASK_CPSDVSR, 0) \
+)
+
+#define DEFAULT_SSP_REG_DMACR (\
+	GEN_MASK_BITS(SSP_DMA_DISABLED, SSP_DMACR_MASK_RXDMAE, 0) | \
+	GEN_MASK_BITS(SSP_DMA_DISABLED, SSP_DMACR_MASK_TXDMAE, 1) \
+)
+
+/**
+ * load_ssp_default_config - Load default configuration for SSP
+ * @pl022: SSP driver private data structure
+ */
+static void load_ssp_default_config(struct pl022 *pl022)
+{
+	if (pl022->vendor->pl023) {
+		writel(DEFAULT_SSP_REG_CR0_ST_PL023, SSP_CR0(pl022->virtbase));
+		writew(DEFAULT_SSP_REG_CR1_ST_PL023, SSP_CR1(pl022->virtbase));
+	} else if (pl022->vendor->extended_cr) {
+		writel(DEFAULT_SSP_REG_CR0_ST, SSP_CR0(pl022->virtbase));
+		writew(DEFAULT_SSP_REG_CR1_ST, SSP_CR1(pl022->virtbase));
+	} else {
+		writew(DEFAULT_SSP_REG_CR0, SSP_CR0(pl022->virtbase));
+		writew(DEFAULT_SSP_REG_CR1, SSP_CR1(pl022->virtbase));
+	}
+	writew(DEFAULT_SSP_REG_DMACR, SSP_DMACR(pl022->virtbase));
+	writew(DEFAULT_SSP_REG_CPSR, SSP_CPSR(pl022->virtbase));
+	writew(DISABLE_ALL_INTERRUPTS, SSP_IMSC(pl022->virtbase));
+	writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
+}
+
+/*
+ * This will write to TX and read from RX according to the parameters
+ * set in pl022.
+ */
+static void readwriter(struct pl022 *pl022)
+{
+	/*
+	 * The FIFO depth is different between primecell variants.
+	 * I believe filling in too much in the FIFO might cause
+	 * errons in 8bit wide transfers on ARM variants (just 8 words
+	 * FIFO, means only 8x8 = 64 bits in FIFO) at least.
+	 *
+	 * To prevent this issue, the TX FIFO is only filled to the
+	 * unused RX FIFO fill length, regardless of what the TX
+	 * FIFO status flag indicates.
+	 */
+	dev_dbg(&pl022->adev->dev,
+		"%s, rx: %p, rxend: %p, tx: %p, txend: %p\n",
+		__func__, pl022->rx, pl022->rx_end, pl022->tx, pl022->tx_end);
+
+	/* Read as much as you can */
+	while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
+	       && (pl022->rx < pl022->rx_end)) {
+		switch (pl022->read) {
+		case READING_NULL:
+			readw(SSP_DR(pl022->virtbase));
+			break;
+		case READING_U8:
+			*(u8 *) (pl022->rx) =
+				readw(SSP_DR(pl022->virtbase)) & 0xFFU;
+			break;
+		case READING_U16:
+			*(u16 *) (pl022->rx) =
+				(u16) readw(SSP_DR(pl022->virtbase));
+			break;
+		case READING_U32:
+			*(u32 *) (pl022->rx) =
+				readl(SSP_DR(pl022->virtbase));
+			break;
+		}
+		pl022->rx += (pl022->cur_chip->n_bytes);
+		pl022->exp_fifo_level--;
+	}
+	/*
+	 * Write as much as possible up to the RX FIFO size
+	 */
+	while ((pl022->exp_fifo_level < pl022->vendor->fifodepth)
+	       && (pl022->tx < pl022->tx_end)) {
+		switch (pl022->write) {
+		case WRITING_NULL:
+			writew(0x0, SSP_DR(pl022->virtbase));
+			break;
+		case WRITING_U8:
+			writew(*(u8 *) (pl022->tx), SSP_DR(pl022->virtbase));
+			break;
+		case WRITING_U16:
+			writew((*(u16 *) (pl022->tx)), SSP_DR(pl022->virtbase));
+			break;
+		case WRITING_U32:
+			writel(*(u32 *) (pl022->tx), SSP_DR(pl022->virtbase));
+			break;
+		}
+		pl022->tx += (pl022->cur_chip->n_bytes);
+		pl022->exp_fifo_level++;
+		/*
+		 * This inner reader takes care of things appearing in the RX
+		 * FIFO as we're transmitting. This will happen a lot since the
+		 * clock starts running when you put things into the TX FIFO,
+		 * and then things are continuously clocked into the RX FIFO.
+		 */
+		while ((readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE)
+		       && (pl022->rx < pl022->rx_end)) {
+			switch (pl022->read) {
+			case READING_NULL:
+				readw(SSP_DR(pl022->virtbase));
+				break;
+			case READING_U8:
+				*(u8 *) (pl022->rx) =
+					readw(SSP_DR(pl022->virtbase)) & 0xFFU;
+				break;
+			case READING_U16:
+				*(u16 *) (pl022->rx) =
+					(u16) readw(SSP_DR(pl022->virtbase));
+				break;
+			case READING_U32:
+				*(u32 *) (pl022->rx) =
+					readl(SSP_DR(pl022->virtbase));
+				break;
+			}
+			pl022->rx += (pl022->cur_chip->n_bytes);
+			pl022->exp_fifo_level--;
+		}
+	}
+	/*
+	 * When we exit here the TX FIFO should be full and the RX FIFO
+	 * should be empty
+	 */
+}
+
+/**
+ * next_transfer - Move to the Next transfer in the current spi message
+ * @pl022: SSP driver private data structure
+ *
+ * This function moves though the linked list of spi transfers in the
+ * current spi message and returns with the state of current spi
+ * message i.e whether its last transfer is done(STATE_DONE) or
+ * Next transfer is ready(STATE_RUNNING)
+ */
+static void *next_transfer(struct pl022 *pl022)
+{
+	struct spi_message *msg = pl022->cur_msg;
+	struct spi_transfer *trans = pl022->cur_transfer;
+
+	/* Move to next transfer */
+	if (trans->transfer_list.next != &msg->transfers) {
+		pl022->cur_transfer =
+		    list_entry(trans->transfer_list.next,
+			       struct spi_transfer, transfer_list);
+		return STATE_RUNNING;
+	}
+	return STATE_DONE;
+}
+
+/*
+ * This DMA functionality is only compiled in if we have
+ * access to the generic DMA devices/DMA engine.
+ */
+#ifdef CONFIG_DMA_ENGINE
+static void unmap_free_dma_scatter(struct pl022 *pl022)
+{
+	/* Unmap and free the SG tables */
+	dma_unmap_sg(pl022->dma_tx_channel->device->dev, pl022->sgt_tx.sgl,
+		     pl022->sgt_tx.nents, DMA_TO_DEVICE);
+	dma_unmap_sg(pl022->dma_rx_channel->device->dev, pl022->sgt_rx.sgl,
+		     pl022->sgt_rx.nents, DMA_FROM_DEVICE);
+	sg_free_table(&pl022->sgt_rx);
+	sg_free_table(&pl022->sgt_tx);
+}
+
+static void dma_callback(void *data)
+{
+	struct pl022 *pl022 = data;
+	struct spi_message *msg = pl022->cur_msg;
+
+	BUG_ON(!pl022->sgt_rx.sgl);
+
+#ifdef VERBOSE_DEBUG
+	/*
+	 * Optionally dump out buffers to inspect contents, this is
+	 * good if you want to convince yourself that the loopback
+	 * read/write contents are the same, when adopting to a new
+	 * DMA engine.
+	 */
+	{
+		struct scatterlist *sg;
+		unsigned int i;
+
+		dma_sync_sg_for_cpu(&pl022->adev->dev,
+				    pl022->sgt_rx.sgl,
+				    pl022->sgt_rx.nents,
+				    DMA_FROM_DEVICE);
+
+		for_each_sg(pl022->sgt_rx.sgl, sg, pl022->sgt_rx.nents, i) {
+			dev_dbg(&pl022->adev->dev, "SPI RX SG ENTRY: %d", i);
+			print_hex_dump(KERN_ERR, "SPI RX: ",
+				       DUMP_PREFIX_OFFSET,
+				       16,
+				       1,
+				       sg_virt(sg),
+				       sg_dma_len(sg),
+				       1);
+		}
+		for_each_sg(pl022->sgt_tx.sgl, sg, pl022->sgt_tx.nents, i) {
+			dev_dbg(&pl022->adev->dev, "SPI TX SG ENTRY: %d", i);
+			print_hex_dump(KERN_ERR, "SPI TX: ",
+				       DUMP_PREFIX_OFFSET,
+				       16,
+				       1,
+				       sg_virt(sg),
+				       sg_dma_len(sg),
+				       1);
+		}
+	}
+#endif
+
+	unmap_free_dma_scatter(pl022);
+
+	/* Update total bytes transferred */
+	msg->actual_length += pl022->cur_transfer->len;
+	/* Move to next transfer */
+	msg->state = next_transfer(pl022);
+	if (msg->state != STATE_DONE && pl022->cur_transfer->cs_change)
+		pl022_cs_control(pl022, SSP_CHIP_DESELECT);
+	tasklet_schedule(&pl022->pump_transfers);
+}
+
+static void setup_dma_scatter(struct pl022 *pl022,
+			      void *buffer,
+			      unsigned int length,
+			      struct sg_table *sgtab)
+{
+	struct scatterlist *sg;
+	int bytesleft = length;
+	void *bufp = buffer;
+	int mapbytes;
+	int i;
+
+	if (buffer) {
+		for_each_sg(sgtab->sgl, sg, sgtab->nents, i) {
+			/*
+			 * If there are less bytes left than what fits
+			 * in the current page (plus page alignment offset)
+			 * we just feed in this, else we stuff in as much
+			 * as we can.
+			 */
+			if (bytesleft < (PAGE_SIZE - offset_in_page(bufp)))
+				mapbytes = bytesleft;
+			else
+				mapbytes = PAGE_SIZE - offset_in_page(bufp);
+			sg_set_page(sg, virt_to_page(bufp),
+				    mapbytes, offset_in_page(bufp));
+			bufp += mapbytes;
+			bytesleft -= mapbytes;
+			dev_dbg(&pl022->adev->dev,
+				"set RX/TX target page @ %p, %d bytes, %d left\n",
+				bufp, mapbytes, bytesleft);
+		}
+	} else {
+		/* Map the dummy buffer on every page */
+		for_each_sg(sgtab->sgl, sg, sgtab->nents, i) {
+			if (bytesleft < PAGE_SIZE)
+				mapbytes = bytesleft;
+			else
+				mapbytes = PAGE_SIZE;
+			sg_set_page(sg, virt_to_page(pl022->dummypage),
+				    mapbytes, 0);
+			bytesleft -= mapbytes;
+			dev_dbg(&pl022->adev->dev,
+				"set RX/TX to dummy page %d bytes, %d left\n",
+				mapbytes, bytesleft);
+
+		}
+	}
+	BUG_ON(bytesleft);
+}
+
+/**
+ * configure_dma - configures the channels for the next transfer
+ * @pl022: SSP driver's private data structure
+ */
+static int configure_dma(struct pl022 *pl022)
+{
+	struct dma_slave_config rx_conf = {
+		.src_addr = SSP_DR(pl022->phybase),
+		.direction = DMA_DEV_TO_MEM,
+		.device_fc = false,
+	};
+	struct dma_slave_config tx_conf = {
+		.dst_addr = SSP_DR(pl022->phybase),
+		.direction = DMA_MEM_TO_DEV,
+		.device_fc = false,
+	};
+	unsigned int pages;
+	int ret;
+	int rx_sglen, tx_sglen;
+	struct dma_chan *rxchan = pl022->dma_rx_channel;
+	struct dma_chan *txchan = pl022->dma_tx_channel;
+	struct dma_async_tx_descriptor *rxdesc;
+	struct dma_async_tx_descriptor *txdesc;
+
+	/* Check that the channels are available */
+	if (!rxchan || !txchan)
+		return -ENODEV;
+
+	/*
+	 * If supplied, the DMA burstsize should equal the FIFO trigger level.
+	 * Notice that the DMA engine uses one-to-one mapping. Since we can
+	 * not trigger on 2 elements this needs explicit mapping rather than
+	 * calculation.
+	 */
+	switch (pl022->rx_lev_trig) {
+	case SSP_RX_1_OR_MORE_ELEM:
+		rx_conf.src_maxburst = 1;
+		break;
+	case SSP_RX_4_OR_MORE_ELEM:
+		rx_conf.src_maxburst = 4;
+		break;
+	case SSP_RX_8_OR_MORE_ELEM:
+		rx_conf.src_maxburst = 8;
+		break;
+	case SSP_RX_16_OR_MORE_ELEM:
+		rx_conf.src_maxburst = 16;
+		break;
+	case SSP_RX_32_OR_MORE_ELEM:
+		rx_conf.src_maxburst = 32;
+		break;
+	default:
+		rx_conf.src_maxburst = pl022->vendor->fifodepth >> 1;
+		break;
+	}
+
+	switch (pl022->tx_lev_trig) {
+	case SSP_TX_1_OR_MORE_EMPTY_LOC:
+		tx_conf.dst_maxburst = 1;
+		break;
+	case SSP_TX_4_OR_MORE_EMPTY_LOC:
+		tx_conf.dst_maxburst = 4;
+		break;
+	case SSP_TX_8_OR_MORE_EMPTY_LOC:
+		tx_conf.dst_maxburst = 8;
+		break;
+	case SSP_TX_16_OR_MORE_EMPTY_LOC:
+		tx_conf.dst_maxburst = 16;
+		break;
+	case SSP_TX_32_OR_MORE_EMPTY_LOC:
+		tx_conf.dst_maxburst = 32;
+		break;
+	default:
+		tx_conf.dst_maxburst = pl022->vendor->fifodepth >> 1;
+		break;
+	}
+
+	switch (pl022->read) {
+	case READING_NULL:
+		/* Use the same as for writing */
+		rx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
+		break;
+	case READING_U8:
+		rx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+		break;
+	case READING_U16:
+		rx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case READING_U32:
+		rx_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	}
+
+	switch (pl022->write) {
+	case WRITING_NULL:
+		/* Use the same as for reading */
+		tx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_UNDEFINED;
+		break;
+	case WRITING_U8:
+		tx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+		break;
+	case WRITING_U16:
+		tx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case WRITING_U32:
+		tx_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	}
+
+	/* SPI pecularity: we need to read and write the same width */
+	if (rx_conf.src_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)
+		rx_conf.src_addr_width = tx_conf.dst_addr_width;
+	if (tx_conf.dst_addr_width == DMA_SLAVE_BUSWIDTH_UNDEFINED)
+		tx_conf.dst_addr_width = rx_conf.src_addr_width;
+	BUG_ON(rx_conf.src_addr_width != tx_conf.dst_addr_width);
+
+	dmaengine_slave_config(rxchan, &rx_conf);
+	dmaengine_slave_config(txchan, &tx_conf);
+
+	/* Create sglists for the transfers */
+	pages = DIV_ROUND_UP(pl022->cur_transfer->len, PAGE_SIZE);
+	dev_dbg(&pl022->adev->dev, "using %d pages for transfer\n", pages);
+
+	ret = sg_alloc_table(&pl022->sgt_rx, pages, GFP_ATOMIC);
+	if (ret)
+		goto err_alloc_rx_sg;
+
+	ret = sg_alloc_table(&pl022->sgt_tx, pages, GFP_ATOMIC);
+	if (ret)
+		goto err_alloc_tx_sg;
+
+	/* Fill in the scatterlists for the RX+TX buffers */
+	setup_dma_scatter(pl022, pl022->rx,
+			  pl022->cur_transfer->len, &pl022->sgt_rx);
+	setup_dma_scatter(pl022, pl022->tx,
+			  pl022->cur_transfer->len, &pl022->sgt_tx);
+
+	/* Map DMA buffers */
+	rx_sglen = dma_map_sg(rxchan->device->dev, pl022->sgt_rx.sgl,
+			   pl022->sgt_rx.nents, DMA_FROM_DEVICE);
+	if (!rx_sglen)
+		goto err_rx_sgmap;
+
+	tx_sglen = dma_map_sg(txchan->device->dev, pl022->sgt_tx.sgl,
+			   pl022->sgt_tx.nents, DMA_TO_DEVICE);
+	if (!tx_sglen)
+		goto err_tx_sgmap;
+
+	/* Send both scatterlists */
+	rxdesc = dmaengine_prep_slave_sg(rxchan,
+				      pl022->sgt_rx.sgl,
+				      rx_sglen,
+				      DMA_DEV_TO_MEM,
+				      DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!rxdesc)
+		goto err_rxdesc;
+
+	txdesc = dmaengine_prep_slave_sg(txchan,
+				      pl022->sgt_tx.sgl,
+				      tx_sglen,
+				      DMA_MEM_TO_DEV,
+				      DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!txdesc)
+		goto err_txdesc;
+
+	/* Put the callback on the RX transfer only, that should finish last */
+	rxdesc->callback = dma_callback;
+	rxdesc->callback_param = pl022;
+
+	/* Submit and fire RX and TX with TX last so we're ready to read! */
+	dmaengine_submit(rxdesc);
+	dmaengine_submit(txdesc);
+	dma_async_issue_pending(rxchan);
+	dma_async_issue_pending(txchan);
+	pl022->dma_running = true;
+
+	return 0;
+
+err_txdesc:
+	dmaengine_terminate_all(txchan);
+err_rxdesc:
+	dmaengine_terminate_all(rxchan);
+	dma_unmap_sg(txchan->device->dev, pl022->sgt_tx.sgl,
+		     pl022->sgt_tx.nents, DMA_TO_DEVICE);
+err_tx_sgmap:
+	dma_unmap_sg(rxchan->device->dev, pl022->sgt_rx.sgl,
+		     pl022->sgt_rx.nents, DMA_FROM_DEVICE);
+err_rx_sgmap:
+	sg_free_table(&pl022->sgt_tx);
+err_alloc_tx_sg:
+	sg_free_table(&pl022->sgt_rx);
+err_alloc_rx_sg:
+	return -ENOMEM;
+}
+
+static int pl022_dma_probe(struct pl022 *pl022)
+{
+	dma_cap_mask_t mask;
+
+	/* Try to acquire a generic DMA engine slave channel */
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+	/*
+	 * We need both RX and TX channels to do DMA, else do none
+	 * of them.
+	 */
+	pl022->dma_rx_channel = dma_request_channel(mask,
+					    pl022->master_info->dma_filter,
+					    pl022->master_info->dma_rx_param);
+	if (!pl022->dma_rx_channel) {
+		dev_dbg(&pl022->adev->dev, "no RX DMA channel!\n");
+		goto err_no_rxchan;
+	}
+
+	pl022->dma_tx_channel = dma_request_channel(mask,
+					    pl022->master_info->dma_filter,
+					    pl022->master_info->dma_tx_param);
+	if (!pl022->dma_tx_channel) {
+		dev_dbg(&pl022->adev->dev, "no TX DMA channel!\n");
+		goto err_no_txchan;
+	}
+
+	pl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!pl022->dummypage)
+		goto err_no_dummypage;
+
+	dev_info(&pl022->adev->dev, "setup for DMA on RX %s, TX %s\n",
+		 dma_chan_name(pl022->dma_rx_channel),
+		 dma_chan_name(pl022->dma_tx_channel));
+
+	return 0;
+
+err_no_dummypage:
+	dma_release_channel(pl022->dma_tx_channel);
+err_no_txchan:
+	dma_release_channel(pl022->dma_rx_channel);
+	pl022->dma_rx_channel = NULL;
+err_no_rxchan:
+	dev_err(&pl022->adev->dev,
+			"Failed to work in dma mode, work without dma!\n");
+	return -ENODEV;
+}
+
+static int pl022_dma_autoprobe(struct pl022 *pl022)
+{
+	struct device *dev = &pl022->adev->dev;
+	struct dma_chan *chan;
+	int err;
+
+	/* automatically configure DMA channels from platform, normally using DT */
+	chan = dma_request_chan(dev, "rx");
+	if (IS_ERR(chan)) {
+		err = PTR_ERR(chan);
+		goto err_no_rxchan;
+	}
+
+	pl022->dma_rx_channel = chan;
+
+	chan = dma_request_chan(dev, "tx");
+	if (IS_ERR(chan)) {
+		err = PTR_ERR(chan);
+		goto err_no_txchan;
+	}
+
+	pl022->dma_tx_channel = chan;
+
+	pl022->dummypage = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!pl022->dummypage) {
+		err = -ENOMEM;
+		goto err_no_dummypage;
+	}
+
+	return 0;
+
+err_no_dummypage:
+	dma_release_channel(pl022->dma_tx_channel);
+	pl022->dma_tx_channel = NULL;
+err_no_txchan:
+	dma_release_channel(pl022->dma_rx_channel);
+	pl022->dma_rx_channel = NULL;
+err_no_rxchan:
+	return err;
+}
+
+static void terminate_dma(struct pl022 *pl022)
+{
+	struct dma_chan *rxchan = pl022->dma_rx_channel;
+	struct dma_chan *txchan = pl022->dma_tx_channel;
+
+	dmaengine_terminate_all(rxchan);
+	dmaengine_terminate_all(txchan);
+	unmap_free_dma_scatter(pl022);
+	pl022->dma_running = false;
+}
+
+static void pl022_dma_remove(struct pl022 *pl022)
+{
+	if (pl022->dma_running)
+		terminate_dma(pl022);
+	if (pl022->dma_tx_channel)
+		dma_release_channel(pl022->dma_tx_channel);
+	if (pl022->dma_rx_channel)
+		dma_release_channel(pl022->dma_rx_channel);
+	kfree(pl022->dummypage);
+}
+
+#else
+static inline int configure_dma(struct pl022 *pl022)
+{
+	return -ENODEV;
+}
+
+static inline int pl022_dma_autoprobe(struct pl022 *pl022)
+{
+	return 0;
+}
+
+static inline int pl022_dma_probe(struct pl022 *pl022)
+{
+	return 0;
+}
+
+static inline void pl022_dma_remove(struct pl022 *pl022)
+{
+}
+#endif
+
+/**
+ * pl022_interrupt_handler - Interrupt handler for SSP controller
+ * @irq: IRQ number
+ * @dev_id: Local device data
+ *
+ * This function handles interrupts generated for an interrupt based transfer.
+ * If a receive overrun (ROR) interrupt is there then we disable SSP, flag the
+ * current message's state as STATE_ERROR and schedule the tasklet
+ * pump_transfers which will do the postprocessing of the current message by
+ * calling giveback(). Otherwise it reads data from RX FIFO till there is no
+ * more data, and writes data in TX FIFO till it is not full. If we complete
+ * the transfer we move to the next transfer and schedule the tasklet.
+ */
+static irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)
+{
+	struct pl022 *pl022 = dev_id;
+	struct spi_message *msg = pl022->cur_msg;
+	u16 irq_status = 0;
+
+	if (unlikely(!msg)) {
+		dev_err(&pl022->adev->dev,
+			"bad message state in interrupt handler");
+		/* Never fail */
+		return IRQ_HANDLED;
+	}
+
+	/* Read the Interrupt Status Register */
+	irq_status = readw(SSP_MIS(pl022->virtbase));
+
+	if (unlikely(!irq_status))
+		return IRQ_NONE;
+
+	/*
+	 * This handles the FIFO interrupts, the timeout
+	 * interrupts are flatly ignored, they cannot be
+	 * trusted.
+	 */
+	if (unlikely(irq_status & SSP_MIS_MASK_RORMIS)) {
+		/*
+		 * Overrun interrupt - bail out since our Data has been
+		 * corrupted
+		 */
+		dev_err(&pl022->adev->dev, "FIFO overrun\n");
+		if (readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RFF)
+			dev_err(&pl022->adev->dev,
+				"RXFIFO is full\n");
+
+		/*
+		 * Disable and clear interrupts, disable SSP,
+		 * mark message with bad status so it can be
+		 * retried.
+		 */
+		writew(DISABLE_ALL_INTERRUPTS,
+		       SSP_IMSC(pl022->virtbase));
+		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
+		writew((readw(SSP_CR1(pl022->virtbase)) &
+			(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));
+		msg->state = STATE_ERROR;
+
+		/* Schedule message queue handler */
+		tasklet_schedule(&pl022->pump_transfers);
+		return IRQ_HANDLED;
+	}
+
+	readwriter(pl022);
+
+	if (pl022->tx == pl022->tx_end) {
+		/* Disable Transmit interrupt, enable receive interrupt */
+		writew((readw(SSP_IMSC(pl022->virtbase)) &
+		       ~SSP_IMSC_MASK_TXIM) | SSP_IMSC_MASK_RXIM,
+		       SSP_IMSC(pl022->virtbase));
+	}
+
+	/*
+	 * Since all transactions must write as much as shall be read,
+	 * we can conclude the entire transaction once RX is complete.
+	 * At this point, all TX will always be finished.
+	 */
+	if (pl022->rx >= pl022->rx_end) {
+		writew(DISABLE_ALL_INTERRUPTS,
+		       SSP_IMSC(pl022->virtbase));
+		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
+		if (unlikely(pl022->rx > pl022->rx_end)) {
+			dev_warn(&pl022->adev->dev, "read %u surplus "
+				 "bytes (did you request an odd "
+				 "number of bytes on a 16bit bus?)\n",
+				 (u32) (pl022->rx - pl022->rx_end));
+		}
+		/* Update total bytes transferred */
+		msg->actual_length += pl022->cur_transfer->len;
+		/* Move to next transfer */
+		msg->state = next_transfer(pl022);
+		if (msg->state != STATE_DONE && pl022->cur_transfer->cs_change)
+			pl022_cs_control(pl022, SSP_CHIP_DESELECT);
+		tasklet_schedule(&pl022->pump_transfers);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * This sets up the pointers to memory for the next message to
+ * send out on the SPI bus.
+ */
+static int set_up_next_transfer(struct pl022 *pl022,
+				struct spi_transfer *transfer)
+{
+	int residue;
+
+	/* Sanity check the message for this bus width */
+	residue = pl022->cur_transfer->len % pl022->cur_chip->n_bytes;
+	if (unlikely(residue != 0)) {
+		dev_err(&pl022->adev->dev,
+			"message of %u bytes to transmit but the current "
+			"chip bus has a data width of %u bytes!\n",
+			pl022->cur_transfer->len,
+			pl022->cur_chip->n_bytes);
+		dev_err(&pl022->adev->dev, "skipping this message\n");
+		return -EIO;
+	}
+	pl022->tx = (void *)transfer->tx_buf;
+	pl022->tx_end = pl022->tx + pl022->cur_transfer->len;
+	pl022->rx = (void *)transfer->rx_buf;
+	pl022->rx_end = pl022->rx + pl022->cur_transfer->len;
+	pl022->write =
+	    pl022->tx ? pl022->cur_chip->write : WRITING_NULL;
+	pl022->read = pl022->rx ? pl022->cur_chip->read : READING_NULL;
+	return 0;
+}
+
+/**
+ * pump_transfers - Tasklet function which schedules next transfer
+ * when running in interrupt or DMA transfer mode.
+ * @data: SSP driver private data structure
+ *
+ */
+static void pump_transfers(unsigned long data)
+{
+	struct pl022 *pl022 = (struct pl022 *) data;
+	struct spi_message *message = NULL;
+	struct spi_transfer *transfer = NULL;
+	struct spi_transfer *previous = NULL;
+
+	/* Get current state information */
+	message = pl022->cur_msg;
+	transfer = pl022->cur_transfer;
+
+	/* Handle for abort */
+	if (message->state == STATE_ERROR) {
+		message->status = -EIO;
+		giveback(pl022);
+		return;
+	}
+
+	/* Handle end of message */
+	if (message->state == STATE_DONE) {
+		message->status = 0;
+		giveback(pl022);
+		return;
+	}
+
+	/* Delay if requested at end of transfer before CS change */
+	if (message->state == STATE_RUNNING) {
+		previous = list_entry(transfer->transfer_list.prev,
+					struct spi_transfer,
+					transfer_list);
+		/*
+		 * FIXME: This runs in interrupt context.
+		 * Is this really smart?
+		 */
+		spi_transfer_delay_exec(previous);
+
+		/* Reselect chip select only if cs_change was requested */
+		if (previous->cs_change)
+			pl022_cs_control(pl022, SSP_CHIP_SELECT);
+	} else {
+		/* STATE_START */
+		message->state = STATE_RUNNING;
+	}
+
+	if (set_up_next_transfer(pl022, transfer)) {
+		message->state = STATE_ERROR;
+		message->status = -EIO;
+		giveback(pl022);
+		return;
+	}
+	/* Flush the FIFOs and let's go! */
+	flush(pl022);
+
+	if (pl022->cur_chip->enable_dma) {
+		if (configure_dma(pl022)) {
+			dev_dbg(&pl022->adev->dev,
+				"configuration of DMA failed, fall back to interrupt mode\n");
+			goto err_config_dma;
+		}
+		return;
+	}
+
+err_config_dma:
+	/* enable all interrupts except RX */
+	writew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM, SSP_IMSC(pl022->virtbase));
+}
+
+static void do_interrupt_dma_transfer(struct pl022 *pl022)
+{
+	/*
+	 * Default is to enable all interrupts except RX -
+	 * this will be enabled once TX is complete
+	 */
+	u32 irqflags = (u32)(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM);
+
+	/* Enable target chip, if not already active */
+	if (!pl022->next_msg_cs_active)
+		pl022_cs_control(pl022, SSP_CHIP_SELECT);
+
+	if (set_up_next_transfer(pl022, pl022->cur_transfer)) {
+		/* Error path */
+		pl022->cur_msg->state = STATE_ERROR;
+		pl022->cur_msg->status = -EIO;
+		giveback(pl022);
+		return;
+	}
+	/* If we're using DMA, set up DMA here */
+	if (pl022->cur_chip->enable_dma) {
+		/* Configure DMA transfer */
+		if (configure_dma(pl022)) {
+			dev_dbg(&pl022->adev->dev,
+				"configuration of DMA failed, fall back to interrupt mode\n");
+			goto err_config_dma;
+		}
+		/* Disable interrupts in DMA mode, IRQ from DMA controller */
+		irqflags = DISABLE_ALL_INTERRUPTS;
+	}
+err_config_dma:
+	/* Enable SSP, turn on interrupts */
+	writew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),
+	       SSP_CR1(pl022->virtbase));
+	writew(irqflags, SSP_IMSC(pl022->virtbase));
+}
+
+static void print_current_status(struct pl022 *pl022)
+{
+	u32 read_cr0;
+	u16 read_cr1, read_dmacr, read_sr;
+
+	if (pl022->vendor->extended_cr)
+		read_cr0 = readl(SSP_CR0(pl022->virtbase));
+	else
+		read_cr0 = readw(SSP_CR0(pl022->virtbase));
+	read_cr1 = readw(SSP_CR1(pl022->virtbase));
+	read_dmacr = readw(SSP_DMACR(pl022->virtbase));
+	read_sr = readw(SSP_SR(pl022->virtbase));
+
+	dev_warn(&pl022->adev->dev, "spi-pl022 CR0: %x\n", read_cr0);
+	dev_warn(&pl022->adev->dev, "spi-pl022 CR1: %x\n", read_cr1);
+	dev_warn(&pl022->adev->dev, "spi-pl022 DMACR: %x\n", read_dmacr);
+	dev_warn(&pl022->adev->dev, "spi-pl022 SR: %x\n", read_sr);
+	dev_warn(&pl022->adev->dev,
+			"spi-pl022 exp_fifo_level/fifodepth: %u/%d\n",
+			pl022->exp_fifo_level,
+			pl022->vendor->fifodepth);
+
+}
+
+static void do_polling_transfer(struct pl022 *pl022)
+{
+	struct spi_message *message = NULL;
+	struct spi_transfer *transfer = NULL;
+	struct spi_transfer *previous = NULL;
+	unsigned long time, timeout;
+
+	message = pl022->cur_msg;
+
+	while (message->state != STATE_DONE) {
+		/* Handle for abort */
+		if (message->state == STATE_ERROR)
+			break;
+		transfer = pl022->cur_transfer;
+
+		/* Delay if requested at end of transfer */
+		if (message->state == STATE_RUNNING) {
+			previous =
+			    list_entry(transfer->transfer_list.prev,
+				       struct spi_transfer, transfer_list);
+			spi_transfer_delay_exec(previous);
+			if (previous->cs_change)
+				pl022_cs_control(pl022, SSP_CHIP_SELECT);
+		} else {
+			/* STATE_START */
+			message->state = STATE_RUNNING;
+			if (!pl022->next_msg_cs_active)
+				pl022_cs_control(pl022, SSP_CHIP_SELECT);
+		}
+
+		/* Configuration Changing Per Transfer */
+		if (set_up_next_transfer(pl022, transfer)) {
+			/* Error path */
+			message->state = STATE_ERROR;
+			break;
+		}
+		/* Flush FIFOs and enable SSP */
+		flush(pl022);
+		writew((readw(SSP_CR1(pl022->virtbase)) | SSP_CR1_MASK_SSE),
+		       SSP_CR1(pl022->virtbase));
+
+		dev_dbg(&pl022->adev->dev, "polling transfer ongoing ...\n");
+
+		timeout = jiffies + msecs_to_jiffies(SPI_POLLING_TIMEOUT);
+		while (pl022->tx < pl022->tx_end || pl022->rx < pl022->rx_end) {
+			time = jiffies;
+			readwriter(pl022);
+			if (time_after(time, timeout)) {
+				dev_warn(&pl022->adev->dev,
+				"%s: timeout!\n", __func__);
+				message->state = STATE_TIMEOUT;
+				print_current_status(pl022);
+				goto out;
+			}
+			cpu_relax();
+		}
+
+		/* Update total byte transferred */
+		message->actual_length += pl022->cur_transfer->len;
+		/* Move to next transfer */
+		message->state = next_transfer(pl022);
+		if (message->state != STATE_DONE
+		    && pl022->cur_transfer->cs_change)
+			pl022_cs_control(pl022, SSP_CHIP_DESELECT);
+	}
+out:
+	/* Handle end of message */
+	if (message->state == STATE_DONE)
+		message->status = 0;
+	else if (message->state == STATE_TIMEOUT)
+		message->status = -EAGAIN;
+	else
+		message->status = -EIO;
+
+	giveback(pl022);
+}
+
+static int pl022_transfer_one_message(struct spi_master *master,
+				      struct spi_message *msg)
+{
+	struct pl022 *pl022 = spi_master_get_devdata(master);
+
+	/* Initial message state */
+	pl022->cur_msg = msg;
+	msg->state = STATE_START;
+
+	pl022->cur_transfer = list_entry(msg->transfers.next,
+					 struct spi_transfer, transfer_list);
+
+	/* Setup the SPI using the per chip configuration */
+	pl022->cur_chip = spi_get_ctldata(msg->spi);
+	pl022->cur_cs = pl022->chipselects[msg->spi->chip_select];
+
+	restore_state(pl022);
+	flush(pl022);
+
+	if (pl022->cur_chip->xfer_type == POLLING_TRANSFER)
+		do_polling_transfer(pl022);
+	else
+		do_interrupt_dma_transfer(pl022);
+
+	return 0;
+}
+
+static int pl022_unprepare_transfer_hardware(struct spi_master *master)
+{
+	struct pl022 *pl022 = spi_master_get_devdata(master);
+
+	/* nothing more to do - disable spi/ssp and power off */
+	writew((readw(SSP_CR1(pl022->virtbase)) &
+		(~SSP_CR1_MASK_SSE)), SSP_CR1(pl022->virtbase));
+
+	return 0;
+}
+
+static int verify_controller_parameters(struct pl022 *pl022,
+				struct pl022_config_chip const *chip_info)
+{
+	if ((chip_info->iface < SSP_INTERFACE_MOTOROLA_SPI)
+	    || (chip_info->iface > SSP_INTERFACE_UNIDIRECTIONAL)) {
+		dev_err(&pl022->adev->dev,
+			"interface is configured incorrectly\n");
+		return -EINVAL;
+	}
+	if ((chip_info->iface == SSP_INTERFACE_UNIDIRECTIONAL) &&
+	    (!pl022->vendor->unidir)) {
+		dev_err(&pl022->adev->dev,
+			"unidirectional mode not supported in this "
+			"hardware version\n");
+		return -EINVAL;
+	}
+	if ((chip_info->hierarchy != SSP_MASTER)
+	    && (chip_info->hierarchy != SSP_SLAVE)) {
+		dev_err(&pl022->adev->dev,
+			"hierarchy is configured incorrectly\n");
+		return -EINVAL;
+	}
+	if ((chip_info->com_mode != INTERRUPT_TRANSFER)
+	    && (chip_info->com_mode != DMA_TRANSFER)
+	    && (chip_info->com_mode != POLLING_TRANSFER)) {
+		dev_err(&pl022->adev->dev,
+			"Communication mode is configured incorrectly\n");
+		return -EINVAL;
+	}
+	switch (chip_info->rx_lev_trig) {
+	case SSP_RX_1_OR_MORE_ELEM:
+	case SSP_RX_4_OR_MORE_ELEM:
+	case SSP_RX_8_OR_MORE_ELEM:
+		/* These are always OK, all variants can handle this */
+		break;
+	case SSP_RX_16_OR_MORE_ELEM:
+		if (pl022->vendor->fifodepth < 16) {
+			dev_err(&pl022->adev->dev,
+			"RX FIFO Trigger Level is configured incorrectly\n");
+			return -EINVAL;
+		}
+		break;
+	case SSP_RX_32_OR_MORE_ELEM:
+		if (pl022->vendor->fifodepth < 32) {
+			dev_err(&pl022->adev->dev,
+			"RX FIFO Trigger Level is configured incorrectly\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_err(&pl022->adev->dev,
+			"RX FIFO Trigger Level is configured incorrectly\n");
+		return -EINVAL;
+	}
+	switch (chip_info->tx_lev_trig) {
+	case SSP_TX_1_OR_MORE_EMPTY_LOC:
+	case SSP_TX_4_OR_MORE_EMPTY_LOC:
+	case SSP_TX_8_OR_MORE_EMPTY_LOC:
+		/* These are always OK, all variants can handle this */
+		break;
+	case SSP_TX_16_OR_MORE_EMPTY_LOC:
+		if (pl022->vendor->fifodepth < 16) {
+			dev_err(&pl022->adev->dev,
+			"TX FIFO Trigger Level is configured incorrectly\n");
+			return -EINVAL;
+		}
+		break;
+	case SSP_TX_32_OR_MORE_EMPTY_LOC:
+		if (pl022->vendor->fifodepth < 32) {
+			dev_err(&pl022->adev->dev,
+			"TX FIFO Trigger Level is configured incorrectly\n");
+			return -EINVAL;
+		}
+		break;
+	default:
+		dev_err(&pl022->adev->dev,
+			"TX FIFO Trigger Level is configured incorrectly\n");
+		return -EINVAL;
+	}
+	if (chip_info->iface == SSP_INTERFACE_NATIONAL_MICROWIRE) {
+		if ((chip_info->ctrl_len < SSP_BITS_4)
+		    || (chip_info->ctrl_len > SSP_BITS_32)) {
+			dev_err(&pl022->adev->dev,
+				"CTRL LEN is configured incorrectly\n");
+			return -EINVAL;
+		}
+		if ((chip_info->wait_state != SSP_MWIRE_WAIT_ZERO)
+		    && (chip_info->wait_state != SSP_MWIRE_WAIT_ONE)) {
+			dev_err(&pl022->adev->dev,
+				"Wait State is configured incorrectly\n");
+			return -EINVAL;
+		}
+		/* Half duplex is only available in the ST Micro version */
+		if (pl022->vendor->extended_cr) {
+			if ((chip_info->duplex !=
+			     SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
+			    && (chip_info->duplex !=
+				SSP_MICROWIRE_CHANNEL_HALF_DUPLEX)) {
+				dev_err(&pl022->adev->dev,
+					"Microwire duplex mode is configured incorrectly\n");
+				return -EINVAL;
+			}
+		} else {
+			if (chip_info->duplex != SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
+				dev_err(&pl022->adev->dev,
+					"Microwire half duplex mode requested,"
+					" but this is only available in the"
+					" ST version of PL022\n");
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+static inline u32 spi_rate(u32 rate, u16 cpsdvsr, u16 scr)
+{
+	return rate / (cpsdvsr * (1 + scr));
+}
+
+static int calculate_effective_freq(struct pl022 *pl022, int freq, struct
+				    ssp_clock_params * clk_freq)
+{
+	/* Lets calculate the frequency parameters */
+	u16 cpsdvsr = CPSDVR_MIN, scr = SCR_MIN;
+	u32 rate, max_tclk, min_tclk, best_freq = 0, best_cpsdvsr = 0,
+		best_scr = 0, tmp, found = 0;
+
+	rate = clk_get_rate(pl022->clk);
+	/* cpsdvscr = 2 & scr 0 */
+	max_tclk = spi_rate(rate, CPSDVR_MIN, SCR_MIN);
+	/* cpsdvsr = 254 & scr = 255 */
+	min_tclk = spi_rate(rate, CPSDVR_MAX, SCR_MAX);
+
+	if (freq > max_tclk)
+		dev_warn(&pl022->adev->dev,
+			"Max speed that can be programmed is %d Hz, you requested %d\n",
+			max_tclk, freq);
+
+	if (freq < min_tclk) {
+		dev_err(&pl022->adev->dev,
+			"Requested frequency: %d Hz is less than minimum possible %d Hz\n",
+			freq, min_tclk);
+		return -EINVAL;
+	}
+
+	/*
+	 * best_freq will give closest possible available rate (<= requested
+	 * freq) for all values of scr & cpsdvsr.
+	 */
+	while ((cpsdvsr <= CPSDVR_MAX) && !found) {
+		while (scr <= SCR_MAX) {
+			tmp = spi_rate(rate, cpsdvsr, scr);
+
+			if (tmp > freq) {
+				/* we need lower freq */
+				scr++;
+				continue;
+			}
+
+			/*
+			 * If found exact value, mark found and break.
+			 * If found more closer value, update and break.
+			 */
+			if (tmp > best_freq) {
+				best_freq = tmp;
+				best_cpsdvsr = cpsdvsr;
+				best_scr = scr;
+
+				if (tmp == freq)
+					found = 1;
+			}
+			/*
+			 * increased scr will give lower rates, which are not
+			 * required
+			 */
+			break;
+		}
+		cpsdvsr += 2;
+		scr = SCR_MIN;
+	}
+
+	WARN(!best_freq, "pl022: Matching cpsdvsr and scr not found for %d Hz rate\n",
+			freq);
+
+	if (best_freq != freq)
+		dev_warn(&pl022->adev->dev,
+		"Requested frequency: %d Hz is unsupported,select by default %d Hz\n",
+			freq, best_freq);
+
+	clk_freq->cpsdvsr = (u8) (best_cpsdvsr & 0xFF);
+	clk_freq->scr = (u8) (best_scr & 0xFF);
+	dev_dbg(&pl022->adev->dev,
+		"SSP Target Frequency is: %u, Effective Frequency is %u\n",
+		freq, best_freq);
+	dev_dbg(&pl022->adev->dev, "SSP cpsdvsr = %d, scr = %d\n",
+		clk_freq->cpsdvsr, clk_freq->scr);
+
+	return 0;
+}
+
+/*
+ * A piece of default chip info unless the platform
+ * supplies it.
+ */
+static const struct pl022_config_chip pl022_default_chip_info = {
+	.com_mode = POLLING_TRANSFER,
+	.iface = SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy = SSP_SLAVE,
+	.slave_tx_disable = DO_NOT_DRIVE_TX,
+	.rx_lev_trig = SSP_RX_1_OR_MORE_ELEM,
+	.tx_lev_trig = SSP_TX_1_OR_MORE_EMPTY_LOC,
+	.ctrl_len = SSP_BITS_8,
+	.wait_state = SSP_MWIRE_WAIT_ZERO,
+	.duplex = SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control = null_cs_control,
+};
+
+/**
+ * pl022_setup - setup function registered to SPI master framework
+ * @spi: spi device which is requesting setup
+ *
+ * This function is registered to the SPI framework for this SPI master
+ * controller. If it is the first time when setup is called by this device,
+ * this function will initialize the runtime state for this chip and save
+ * the same in the device structure. Else it will update the runtime info
+ * with the updated chip info. Nothing is really being written to the
+ * controller hardware here, that is not done until the actual transfer
+ * commence.
+ */
+static int pl022_setup(struct spi_device *spi)
+{
+	struct pl022_config_chip const *chip_info;
+	struct pl022_config_chip chip_info_dt;
+	struct chip_data *chip;
+	struct ssp_clock_params clk_freq = { .cpsdvsr = 0, .scr = 0};
+	int status = 0;
+	struct pl022 *pl022 = spi_master_get_devdata(spi->master);
+	unsigned int bits = spi->bits_per_word;
+	u32 tmp;
+	struct device_node *np = spi->dev.of_node;
+
+	if (!spi->max_speed_hz)
+		return -EINVAL;
+
+	/* Get controller_state if one is supplied */
+	chip = spi_get_ctldata(spi);
+
+	if (chip == NULL) {
+		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
+		if (!chip)
+			return -ENOMEM;
+		dev_dbg(&spi->dev,
+			"allocated memory for controller's runtime state\n");
+	}
+
+	/* Get controller data if one is supplied */
+	chip_info = spi->controller_data;
+
+	if (chip_info == NULL) {
+		if (np) {
+			chip_info_dt = pl022_default_chip_info;
+
+			chip_info_dt.hierarchy = SSP_MASTER;
+			of_property_read_u32(np, "pl022,interface",
+				&chip_info_dt.iface);
+			of_property_read_u32(np, "pl022,com-mode",
+				&chip_info_dt.com_mode);
+			of_property_read_u32(np, "pl022,rx-level-trig",
+				&chip_info_dt.rx_lev_trig);
+			of_property_read_u32(np, "pl022,tx-level-trig",
+				&chip_info_dt.tx_lev_trig);
+			of_property_read_u32(np, "pl022,ctrl-len",
+				&chip_info_dt.ctrl_len);
+			of_property_read_u32(np, "pl022,wait-state",
+				&chip_info_dt.wait_state);
+			of_property_read_u32(np, "pl022,duplex",
+				&chip_info_dt.duplex);
+
+			chip_info = &chip_info_dt;
+		} else {
+			chip_info = &pl022_default_chip_info;
+			/* spi_board_info.controller_data not is supplied */
+			dev_dbg(&spi->dev,
+				"using default controller_data settings\n");
+		}
+	} else
+		dev_dbg(&spi->dev,
+			"using user supplied controller_data settings\n");
+
+	/*
+	 * We can override with custom divisors, else we use the board
+	 * frequency setting
+	 */
+	if ((chip_info->clk_freq.cpsdvsr == 0)
+	    && (chip_info->clk_freq.scr == 0)) {
+		status = calculate_effective_freq(pl022,
+						  spi->max_speed_hz,
+						  &clk_freq);
+		if (status < 0)
+			goto err_config_params;
+	} else {
+		memcpy(&clk_freq, &chip_info->clk_freq, sizeof(clk_freq));
+		if ((clk_freq.cpsdvsr % 2) != 0)
+			clk_freq.cpsdvsr =
+				clk_freq.cpsdvsr - 1;
+	}
+	if ((clk_freq.cpsdvsr < CPSDVR_MIN)
+	    || (clk_freq.cpsdvsr > CPSDVR_MAX)) {
+		status = -EINVAL;
+		dev_err(&spi->dev,
+			"cpsdvsr is configured incorrectly\n");
+		goto err_config_params;
+	}
+
+	status = verify_controller_parameters(pl022, chip_info);
+	if (status) {
+		dev_err(&spi->dev, "controller data is incorrect");
+		goto err_config_params;
+	}
+
+	pl022->rx_lev_trig = chip_info->rx_lev_trig;
+	pl022->tx_lev_trig = chip_info->tx_lev_trig;
+
+	/* Now set controller state based on controller data */
+	chip->xfer_type = chip_info->com_mode;
+	if (!chip_info->cs_control) {
+		chip->cs_control = null_cs_control;
+		if (!gpio_is_valid(pl022->chipselects[spi->chip_select]))
+			dev_warn(&spi->dev,
+				 "invalid chip select\n");
+	} else
+		chip->cs_control = chip_info->cs_control;
+
+	/* Check bits per word with vendor specific range */
+	if ((bits <= 3) || (bits > pl022->vendor->max_bpw)) {
+		status = -ENOTSUPP;
+		dev_err(&spi->dev, "illegal data size for this controller!\n");
+		dev_err(&spi->dev, "This controller can only handle 4 <= n <= %d bit words\n",
+				pl022->vendor->max_bpw);
+		goto err_config_params;
+	} else if (bits <= 8) {
+		dev_dbg(&spi->dev, "4 <= n <=8 bits per word\n");
+		chip->n_bytes = 1;
+		chip->read = READING_U8;
+		chip->write = WRITING_U8;
+	} else if (bits <= 16) {
+		dev_dbg(&spi->dev, "9 <= n <= 16 bits per word\n");
+		chip->n_bytes = 2;
+		chip->read = READING_U16;
+		chip->write = WRITING_U16;
+	} else {
+		dev_dbg(&spi->dev, "17 <= n <= 32 bits per word\n");
+		chip->n_bytes = 4;
+		chip->read = READING_U32;
+		chip->write = WRITING_U32;
+	}
+
+	/* Now Initialize all register settings required for this chip */
+	chip->cr0 = 0;
+	chip->cr1 = 0;
+	chip->dmacr = 0;
+	chip->cpsr = 0;
+	if ((chip_info->com_mode == DMA_TRANSFER)
+	    && ((pl022->master_info)->enable_dma)) {
+		chip->enable_dma = true;
+		dev_dbg(&spi->dev, "DMA mode set in controller state\n");
+		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,
+			       SSP_DMACR_MASK_RXDMAE, 0);
+		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_ENABLED,
+			       SSP_DMACR_MASK_TXDMAE, 1);
+	} else {
+		chip->enable_dma = false;
+		dev_dbg(&spi->dev, "DMA mode NOT set in controller state\n");
+		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,
+			       SSP_DMACR_MASK_RXDMAE, 0);
+		SSP_WRITE_BITS(chip->dmacr, SSP_DMA_DISABLED,
+			       SSP_DMACR_MASK_TXDMAE, 1);
+	}
+
+	chip->cpsr = clk_freq.cpsdvsr;
+
+	/* Special setup for the ST micro extended control registers */
+	if (pl022->vendor->extended_cr) {
+		u32 etx;
+
+		if (pl022->vendor->pl023) {
+			/* These bits are only in the PL023 */
+			SSP_WRITE_BITS(chip->cr1, chip_info->clkdelay,
+				       SSP_CR1_MASK_FBCLKDEL_ST, 13);
+		} else {
+			/* These bits are in the PL022 but not PL023 */
+			SSP_WRITE_BITS(chip->cr0, chip_info->duplex,
+				       SSP_CR0_MASK_HALFDUP_ST, 5);
+			SSP_WRITE_BITS(chip->cr0, chip_info->ctrl_len,
+				       SSP_CR0_MASK_CSS_ST, 16);
+			SSP_WRITE_BITS(chip->cr0, chip_info->iface,
+				       SSP_CR0_MASK_FRF_ST, 21);
+			SSP_WRITE_BITS(chip->cr1, chip_info->wait_state,
+				       SSP_CR1_MASK_MWAIT_ST, 6);
+		}
+		SSP_WRITE_BITS(chip->cr0, bits - 1,
+			       SSP_CR0_MASK_DSS_ST, 0);
+
+		if (spi->mode & SPI_LSB_FIRST) {
+			tmp = SSP_RX_LSB;
+			etx = SSP_TX_LSB;
+		} else {
+			tmp = SSP_RX_MSB;
+			etx = SSP_TX_MSB;
+		}
+		SSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_RENDN_ST, 4);
+		SSP_WRITE_BITS(chip->cr1, etx, SSP_CR1_MASK_TENDN_ST, 5);
+		SSP_WRITE_BITS(chip->cr1, chip_info->rx_lev_trig,
+			       SSP_CR1_MASK_RXIFLSEL_ST, 7);
+		SSP_WRITE_BITS(chip->cr1, chip_info->tx_lev_trig,
+			       SSP_CR1_MASK_TXIFLSEL_ST, 10);
+	} else {
+		SSP_WRITE_BITS(chip->cr0, bits - 1,
+			       SSP_CR0_MASK_DSS, 0);
+		SSP_WRITE_BITS(chip->cr0, chip_info->iface,
+			       SSP_CR0_MASK_FRF, 4);
+	}
+
+	/* Stuff that is common for all versions */
+	if (spi->mode & SPI_CPOL)
+		tmp = SSP_CLK_POL_IDLE_HIGH;
+	else
+		tmp = SSP_CLK_POL_IDLE_LOW;
+	SSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPO, 6);
+
+	if (spi->mode & SPI_CPHA)
+		tmp = SSP_CLK_SECOND_EDGE;
+	else
+		tmp = SSP_CLK_FIRST_EDGE;
+	SSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPH, 7);
+
+	SSP_WRITE_BITS(chip->cr0, clk_freq.scr, SSP_CR0_MASK_SCR, 8);
+	/* Loopback is available on all versions except PL023 */
+	if (pl022->vendor->loopback) {
+		if (spi->mode & SPI_LOOP)
+			tmp = LOOPBACK_ENABLED;
+		else
+			tmp = LOOPBACK_DISABLED;
+		SSP_WRITE_BITS(chip->cr1, tmp, SSP_CR1_MASK_LBM, 0);
+	}
+	SSP_WRITE_BITS(chip->cr1, SSP_DISABLED, SSP_CR1_MASK_SSE, 1);
+	SSP_WRITE_BITS(chip->cr1, chip_info->hierarchy, SSP_CR1_MASK_MS, 2);
+	SSP_WRITE_BITS(chip->cr1, chip_info->slave_tx_disable, SSP_CR1_MASK_SOD,
+		3);
+
+	/* Save controller_state */
+	spi_set_ctldata(spi, chip);
+	return status;
+ err_config_params:
+	spi_set_ctldata(spi, NULL);
+	kfree(chip);
+	return status;
+}
+
+/**
+ * pl022_cleanup - cleanup function registered to SPI master framework
+ * @spi: spi device which is requesting cleanup
+ *
+ * This function is registered to the SPI framework for this SPI master
+ * controller. It will free the runtime state of chip.
+ */
+static void pl022_cleanup(struct spi_device *spi)
+{
+	struct chip_data *chip = spi_get_ctldata(spi);
+
+	spi_set_ctldata(spi, NULL);
+	kfree(chip);
+}
+
+static struct pl022_ssp_controller *
+pl022_platform_data_dt_get(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct pl022_ssp_controller *pd;
+	u32 tmp = 0;
+
+	if (!np) {
+		dev_err(dev, "no dt node defined\n");
+		return NULL;
+	}
+
+	if (strncmp(dev->bus->name, "platform", strlen("platform")))
+		pd = devm_kzalloc(dev, sizeof(struct pl022_ssp_controller), GFP_KERNEL);
+	else
+		pd = kzalloc(sizeof(struct pl022_ssp_controller), GFP_KERNEL);
+	if (!pd)
+		return NULL;
+
+	pd->bus_id = -1;
+	pd->enable_dma = 1;
+	of_property_read_u32(np, "num-cs", &tmp);
+	pd->num_chipselect = tmp;
+	of_property_read_u32(np, "pl022,autosuspend-delay",
+			     &pd->autosuspend_delay);
+	pd->rt = of_property_read_bool(np, "pl022,rt");
+
+	return pd;
+}
+
+static int pl022_platform_probe(struct platform_device *pdev, const struct amba_id *id)
+{
+	struct device *dev = &pdev->dev;
+	struct pl022_ssp_controller *platform_info;
+	struct spi_master *master;
+	struct pl022 *pl022 = NULL;	/*Data for this driver */
+	struct amba_device *adev;
+	struct device_node *np = pdev->dev.of_node;
+	struct resource *res;
+	int status = 0, i, num_cs;
+	int irq;
+
+	dev_info(dev,
+		"ARM PL022 driver for StarFive SoC platform, device ID: 0x%08x\n",
+		id->id);
+
+	adev = devm_kzalloc(dev, sizeof(*adev), GFP_KERNEL);
+	adev->dev = pdev->dev;
+	platform_info = pl022_platform_data_dt_get(dev);
+	if (!platform_info) {
+		dev_err(dev, "probe: no platform data defined\n");
+		return -ENODEV;
+	}
+
+	if (platform_info->num_chipselect) {
+		num_cs = platform_info->num_chipselect;
+	} else {
+		dev_err(dev, "probe: no chip select defined\n");
+		return -ENODEV;
+	}
+
+	/* Allocate master with space for data */
+	master = spi_alloc_master(dev, sizeof(struct pl022));
+	if (master == NULL) {
+		dev_err(dev, "probe - cannot alloc SPI master\n");
+		return -ENOMEM;
+	}
+
+	pl022 = spi_master_get_devdata(master);
+	pl022->master = master;
+	pl022->master_info = platform_info;
+	pl022->adev = adev;
+	pl022->vendor = id->data;
+	pl022->master->dev.parent = &pdev->dev;
+
+	pl022->chipselects = devm_kcalloc(dev, num_cs, sizeof(int),
+					  GFP_KERNEL);
+	if (!pl022->chipselects) {
+		status = -ENOMEM;
+		goto err_no_mem;
+	}
+
+	/*
+	 * Bus Number Which has been Assigned to this SSP controller
+	 * on this board
+	 */
+	master->bus_num = platform_info->bus_id;
+	master->num_chipselect = num_cs;
+	master->cleanup = pl022_cleanup;
+	master->setup = pl022_setup;
+	/* If open CONFIG_PM, auto_runtime_pm should be false when of-platform.*/
+	master->auto_runtime_pm = true;
+	master->transfer_one_message = pl022_transfer_one_message;
+	master->unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;
+	master->rt = platform_info->rt;
+	master->dev.of_node = dev->of_node;
+
+	if (platform_info->num_chipselect && platform_info->chipselects) {
+		for (i = 0; i < num_cs; i++)
+			pl022->chipselects[i] = platform_info->chipselects[i];
+	} else if (pl022->vendor->internal_cs_ctrl) {
+		for (i = 0; i < num_cs; i++)
+			pl022->chipselects[i] = i;
+	} else if (IS_ENABLED(CONFIG_OF)) {
+		for (i = 0; i < num_cs; i++) {
+			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
+
+			if (cs_gpio == -EPROBE_DEFER) {
+				status = -EPROBE_DEFER;
+				goto err_no_gpio;
+			}
+
+			pl022->chipselects[i] = cs_gpio;
+
+			if (gpio_is_valid(cs_gpio)) {
+				if (devm_gpio_request(dev, cs_gpio, "ssp-pl022"))
+					dev_err(dev,
+						"could not request %d gpio\n",
+						cs_gpio);
+				else if (gpio_direction_output(cs_gpio, 1))
+					dev_err(dev,
+						"could not set gpio %d as output\n",
+						cs_gpio);
+			}
+		}
+	}
+
+	/*
+	 * Supports mode 0-3, loopback, and active low CS. Transfers are
+	 * always MS bit first on the original pl022.
+	 */
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
+	if (pl022->vendor->extended_cr)
+		master->mode_bits |= SPI_LSB_FIRST;
+
+	dev_dbg(dev, "BUSNO: %d\n", master->bus_num);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pl022->phybase = res->start;
+	pl022->virtbase = devm_ioremap_resource(dev, res);
+	if (pl022->virtbase == NULL) {
+		status = -ENOMEM;
+		goto err_no_ioremap;
+	}
+	dev_info(dev, "mapped registers from %llx to %llx\n",
+		pdev->resource->start, pdev->resource->end);
+
+	pl022->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(pl022->clk)) {
+		status = PTR_ERR(pl022->clk);
+		dev_err(dev, "could not retrieve SSP/SPI bus clock\n");
+		goto err_no_clk;
+	}
+
+	status = clk_prepare_enable(pl022->clk);
+	if (status) {
+		dev_err(dev, "could not enable SSP/SPI bus clock\n");
+		goto err_no_clk_en;
+	}
+
+	pl022->rst = devm_reset_control_get_exclusive(dev, "rst_apb");
+	if (!IS_ERR(pl022->rst)) {
+		status = reset_control_deassert(pl022->rst);
+		if (status) {
+			dev_err(dev, "could not deassert SSP/SPI bus reset\n");
+			goto err_no_rst_clr;
+		}
+	} else {
+		status = PTR_ERR(pl022->rst);
+		dev_err(dev, "could not retrieve SSP/SPI bus reset\n");
+		goto err_no_rst;
+	}
+
+	/* Initialize transfer pump */
+	tasklet_init(&pl022->pump_transfers, pump_transfers,
+		     (unsigned long)pl022);
+
+	/* Disable SSP */
+	writew((readw(SSP_CR1(pl022->virtbase)) & (~SSP_CR1_MASK_SSE)),
+	       SSP_CR1(pl022->virtbase));
+	load_ssp_default_config(pl022);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		status = -ENXIO;
+		goto err_no_irq;
+	}
+	status = devm_request_irq(dev, irq, pl022_interrupt_handler,
+				0, "pl022", pl022);
+	if (status < 0) {
+		dev_err(dev, "probe - cannot get IRQ (%d)\n", status);
+		goto err_no_irq;
+	}
+
+	/* Get DMA channels, try autoconfiguration first */
+	status = pl022_dma_autoprobe(pl022);
+	if (status == -EPROBE_DEFER) {
+		dev_dbg(dev, "deferring probe to get DMA channel\n");
+		goto err_no_irq;
+	}
+
+	/* dma is not used unless configured in device tree */
+	platform_info->enable_dma = 0;
+
+	/* If that failed, use channels from platform_info */
+	if (status == 0)
+		platform_info->enable_dma = 1;
+	else if (platform_info->enable_dma) {
+		status = pl022_dma_probe(pl022);
+		if (status != 0)
+			platform_info->enable_dma = 0;
+	}
+
+	/* Register with the SPI framework */
+	dev_set_drvdata(dev, pl022);
+
+	status = devm_spi_register_master(dev, master);
+	if (status != 0) {
+		dev_err(dev,
+			"probe - problem registering spi master\n");
+		goto err_spi_register;
+	}
+	dev_dbg(dev, "probe succeeded\n");
+
+	/* let runtime pm put suspend */
+	if (platform_info->autosuspend_delay > 0) {
+		dev_info(dev,
+			"will use autosuspend for runtime pm, delay %dms\n",
+			platform_info->autosuspend_delay);
+		pm_runtime_set_autosuspend_delay(dev,
+			platform_info->autosuspend_delay);
+		pm_runtime_use_autosuspend(dev);
+	}
+
+	return 0;
+
+err_spi_register:
+	if (platform_info->enable_dma)
+		pl022_dma_remove(pl022);
+err_no_irq:
+	reset_control_assert(pl022->rst);
+err_no_rst_clr:
+err_no_rst:
+	clk_disable_unprepare(pl022->clk);
+err_no_clk_en:
+err_no_clk:
+err_no_ioremap:
+	release_mem_region(pdev->resource->start, resource_size(pdev->resource));
+err_no_gpio:
+err_no_mem:
+	spi_master_put(master);
+	return status;
+}
+static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
+{
+	struct device *dev = &adev->dev;
+	struct pl022_ssp_controller *platform_info =
+			dev_get_platdata(&adev->dev);
+	struct spi_master *master;
+	struct pl022 *pl022 = NULL;	/*Data for this driver */
+	struct device_node *np = adev->dev.of_node;
+	int status = 0, i, num_cs;
+
+	dev_info(&adev->dev,
+		"ARM PL022 driver for StarFive SoC platform, device ID: 0x%08x\n",
+		adev->periphid);
+	if (!platform_info && IS_ENABLED(CONFIG_OF))
+		platform_info = pl022_platform_data_dt_get(dev);
+
+	if (!platform_info) {
+		dev_err(dev, "probe: no platform data defined\n");
+		return -ENODEV;
+	}
+
+	if (platform_info->num_chipselect) {
+		num_cs = platform_info->num_chipselect;
+	} else {
+		dev_err(dev, "probe: no chip select defined\n");
+		return -ENODEV;
+	}
+
+	/* Allocate master with space for data */
+	master = spi_alloc_master(dev, sizeof(struct pl022));
+	if (master == NULL) {
+		dev_err(&adev->dev, "probe - cannot alloc SPI master\n");
+		return -ENOMEM;
+	}
+
+	pl022 = spi_master_get_devdata(master);
+	pl022->master = master;
+	pl022->master_info = platform_info;
+	pl022->adev = adev;
+	pl022->vendor = id->data;
+
+	pl022->chipselects = devm_kcalloc(dev, num_cs, sizeof(int),
+					  GFP_KERNEL);
+	if (!pl022->chipselects) {
+		status = -ENOMEM;
+		goto err_no_mem;
+	}
+
+	/*
+	 * Bus Number Which has been Assigned to this SSP controller
+	 * on this board
+	 */
+	master->bus_num = platform_info->bus_id;
+	master->num_chipselect = num_cs;
+	master->cleanup = pl022_cleanup;
+	master->setup = pl022_setup;
+	master->auto_runtime_pm = true;
+	master->transfer_one_message = pl022_transfer_one_message;
+	master->unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;
+	master->rt = platform_info->rt;
+	master->dev.of_node = dev->of_node;
+
+	if (platform_info->num_chipselect && platform_info->chipselects) {
+		for (i = 0; i < num_cs; i++)
+			pl022->chipselects[i] = platform_info->chipselects[i];
+	} else if (pl022->vendor->internal_cs_ctrl) {
+		for (i = 0; i < num_cs; i++)
+			pl022->chipselects[i] = i;
+	} else if (IS_ENABLED(CONFIG_OF)) {
+		for (i = 0; i < num_cs; i++) {
+			int cs_gpio = of_get_named_gpio(np, "cs-gpios", i);
+
+			if (cs_gpio == -EPROBE_DEFER) {
+				status = -EPROBE_DEFER;
+				goto err_no_gpio;
+			}
+
+			pl022->chipselects[i] = cs_gpio;
+
+			if (gpio_is_valid(cs_gpio)) {
+				if (devm_gpio_request(dev, cs_gpio, "ssp-pl022"))
+					dev_err(&adev->dev,
+						"could not request %d gpio\n",
+						cs_gpio);
+				else if (gpio_direction_output(cs_gpio, 1))
+					dev_err(&adev->dev,
+						"could not set gpio %d as output\n",
+						cs_gpio);
+			}
+		}
+	}
+
+	/*
+	 * Supports mode 0-3, loopback, and active low CS. Transfers are
+	 * always MS bit first on the original pl022.
+	 */
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;
+	if (pl022->vendor->extended_cr)
+		master->mode_bits |= SPI_LSB_FIRST;
+
+	dev_dbg(&adev->dev, "BUSNO: %d\n", master->bus_num);
+
+	status = amba_request_regions(adev, NULL);
+	if (status)
+		goto err_no_ioregion;
+
+	pl022->phybase = adev->res.start;
+
+	pl022->virtbase = devm_ioremap(dev, adev->res.start,
+				       resource_size(&adev->res));
+	if (pl022->virtbase == NULL) {
+		status = -ENOMEM;
+		goto err_no_ioremap;
+	}
+	dev_info(&adev->dev, "mapped registers from %pa to %p\n",
+		&adev->res.start, pl022->virtbase);
+
+	pl022->clk = devm_clk_get(&adev->dev, NULL);
+	if (IS_ERR(pl022->clk)) {
+		status = PTR_ERR(pl022->clk);
+		dev_err(&adev->dev, "could not retrieve SSP/SPI bus clock\n");
+		goto err_no_clk;
+	}
+
+	status = clk_prepare_enable(pl022->clk);
+	if (status) {
+		dev_err(&adev->dev, "could not enable SSP/SPI bus clock\n");
+		goto err_no_clk_en;
+	}
+
+	pl022->rst = devm_reset_control_get_exclusive(&adev->dev, "rst_apb");
+	if (!IS_ERR(pl022->rst)) {
+		status = reset_control_deassert(pl022->rst);
+		if (status) {
+			dev_err(&adev->dev, "could not deassert SSP/SPI bus reset\n");
+			goto err_no_rst_clr;
+		}
+	} else {
+		status = PTR_ERR(pl022->rst);
+		dev_err(&adev->dev, "could not retrieve SSP/SPI bus reset\n");
+		goto err_no_rst;
+	}
+
+	/* Initialize transfer pump */
+	tasklet_init(&pl022->pump_transfers, pump_transfers,
+		     (unsigned long)pl022);
+
+	/* Disable SSP */
+	writew((readw(SSP_CR1(pl022->virtbase)) & (~SSP_CR1_MASK_SSE)),
+	       SSP_CR1(pl022->virtbase));
+	load_ssp_default_config(pl022);
+
+	status = devm_request_irq(dev, adev->irq[0], pl022_interrupt_handler,
+				  0, "pl022", pl022);
+	if (status < 0) {
+		dev_err(&adev->dev, "probe - cannot get IRQ (%d)\n", status);
+		goto err_no_irq;
+	}
+
+	/* Get DMA channels, try autoconfiguration first */
+	status = pl022_dma_autoprobe(pl022);
+	if (status == -EPROBE_DEFER) {
+		dev_dbg(dev, "deferring probe to get DMA channel\n");
+		goto err_no_irq;
+	}
+
+	/* dma is not used unless configured in device tree */
+	platform_info->enable_dma = 0;
+
+	/* If that failed, use channels from platform_info */
+	if (status == 0)
+		platform_info->enable_dma = 1;
+	else if (platform_info->enable_dma) {
+		status = pl022_dma_probe(pl022);
+		if (status != 0)
+			platform_info->enable_dma = 0;
+	}
+
+	/* Register with the SPI framework */
+	amba_set_drvdata(adev, pl022);
+
+	status = devm_spi_register_master(&adev->dev, master);
+	if (status != 0) {
+		dev_err(&adev->dev,
+			"probe - problem registering spi master\n");
+		goto err_spi_register;
+	}
+	dev_dbg(dev, "probe succeeded\n");
+
+	platform_info->autosuspend_delay = 100;
+	/* let runtime pm put suspend */
+	if (platform_info->autosuspend_delay > 0) {
+		dev_info(&adev->dev,
+			"will use autosuspend for runtime pm, delay %dms\n",
+			platform_info->autosuspend_delay);
+		pm_runtime_set_autosuspend_delay(dev,
+			platform_info->autosuspend_delay);
+		pm_runtime_use_autosuspend(dev);
+	}
+
+	pm_runtime_put(dev);
+
+	return 0;
+
+ err_spi_register:
+	if (platform_info->enable_dma)
+		pl022_dma_remove(pl022);
+ err_no_irq:
+	reset_control_assert(pl022->rst);
+ err_no_rst_clr:
+ err_no_rst:
+	clk_disable_unprepare(pl022->clk);
+ err_no_clk_en:
+ err_no_clk:
+ err_no_ioremap:
+	amba_release_regions(adev);
+ err_no_ioregion:
+ err_no_gpio:
+ err_no_mem:
+	spi_master_put(master);
+
+	return status;
+}
+
+static int
+pl022_remove(struct amba_device *adev)
+{
+	struct pl022 *pl022 = amba_get_drvdata(adev);
+
+	if (!pl022)
+		return 0;
+
+	/*
+	 * undo pm_runtime_put() in probe.  I assume that we're not
+	 * accessing the primecell here.
+	 */
+	pm_runtime_get_noresume(&adev->dev);
+
+	load_ssp_default_config(pl022);
+	if (pl022->master_info->enable_dma)
+		pl022_dma_remove(pl022);
+
+	clk_disable_unprepare(pl022->clk);
+	amba_release_regions(adev);
+	tasklet_disable(&pl022->pump_transfers);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int pl022_suspend(struct device *dev)
+{
+	struct pl022 *pl022 = dev_get_drvdata(dev);
+	int ret;
+
+	ret = spi_master_suspend(pl022->master);
+	if (ret)
+		return ret;
+
+	ret = pm_runtime_force_suspend(dev);
+	if (ret) {
+		spi_master_resume(pl022->master);
+		return ret;
+	}
+
+	pinctrl_pm_select_sleep_state(dev);
+
+	dev_dbg(dev, "starfive spi suspended\n");
+
+	return 0;
+}
+
+static int pl022_resume(struct device *dev)
+{
+	struct pl022 *pl022 = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret)
+		dev_err(dev, "problem resuming\n");
+
+	/* Start the queue running */
+	ret = spi_master_resume(pl022->master);
+	if (!ret)
+		dev_dbg(dev, "starfive spi resumed\n");
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_PM
+static int pl022_runtime_suspend(struct device *dev)
+{
+	struct pl022 *pl022 = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(pl022->clk);
+	pinctrl_pm_select_idle_state(dev);
+
+	dev_dbg(dev, "starfive spi runtime suspend");
+
+	return 0;
+}
+
+static int pl022_runtime_resume(struct device *dev)
+{
+	struct pl022 *pl022 = dev_get_drvdata(dev);
+
+	pinctrl_pm_select_default_state(dev);
+	clk_prepare_enable(pl022->clk);
+
+	dev_dbg(dev, "stafive spi runtime resume");
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops pl022_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pl022_suspend, pl022_resume)
+	SET_RUNTIME_PM_OPS(pl022_runtime_suspend, pl022_runtime_resume, NULL)
+};
+
+static struct vendor_data vendor_arm = {
+	.fifodepth = 8,
+	.max_bpw = 16,
+	.unidir = false,
+	.extended_cr = false,
+	.pl023 = false,
+	.loopback = true,
+	.internal_cs_ctrl = false,
+};
+
+static struct vendor_data vendor_st = {
+	.fifodepth = 32,
+	.max_bpw = 32,
+	.unidir = false,
+	.extended_cr = true,
+	.pl023 = false,
+	.loopback = true,
+	.internal_cs_ctrl = false,
+};
+
+static struct vendor_data vendor_st_pl023 = {
+	.fifodepth = 32,
+	.max_bpw = 32,
+	.unidir = false,
+	.extended_cr = true,
+	.pl023 = true,
+	.loopback = false,
+	.internal_cs_ctrl = false,
+};
+
+static struct vendor_data vendor_lsi = {
+	.fifodepth = 8,
+	.max_bpw = 16,
+	.unidir = false,
+	.extended_cr = false,
+	.pl023 = false,
+	.loopback = true,
+	.internal_cs_ctrl = true,
+};
+
+static const struct amba_id pl022_ids[] = {
+	{
+		/*
+		 * ARM PL022 variant, this has a 16bit wide
+		 * and 8 locations deep TX/RX FIFO
+		 */
+		.id	= 0x00041022,
+		.mask	= 0x000fffff,
+		.data	= &vendor_arm,
+	},
+	{
+		/*
+		 * ST Micro derivative, this has 32bit wide
+		 * and 32 locations deep TX/RX FIFO
+		 */
+		.id	= 0x01080022,
+		.mask	= 0xffffffff,
+		.data	= &vendor_st,
+	},
+	{
+		/*
+		 * ST-Ericsson derivative "PL023" (this is not
+		 * an official ARM number), this is a PL022 SSP block
+		 * stripped to SPI mode only, it has 32bit wide
+		 * and 32 locations deep TX/RX FIFO but no extended
+		 * CR0/CR1 register
+		 */
+		.id	= 0x00080023,
+		.mask	= 0xffffffff,
+		.data	= &vendor_st_pl023,
+	},
+	{
+		/*
+		 * PL022 variant that has a chip select control register whih
+		 * allows control of 5 output signals nCS[0:4].
+		 */
+		.id	= 0x000b6022,
+		.mask	= 0x000fffff,
+		.data	= &vendor_lsi,
+	},
+	{ 0, 0 },
+};
+
+MODULE_DEVICE_TABLE(amba, pl022_ids);
+
+static struct amba_driver pl022_driver = {
+	.drv = {
+		.name	= "ssp-pl022",
+		.pm	= &pl022_dev_pm_ops,
+	},
+	.id_table	= pl022_ids,
+	.probe		= pl022_probe,
+	.remove		= pl022_remove,
+};
+
+static int __init pl022_init(void)
+{
+	return amba_driver_register(&pl022_driver);
+}
+#if !IS_MODULE(CONFIG_SPI_PL022_STARFIVE)
+	subsys_initcall(pl022_init);
+#else
+	module_init(pl022_init);
+#endif
+
+static void __exit pl022_exit(void)
+{
+	amba_driver_unregister(&pl022_driver);
+}
+module_exit(pl022_exit);
+
+/*
+ * Register PL022 in platform bus to accommodate overlay use.
+ * Because overlay only trigger response from the platform bus
+ * not amba bus.
+ */
+static int starfive_of_pl022_probe(struct platform_device *pdev)
+{
+	int ret;
+	const struct amba_id id = {
+		.id = 0x00041022,
+		.mask = 0x000fffff,
+		.data = &vendor_arm
+	};
+	struct device *dev = &pdev->dev;
+
+	ret = of_clk_set_defaults(dev->of_node, false);
+	if (ret < 0)
+		goto err_probe;
+
+	ret = dev_pm_domain_attach(dev, true);
+	if (ret)
+		goto err_probe;
+
+	ret = pl022_platform_probe(pdev, &id);
+
+	pm_runtime_enable(dev);
+	pm_runtime_set_autosuspend_delay(dev, 100);
+	pm_runtime_use_autosuspend(dev);
+
+	if (ret) {
+		pm_runtime_disable(dev);
+		pm_runtime_set_suspended(dev);
+		pm_runtime_put_noidle(dev);
+		dev_pm_domain_detach(dev, true);
+	}
+
+err_probe:
+	return ret;
+}
+
+static int starfive_of_pl022_remove(struct platform_device *pdev)
+{
+	struct pl022 *pl022 = dev_get_drvdata(&pdev->dev);
+
+	if (!pl022)
+		return 0;
+
+	pm_runtime_get_sync(&pdev->dev);
+	pm_runtime_get_noresume(&pdev->dev);
+
+	load_ssp_default_config(pl022);
+	if (pl022->master_info->enable_dma)
+		pl022_dma_remove(pl022);
+
+	clk_disable_unprepare(pl022->clk);
+	tasklet_disable(&pl022->pump_transfers);
+
+	pm_runtime_put_noidle(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
+	dev_pm_domain_detach(&pdev->dev, true);
+
+	return 0;
+}
+
+static const struct of_device_id starfive_of_pl022_match[] = {
+	{ .compatible = "starfive,jh7110-spi-pl022" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, starfive_of_pl022_match);
+
+static struct platform_driver starfive_of_pl022_driver = {
+	.driver = {
+		.name = "starfive-spi-pl022",
+		.of_match_table = starfive_of_pl022_match,
+		.pm	= &pl022_dev_pm_ops,
+	},
+	.probe = starfive_of_pl022_probe,
+	.remove = starfive_of_pl022_remove,
+};
+#if !IS_MODULE(CONFIG_SPI_PL022_STARFIVE)
+	module_platform_driver(starfive_of_pl022_driver);
+/* platform register end */
+#endif
+
+MODULE_AUTHOR("xingyu.wu <xingyu.wu@starfivetech.com>");
+MODULE_AUTHOR("Linus Walleij <linus.walleij@stericsson.com>");
+MODULE_DESCRIPTION("PL022 SSP Controller Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/cdns3/Kconfig b/drivers/usb/cdns3/Kconfig
index 84716d216ae5..1a2cb1bf69e3 100644
--- a/drivers/usb/cdns3/Kconfig
+++ b/drivers/usb/cdns3/Kconfig
@@ -63,4 +63,13 @@ config USB_CDNS3_IMX
 
 	  For example, imx8qm and imx8qxp.
 
+config USB_CDNS3_STARFIVE
+	tristate "Cadence USB3 support on StarFive SoC platforms"
+	depends on SOC_STARFIVE || COMPILE_TEST || USB_CDNS3
+	help
+	  Say 'Y' or 'M' here if you are building for StarFive SoCs
+	  platforms that contain Cadence USB3 controller core.
+
+	  e.g. JH7110.
+
 endif
diff --git a/drivers/usb/cdns3/Makefile b/drivers/usb/cdns3/Makefile
index d47e341a6f39..232e689ce8e9 100644
--- a/drivers/usb/cdns3/Makefile
+++ b/drivers/usb/cdns3/Makefile
@@ -16,3 +16,4 @@ cdns3-$(CONFIG_USB_CDNS3_HOST)		+= host.o
 obj-$(CONFIG_USB_CDNS3_PCI_WRAP)	+= cdns3-pci-wrap.o
 obj-$(CONFIG_USB_CDNS3_TI)		+= cdns3-ti.o
 obj-$(CONFIG_USB_CDNS3_IMX)		+= cdns3-imx.o
+obj-$(CONFIG_USB_CDNS3_STARFIVE)		+= cdns3-starfive.o
diff --git a/drivers/usb/cdns3/cdns3-starfive.c b/drivers/usb/cdns3/cdns3-starfive.c
new file mode 100644
index 000000000000..60700a969a93
--- /dev/null
+++ b/drivers/usb/cdns3/cdns3-starfive.c
@@ -0,0 +1,421 @@
+// SPDX-License-Identifier: GPL-2.0
+/**
+ * cdns-starfive.c - Cadence USB Controller
+ *
+ * Copyright (C) 2022 Starfive, Inc.
+ */
+
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/usb/otg.h>
+#include "core.h"
+
+#define USB_STRAP_HOST			(2 << 0x10)
+#define USB_STRAP_DEVICE		(4 << 0X10)
+#define USB_STRAP_MASK			0x70000
+
+#define USB_SUSPENDM_HOST		(1 << 0x13)
+#define USB_SUSPENDM_DEVICE		(0 << 0x13)
+#define USB_SUSPENDM_MASK		0x80000
+
+#define USB_SUSPENDM_BYPS_SHIFT		0x14
+#define USB_SUSPENDM_BYPS_MASK		0x100000
+#define USB_REFCLK_MODE_SHIFT		0x17
+#define USB_REFCLK_MODE_MASK		0x800000
+#define USB_PLL_EN_SHIFT		0x16
+#define USB_PLL_EN_MASK			0x400000
+#define USB_PDRSTN_SPLIT_SHIFT		0x11
+#define USB_PDRSTN_SPLIT_MASK		0x20000
+
+#define PCIE_CKREF_SRC_SHIFT		0x12
+#define PCIE_CKREF_SRC_MASK		0xC0000
+#define PCIE_CLK_SEL_SHIFT		0x14
+#define PCIE_CLK_SEL_MASK		0x300000
+#define PCIE_PHY_MODE_SHIFT		0x14
+#define PCIE_PHY_MODE_MASK		0x300000
+#define PCIE_USB3_BUS_WIDTH_SHIFT	0x2
+#define PCIE_USB3_BUS_WIDTH_MASK	0xC
+#define PCIE_USB3_RATE_SHIFT		0x5
+#define PCIE_USB3_RATE_MASK		0x60
+#define PCIE_USB3_RX_STANDBY_SHIFT	0x7
+#define PCIE_USB3_RX_STANDBY_MASK	0x80
+#define PCIE_USB3_PHY_ENABLE_SHIFT	0x4
+#define PCIE_USB3_PHY_ENABLE_MASK	0x10
+#define PCIE_USB3_PHY_PLL_CTL_OFF	(0x1f * 4)
+
+
+#define USB_125M_CLK_RATE		125000000
+
+#define USB3_PHY_RES_INDEX		0
+#define USB2_PHY_RES_INDEX		1
+#define USB_LS_KEEPALIVE_OFF		0x4
+#define USB_LS_KEEPALIVE_ENABLE		4
+
+struct cdns_starfive {
+	struct device *dev;
+	struct regmap *stg_syscon;
+	struct regmap *sys_syscon;
+	struct reset_control *resets;
+	struct clk_bulk_data *clks;
+	int num_clks;
+	struct clk *usb_125m_clk;
+	u32 sys_offset;
+	u32 stg_offset_4;
+	u32 stg_offset_196;
+	u32 stg_offset_328;
+	u32 stg_offset_500;
+	bool usb2_only;
+	enum usb_dr_mode mode;
+	void __iomem *phybase_20;
+	void __iomem *phybase_30;
+};
+
+static int cdns_mode_init(struct platform_device *pdev,
+				struct cdns_starfive *data)
+{
+	enum usb_dr_mode mode;
+
+	/* Init usb 2.0 utmi phy */
+	regmap_update_bits(data->stg_syscon, data->stg_offset_4,
+		USB_SUSPENDM_BYPS_MASK, BIT(USB_SUSPENDM_BYPS_SHIFT));
+	regmap_update_bits(data->stg_syscon, data->stg_offset_4,
+		USB_PLL_EN_MASK, BIT(USB_PLL_EN_SHIFT));
+	regmap_update_bits(data->stg_syscon, data->stg_offset_4,
+		USB_REFCLK_MODE_MASK, BIT(USB_REFCLK_MODE_SHIFT));
+
+	if (data->usb2_only) {
+		/* Disconnect usb 3.0 phy mode */
+		regmap_update_bits(data->sys_syscon, data->sys_offset,
+			USB_PDRSTN_SPLIT_MASK, BIT(USB_PDRSTN_SPLIT_SHIFT));
+	} else {
+		/* Config usb 3.0 pipe phy */
+		regmap_update_bits(data->stg_syscon, data->stg_offset_196,
+			PCIE_CKREF_SRC_MASK, (0<<PCIE_CKREF_SRC_SHIFT));
+		regmap_update_bits(data->stg_syscon, data->stg_offset_196,
+			PCIE_CLK_SEL_MASK, (0<<PCIE_CLK_SEL_SHIFT));
+		regmap_update_bits(data->stg_syscon, data->stg_offset_328,
+			PCIE_PHY_MODE_MASK, BIT(PCIE_PHY_MODE_SHIFT));
+		regmap_update_bits(data->stg_syscon, data->stg_offset_500,
+			PCIE_USB3_BUS_WIDTH_MASK, (0 << PCIE_USB3_BUS_WIDTH_SHIFT));
+		regmap_update_bits(data->stg_syscon, data->stg_offset_500,
+			PCIE_USB3_RATE_MASK, (0 << PCIE_USB3_RATE_SHIFT));
+		regmap_update_bits(data->stg_syscon, data->stg_offset_500,
+			PCIE_USB3_RX_STANDBY_MASK, (0 << PCIE_USB3_RX_STANDBY_SHIFT));
+		regmap_update_bits(data->stg_syscon, data->stg_offset_500,
+			PCIE_USB3_PHY_ENABLE_MASK, BIT(PCIE_USB3_PHY_ENABLE_SHIFT));
+
+		/* Connect usb 3.0 phy mode */
+		regmap_update_bits(data->sys_syscon, data->sys_offset,
+			USB_PDRSTN_SPLIT_MASK, (0 << USB_PDRSTN_SPLIT_SHIFT));
+	}
+	mode = usb_get_dr_mode(&pdev->dev);
+	data->mode = mode;
+
+	switch (mode) {
+	case USB_DR_MODE_HOST:
+		regmap_update_bits(data->stg_syscon,
+			data->stg_offset_4,
+			USB_STRAP_MASK,
+			USB_STRAP_HOST);
+		regmap_update_bits(data->stg_syscon,
+			data->stg_offset_4,
+			USB_SUSPENDM_MASK,
+			USB_SUSPENDM_HOST);
+		break;
+
+	case USB_DR_MODE_PERIPHERAL:
+		regmap_update_bits(data->stg_syscon, data->stg_offset_4,
+			USB_STRAP_MASK, USB_STRAP_DEVICE);
+		regmap_update_bits(data->stg_syscon, data->stg_offset_4,
+			USB_SUSPENDM_MASK, USB_SUSPENDM_DEVICE);
+		break;
+
+	case USB_DR_MODE_UNKNOWN:
+	case USB_DR_MODE_OTG:
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+
+static int cdns_clk_rst_init(struct cdns_starfive *data)
+{
+	int ret;
+
+	data->usb_125m_clk = devm_clk_get(data->dev, "125m");
+	if (IS_ERR(data->usb_125m_clk)) {
+		dev_err(data->dev, "Failed to get usb 125m clock\n");
+		ret = PTR_ERR(data->usb_125m_clk);
+		goto exit;
+	}
+
+	data->num_clks = devm_clk_bulk_get_all(data->dev, &data->clks);
+	if (data->num_clks < 0) {
+		dev_err(data->dev, "Failed to get usb clocks\n");
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	/* Needs to set the USB_125M clock explicitly,
+	 * since it's divided from pll0 clock, and the pll0 clock
+	 * changes per the cpu frequency.
+	 */
+	ret = clk_set_rate(data->usb_125m_clk, USB_125M_CLK_RATE);
+	if (ret) {
+		dev_err(data->dev, "Failed to set usb 125m clock\n");
+		goto exit;
+	}
+	ret = clk_bulk_prepare_enable(data->num_clks, data->clks);
+	if (ret) {
+		dev_err(data->dev, "Failed to enable clocks\n");
+		goto exit;
+	}
+
+	data->resets = devm_reset_control_array_get_exclusive(data->dev);
+	if (IS_ERR(data->resets)) {
+		ret = PTR_ERR(data->resets);
+		dev_err(data->dev, "Failed to get usb resets");
+		goto err_clk_init;
+	}
+	ret = reset_control_deassert(data->resets);
+	goto exit;
+
+err_clk_init:
+	clk_bulk_disable_unprepare(data->num_clks, data->clks);
+exit:
+	return ret;
+}
+
+static void cdns_starfive_set_phy(struct cdns_starfive *data)
+{
+	unsigned int val;
+
+	if (data->mode != USB_DR_MODE_PERIPHERAL) {
+		/* Enable the LS speed keep-alive signal */
+		val = readl(data->phybase_20 + USB_LS_KEEPALIVE_OFF);
+		val |= BIT(USB_LS_KEEPALIVE_ENABLE);
+		writel(val, data->phybase_20 + USB_LS_KEEPALIVE_OFF);
+	}
+
+	if (!data->usb2_only) {
+		/* Configuare spread-spectrum mode: down-spread-spectrum */
+		writel(BIT(4), data->phybase_30 + PCIE_USB3_PHY_PLL_CTL_OFF);
+	}
+}
+
+static int cdns_starfive_phy_init(struct platform_device *pdev,
+							struct cdns_starfive *data)
+{
+	struct device *dev = &pdev->dev;
+	int ret = 0;
+
+	data->phybase_20 = devm_platform_ioremap_resource(pdev, USB2_PHY_RES_INDEX);
+	if (IS_ERR(data->phybase_20)) {
+		dev_err(dev, "Can't map phybase_20 IOMEM resource\n");
+		ret = PTR_ERR(data->phybase_20);
+		goto get_res_err;
+	}
+
+	data->phybase_30 = devm_platform_ioremap_resource(pdev, USB3_PHY_RES_INDEX);
+	if (IS_ERR(data->phybase_30)) {
+		dev_err(dev, "Can't map phybase_30 IOMEM resource\n");
+		ret = PTR_ERR(data->phybase_30);
+		goto get_res_err;
+	}
+
+	cdns_starfive_set_phy(data);
+
+get_res_err:
+	return ret;
+}
+
+static struct cdns3_platform_data cdns_starfive_pdata = {
+#ifdef CONFIG_PM_SLEEP
+	.quirks		  = CDNS3_REGISTER_PM_NOTIFIER,
+#endif
+};
+
+static const struct of_dev_auxdata cdns_starfive_auxdata[] = {
+	{
+		.compatible = "cdns,usb3",
+		.platform_data = &cdns_starfive_pdata,
+	},
+	{},
+};
+
+static int cdns_starfive_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = pdev->dev.of_node;
+	struct cdns_starfive *data;
+	struct of_phandle_args args;
+	int ret;
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, data);
+
+	data->dev = dev;
+
+	data->usb2_only = device_property_read_bool(dev, "starfive,usb2-only");
+	ret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+						"starfive,stg-syscon", 4, 0, &args);
+	if (ret < 0) {
+		dev_err(dev, "Failed to parse starfive,stg-syscon\n");
+		return -EINVAL;
+	}
+
+	data->stg_syscon = syscon_node_to_regmap(args.np);
+	of_node_put(args.np);
+	if (IS_ERR(data->stg_syscon))
+		return PTR_ERR(data->stg_syscon);
+	data->stg_offset_4 = args.args[0];
+	data->stg_offset_196 = args.args[1];
+	data->stg_offset_328 = args.args[2];
+	data->stg_offset_500 = args.args[3];
+
+	ret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+						"starfive,sys-syscon", 1, 0, &args);
+	if (ret < 0) {
+		dev_err(dev, "Failed to parse starfive,sys-syscon\n");
+		return -EINVAL;
+	}
+
+	data->sys_syscon = syscon_node_to_regmap(args.np);
+	of_node_put(args.np);
+	if (IS_ERR(data->sys_syscon))
+		return PTR_ERR(data->sys_syscon);
+	data->sys_offset = args.args[0];
+
+	cdns_mode_init(pdev, data);
+
+	ret = cdns_clk_rst_init(data);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to init usb clk reset: %d\n", ret);
+		goto exit;
+	}
+
+	ret = cdns_starfive_phy_init(pdev, data);
+	if (ret) {
+		dev_err(dev, "Failed to init sratfive usb phy: %d\n", ret);
+		goto exit;
+	}
+
+	ret = of_platform_populate(node, NULL, cdns_starfive_auxdata, dev);
+	if (ret) {
+		dev_err(dev, "Failed to create children: %d\n", ret);
+		goto exit;
+	}
+
+	device_set_wakeup_capable(dev, true);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	dev_info(dev, "usb mode %d %s probe success\n",
+		data->mode, data->usb2_only ? "2.0" : "3.0");
+
+	return 0;
+exit:
+	return ret;
+}
+
+static int cdns_starfive_remove_core(struct device *dev, void *c)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	platform_device_unregister(pdev);
+
+	return 0;
+}
+
+static int cdns_starfive_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct cdns_starfive *data = dev_get_drvdata(dev);
+
+	pm_runtime_get_sync(dev);
+	device_for_each_child(dev, NULL, cdns_starfive_remove_core);
+
+	reset_control_assert(data->resets);
+	clk_bulk_disable_unprepare(data->num_clks, data->clks);
+	pm_runtime_disable(dev);
+	pm_runtime_put_noidle(dev);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int cdns_starfive_resume(struct device *dev)
+{
+	struct cdns_starfive *data = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_set_rate(data->usb_125m_clk, USB_125M_CLK_RATE);
+	if (ret)
+		goto err;
+
+	ret = clk_bulk_prepare_enable(data->num_clks, data->clks);
+	if (ret)
+		goto err;
+
+	ret = reset_control_deassert(data->resets);
+	if (ret)
+		goto err;
+
+	cdns_starfive_set_phy(data);
+err:
+	return ret;
+}
+
+static int cdns_starfive_suspend(struct device *dev)
+{
+	struct cdns_starfive *data = dev_get_drvdata(dev);
+
+	clk_bulk_disable_unprepare(data->num_clks, data->clks);
+	reset_control_assert(data->resets);
+
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops cdns_starfive_pm_ops = {
+	SET_RUNTIME_PM_OPS(cdns_starfive_suspend, cdns_starfive_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(cdns_starfive_suspend, cdns_starfive_resume)
+};
+
+static const struct of_device_id cdns_starfive_of_match[] = {
+	{ .compatible = "starfive,jh7110-cdns3", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, cdns_starfive_of_match);
+
+static struct platform_driver cdns_starfive_driver = {
+	.probe		= cdns_starfive_probe,
+	.remove		= cdns_starfive_remove,
+	.driver		= {
+		.name	= "cdns3-starfive",
+		.of_match_table	= cdns_starfive_of_match,
+		.pm	= &cdns_starfive_pm_ops,
+	},
+};
+
+module_platform_driver(cdns_starfive_driver);
+
+MODULE_ALIAS("platform:cdns3-starfive");
+MODULE_AUTHOR("YanHong Wang <yanhong.wang@starfivetech.com>");
+MODULE_AUTHOR("Mason Huo <mason.huo@starfivetech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Cadence USB3 StarFive SoC platform");
diff --git a/drivers/usb/cdns3/core.h b/drivers/usb/cdns3/core.h
index 3176f924293a..3b7718f41e72 100644
--- a/drivers/usb/cdns3/core.h
+++ b/drivers/usb/cdns3/core.h
@@ -44,6 +44,7 @@ struct cdns3_platform_data {
 			bool suspend, bool wakeup);
 	unsigned long quirks;
 #define CDNS3_DEFAULT_PM_RUNTIME_ALLOW	BIT(0)
+#define CDNS3_REGISTER_PM_NOTIFIER	BIT(1)
 };
 
 /**
diff --git a/drivers/usb/cdns3/host.c b/drivers/usb/cdns3/host.c
index 102977790d60..805244ac58b8 100644
--- a/drivers/usb/cdns3/host.c
+++ b/drivers/usb/cdns3/host.c
@@ -28,6 +28,76 @@ static const struct xhci_plat_priv xhci_plat_cdns3_xhci = {
 	.suspend_quirk = xhci_cdns3_suspend_quirk,
 };
 
+#ifdef CONFIG_PM_SLEEP
+struct cdns_hiber_data {
+	struct usb_hcd *hcd;
+	struct usb_hcd *shared_hcd;
+	struct notifier_block pm_notifier;
+	int (*pm_setup)(struct usb_hcd *hcd);
+	int (*pm_remove)(struct cdns3 *cdns);
+};
+static struct cdns_hiber_data cdns3_hiber_data;
+
+static int cdns_hiber_notifier(struct notifier_block *nb, unsigned long action,
+			void *data)
+{
+	struct usb_hcd *hcd = cdns3_hiber_data.hcd;
+	struct usb_hcd *shared_hcd = cdns3_hiber_data.shared_hcd;
+
+	switch (action) {
+	case PM_RESTORE_PREPARE:
+		if (hcd->state == HC_STATE_SUSPENDED) {
+			usb_hcd_resume_root_hub(hcd);
+			usb_disable_autosuspend(hcd->self.root_hub);
+		}
+		if (shared_hcd->state == HC_STATE_SUSPENDED) {
+			usb_hcd_resume_root_hub(shared_hcd);
+			usb_disable_autosuspend(shared_hcd->self.root_hub);
+		}
+		break;
+	case PM_POST_RESTORE:
+		usb_enable_autosuspend(hcd->self.root_hub);
+		usb_enable_autosuspend(shared_hcd->self.root_hub);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int cdns_register_pm_notifier(struct usb_hcd *hcd)
+{
+	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+
+	cdns3_hiber_data.hcd = xhci->main_hcd;
+	cdns3_hiber_data.shared_hcd = xhci->shared_hcd;
+	cdns3_hiber_data.pm_notifier.notifier_call = cdns_hiber_notifier;
+	return register_pm_notifier(&cdns3_hiber_data.pm_notifier);
+}
+
+static int cdns_unregister_pm_notifier(struct cdns3 *cdns)
+{
+	int ret;
+
+	ret = unregister_pm_notifier(&cdns3_hiber_data.pm_notifier);
+
+	cdns3_hiber_data.hcd = NULL;
+	cdns3_hiber_data.shared_hcd = NULL;
+
+	return ret;
+}
+#endif
+
+static int xhci_cdns3_plat_setup(struct usb_hcd *hcd)
+{
+#ifdef CONFIG_PM_SLEEP
+	if (cdns3_hiber_data.pm_setup)
+		cdns3_hiber_data.pm_setup(hcd);
+#endif
+	return 0;
+}
+
 static int __cdns3_host_init(struct cdns3 *cdns)
 {
 	struct platform_device *xhci;
@@ -62,6 +132,13 @@ static int __cdns3_host_init(struct cdns3 *cdns)
 	if (cdns->pdata && (cdns->pdata->quirks & CDNS3_DEFAULT_PM_RUNTIME_ALLOW))
 		cdns->xhci_plat_data->quirks |= XHCI_DEFAULT_PM_RUNTIME_ALLOW;
 
+	cdns->xhci_plat_data->plat_setup = xhci_cdns3_plat_setup;
+#ifdef CONFIG_PM_SLEEP
+	if (cdns->pdata && (cdns->pdata->quirks & CDNS3_REGISTER_PM_NOTIFIER)) {
+		cdns3_hiber_data.pm_setup = cdns_register_pm_notifier;
+		cdns3_hiber_data.pm_remove = cdns_unregister_pm_notifier;
+	}
+#endif
 	ret = platform_device_add_data(xhci, cdns->xhci_plat_data,
 			sizeof(struct xhci_plat_priv));
 	if (ret)
@@ -115,6 +192,14 @@ int xhci_cdns3_suspend_quirk(struct usb_hcd *hcd)
 
 static void cdns3_host_exit(struct cdns3 *cdns)
 {
+#ifdef CONFIG_PM_SLEEP
+	if (cdns3_hiber_data.pm_remove) {
+		cdns3_hiber_data.pm_remove(cdns);
+		cdns3_hiber_data.pm_remove = NULL;
+		cdns3_hiber_data.pm_setup = NULL;
+	}
+#endif
+
 	kfree(cdns->xhci_plat_data);
 	platform_device_unregister(cdns->host_dev);
 	cdns->host_dev = NULL;
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 01ce3f41cc21..2e761ace3775 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -2056,6 +2056,14 @@ config UML_WATCHDOG
 	tristate "UML watchdog"
 	depends on UML || COMPILE_TEST
 
+# RISCV Architecture
+
+config STARFIVE_WATCHDOG
+	tristate "StarFive Watchdog support"
+	depends on RISCV
+	select WATCHDOG_CORE
+	help
+	  Say Y here to support the Starfive watchdog.
 #
 # ISA-based Watchdog Cards
 #
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 071a2e50be98..a95bd3858f7b 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -207,6 +207,9 @@ obj-$(CONFIG_WATCHDOG_SUN4V)		+= sun4v_wdt.o
 # Xen
 obj-$(CONFIG_XEN_WDT) += xen_wdt.o
 
+# RISCV Architecture
+obj-$(CONFIG_STARFIVE_WATCHDOG) += starfive-wdt.o
+
 # Architecture Independent
 obj-$(CONFIG_BD70528_WATCHDOG) += bd70528_wdt.o
 obj-$(CONFIG_DA9052_WATCHDOG) += da9052_wdt.o
diff --git a/drivers/watchdog/starfive-wdt.c b/drivers/watchdog/starfive-wdt.c
new file mode 100644
index 000000000000..d316767fcaf5
--- /dev/null
+++ b/drivers/watchdog/starfive-wdt.c
@@ -0,0 +1,887 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2021 StarFive, Inc <samin.guo@starfivetech.com>
+ * Copyright 2022 StarFive, Inc <xingyu.wu@starfivetech.com>
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING
+ * CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER
+ * FOR THEM TO SAVE TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE
+ * FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY
+ * CLAIMS ARISING FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE
+ * BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION
+ * WITH THEIR PRODUCTS.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/mfd/syscon.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <linux/uaccess.h>
+#include <linux/watchdog.h>
+#include <linux/reset.h>
+#include <linux/reset-controller.h>
+#include <linux/pm_runtime.h>
+
+#define WDT_INT_DIS	BIT(0)
+#define DELAY_US	0
+#define TIMEOUT_US	10000
+
+/* JH7100 WatchDog register define */
+#define JH7100_WDGINTSTAUS	0x000
+#define JH7100_WDOGCONTROL	0x104	/* Watchdog Control Register R/W */
+#define JH7100_WDOGLOAD		0x108	/* The initial value to be loaded */
+				/* into the counter and is also used */
+				/* as the reload value. R/W */
+#define JH7100_WDOGEN		0x110	/* Watchdog enable Register */
+#define JH7100_WDOGRELOAD	0x114	/* Write this register to reload preset */
+				/* value to counter. (Write 0 or 1 are both ok) */
+#define JH7100_WDOGVALUE	0x118	/* Watchdog Value Register RO */
+#define JH7100_WDOGINTCLR	0x120	/* Watchdog Clear Interrupt Register WO */
+#define JH7100_WDOGINTMSK	0x124	/* Watchdog Interrupt Mask Register */
+#define JH7100_WDOGLOCK		0x13c	/* Watchdog Lock Register  R/W */
+
+#define JH7100_UNLOCK_KEY	0x378f0765
+#define JH7100_RESEN_SHIFT	0
+#define JH7100_EN_SHIFT		0
+#define JH7100_INTCLR_AVA_SHIFT	1	/* Watchdog can clear interrupt when this bit is 0 */
+
+/* JH7110 WatchDog register define */
+#define JH7110_WDOGLOAD		0x000	/* RW: Watchdog load register */
+#define JH7110_WDOGVALUE	0x004	/* RO: The current value for the watchdog counter */
+#define JH7110_WDOGCONTROL	0x008	/* RW: [0]: reset enable;  [1]: int enable/wdt enable/reload counter; [31:2]: res */
+#define JH7110_WDOGINTCLR	0x00c	/* WO: clear intterupt && reload the counter */
+#define JH7110_WDOGRIS		0x010	/* RO: Raw interrupt status from the counter */
+#define JH7110_WDOGIMS		0x014	/* RO: Enabled interrupt status from the counter */
+#define JH7110_WDOGLOCK		0xc00	/* RO: Enable write access to all other registers by writing 0x1ACCE551 */
+#define JH7110_WDOGITCR		0xf00	/* RW: When set HIGH, places the Watchdog into integraeion test mode */
+#define JH7110_WDOGITOP		0xf04	/* WO:	[0] Integration Test WDOGRES value Integration Test Mode
+					 * Value output on WDOGRES when in Integration Test Mode
+					 * [1] Integration Test WDOGINT value
+					 * Value output on WDOGINT when in Integration Test Mode
+					 */
+
+#define JH7110_UNLOCK_KEY	0x1acce551
+#define JH7110_RESEN_SHIFT	1
+#define JH7110_EN_SHIFT		0
+#define JH7110_INT_EN_SHIFT	JH7110_EN_SHIFT
+
+/* WDOGCONTROL */
+#define WDOG_INT_EN	0x0
+#define WDOG_RESET_EN	0x1
+
+/* WDOGLOCK */
+#define WDOG_LOCKED		BIT(0)
+
+#define STARFIVE_WATCHDOG_INTCLR	0x1
+#define STARFIVE_WATCHDOG_ENABLE	0x1
+#define STARFIVE_WATCHDOG_ATBOOT	0x0
+#define STARFIVE_WATCHDOG_MAXCNT	0xffffffff
+
+#define STARFIVE_WATCHDOG_DEFAULT_TIME	(15)
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+static int tmr_margin;
+static int tmr_atboot = STARFIVE_WATCHDOG_ATBOOT;
+static int soft_noboot;
+
+module_param(tmr_margin, int, 0);
+module_param(tmr_atboot, int, 0);
+module_param(nowayout, bool, 0);
+module_param(soft_noboot, int, 0);
+
+MODULE_PARM_DESC(tmr_margin, "Watchdog tmr_margin in seconds. (default="
+		__MODULE_STRING(STARFIVE_WATCHDOG_DEFAULT_TIME) ")");
+MODULE_PARM_DESC(tmr_atboot,
+		"Watchdog is started at boot time if set to 1, default="
+			__MODULE_STRING(STARFIVE_WATCHDOG_ATBOOT));
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default="
+			__MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+MODULE_PARM_DESC(soft_noboot,
+	"Watchdog action, set to 1 to ignore reboots, 0 to reboot (default 0)");
+
+struct starfive_wdt_variant_t {
+	u32 unlock_key;
+	u8 enrst_shift;
+	u8 en_shift;
+	u8 intclr_check;
+	u8 intclr_ava_shift;
+};
+
+struct starfive_wdt_variant {
+	u32 control;
+	u32 load;
+	u32 enable;
+	u32 reload;
+	u32 value;
+	u32 int_clr;
+	u32 int_mask;
+	u32 unlock;
+	u32 enter_irq_status;
+	struct starfive_wdt_variant_t *variant;
+};
+
+struct starfive_wdt {
+	u64 freq;
+	struct device *dev;
+	struct watchdog_device wdt_device;
+	struct clk *core_clk;
+	struct clk *apb_clk;
+	struct reset_control *rsts;
+	const struct starfive_wdt_variant *drv_data;
+	u32 count;	/*count of timeout*/
+	u32 reload;	/*restore the count*/
+	void __iomem *base;
+	spinlock_t lock;
+
+	int irq;
+};
+
+#ifdef CONFIG_OF
+static struct starfive_wdt_variant_t jh7100_variant = {
+	.unlock_key = JH7100_UNLOCK_KEY,
+	.enrst_shift = JH7100_RESEN_SHIFT,
+	.en_shift = JH7100_EN_SHIFT,
+	.intclr_check = 1,
+	.intclr_ava_shift = JH7100_INTCLR_AVA_SHIFT,
+};
+
+static struct starfive_wdt_variant_t jh7110_variant = {
+	.unlock_key = JH7110_UNLOCK_KEY,
+	.enrst_shift = JH7110_RESEN_SHIFT,
+	.en_shift = JH7110_EN_SHIFT,
+};
+
+static const struct starfive_wdt_variant drv_data_jh7100 = {
+	.control = JH7100_WDOGCONTROL,
+	.load = JH7100_WDOGLOAD,
+	.enable = JH7100_WDOGEN,
+	.reload = JH7100_WDOGRELOAD,
+	.value = JH7100_WDOGVALUE,
+	.int_clr = JH7100_WDOGINTCLR,
+	.int_mask = JH7100_WDOGINTMSK,
+	.unlock = JH7100_WDOGLOCK,
+	.variant = &jh7100_variant,
+};
+
+static const struct starfive_wdt_variant drv_data_jh7110 = {
+	.control = JH7110_WDOGCONTROL,
+	.load = JH7110_WDOGLOAD,
+	.enable = JH7110_WDOGCONTROL,
+	.value = JH7110_WDOGVALUE,
+	.int_clr = JH7110_WDOGINTCLR,
+	.unlock = JH7110_WDOGLOCK,
+	.enter_irq_status = JH7110_WDOGIMS,
+	.variant = &jh7110_variant,
+};
+
+static const struct of_device_id starfive_wdt_match[] = {
+	{ .compatible = "starfive,jh7100-wdt", .data = &drv_data_jh7100 },
+	{ .compatible = "starfive,jh7110-wdt", .data = &drv_data_jh7110 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, starfive_wdt_match);
+#endif
+
+static const struct platform_device_id starfive_wdt_ids[] = {
+	{
+		.name = "starfive-wdt",
+		.driver_data = (unsigned long)&drv_data_jh7100,
+	},
+	{
+		.name = "starfive-dskit-wdt",
+		.driver_data = (unsigned long)&drv_data_jh7110,
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(platform, starfive_wdt_ids);
+
+static int starfive_wdt_get_clock_rate(struct starfive_wdt *wdt)
+{
+	int ret;
+	u32 freq;
+
+	/* Next we try to get clock-frequency from dts.*/
+	ret = of_property_read_u32(wdt->dev->of_node, "clock-frequency", &freq);
+	if (!ret) {
+		wdt->freq = (u64)freq;
+		return 0;
+	}
+	dev_dbg(wdt->dev, "get rate failed, need clock-frequency define in dts.\n");
+
+	if (!IS_ERR(wdt->core_clk)) {
+		wdt->freq = clk_get_rate(wdt->core_clk);
+		return 0;
+	}
+	dev_err(wdt->dev, "get clock-frequency failed\n");
+	return -ENOENT;
+}
+
+static int starfive_wdt_enable_clock(struct starfive_wdt *wdt)
+{
+	int err = 0;
+
+	wdt->apb_clk = devm_clk_get(wdt->dev, "apb_clk");
+	if (!IS_ERR(wdt->apb_clk)) {
+		err = clk_prepare_enable(wdt->apb_clk);
+		if (err)
+			dev_warn(wdt->dev, "enable core_clk error.\n");
+	}
+
+	wdt->core_clk = devm_clk_get(wdt->dev, "core_clk");
+	if (!IS_ERR(wdt->core_clk)) {
+		err = clk_prepare_enable(wdt->core_clk);
+		if (err)
+			dev_warn(wdt->dev, "enable apb_clk error.\n");
+	}
+
+	return err;
+}
+
+static int starfive_wdt_reset_init(struct starfive_wdt *wdt)
+{
+	int err = 0;
+
+	wdt->rsts = devm_reset_control_array_get_exclusive(wdt->dev);
+	if (!IS_ERR(wdt->rsts)) {
+		err = reset_control_deassert(wdt->rsts);
+		if (err)
+			dev_err(wdt->dev, "deassert rsts error.\n");
+	} else
+		err = PTR_ERR(wdt->rsts);
+
+	return err;
+}
+
+static __maybe_unused
+u32 starfive_wdt_sec_to_ticks(struct starfive_wdt *wdt, u32 sec)
+{
+	return sec * wdt->freq;
+}
+
+static __maybe_unused
+u32 starfive_wdt_ticks_to_sec(struct starfive_wdt *wdt, u32 ticks)
+{
+	return DIV_ROUND_CLOSEST(ticks, wdt->freq);
+}
+
+/*
+ * Write unlock-key to unlock. Write other value to lock. When lock bit is 1,
+ * external accesses to other watchdog registers are ignored.
+ */
+static int starfive_wdt_is_locked(struct starfive_wdt *wdt)
+{
+	u32 val;
+
+	val = readl(wdt->base + wdt->drv_data->unlock);
+	return !!(val & WDOG_LOCKED);
+}
+
+static void starfive_wdt_unlock(struct starfive_wdt *wdt)
+{
+	if (starfive_wdt_is_locked(wdt))
+		writel(wdt->drv_data->variant->unlock_key,
+			wdt->base + wdt->drv_data->unlock);
+}
+
+static void starfive_wdt_lock(struct starfive_wdt *wdt)
+{
+	if (!starfive_wdt_is_locked(wdt))
+		writel(~wdt->drv_data->variant->unlock_key,
+			wdt->base + wdt->drv_data->unlock);
+}
+
+static int __maybe_unused starfive_wdt_is_running(struct starfive_wdt *wdt)
+{
+	u32 val;
+
+	starfive_wdt_unlock(wdt);
+	val = readl(wdt->base + wdt->drv_data->enable);
+	starfive_wdt_lock(wdt);
+
+	return !!(val & STARFIVE_WATCHDOG_ENABLE <<
+		wdt->drv_data->variant->en_shift);
+}
+
+static inline void starfive_wdt_int_enable(struct starfive_wdt *wdt)
+{
+	u32 val;
+
+	if (wdt->drv_data->int_mask) {
+		val = readl(wdt->base + wdt->drv_data->int_mask);
+		val &= ~WDT_INT_DIS;
+		writel(val, wdt->base + wdt->drv_data->int_mask);
+	}
+}
+
+static inline void starfive_wdt_int_disable(struct starfive_wdt *wdt)
+{
+	u32 val;
+
+	if (wdt->drv_data->int_mask) {
+		val = readl(wdt->base + wdt->drv_data->int_mask);
+		val |= WDT_INT_DIS;
+		writel(val, wdt->base + wdt->drv_data->int_mask);
+	}
+}
+
+static void starfive_wdt_enable_reset(struct starfive_wdt *wdt)
+{
+	u32 val;
+
+	val = readl(wdt->base + wdt->drv_data->control);
+	val |= WDOG_RESET_EN << wdt->drv_data->variant->enrst_shift;
+	/* enable wdog interrupt to reset */
+	writel(val, wdt->base + wdt->drv_data->control);
+}
+
+static void starfive_wdt_disable_reset(struct starfive_wdt *wdt)
+{
+	u32 val;
+
+	val = readl(wdt->base + wdt->drv_data->control);
+	val &= ~(WDOG_RESET_EN << wdt->drv_data->variant->enrst_shift);
+	/*disable wdog interrupt to reset*/
+	writel(val, wdt->base + wdt->drv_data->control);
+}
+
+static bool starfive_wdt_enter_irq_status(struct starfive_wdt *wdt)
+{
+	/* interrupt status whether has entered from the counter */
+	return !!readl(wdt->base + wdt->drv_data->enter_irq_status);
+}
+
+static void starfive_wdt_int_clr(struct starfive_wdt *wdt)
+{
+	void __iomem *addr;
+	u8 clr_check;
+	u8 clr_ava_shift;
+	u32 value;
+	int ret = 0;
+
+	addr = wdt->base + wdt->drv_data->int_clr;
+	clr_ava_shift = wdt->drv_data->variant->intclr_ava_shift;
+	clr_check = wdt->drv_data->variant->intclr_check;
+	if (clr_check) {
+		/* waiting interrupt can be to clearing */
+		value = readl(addr);
+		ret = readl_poll_timeout_atomic(addr, value,
+				!(value & BIT(clr_ava_shift)), DELAY_US, TIMEOUT_US);
+	}
+
+	if (!ret)
+		writel(STARFIVE_WATCHDOG_INTCLR, addr);
+
+	if (starfive_wdt_enter_irq_status(wdt))
+		enable_irq(wdt->irq);
+}
+
+static inline void starfive_wdt_set_count(struct starfive_wdt *wdt, u32 val)
+{
+	writel(val, wdt->base + wdt->drv_data->load);
+}
+
+static inline u32 starfive_wdt_get_count(struct starfive_wdt *wdt)
+{
+	return readl(wdt->base + wdt->drv_data->value);
+}
+
+static inline void starfive_wdt_enable(struct starfive_wdt *wdt)
+{
+	u32 val;
+
+	val = readl(wdt->base + wdt->drv_data->enable);
+	val |= STARFIVE_WATCHDOG_ENABLE << wdt->drv_data->variant->en_shift;
+	writel(val, wdt->base + wdt->drv_data->enable);
+}
+
+static inline void starfive_wdt_disable(struct starfive_wdt *wdt)
+{
+	u32 val;
+
+	val = readl(wdt->base + wdt->drv_data->enable);
+	val &= ~(STARFIVE_WATCHDOG_ENABLE << wdt->drv_data->variant->en_shift);
+	writel(val, wdt->base + wdt->drv_data->enable);
+}
+
+static inline void
+starfive_wdt_set_relod_count(struct starfive_wdt *wdt, u32 count)
+{
+	writel(count, wdt->base + wdt->drv_data->load);
+	if (wdt->drv_data->reload)
+		writel(0x1, wdt->base + wdt->drv_data->reload);
+	else
+		/* jh7110 need enable controller to reload counter */
+		starfive_wdt_enable(wdt);
+}
+
+static int starfive_wdt_mask_and_disable_reset(struct starfive_wdt *wdt, bool mask)
+{
+	starfive_wdt_unlock(wdt);
+
+	if (mask)
+		starfive_wdt_disable_reset(wdt);
+	else
+		starfive_wdt_enable_reset(wdt);
+
+	starfive_wdt_lock(wdt);
+
+	return 0;
+}
+
+static unsigned int starfive_wdt_max_timeout(struct starfive_wdt *wdt)
+{
+	return DIV_ROUND_UP(STARFIVE_WATCHDOG_MAXCNT, wdt->freq) - 1;
+}
+
+static unsigned int starfive_wdt_get_timeleft(struct watchdog_device *wdd)
+{
+	struct starfive_wdt *wdt = watchdog_get_drvdata(wdd);
+	u32 count;
+	u32 irq_status;
+
+	starfive_wdt_unlock(wdt);
+	/*
+	 * Because set half count value,
+	 * timeleft value should add the count value before first timeout.
+	 */
+	irq_status = starfive_wdt_enter_irq_status(wdt) ? 1 : 0;
+	count = starfive_wdt_get_count(wdt) + (1 - irq_status) * wdt->count;
+	starfive_wdt_lock(wdt);
+
+	return starfive_wdt_ticks_to_sec(wdt, count);
+}
+
+static int starfive_wdt_keepalive(struct watchdog_device *wdd)
+{
+	struct starfive_wdt *wdt = watchdog_get_drvdata(wdd);
+
+	spin_lock(&wdt->lock);
+
+	starfive_wdt_unlock(wdt);
+	starfive_wdt_int_clr(wdt);
+	starfive_wdt_set_relod_count(wdt, wdt->count);
+	starfive_wdt_lock(wdt);
+
+	spin_unlock(&wdt->lock);
+
+	return 0;
+}
+
+static irqreturn_t starfive_wdt_interrupt_handler(int irq, void *data)
+{
+	/*
+	 * We don't clear the IRQ status. It's supposed to be done by the
+	 * following ping operations.
+	 */
+	struct platform_device *pdev = data;
+	struct starfive_wdt *wdt = platform_get_drvdata(pdev);
+
+	/* Disable the IRQ and avoid re-entry interrupt. */
+	disable_irq_nosync(wdt->irq);
+
+	return IRQ_HANDLED;
+}
+
+static int starfive_wdt_stop(struct watchdog_device *wdd)
+{
+	struct starfive_wdt *wdt = watchdog_get_drvdata(wdd);
+
+	spin_lock(&wdt->lock);
+
+	starfive_wdt_unlock(wdt);
+	starfive_wdt_int_disable(wdt);
+	starfive_wdt_int_clr(wdt);
+	starfive_wdt_disable(wdt);
+	starfive_wdt_lock(wdt);
+
+	spin_unlock(&wdt->lock);
+
+	return 0;
+}
+
+static int starfive_wdt_pm_stop(struct watchdog_device *wdd)
+{
+	struct starfive_wdt *wdt = watchdog_get_drvdata(wdd);
+
+	starfive_wdt_stop(wdd);
+	pm_runtime_put(wdt->dev);
+
+	return 0;
+}
+
+static int starfive_wdt_start(struct watchdog_device *wdd)
+{
+	struct starfive_wdt *wdt = watchdog_get_drvdata(wdd);
+
+	pm_runtime_get_sync(wdt->dev);
+
+	spin_lock(&wdt->lock);
+
+	starfive_wdt_unlock(wdt);
+
+	if (soft_noboot)
+		starfive_wdt_disable_reset(wdt);
+	else
+		starfive_wdt_enable_reset(wdt);
+
+	starfive_wdt_int_clr(wdt);
+	starfive_wdt_set_count(wdt, wdt->count);
+	starfive_wdt_int_enable(wdt);
+	starfive_wdt_enable(wdt);
+
+	starfive_wdt_lock(wdt);
+
+	spin_unlock(&wdt->lock);
+
+	return 0;
+}
+
+static int starfive_wdt_restart(struct watchdog_device *wdd, unsigned long action,
+				void *data)
+{
+	struct starfive_wdt *wdt = watchdog_get_drvdata(wdd);
+
+	starfive_wdt_unlock(wdt);
+	/* disable watchdog, to be safe */
+	starfive_wdt_disable(wdt);
+
+	if (soft_noboot)
+		starfive_wdt_disable_reset(wdt);
+	else
+		starfive_wdt_enable_reset(wdt);
+
+	/* put initial values into count and data */
+	starfive_wdt_set_count(wdt, wdt->count);
+
+	/* set the watchdog to go and reset... */
+	starfive_wdt_int_clr(wdt);
+	starfive_wdt_int_enable(wdt);
+	starfive_wdt_enable(wdt);
+
+	/* wait for reset to assert... */
+	mdelay(500);
+
+	starfive_wdt_lock(wdt);
+
+	return 0;
+}
+
+static int starfive_wdt_set_timeout(struct watchdog_device *wdd,
+				    unsigned int timeout)
+{
+	struct starfive_wdt *wdt = watchdog_get_drvdata(wdd);
+
+	unsigned long freq = wdt->freq;
+	unsigned int count;
+
+	if (timeout < 1)
+		return -EINVAL;
+
+	/*
+	 * This watchdog takes twice timeouts to reset.
+	 * In order to reduce time to reset, should set half count value.
+	 */
+	count = timeout * freq / 2;
+
+	if (count > STARFIVE_WATCHDOG_MAXCNT) {
+		dev_warn(wdt->dev, "timeout %d too big,use the MAX-timeout set.\n",
+				timeout);
+		timeout = starfive_wdt_max_timeout(wdt);
+		count = timeout * freq;
+	}
+
+	dev_info(wdt->dev, "Heartbeat: timeout=%d, count/2=%d (%08x)\n",
+		timeout, count, count);
+
+	starfive_wdt_unlock(wdt);
+	starfive_wdt_disable(wdt);
+	starfive_wdt_set_relod_count(wdt, count);
+	starfive_wdt_enable(wdt);
+	starfive_wdt_lock(wdt);
+
+	wdt->count = count;
+	wdd->timeout = timeout;
+
+	return 0;
+}
+
+#define OPTIONS (WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE)
+
+static const struct watchdog_info starfive_wdt_ident = {
+	.options	= OPTIONS,
+	.firmware_version = 0,
+	.identity	= "StarFive Watchdog",
+};
+
+static const struct watchdog_ops starfive_wdt_ops = {
+	.owner = THIS_MODULE,
+	.start = starfive_wdt_start,
+	.stop = starfive_wdt_pm_stop,
+	.ping = starfive_wdt_keepalive,
+	.set_timeout = starfive_wdt_set_timeout,
+	.restart = starfive_wdt_restart,
+	.get_timeleft = starfive_wdt_get_timeleft,
+};
+
+static const struct watchdog_device starfive_wdd = {
+	.info = &starfive_wdt_ident,
+	.ops = &starfive_wdt_ops,
+	.timeout = STARFIVE_WATCHDOG_DEFAULT_TIME,
+};
+
+static inline const struct starfive_wdt_variant *
+starfive_get_wdt_drv_data(struct platform_device *pdev)
+{
+	const struct starfive_wdt_variant *variant;
+
+	variant = of_device_get_match_data(&pdev->dev);
+	if (!variant) {
+		/* Device matched by platform_device_id */
+		variant = (struct starfive_wdt_variant *)
+			platform_get_device_id(pdev)->driver_data;
+	}
+
+	return variant;
+}
+
+static int starfive_wdt_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct starfive_wdt *wdt;
+	int started = 0;
+	int ret;
+
+	pm_runtime_enable(dev);
+
+	wdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);
+	if (!wdt)
+		return -ENOMEM;
+
+	wdt->dev = dev;
+	spin_lock_init(&wdt->lock);
+	wdt->wdt_device = starfive_wdd;
+
+	wdt->drv_data = starfive_get_wdt_drv_data(pdev);
+
+	wdt->irq = platform_get_irq(pdev, 0);
+	if (wdt->irq < 0) {
+		dev_err(dev, "can not find irq.\n");
+		return wdt->irq;
+	}
+
+	/* get the memory region for the watchdog timer */
+	wdt->base = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(wdt->base)) {
+		ret = PTR_ERR(wdt->base);
+		goto err;
+	}
+
+	ret = starfive_wdt_enable_clock(wdt);
+	if (ret)
+		dev_warn(wdt->dev, "get & enable clk err\n");
+
+	starfive_wdt_get_clock_rate(wdt);
+
+	ret = starfive_wdt_reset_init(wdt);
+	if (ret)
+		dev_warn(wdt->dev, "get & deassert rst err\n");
+
+	wdt->wdt_device.min_timeout = 1;
+	wdt->wdt_device.max_timeout = starfive_wdt_max_timeout(wdt);
+
+	watchdog_set_drvdata(&wdt->wdt_device, wdt);
+
+	/*
+	 * see if we can actually set the requested timer margin,
+	 * and if not, try the default value.
+	 */
+	watchdog_init_timeout(&wdt->wdt_device, tmr_margin, dev);
+
+	ret = starfive_wdt_set_timeout(&wdt->wdt_device,
+				       wdt->wdt_device.timeout);
+	if (ret) {
+		dev_info(dev, "tmr_margin value out of range, default %d used\n",
+				 STARFIVE_WATCHDOG_DEFAULT_TIME);
+		starfive_wdt_set_timeout(&wdt->wdt_device,
+					 STARFIVE_WATCHDOG_DEFAULT_TIME);
+	}
+
+	ret = devm_request_irq(dev, wdt->irq, starfive_wdt_interrupt_handler, 0,
+			       pdev->name, pdev);
+	if (ret != 0) {
+		dev_err(dev, "failed to install irq (%d)\n", ret);
+		goto err;
+	}
+
+	watchdog_set_nowayout(&wdt->wdt_device, nowayout);
+	watchdog_set_restart_priority(&wdt->wdt_device, 128);
+
+	wdt->wdt_device.parent = dev;
+
+	ret = watchdog_register_device(&wdt->wdt_device);
+	if (ret)
+		goto err;
+
+	ret = starfive_wdt_mask_and_disable_reset(wdt, false);
+	if (ret < 0)
+		goto err_unregister;
+
+	if (tmr_atboot && started == 0) {
+		dev_info(dev, "starting watchdog timer\n");
+		starfive_wdt_start(&wdt->wdt_device);
+	} else if (!tmr_atboot) {
+
+		/*
+		 *if we're not enabling the watchdog, then ensure it is
+		 * disabled if it has been left running from the bootloader
+		 * or other source.
+		 */
+		starfive_wdt_stop(&wdt->wdt_device);
+	}
+	clk_disable_unprepare(wdt->core_clk);
+	clk_disable_unprepare(wdt->apb_clk);
+
+	platform_set_drvdata(pdev, wdt);
+
+	return 0;
+
+err_unregister:
+	watchdog_unregister_device(&wdt->wdt_device);
+err:
+	return ret;
+}
+
+static int starfive_wdt_remove(struct platform_device *dev)
+{
+	int ret;
+	struct starfive_wdt *wdt = platform_get_drvdata(dev);
+
+	ret = starfive_wdt_mask_and_disable_reset(wdt, true);
+	if (ret < 0)
+		return ret;
+
+	watchdog_unregister_device(&wdt->wdt_device);
+
+	clk_disable_unprepare(wdt->core_clk);
+	clk_disable_unprepare(wdt->apb_clk);
+	pm_runtime_disable(wdt->dev);
+
+	return 0;
+}
+
+static void starfive_wdt_shutdown(struct platform_device *dev)
+{
+	struct starfive_wdt *wdt = platform_get_drvdata(dev);
+
+	starfive_wdt_mask_and_disable_reset(wdt, true);
+
+	starfive_wdt_pm_stop(&wdt->wdt_device);
+}
+
+#ifdef CONFIG_PM_SLEEP
+
+static int starfive_wdt_suspend(struct device *dev)
+{
+	int ret;
+	struct starfive_wdt *wdt = dev_get_drvdata(dev);
+
+	starfive_wdt_unlock(wdt);
+
+	/* Save watchdog state, and turn it off. */
+	wdt->reload = starfive_wdt_get_count(wdt);
+
+	ret = starfive_wdt_mask_and_disable_reset(wdt, true);
+	if (ret < 0)
+		return ret;
+
+	/* Note that WTCNT doesn't need to be saved. */
+	starfive_wdt_stop(&wdt->wdt_device);
+	pm_runtime_force_suspend(dev);
+
+	starfive_wdt_lock(wdt);
+
+	return 0;
+}
+
+static int starfive_wdt_resume(struct device *dev)
+{
+	int ret;
+	struct starfive_wdt *wdt = dev_get_drvdata(dev);
+
+	starfive_wdt_unlock(wdt);
+
+	/* Restore watchdog state. */
+	starfive_wdt_set_relod_count(wdt, wdt->reload);
+
+	pm_runtime_force_resume(dev);
+
+	starfive_wdt_restart(&wdt->wdt_device, 0, NULL);
+
+	ret = starfive_wdt_mask_and_disable_reset(wdt, false);
+	if (ret < 0)
+		return ret;
+
+	starfive_wdt_lock(wdt);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_PM
+
+static int starfive_wdt_runtime_suspend(struct device *dev)
+{
+	struct starfive_wdt *wdt = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(wdt->apb_clk);
+	clk_disable_unprepare(wdt->core_clk);
+
+	return 0;
+}
+
+static int starfive_wdt_runtime_resume(struct device *dev)
+{
+	struct starfive_wdt *wdt = dev_get_drvdata(dev);
+
+	clk_prepare_enable(wdt->apb_clk);
+	clk_prepare_enable(wdt->core_clk);
+
+	return 0;
+}
+
+#endif /*CONFIG_PM*/
+
+static const struct dev_pm_ops starfive_wdt_pm_ops = {
+	SET_RUNTIME_PM_OPS(starfive_wdt_runtime_suspend, starfive_wdt_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(starfive_wdt_suspend, starfive_wdt_resume)
+};
+
+static struct platform_driver starfive_starfive_wdt_driver = {
+	.probe		= starfive_wdt_probe,
+	.remove		= starfive_wdt_remove,
+	.shutdown	= starfive_wdt_shutdown,
+	.id_table	= starfive_wdt_ids,
+	.driver		= {
+		.name	= "starfive-wdt",
+		.pm	= &starfive_wdt_pm_ops,
+		.of_match_table = of_match_ptr(starfive_wdt_match),
+	},
+};
+
+module_platform_driver(starfive_starfive_wdt_driver);
+
+MODULE_AUTHOR("xingyu.wu <xingyu.wu@starfivetech.com>");
+MODULE_AUTHOR("samin.guo <samin.guo@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive Watchdog Device Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/crypto/sha.h b/include/crypto/sha.h
new file mode 100644
index 000000000000..4ff3da816630
--- /dev/null
+++ b/include/crypto/sha.h
@@ -0,0 +1,167 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Common values for SHA algorithms
+ */
+
+#ifndef _CRYPTO_SHA_H
+#define _CRYPTO_SHA_H
+
+#include <linux/types.h>
+
+#define SHA1_DIGEST_SIZE        20
+#define SHA1_BLOCK_SIZE         64
+
+#define SHA224_DIGEST_SIZE	28
+#define SHA224_BLOCK_SIZE	64
+
+#define SHA256_DIGEST_SIZE      32
+#define SHA256_BLOCK_SIZE       64
+
+#define SHA384_DIGEST_SIZE      48
+#define SHA384_BLOCK_SIZE       128
+
+#define SHA512_DIGEST_SIZE      64
+#define SHA512_BLOCK_SIZE       128
+
+#define SHA1_H0		0x67452301UL
+#define SHA1_H1		0xefcdab89UL
+#define SHA1_H2		0x98badcfeUL
+#define SHA1_H3		0x10325476UL
+#define SHA1_H4		0xc3d2e1f0UL
+
+#define SHA224_H0	0xc1059ed8UL
+#define SHA224_H1	0x367cd507UL
+#define SHA224_H2	0x3070dd17UL
+#define SHA224_H3	0xf70e5939UL
+#define SHA224_H4	0xffc00b31UL
+#define SHA224_H5	0x68581511UL
+#define SHA224_H6	0x64f98fa7UL
+#define SHA224_H7	0xbefa4fa4UL
+
+#define SHA256_H0	0x6a09e667UL
+#define SHA256_H1	0xbb67ae85UL
+#define SHA256_H2	0x3c6ef372UL
+#define SHA256_H3	0xa54ff53aUL
+#define SHA256_H4	0x510e527fUL
+#define SHA256_H5	0x9b05688cUL
+#define SHA256_H6	0x1f83d9abUL
+#define SHA256_H7	0x5be0cd19UL
+
+#define SHA384_H0	0xcbbb9d5dc1059ed8ULL
+#define SHA384_H1	0x629a292a367cd507ULL
+#define SHA384_H2	0x9159015a3070dd17ULL
+#define SHA384_H3	0x152fecd8f70e5939ULL
+#define SHA384_H4	0x67332667ffc00b31ULL
+#define SHA384_H5	0x8eb44a8768581511ULL
+#define SHA384_H6	0xdb0c2e0d64f98fa7ULL
+#define SHA384_H7	0x47b5481dbefa4fa4ULL
+
+#define SHA512_H0	0x6a09e667f3bcc908ULL
+#define SHA512_H1	0xbb67ae8584caa73bULL
+#define SHA512_H2	0x3c6ef372fe94f82bULL
+#define SHA512_H3	0xa54ff53a5f1d36f1ULL
+#define SHA512_H4	0x510e527fade682d1ULL
+#define SHA512_H5	0x9b05688c2b3e6c1fULL
+#define SHA512_H6	0x1f83d9abfb41bd6bULL
+#define SHA512_H7	0x5be0cd19137e2179ULL
+
+extern const u8 sha1_zero_message_hash[SHA1_DIGEST_SIZE];
+
+extern const u8 sha224_zero_message_hash[SHA224_DIGEST_SIZE];
+
+extern const u8 sha256_zero_message_hash[SHA256_DIGEST_SIZE];
+
+extern const u8 sha384_zero_message_hash[SHA384_DIGEST_SIZE];
+
+extern const u8 sha512_zero_message_hash[SHA512_DIGEST_SIZE];
+
+struct sha1_state {
+	u32 state[SHA1_DIGEST_SIZE / 4];
+	u64 count;
+	u8 buffer[SHA1_BLOCK_SIZE];
+};
+
+struct sha256_state {
+	u32 state[SHA256_DIGEST_SIZE / 4];
+	u64 count;
+	u8 buf[SHA256_BLOCK_SIZE];
+};
+
+struct sha512_state {
+	u64 state[SHA512_DIGEST_SIZE / 8];
+	u64 count[2];
+	u8 buf[SHA512_BLOCK_SIZE];
+};
+
+struct shash_desc;
+
+extern int crypto_sha1_update(struct shash_desc *desc, const u8 *data,
+			      unsigned int len);
+
+extern int crypto_sha1_finup(struct shash_desc *desc, const u8 *data,
+			     unsigned int len, u8 *hash);
+
+extern int crypto_sha256_update(struct shash_desc *desc, const u8 *data,
+			      unsigned int len);
+
+extern int crypto_sha256_finup(struct shash_desc *desc, const u8 *data,
+			       unsigned int len, u8 *hash);
+
+extern int crypto_sha512_update(struct shash_desc *desc, const u8 *data,
+			      unsigned int len);
+
+extern int crypto_sha512_finup(struct shash_desc *desc, const u8 *data,
+			       unsigned int len, u8 *hash);
+
+/*
+ * An implementation of SHA-1's compression function.  Don't use in new code!
+ * You shouldn't be using SHA-1, and even if you *have* to use SHA-1, this isn't
+ * the correct way to hash something with SHA-1 (use crypto_shash instead).
+ */
+#define SHA1_DIGEST_WORDS	(SHA1_DIGEST_SIZE / 4)
+#define SHA1_WORKSPACE_WORDS	16
+void sha1_init(__u32 *buf);
+void sha1_transform(__u32 *digest, const char *data, __u32 *W);
+
+/*
+ * Stand-alone implementation of the SHA256 algorithm. It is designed to
+ * have as little dependencies as possible so it can be used in the
+ * kexec_file purgatory. In other cases you should generally use the
+ * hash APIs from include/crypto/hash.h. Especially when hashing large
+ * amounts of data as those APIs may be hw-accelerated.
+ *
+ * For details see lib/crypto/sha256.c
+ */
+
+static inline void sha256_init(struct sha256_state *sctx)
+{
+	sctx->state[0] = SHA256_H0;
+	sctx->state[1] = SHA256_H1;
+	sctx->state[2] = SHA256_H2;
+	sctx->state[3] = SHA256_H3;
+	sctx->state[4] = SHA256_H4;
+	sctx->state[5] = SHA256_H5;
+	sctx->state[6] = SHA256_H6;
+	sctx->state[7] = SHA256_H7;
+	sctx->count = 0;
+}
+void sha256_update(struct sha256_state *sctx, const u8 *data, unsigned int len);
+void sha256_final(struct sha256_state *sctx, u8 *out);
+void sha256(const u8 *data, unsigned int len, u8 *out);
+
+static inline void sha224_init(struct sha256_state *sctx)
+{
+	sctx->state[0] = SHA224_H0;
+	sctx->state[1] = SHA224_H1;
+	sctx->state[2] = SHA224_H2;
+	sctx->state[3] = SHA224_H3;
+	sctx->state[4] = SHA224_H4;
+	sctx->state[5] = SHA224_H5;
+	sctx->state[6] = SHA224_H6;
+	sctx->state[7] = SHA224_H7;
+	sctx->count = 0;
+}
+void sha224_update(struct sha256_state *sctx, const u8 *data, unsigned int len);
+void sha224_final(struct sha256_state *sctx, u8 *out);
+
+#endif
diff --git a/include/dt-bindings/clock/starfive-jh7110-clkgen.h b/include/dt-bindings/clock/starfive-jh7110-clkgen.h
new file mode 100755
index 000000000000..03ce4952b45f
--- /dev/null
+++ b/include/dt-bindings/clock/starfive-jh7110-clkgen.h
@@ -0,0 +1,374 @@
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
+/*
+ * Copyright 2022 StarFive, Inc <xingyu.wu@starfivetech.com>
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_STARFIVE_JH7110_CLKGEN_H__
+#define __DT_BINDINGS_CLOCK_STARFIVE_JH7110_CLKGEN_H__
+
+/* sys regisger */
+#define JH7110_CPU_ROOT				0
+#define JH7110_CPU_CORE				1
+#define JH7110_CPU_BUS				2
+#define JH7110_GPU_ROOT				3
+#define JH7110_PERH_ROOT			4
+#define JH7110_BUS_ROOT				5
+#define JH7110_NOCSTG_BUS			6
+#define JH7110_AXI_CFG0				7
+#define JH7110_STG_AXIAHB			8
+#define JH7110_AHB0				9
+#define JH7110_AHB1				10
+#define JH7110_APB_BUS_FUNC			11
+#define JH7110_APB0				12
+#define JH7110_PLL0_DIV2			13
+#define JH7110_PLL1_DIV2			14
+#define JH7110_PLL2_DIV2			15
+#define JH7110_AUDIO_ROOT			16
+#define JH7110_MCLK_INNER			17
+#define JH7110_MCLK				18
+#define JH7110_MCLK_OUT				19
+#define JH7110_ISP_2X				20
+#define JH7110_ISP_AXI				21
+#define JH7110_GCLK0				22
+#define JH7110_GCLK1				23
+#define JH7110_GCLK2				24
+#define JH7110_U7_CORE_CLK			25
+#define JH7110_U7_CORE_CLK1			26
+#define JH7110_U7_CORE_CLK2			27
+#define JH7110_U7_CORE_CLK3			28
+#define JH7110_U7_CORE_CLK4			29
+#define JH7110_U7_DEBUG_CLK			30
+#define JH7110_U7_RTC_TOGGLE			31
+#define JH7110_U7_TRACE_CLK0			32
+#define JH7110_U7_TRACE_CLK1			33
+#define JH7110_U7_TRACE_CLK2			34
+#define JH7110_U7_TRACE_CLK3			35
+#define JH7110_U7_TRACE_CLK4			36
+#define JH7110_U7_TRACE_COM_CLK			37
+#define JH7110_NOC_BUS_CLK_CPU_AXI		38
+#define JH7110_NOC_BUS_CLK_AXICFG0_AXI		39
+#define JH7110_OSC_DIV2				40
+#define JH7110_PLL1_DIV4			41
+#define JH7110_PLL1_DIV8			42
+#define JH7110_DDR_BUS				43
+#define JH7110_DDR_CLK_AXI			44
+#define JH7110_GPU_CORE				45
+#define JH7110_GPU_CORE_CLK			46
+#define JH7110_GPU_SYS_CLK			47
+#define JH7110_GPU_CLK_APB			48
+#define JH7110_GPU_RTC_TOGGLE			49
+#define JH7110_NOC_BUS_CLK_GPU_AXI		50
+#define JH7110_ISP_TOP_CLK_ISPCORE_2X		51
+#define JH7110_ISP_TOP_CLK_ISP_AXI		52
+#define JH7110_NOC_BUS_CLK_ISP_AXI		53
+#define JH7110_HIFI4_CORE			54
+#define JH7110_HIFI4_AXI			55
+#define JH7110_AXI_CFG1_DEC_CLK_MAIN		56
+#define JH7110_AXI_CFG1_DEC_CLK_AHB		57
+#define JH7110_VOUT_SRC				58
+#define JH7110_VOUT_AXI				59
+#define JH7110_NOC_BUS_CLK_DISP_AXI		60
+#define JH7110_VOUT_TOP_CLK_VOUT_AHB		61
+#define JH7110_VOUT_TOP_CLK_VOUT_AXI		62
+#define JH7110_VOUT_TOP_CLK_HDMITX0_MCLK	63
+#define JH7110_VOUT_TOP_CLK_MIPIPHY_REF		64
+#define JH7110_JPEGC_AXI			65
+#define JH7110_CODAJ12_CLK_AXI			66
+#define JH7110_CODAJ12_CLK_CORE			67
+#define JH7110_CODAJ12_CLK_APB			68
+#define JH7110_VDEC_AXI				69
+#define JH7110_WAVE511_CLK_AXI			70
+#define JH7110_WAVE511_CLK_BPU			71
+#define JH7110_WAVE511_CLK_VCE			72
+#define JH7110_WAVE511_CLK_APB			73
+#define JH7110_VDEC_JPG_ARB_JPGCLK		74
+#define JH7110_VDEC_JPG_ARB_MAINCLK		75
+#define JH7110_NOC_BUS_CLK_VDEC_AXI		76
+#define JH7110_VENC_AXI				77
+#define JH7110_WAVE420L_CLK_AXI			78
+#define JH7110_WAVE420L_CLK_BPU			79
+#define JH7110_WAVE420L_CLK_VCE			80
+#define JH7110_WAVE420L_CLK_APB			81
+#define JH7110_NOC_BUS_CLK_VENC_AXI		82
+#define JH7110_AXI_CFG0_DEC_CLK_MAIN_DIV	83
+#define JH7110_AXI_CFG0_DEC_CLK_MAIN		84
+#define JH7110_AXI_CFG0_DEC_CLK_HIFI4		85
+#define JH7110_AXIMEM2_128B_CLK_AXI		86
+#define JH7110_QSPI_CLK_AHB			87
+#define JH7110_QSPI_CLK_APB			88
+#define JH7110_QSPI_REF_SRC			89
+#define JH7110_QSPI_CLK_REF			90
+#define JH7110_SDIO0_CLK_AHB			91
+#define JH7110_SDIO1_CLK_AHB			92
+#define JH7110_SDIO0_CLK_SDCARD			93
+#define JH7110_SDIO1_CLK_SDCARD			94
+#define JH7110_USB_125M				95
+#define JH7110_NOC_BUS_CLK_STG_AXI		96
+#define JH7110_GMAC5_CLK_AHB			97
+#define JH7110_GMAC5_CLK_AXI			98
+#define JH7110_GMAC_SRC				99
+#define JH7110_GMAC1_GTXCLK			100
+#define JH7110_GMAC1_RMII_RTX			101
+#define JH7110_GMAC5_CLK_PTP			102
+#define JH7110_GMAC5_CLK_RX			103
+#define JH7110_GMAC5_CLK_RX_INV			104
+#define JH7110_GMAC5_CLK_TX			105
+#define JH7110_GMAC5_CLK_TX_INV			106
+#define JH7110_GMAC1_GTXC			107
+#define JH7110_GMAC0_GTXCLK			108
+#define JH7110_GMAC0_PTP			109
+#define JH7110_GMAC_PHY				110
+#define JH7110_GMAC0_GTXC			111
+#define JH7110_SYS_IOMUX_PCLK			112
+#define JH7110_MAILBOX_CLK_APB			113
+#define JH7110_INT_CTRL_CLK_APB			114
+#define JH7110_CAN0_CTRL_CLK_APB		115
+#define JH7110_CAN0_CTRL_CLK_TIMER		116
+#define JH7110_CAN0_CTRL_CLK_CAN		117
+#define JH7110_CAN1_CTRL_CLK_APB		118
+#define JH7110_CAN1_CTRL_CLK_TIMER		119
+#define JH7110_CAN1_CTRL_CLK_CAN		120
+#define JH7110_PWM_CLK_APB			121
+#define JH7110_DSKIT_WDT_CLK_APB		122
+#define JH7110_DSKIT_WDT_CLK_WDT		123
+#define JH7110_TIMER_CLK_APB			124
+#define JH7110_TIMER_CLK_TIMER0			125
+#define JH7110_TIMER_CLK_TIMER1			126
+#define JH7110_TIMER_CLK_TIMER2			127
+#define JH7110_TIMER_CLK_TIMER3			128
+#define JH7110_TEMP_SENSOR_CLK_APB		129
+#define JH7110_TEMP_SENSOR_CLK_TEMP		130
+#define JH7110_SPI0_CLK_APB			131
+#define JH7110_SPI1_CLK_APB			132
+#define JH7110_SPI2_CLK_APB			133
+#define JH7110_SPI3_CLK_APB			134
+#define JH7110_SPI4_CLK_APB			135
+#define JH7110_SPI5_CLK_APB			136
+#define JH7110_SPI6_CLK_APB			137
+#define JH7110_I2C0_CLK_APB			138
+#define JH7110_I2C1_CLK_APB			139
+#define JH7110_I2C2_CLK_APB			140
+#define JH7110_I2C3_CLK_APB			141
+#define JH7110_I2C4_CLK_APB			142
+#define JH7110_I2C5_CLK_APB			143
+#define JH7110_I2C6_CLK_APB			144
+#define JH7110_UART0_CLK_APB			145
+#define JH7110_UART0_CLK_CORE			146
+#define JH7110_UART1_CLK_APB			147
+#define JH7110_UART1_CLK_CORE			148
+#define JH7110_UART2_CLK_APB			149
+#define JH7110_UART2_CLK_CORE			150
+#define JH7110_UART3_CLK_APB			151
+#define JH7110_UART3_CLK_CORE			152
+#define JH7110_UART4_CLK_APB			153
+#define JH7110_UART4_CLK_CORE			154
+#define JH7110_UART5_CLK_APB			155
+#define JH7110_UART5_CLK_CORE			156
+#define JH7110_PWMDAC_CLK_APB			157
+#define JH7110_PWMDAC_CLK_CORE			158
+#define JH7110_SPDIF_CLK_APB			159
+#define JH7110_SPDIF_CLK_CORE			160
+#define JH7110_I2STX0_4CHCLK_APB		161
+#define JH7110_I2STX_4CH0_BCLK_MST		162
+#define JH7110_I2STX_4CH0_BCLK_MST_INV		163
+#define JH7110_I2STX_4CH0_LRCK_MST		164
+#define JH7110_I2STX0_4CHBCLK			165
+#define JH7110_I2STX0_4CHBCLK_N			166
+#define JH7110_I2STX0_4CHLRCK			167
+#define JH7110_I2STX1_4CHCLK_APB		168
+#define JH7110_I2STX_4CH1_BCLK_MST		169
+#define JH7110_I2STX_4CH1_BCLK_MST_INV		170
+#define JH7110_I2STX_4CH1_LRCK_MST		171
+#define JH7110_I2STX1_4CHBCLK			172
+#define JH7110_I2STX1_4CHBCLK_N			173
+#define JH7110_I2STX1_4CHLRCK			174
+#define JH7110_I2SRX0_3CH_CLK_APB		175
+#define JH7110_I2SRX_3CH_BCLK_MST		176
+#define JH7110_I2SRX_3CH_BCLK_MST_INV		177
+#define JH7110_I2SRX_3CH_LRCK_MST		178
+#define JH7110_I2SRX0_3CH_BCLK			179
+#define JH7110_I2SRX0_3CH_BCLK_N		180
+#define JH7110_I2SRX0_3CH_LRCK			181
+#define JH7110_PDM_CLK_DMIC			182
+#define JH7110_PDM_CLK_APB			183
+#define JH7110_TDM_CLK_AHB			184
+#define JH7110_TDM_CLK_APB			185
+#define JH7110_TDM_INTERNAL			186
+#define JH7110_TDM_CLK_TDM			187
+#define JH7110_TDM_CLK_TDM_N			188
+#define JH7110_JTAG_CERTIFICATION_TRNG_CLK	189
+
+#define JH7110_CLK_SYS_REG_END			190
+
+/* stg regisger */
+#define JH7110_HIFI4_CLK_CORE			190
+#define JH7110_USB0_CLK_USB_APB			191
+#define JH7110_USB0_CLK_UTMI_APB		192
+#define JH7110_USB0_CLK_AXI			193
+#define JH7110_USB0_CLK_LPM			194
+#define JH7110_USB0_CLK_STB			195
+#define JH7110_USB0_CLK_APP_125			196
+#define JH7110_USB0_REFCLK			197
+#define JH7110_PCIE0_CLK_AXI_MST0		198
+#define JH7110_PCIE0_CLK_APB			199
+#define JH7110_PCIE0_CLK_TL			200
+#define JH7110_PCIE1_CLK_AXI_MST0		201
+#define JH7110_PCIE1_CLK_APB			202
+#define JH7110_PCIE1_CLK_TL			203
+#define JH7110_PCIE01_SLV_DEC_MAINCLK		204
+#define JH7110_SEC_HCLK				205
+#define JH7110_SEC_MISCAHB_CLK			206
+#define JH7110_STG_MTRX_GRP0_CLK_MAIN		207
+#define JH7110_STG_MTRX_GRP0_CLK_BUS		208
+#define JH7110_STG_MTRX_GRP0_CLK_STG		209
+#define JH7110_STG_MTRX_GRP1_CLK_MAIN		210
+#define JH7110_STG_MTRX_GRP1_CLK_BUS		211
+#define JH7110_STG_MTRX_GRP1_CLK_STG		212
+#define JH7110_STG_MTRX_GRP1_CLK_HIFI		213
+#define JH7110_E2_RTC_CLK			214
+#define JH7110_E2_CLK_CORE			215
+#define JH7110_E2_CLK_DBG			216
+#define JH7110_DMA1P_CLK_AXI			217
+#define JH7110_DMA1P_CLK_AHB			218
+
+#define JH7110_CLK_STG_REG_END			219
+
+/* aon regisger */
+#define JH7110_OSC_DIV4				219
+#define JH7110_AON_APB_FUNC			220
+#define JH7110_U0_GMAC5_CLK_AHB			221
+#define JH7110_U0_GMAC5_CLK_AXI			222
+#define JH7110_GMAC0_RMII_RTX			223
+#define JH7110_U0_GMAC5_CLK_TX			224
+#define JH7110_U0_GMAC5_CLK_TX_INV		225
+#define JH7110_U0_GMAC5_CLK_RX			226
+#define JH7110_U0_GMAC5_CLK_RX_INV		227
+#define JH7110_OTPC_CLK_APB			228
+#define JH7110_RTC_HMS_CLK_APB			229
+#define JH7110_RTC_INTERNAL			230
+#define JH7110_RTC_HMS_CLK_OSC32K		231
+#define JH7110_RTC_HMS_CLK_CAL			232
+
+#define JH7110_CLK_REG_END			233
+
+/* sys other */
+#define JH7110_PLL0_OUT				233
+#define JH7110_PLL1_OUT				234
+#define JH7110_PLL2_OUT				235
+#define JH7110_AON_APB				236
+#define JH7110_RESET1_CTRL_CLK_SRC		237
+#define JH7110_DDR_ROOT				238
+#define JH7110_VDEC_ROOT			239
+#define JH7110_VENC_ROOT			240
+#define JH7110_VOUT_ROOT			241
+#define JH7110_GMACUSB_ROOT			242
+#define JH7110_PCLK2_MUX_FUNC_PCLK		243
+#define JH7110_PCLK2_MUX_BIST_PCLK		244
+#define JH7110_APB_BUS				245
+#define JH7110_APB12				246
+#define JH7110_AXI_CFG1				247
+#define JH7110_PLL_WRAP_CRG_GCLK0		248
+#define JH7110_PLL_WRAP_CRG_GCLK1		249
+#define JH7110_PLL_WRAP_CRG_GCLK2		250
+#define JH7110_JTAG2APB_PCLK			251
+#define JH7110_U7_BUS_CLK			252
+#define JH7110_U7_IRQ_SYNC_BUS_CLK		253
+#define JH7110_NOC_BUS_CLK2_CPU_AXI		254
+#define JH7110_NOC_BUS_CLK_APB_BUS		255
+#define JH7110_NOC_BUS_CLK2_APB_BUS		256
+#define JH7110_NOC_BUS_CLK2_AXICFG0_AXI		257
+#define JH7110_DDR_CLK_DDRPHY_PLL_BYPASS	258
+#define JH7110_DDR_CLK_OSC			259
+#define JH7110_DDR_CLK_APB			260
+#define JH7110_NOC_BUS_CLK_DDRC			261
+#define JH7110_NOC_BUS_CLK2_DDRC		262
+#define JH7110_SYS_AHB_DEC_CLK_AHB		263
+#define JH7110_STG_AHB_DEC_CLK_AHB		264
+#define JH7110_NOC_BUS_CLK2_GPU_AXI		265
+#define JH7110_ISP_TOP_CLK_DVP			266
+#define JH7110_NOC_BUS_CLK2_ISP_AXI		267
+#define JH7110_ISP_TOP_CLK_BIST_APB		268
+#define JH7110_NOC_BUS_CLK2_DISP_AXI		269
+#define JH7110_VOUT_TOP_CLK_HDMITX0_BCLK	270
+#define JH7110_VOUT_TOP_U0_HDMI_TX_PIN_WS	271
+#define JH7110_VOUT_TOP_CLK_HDMIPHY_REF		272
+#define JH7110_VOUT_TOP_BIST_PCLK		273
+#define JH7110_AXIMEM0_128B_CLK_AXI		274
+#define JH7110_VDEC_INTSRAM_CLK_VDEC_AXI	275
+#define JH7110_NOC_BUS_CLK2_VDEC_AXI		276
+#define JH7110_AXIMEM1_128B_CLK_AXI		277
+#define JH7110_VENC_INTSRAM_CLK_VENC_AXI	278
+#define JH7110_NOC_BUS_CLK2_VENC_AXI		279
+#define JH7110_SRAM_CLK_ROM			280
+#define JH7110_NOC_BUS_CLK2_STG_AXI		281
+#define JH7110_GMAC5_CLK_RMII			282
+#define JH7110_AON_AHB				283
+#define JH7110_SYS_CRG_PCLK			284
+#define JH7110_SYS_SYSCON_PCLK			285
+#define JH7110_SPI0_CLK_CORE			286
+#define JH7110_SPI1_CLK_CORE			287
+#define JH7110_SPI2_CLK_CORE			288
+#define JH7110_SPI3_CLK_CORE			289
+#define JH7110_SPI4_CLK_CORE			290
+#define JH7110_SPI5_CLK_CORE			291
+#define JH7110_SPI6_CLK_CORE			292
+#define JH7110_I2C0_CLK_CORE			293
+#define JH7110_I2C1_CLK_CORE			294
+#define JH7110_I2C2_CLK_CORE			295
+#define JH7110_I2C3_CLK_CORE			296
+#define JH7110_I2C4_CLK_CORE			297
+#define JH7110_I2C5_CLK_CORE			298
+#define JH7110_I2C6_CLK_CORE			299
+#define JH7110_I2STX_BCLK_MST			300
+#define JH7110_I2STX_LRCK_MST			301
+#define JH7110_I2SRX_BCLK_MST			302
+#define JH7110_I2SRX_LRCK_MST			303
+#define JH7110_PDM_CLK_DMIC0_BCLK_SLV		304
+#define JH7110_PDM_CLK_DMIC0_LRCK_SLV		305
+#define JH7110_PDM_CLK_DMIC1_BCLK_SLV		306
+#define JH7110_PDM_CLK_DMIC1_LRCK_SLV		307
+#define JH7110_TDM_CLK_MST			308
+#define JH7110_AHB2APB_CLK_AHB			309
+#define JH7110_P2P_ASYNC_CLK_APBS		310
+#define JH7110_P2P_ASYNC_CLK_APBM		311
+#define JH7110_JTAG_DAISY_CHAIN_JTAG_TCK	312
+#define JH7110_U7_DEBUG_SYSTEMJTAG_JTAG_TCK	313
+#define JH7110_E2_DEBUG_SYSTEMJTAG_TCK		314
+#define JH7110_JTAG_CERTIFICATION_TCK		315
+#define JH7110_SEC_SKP_CLK			316
+#define JH7110_U2_PCLK_MUX_PCLK			317
+
+#define JH7110_CLK_SYS_END			318
+
+/* stg other */
+#define JH7110_PCIE0_CLK_AXI_SLV0		318
+#define JH7110_PCIE0_CLK_AXI_SLV		319
+#define JH7110_PCIE0_CLK_OSC			320
+#define JH7110_PCIE1_CLK_AXI_SLV0		321
+#define JH7110_PCIE1_CLK_AXI_SLV		322
+#define JH7110_PCIE1_CLK_OSC			323
+#define JH7110_E2_IRQ_SYNC_CLK_CORE		324
+#define JH7110_STG_CRG_PCLK			325
+#define JH7110_STG_SYSCON_PCLK			326
+#define JH7110_STG_APB				327
+
+#define JH7110_CLK_STG_END			328
+
+/* aon other */
+#define JH7110_U0_GMAC5_CLK_PTP			328
+#define JH7110_U0_GMAC5_CLK_RMII		329
+#define JH7110_AON_SYSCON_PCLK			330
+#define JH7110_AON_IOMUX_PCLK			331
+#define JH7110_AON_CRG_PCLK			332
+#define JH7110_PMU_CLK_APB			333
+#define JH7110_PMU_CLK_WKUP			334
+#define JH7110_RTC_HMS_CLK_OSC32K_G		335
+#define JH7110_32K_OUT				336
+#define JH7110_RESET0_CTRL_CLK_SRC		337
+/* aon other and source */
+#define JH7110_PCLK_MUX_FUNC_PCLK		338
+#define JH7110_PCLK_MUX_BIST_PCLK		339
+
+#define JH7110_CLK_END				340
+
+#endif /* __DT_BINDINGS_CLOCK_STARFIVE_JH7110_H__ */
diff --git a/include/dt-bindings/clock/starfive-jh7110-isp.h b/include/dt-bindings/clock/starfive-jh7110-isp.h
new file mode 100755
index 000000000000..498d5683f572
--- /dev/null
+++ b/include/dt-bindings/clock/starfive-jh7110-isp.h
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
+/*
+ * Copyright 2022 StarFive, Inc <xingyu.wu@starfivetech.com>
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_STARFIVE_JH7110_ISP_H__
+#define __DT_BINDINGS_CLOCK_STARFIVE_JH7110_ISP_H__
+
+/* regisger */
+#define JH7110_DOM4_APB_FUNC					0
+#define JH7110_MIPI_RX0_PXL					1
+#define JH7110_DVP_INV						2
+#define JH7110_U0_M31DPHY_CFGCLK_IN				3
+#define JH7110_U0_M31DPHY_REFCLK_IN				4
+#define JH7110_U0_M31DPHY_TXCLKESC_LAN0				5
+#define JH7110_U0_VIN_PCLK					6
+#define JH7110_U0_VIN_SYS_CLK					7
+#define JH7110_U0_VIN_PIXEL_CLK_IF0				8
+#define JH7110_U0_VIN_PIXEL_CLK_IF1				9
+#define JH7110_U0_VIN_PIXEL_CLK_IF2				10
+#define JH7110_U0_VIN_PIXEL_CLK_IF3				11
+#define JH7110_U0_VIN_CLK_P_AXIWR				12
+#define JH7110_U0_ISPV2_TOP_WRAPPER_CLK_C			13
+
+#define JH7110_CLK_ISP_REG_END					14
+
+/* other */
+#define JH7110_U3_PCLK_MUX_FUNC_PCLK				14
+#define JH7110_U3_PCLK_MUX_BIST_PCLK				15
+#define JH7110_DOM4_APB						16
+#define JH7110_U0_VIN_PCLK_FREE					17
+#define JH7110_U0_VIN_CLK_P_AXIRD				18
+#define JH7110_U0_VIN_ACLK					19
+#define JH7110_U0_ISPV2_TOP_WRAPPER_CLK_ISP_AXI_IN		20
+#define JH7110_U0_ISPV2_TOP_WRAPPER_CLK_ISP_X2			21
+#define JH7110_U0_ISPV2_TOP_WRAPPER_CLK_ISP			22
+#define JH7110_U0_ISPV2_TOP_WRAPPER_CLK_P			23
+#define JH7110_U0_CRG_PCLK					24
+#define JH7110_U0_SYSCON_PCLK					25
+#define JH7110_U0_M31DPHY_APBCFG_PCLK				26
+#define JH7110_U0_AXI2APB_BRIDGE_CLK_DOM4_APB			27
+#define JH7110_U0_AXI2APB_BRIDGE_ISP_AXI4SLV_CLK		28
+#define JH7110_U3_PCLK_MUX_PCLK					29
+
+#define JH7110_CLK_ISP_END					30
+
+#endif /* __DT_BINDINGS_CLOCK_STARFIVE_JH7110_H__ */
diff --git a/include/dt-bindings/clock/starfive-jh7110-vout.h b/include/dt-bindings/clock/starfive-jh7110-vout.h
new file mode 100755
index 000000000000..9501cdbe1ae1
--- /dev/null
+++ b/include/dt-bindings/clock/starfive-jh7110-vout.h
@@ -0,0 +1,59 @@
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
+/*
+ * Copyright 2022 StarFive, Inc <xingyu.wu@starfivetech.com>
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_STARFIVE_JH7110_VOUT_H__
+#define __DT_BINDINGS_CLOCK_STARFIVE_JH7110_VOUT_H__
+
+/* regisger */
+#define JH7110_APB						0
+#define JH7110_DC8200_PIX0					1
+#define JH7110_DSI_SYS						2
+#define JH7110_TX_ESC						3
+#define JH7110_U0_DC8200_CLK_AXI				4
+#define JH7110_U0_DC8200_CLK_CORE				5
+#define JH7110_U0_DC8200_CLK_AHB				6
+#define JH7110_U0_DC8200_CLK_PIX0				7
+#define JH7110_U0_DC8200_CLK_PIX1				8
+#define JH7110_DOM_VOUT_TOP_LCD_CLK				9
+#define JH7110_U0_CDNS_DSITX_CLK_APB				10
+#define JH7110_U0_CDNS_DSITX_CLK_SYS				11
+#define JH7110_U0_CDNS_DSITX_CLK_DPI				12
+#define JH7110_U0_CDNS_DSITX_CLK_TXESC				13
+#define JH7110_U0_MIPITX_DPHY_CLK_TXESC				14
+#define JH7110_U0_HDMI_TX_CLK_MCLK				15
+#define JH7110_U0_HDMI_TX_CLK_BCLK				16
+#define JH7110_U0_HDMI_TX_CLK_SYS				17
+
+#define JH7110_CLK_VOUT_REG_END					18
+
+/* other */
+#define JH7110_DISP_ROOT					18
+#define JH7110_DISP_AXI						19
+#define JH7110_DISP_AHB						20
+#define JH7110_HDMI_PHY_REF					21
+#define JH7110_HDMITX0_MCLK					22
+#define JH7110_HDMITX0_SCK					23
+
+#define JH7110_MIPI_DPHY_REF					24
+#define JH7110_U0_PCLK_MUX_BIST_PCLK				25
+#define JH7110_DISP_APB						26
+#define JH7110_U0_PCLK_MUX_FUNC_PCLK				27
+#define JH7110_U0_DOM_VOUT_CRG_PCLK				28
+#define JH7110_U0_DOM_VOUT_SYSCON_PCLK				29
+#define JH7110_U0_SAIF_AMBA_DOM_VOUT_AHB_DEC_CLK_AHB		30
+#define JH7110_U0_AHB2APB_CLK_AHB				31
+#define JH7110_U0_P2P_ASYNC_CLK_APBS				32
+#define JH7110_U0_CDNS_DSITX_CLK_RXESC				33
+#define JH7110_U0_CDNS_DSITX_CLK_TXBYTEHS			34
+#define JH7110_U0_MIPITX_DPHY_CLK_SYS				35
+#define JH7110_U0_MIPITX_DPHY_CLK_DPHY_REF			36
+#define JH7110_U0_MIPITX_APBIF_PCLK				37
+#define JH7110_HDMI_TX_CLK_REF					38
+#define JH7110_U0_DC8200_CLK_PIX0_OUT				39
+#define JH7110_U0_DC8200_CLK_PIX1_OUT				40
+
+#define JH7110_CLK_VOUT_END					41
+
+#endif /* __DT_BINDINGS_CLOCK_STARFIVE_JH7110_H__ */
diff --git a/include/dt-bindings/pinctrl/starfive,jh7110-pinfunc.h b/include/dt-bindings/pinctrl/starfive,jh7110-pinfunc.h
new file mode 100644
index 000000000000..63a955ba71af
--- /dev/null
+++ b/include/dt-bindings/pinctrl/starfive,jh7110-pinfunc.h
@@ -0,0 +1,1578 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+
+#ifndef _DT_BINDINGS_PINCTRL_STARFIVE_H
+#define _DT_BINDINGS_PINCTRL_STARFIVE_H
+
+/************************aon_iomux***************************/
+//aon_iomux pin
+#define	PAD_TESTEN      0
+#define	PAD_RGPIO0      1
+#define	PAD_RGPIO1      2
+#define	PAD_RGPIO2      3
+#define	PAD_RGPIO3      4
+#define	PAD_RSTN        5
+#define	PAD_GMAC0_MDC	6
+#define	PAD_GMAC0_MDIO	7
+#define	PAD_GMAC0_RXD0	8
+#define	PAD_GMAC0_RXD1	9
+#define	PAD_GMAC0_RXD2	10
+#define	PAD_GMAC0_RXD3	11
+#define	PAD_GMAC0_RXDV	12
+#define	PAD_GMAC0_RXC	13
+#define	PAD_GMAC0_TXD0	14
+#define	PAD_GMAC0_TXD1	15
+#define	PAD_GMAC0_TXD2	16
+#define	PAD_GMAC0_TXD3	17
+#define	PAD_GMAC0_TXEN	18
+#define	PAD_GMAC0_TXC	19
+
+//<fmux_idx.h>
+//aon_iomux dout
+#define GPO_AON_IOMUX_U0_AON_CRG_CLK_32K_OUT    2
+#define GPO_AON_IOMUX_U0_PWM_8CH_PTC_PWM_4      3
+#define GPO_AON_IOMUX_U0_PWM_8CH_PTC_PWM_5      4
+#define GPO_AON_IOMUX_U0_PWM_8CH_PTC_PWM_6      5
+#define GPO_AON_IOMUX_U0_PWM_8CH_PTC_PWM_7      6
+#define GPO_AON_IOMUX_U0_SYS_CRG_CLK_GCLK0      7
+#define GPO_AON_IOMUX_U0_SYS_CRG_CLK_GCLK1      8
+#define GPO_AON_IOMUX_U0_SYS_CRG_CLK_GCLK2      9
+//aon_iomux doen
+#define GPEN_AON_IOMUX_U0_PWM_8CH_PTC_OE_N_4    2
+#define GPEN_AON_IOMUX_U0_PWM_8CH_PTC_OE_N_5    3
+#define GPEN_AON_IOMUX_U0_PWM_8CH_PTC_OE_N_6    4
+#define GPEN_AON_IOMUX_U0_PWM_8CH_PTC_OE_N_7    5
+//aon_iomux gin
+#define GPI_AON_IOMUX_U0_PMU_IO_EVENT_STUB_GPIO_WAKEUP_0    0
+#define GPI_AON_IOMUX_U0_PMU_IO_EVENT_STUB_GPIO_WAKEUP_1    1
+#define GPI_AON_IOMUX_U0_PMU_IO_EVENT_STUB_GPIO_WAKEUP_2    2
+#define GPI_AON_IOMUX_U0_PMU_IO_EVENT_STUB_GPIO_WAKEUP_3    3
+
+
+//===============================GPIO_OUT_SELECT=======================================
+// gpio_out config:
+// every define below is a couple of signal and signal idx
+// use macros in corresponding syscfg_macro.h and idx defined below to config gpio_out
+//e.g. SET_AON_IOMUX_GPO[gpio_num]_DOUT_CFG([signal])
+//e.g. SET_AON_IOMUX_GPO0_DOUT_CFG(__LOW)
+//=====================================================================================
+#define __LOW                                        0
+#define __HIGH                                       1
+#define U0_AON_CRG_CLK_32K_OUT                       2
+#define U0_PWM_8CH_PTC_PWM_4                         3
+#define U0_PWM_8CH_PTC_PWM_5                         4
+#define U0_PWM_8CH_PTC_PWM_6                         5
+#define U0_PWM_8CH_PTC_PWM_7                         6
+#define U0_SYS_CRG_CLK_GCLK0                         7
+#define U0_SYS_CRG_CLK_GCLK1                         8
+#define U0_SYS_CRG_CLK_GCLK2                         9
+
+//===============================GPIO_OEN_SELECT=======================================
+// gpio_oen config:
+// every define below is a couple of signal and signal idx
+// use macros in corresponding syscfg_macro.h and idx defined below to config gpio_oen
+//e.g. SET_AON_IOMUX_GPO[gpio_num]_DOEN_CFG([signal])
+//e.g. SET_AON_IOMUX_GPO0_DOEN_CFG(__LOW)
+//=====================================================================================
+#define __LOW                                        0
+#define __HIGH                                       1
+#define U0_PWM_8CH_PTC_OE_N_4                        2
+#define U0_PWM_8CH_PTC_OE_N_5                        3
+#define U0_PWM_8CH_PTC_OE_N_6                        4
+#define U0_PWM_8CH_PTC_OE_N_7                        5
+
+
+//aon_iomux gmac0 syscon
+#define AON_IOMUX_CFG__SAIF__SYSCFG_88_ADDR                (0x58U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_92_ADDR                (0x5cU)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_96_ADDR                (0x60U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_100_ADDR               (0x64U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_104_ADDR               (0x68U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_108_ADDR               (0x6cU)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_112_ADDR               (0x70U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_116_ADDR               (0x74U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_120_ADDR               (0x78U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_124_ADDR               (0x7cU)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_128_ADDR               (0x80U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_132_ADDR               (0x84U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_136_ADDR               (0x88U)
+#define AON_IOMUX_CFG__SAIF__SYSCFG_140_ADDR               (0x8cU)
+
+#define PADCFG_PAD_GMAC0_MDC_SYSCON     AON_IOMUX_CFG__SAIF__SYSCFG_88_ADDR
+#define PADCFG_PAD_GMAC0_MDIO_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_92_ADDR
+#define PADCFG_PAD_GMAC0_RXD0_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_96_ADDR
+#define PADCFG_PAD_GMAC0_RXD1_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_100_ADDR
+#define PADCFG_PAD_GMAC0_RXD2_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_104_ADDR
+#define PADCFG_PAD_GMAC0_RXD3_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_108_ADDR
+#define PADCFG_PAD_GMAC0_RXDV_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_112_ADDR
+#define PADCFG_PAD_GMAC0_RXC_SYSCON     AON_IOMUX_CFG__SAIF__SYSCFG_116_ADDR
+#define PADCFG_PAD_GMAC0_TXD0_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_120_ADDR
+#define PADCFG_PAD_GMAC0_TXD1_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_124_ADDR
+#define PADCFG_PAD_GMAC0_TXD2_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_128_ADDR
+#define PADCFG_PAD_GMAC0_TXD3_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_132_ADDR
+#define PADCFG_PAD_GMAC0_TXEN_SYSCON    AON_IOMUX_CFG__SAIF__SYSCFG_136_ADDR
+#define PADCFG_PAD_GMAC0_TXC_SYSCON     AON_IOMUX_CFG__SAIF__SYSCFG_140_ADDR
+
+//aon_iomux func sel
+#define AON_IOMUX_CFGSAIF__SYSCFG_144_ADDR                 (0x90U)
+#define PAD_GMAC0_RXC_FUNC_SEL_SHIFT                       0x0U
+#define PAD_GMAC0_RXC_FUNC_SEL_MASK                        0x3U
+
+#define PAD_GMAC0_RXC_FUNC_SEL              \
+        AON_IOMUX_CFGSAIF__SYSCFG_144_ADDR  \
+        PAD_GMAC0_RXC_FUNC_SEL_SHIFT        \
+        PAD_GMAC0_RXC_FUNC_SEL_MASK
+/************************aon_iomux***************************/
+
+/************************sys_iomux***************************/
+//sys_iomux pin
+#define	PAD_GPIO0       0
+#define	PAD_GPIO1       1
+#define	PAD_GPIO2       2
+#define	PAD_GPIO3       3
+#define	PAD_GPIO4       4
+#define	PAD_GPIO5       5
+#define	PAD_GPIO6       6
+#define	PAD_GPIO7       7
+#define	PAD_GPIO8       8
+#define	PAD_GPIO9       9
+#define	PAD_GPIO10      10
+#define	PAD_GPIO11      11
+#define	PAD_GPIO12      12
+#define	PAD_GPIO13      13
+#define	PAD_GPIO14      14
+#define	PAD_GPIO15      15
+#define	PAD_GPIO16      16
+#define	PAD_GPIO17      17
+#define	PAD_GPIO18      18
+#define	PAD_GPIO19      19
+#define	PAD_GPIO20      20
+#define	PAD_GPIO21      21
+#define	PAD_GPIO22      22
+#define	PAD_GPIO23      23
+#define	PAD_GPIO24      24
+#define	PAD_GPIO25      25
+#define	PAD_GPIO26      26
+#define	PAD_GPIO27      27
+#define	PAD_GPIO28      28
+#define	PAD_GPIO29      29
+#define	PAD_GPIO30      30
+#define	PAD_GPIO31      31
+#define	PAD_GPIO32      32
+#define	PAD_GPIO33      33
+#define	PAD_GPIO34      34
+#define	PAD_GPIO35      35
+#define	PAD_GPIO36      36
+#define	PAD_GPIO37      37
+#define	PAD_GPIO38      38
+#define	PAD_GPIO39      39
+#define	PAD_GPIO40      40
+#define	PAD_GPIO41      41
+#define	PAD_GPIO42      42
+#define	PAD_GPIO43      43
+#define	PAD_GPIO44      44
+#define	PAD_GPIO45      45
+#define	PAD_GPIO46      46
+#define	PAD_GPIO47      47
+#define	PAD_GPIO48      48
+#define	PAD_GPIO49      49
+#define	PAD_GPIO50      50
+#define	PAD_GPIO51      51
+#define	PAD_GPIO52      52
+#define	PAD_GPIO53      53
+#define	PAD_GPIO54      54
+#define	PAD_GPIO55      55
+#define	PAD_GPIO56      56
+#define	PAD_GPIO57      57
+#define	PAD_GPIO58      58
+#define	PAD_GPIO59      59
+#define	PAD_GPIO60      60
+#define	PAD_GPIO61      61
+#define	PAD_GPIO62      62
+#define	PAD_GPIO63      63
+#define	PAD_SD0_CLK     64
+#define	PAD_SD0_CMD     65
+#define	PAD_SD0_DATA0   66
+#define	PAD_SD0_DATA1   67
+#define	PAD_SD0_DATA2   68
+#define	PAD_SD0_DATA3   69
+#define	PAD_SD0_DATA4   70
+#define	PAD_SD0_DATA5   71
+#define	PAD_SD0_DATA6   72
+#define	PAD_SD0_DATA7   73
+#define	PAD_SD0_STRB    74
+#define	PAD_GMAC1_MDC   75
+#define	PAD_GMAC1_MDIO  76
+#define	PAD_GMAC1_RXD0  77
+#define	PAD_GMAC1_RXD1  78
+#define	PAD_GMAC1_RXD2  79
+#define	PAD_GMAC1_RXD3  80
+#define	PAD_GMAC1_RXDV  81
+#define	PAD_GMAC1_RXC   82
+#define	PAD_GMAC1_TXD0  83
+#define	PAD_GMAC1_TXD1  84
+#define	PAD_GMAC1_TXD2  85
+#define	PAD_GMAC1_TXD3  86
+#define	PAD_GMAC1_TXEN  87
+#define	PAD_GMAC1_TXC   88
+#define	PAD_QSPI_SCLK   89
+#define	PAD_QSPI_CSn0   90
+#define	PAD_QSPI_DATA0  91
+#define	PAD_QSPI_DATA1  92
+#define	PAD_QSPI_DATA2  93
+#define	PAD_QSPI_DATA3  94
+
+
+//<fmux_idx.h>
+//oen and out idx is for chosen, in idx is for reg offset
+#define GPO_SYS_IOMUX_U0_WAVE511_O_UART_TXSOUT                      2
+#define GPO_SYS_IOMUX_U0_CAN_CTRL_STBY                              3
+#define GPO_SYS_IOMUX_U0_CAN_CTRL_TST_NEXT_BIT                      4
+#define GPO_SYS_IOMUX_U0_CAN_CTRL_TST_SAMPLE_POINT                  5
+#define GPO_SYS_IOMUX_U0_CAN_CTRL_TXD                               6
+#define GPO_SYS_IOMUX_U0_CDN_USB_DRIVE_VBUS_IO                      7
+#define GPO_SYS_IOMUX_U0_CDNS_QSPI_CSN1                             8
+#define GPO_SYS_IOMUX_U0_CDNS_SPDIF_SPDIFO                          9
+#define GPO_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_CEC_SDA_OUT    10
+#define GPO_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SCL_OUT    11
+#define GPO_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SDA_OUT    12
+#define GPO_SYS_IOMUX_U0_DSKIT_WDT_WDOGRES                          13
+#define GPO_SYS_IOMUX_U0_DW_I2C_IC_CLK_OUT_A                        14
+#define GPO_SYS_IOMUX_U0_DW_I2C_IC_DATA_OUT_A                       15
+#define GPO_SYS_IOMUX_U0_DW_SDIO_BACK_END_POWER                     16
+#define GPO_SYS_IOMUX_U0_DW_SDIO_CARD_POWER_EN                      17
+#define GPO_SYS_IOMUX_U0_DW_SDIO_CCMD_OD_PULLUP_EN_N                18
+#define GPO_SYS_IOMUX_U0_DW_SDIO_RST_N                              19
+#define GPO_SYS_IOMUX_U0_DW_UART_SOUT                               20
+#define GPO_SYS_IOMUX_U0_HIFI4_JTDO                                 21
+#define GPO_SYS_IOMUX_U0_JTAG_CERTIFICATION_TDO                     22
+#define GPO_SYS_IOMUX_U0_PDM_4MIC_DMIC_MCLK                         23
+#define GPO_SYS_IOMUX_U0_PWM_8CH_PTC_PWM_0                          24
+#define GPO_SYS_IOMUX_U0_PWM_8CH_PTC_PWM_1                          25
+#define GPO_SYS_IOMUX_U0_PWM_8CH_PTC_PWM_2                          26
+#define GPO_SYS_IOMUX_U0_PWM_8CH_PTC_PWM_3                          27
+#define GPO_SYS_IOMUX_U0_PWMDAC_PWMDAC_LEFT_OUTPUT                  28
+#define GPO_SYS_IOMUX_U0_PWMDAC_PWMDAC_RIGHT_OUTPUT                 29
+#define GPO_SYS_IOMUX_U0_SSP_SPI_SSPCLKOUT                          30
+#define GPO_SYS_IOMUX_U0_SSP_SPI_SSPFSSOUT                          31
+#define GPO_SYS_IOMUX_U0_SSP_SPI_SSPTXD                             32
+#define GPO_SYS_IOMUX_U0_SYS_CRG_CLK_GMAC_PHY                       33
+#define GPO_SYS_IOMUX_U0_SYS_CRG_I2SRX_BCLK_MST                     34
+#define GPO_SYS_IOMUX_U0_SYS_CRG_I2SRX_LRCK_MST                     35
+#define GPO_SYS_IOMUX_U0_SYS_CRG_I2STX_BCLK_MST                     36
+#define GPO_SYS_IOMUX_U0_SYS_CRG_I2STX_LRCK_MST                     37
+#define GPO_SYS_IOMUX_U0_SYS_CRG_MCLK_OUT                           38
+#define GPO_SYS_IOMUX_U0_SYS_CRG_TDM_CLK_MST                        39
+#define GPO_SYS_IOMUX_U0_TDM16SLOT_PCM_SYNCOUT                      40
+#define GPO_SYS_IOMUX_U0_TDM16SLOT_PCM_TXD                          41
+#define GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TDATA_0         42
+#define GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TDATA_1         43
+#define GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TDATA_2         44
+#define GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TDATA_3         45
+#define GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TREF            46
+#define GPO_SYS_IOMUX_U1_CAN_CTRL_STBY                              47
+#define GPO_SYS_IOMUX_U1_CAN_CTRL_TST_NEXT_BIT                      48
+#define GPO_SYS_IOMUX_U1_CAN_CTRL_TST_SAMPLE_POINT                  49
+#define GPO_SYS_IOMUX_U1_CAN_CTRL_TXD                               50
+#define GPO_SYS_IOMUX_U1_DW_I2C_IC_CLK_OUT_A                        51
+#define GPO_SYS_IOMUX_U1_DW_I2C_IC_DATA_OUT_A                       52
+#define GPO_SYS_IOMUX_U1_DW_SDIO_BACK_END_POWER                     53
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CARD_POWER_EN                      54
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CCLK_OUT                           55
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CCMD_OD_PULLUP_EN_N                56
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CCMD_OUT                           57
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_0                        58
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_1                        59
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_2                        60
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_3                        61
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_4                        62
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_5                        63
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_6                        64
+#define GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_7                        65
+#define GPO_SYS_IOMUX_U1_DW_SDIO_RST_N                              66
+#define GPO_SYS_IOMUX_U1_DW_UART_RTS_N                              67
+#define GPO_SYS_IOMUX_U1_DW_UART_SOUT                               68
+#define GPO_SYS_IOMUX_U1_I2STX_4CH_SDO0                             69
+#define GPO_SYS_IOMUX_U1_I2STX_4CH_SDO1                             70
+#define GPO_SYS_IOMUX_U1_I2STX_4CH_SDO2                             71
+#define GPO_SYS_IOMUX_U1_I2STX_4CH_SDO3                             72
+#define GPO_SYS_IOMUX_U1_SSP_SPI_SSPCLKOUT                          73
+#define GPO_SYS_IOMUX_U1_SSP_SPI_SSPFSSOUT                          74
+#define GPO_SYS_IOMUX_U1_SSP_SPI_SSPTXD                             75
+#define GPO_SYS_IOMUX_U2_DW_I2C_IC_CLK_OUT_A                        76
+#define GPO_SYS_IOMUX_U2_DW_I2C_IC_DATA_OUT_A                       77
+#define GPO_SYS_IOMUX_U2_DW_UART_RTS_N                              78
+#define GPO_SYS_IOMUX_U2_DW_UART_SOUT                               79
+#define GPO_SYS_IOMUX_U2_SSP_SPI_SSPCLKOUT                          80
+#define GPO_SYS_IOMUX_U2_SSP_SPI_SSPFSSOUT                          81
+#define GPO_SYS_IOMUX_U2_SSP_SPI_SSPTXD                             82
+#define GPO_SYS_IOMUX_U3_DW_I2C_IC_CLK_OUT_A                        83
+#define GPO_SYS_IOMUX_U3_DW_I2C_IC_DATA_OUT_A                       84
+#define GPO_SYS_IOMUX_U3_DW_UART_SOUT                               85
+#define GPO_SYS_IOMUX_U3_SSP_SPI_SSPCLKOUT                          86
+#define GPO_SYS_IOMUX_U3_SSP_SPI_SSPFSSOUT                          87
+#define GPO_SYS_IOMUX_U3_SSP_SPI_SSPTXD                             88
+#define GPO_SYS_IOMUX_U4_DW_I2C_IC_CLK_OUT_A                        89
+#define GPO_SYS_IOMUX_U4_DW_I2C_IC_DATA_OUT_A                       90
+#define GPO_SYS_IOMUX_U4_DW_UART_RTS_N                              91
+#define GPO_SYS_IOMUX_U4_DW_UART_SOUT                               92
+#define GPO_SYS_IOMUX_U4_SSP_SPI_SSPCLKOUT                          93
+#define GPO_SYS_IOMUX_U4_SSP_SPI_SSPFSSOUT                          94
+#define GPO_SYS_IOMUX_U4_SSP_SPI_SSPTXD                             95
+#define GPO_SYS_IOMUX_U5_DW_I2C_IC_CLK_OUT_A                        96
+#define GPO_SYS_IOMUX_U5_DW_I2C_IC_DATA_OUT_A                       97
+#define GPO_SYS_IOMUX_U5_DW_UART_RTS_N                              98
+#define GPO_SYS_IOMUX_U5_DW_UART_SOUT                               99
+#define GPO_SYS_IOMUX_U5_SSP_SPI_SSPCLKOUT                          100
+#define GPO_SYS_IOMUX_U5_SSP_SPI_SSPFSSOUT                          101
+#define GPO_SYS_IOMUX_U5_SSP_SPI_SSPTXD                             102
+#define GPO_SYS_IOMUX_U6_DW_I2C_IC_CLK_OUT_A                        103
+#define GPO_SYS_IOMUX_U6_DW_I2C_IC_DATA_OUT_A                       104
+#define GPO_SYS_IOMUX_U6_SSP_SPI_SSPCLKOUT                          105
+#define GPO_SYS_IOMUX_U6_SSP_SPI_SSPFSSOUT                          106
+#define GPO_SYS_IOMUX_U6_SSP_SPI_SSPTXD                             107
+
+#define GPEN_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_CEC_SDA_OEN   2
+#define GPEN_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SCL_OEN   3
+#define GPEN_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SDA_OEN   4
+#define GPEN_SYS_IOMUX_U0_DW_I2C_IC_CLK_OE                          5
+#define GPEN_SYS_IOMUX_U0_DW_I2C_IC_DATA_OE                         6
+#define GPEN_SYS_IOMUX_U0_HIFI4_JTDOEN                              7
+#define GPEN_SYS_IOMUX_U0_JTAG_CERTIFICATION_TDO_OE                 8
+#define GPEN_SYS_IOMUX_U0_PWM_8CH_PTC_OE_N_0                        9
+#define GPEN_SYS_IOMUX_U0_PWM_8CH_PTC_OE_N_1                        10
+#define GPEN_SYS_IOMUX_U0_PWM_8CH_PTC_OE_N_2                        11
+#define GPEN_SYS_IOMUX_U0_PWM_8CH_PTC_OE_N_3                        12
+#define GPEN_SYS_IOMUX_U0_SSP_SPI_NSSPCTLOE                         13
+#define GPEN_SYS_IOMUX_U0_SSP_SPI_NSSPOE                            14
+#define GPEN_SYS_IOMUX_U0_TDM16SLOT_NPCM_SYNCOE                     15
+#define GPEN_SYS_IOMUX_U0_TDM16SLOT_NPCM_TXDOE                      16
+#define GPEN_SYS_IOMUX_U1_DW_I2C_IC_CLK_OE                          17
+#define GPEN_SYS_IOMUX_U1_DW_I2C_IC_DATA_OE                         18
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CCMD_OUT_EN                       19
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_0                    20
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_1                    21
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_2                    22
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_3                    23
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_4                    24
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_5                    25
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_6                    26
+#define GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_7                    27
+#define GPEN_SYS_IOMUX_U1_SSP_SPI_NSSPCTLOE                         28
+#define GPEN_SYS_IOMUX_U1_SSP_SPI_NSSPOE                            29
+#define GPEN_SYS_IOMUX_U2_DW_I2C_IC_CLK_OE                          30
+#define GPEN_SYS_IOMUX_U2_DW_I2C_IC_DATA_OE                         31
+#define GPEN_SYS_IOMUX_U2_SSP_SPI_NSSPCTLOE                         32
+#define GPEN_SYS_IOMUX_U2_SSP_SPI_NSSPOE                            33
+#define GPEN_SYS_IOMUX_U3_DW_I2C_IC_CLK_OE                          34
+#define GPEN_SYS_IOMUX_U3_DW_I2C_IC_DATA_OE                         35
+#define GPEN_SYS_IOMUX_U3_SSP_SPI_NSSPCTLOE                         36
+#define GPEN_SYS_IOMUX_U3_SSP_SPI_NSSPOE                            37
+#define GPEN_SYS_IOMUX_U4_DW_I2C_IC_CLK_OE                          38
+#define GPEN_SYS_IOMUX_U4_DW_I2C_IC_DATA_OE                         39
+#define GPEN_SYS_IOMUX_U4_SSP_SPI_NSSPCTLOE                         40
+#define GPEN_SYS_IOMUX_U4_SSP_SPI_NSSPOE                            41
+#define GPEN_SYS_IOMUX_U5_DW_I2C_IC_CLK_OE                          42
+#define GPEN_SYS_IOMUX_U5_DW_I2C_IC_DATA_OE                         43
+#define GPEN_SYS_IOMUX_U5_SSP_SPI_NSSPCTLOE                         44
+#define GPEN_SYS_IOMUX_U5_SSP_SPI_NSSPOE                            45
+#define GPEN_SYS_IOMUX_U6_DW_I2C_IC_CLK_OE                          46
+#define GPEN_SYS_IOMUX_U6_DW_I2C_IC_DATA_OE                         47
+#define GPEN_SYS_IOMUX_U6_SSP_SPI_NSSPCTLOE                         48
+#define GPEN_SYS_IOMUX_U6_SSP_SPI_NSSPOE                            49
+
+#define GPI_SYS_IOMUX_U0_WAVE511_I_UART_RXSIN                       0
+#define GPI_SYS_IOMUX_U0_CAN_CTRL_RXD                               1
+#define GPI_SYS_IOMUX_U0_CDN_USB_OVERCURRENT_N_IO                   2
+#define GPI_SYS_IOMUX_U0_CDNS_SPDIF_SPDIFI                          3
+#define GPI_SYS_IOMUX_U0_CLKRST_SRC_BYPASS_JTAG_TRSTN               4
+#define GPI_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_CEC_SDA_IN     5
+#define GPI_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SCL_IN     6
+#define GPI_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SDA_IN     7
+#define GPI_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_HPD            8
+#define GPI_SYS_IOMUX_U0_DW_I2C_IC_CLK_IN_A                         9
+#define GPI_SYS_IOMUX_U0_DW_I2C_IC_DATA_IN_A                        10
+#define GPI_SYS_IOMUX_U0_DW_SDIO_CARD_DETECT_N                      11
+#define GPI_SYS_IOMUX_U0_DW_SDIO_CARD_INT_N                         12
+#define GPI_SYS_IOMUX_U0_DW_SDIO_CARD_WRITE_PRT                     13
+#define GPI_SYS_IOMUX_U0_DW_UART_SIN                                14
+#define GPI_SYS_IOMUX_U0_HIFI4_JTCK                                 15
+#define GPI_SYS_IOMUX_U0_HIFI4_JTDI                                 16
+#define GPI_SYS_IOMUX_U0_HIFI4_JTMS                                 17
+#define GPI_SYS_IOMUX_U0_HIFI4_JTRSTN                               18
+#define GPI_SYS_IOMUX_U0_JTAG_CERTIFICATION_TDI                     19
+#define GPI_SYS_IOMUX_U0_JTAG_CERTIFICATION_TMS                     20
+#define GPI_SYS_IOMUX_U0_PDM_4MIC_DMIC0_DIN                         21
+#define GPI_SYS_IOMUX_U0_PDM_4MIC_DMIC1_DIN                         22
+#define GPI_SYS_IOMUX_U0_SAIF_AUDIO_SDIN_MUX_I2SRX_EXT_SDIN0        23
+#define GPI_SYS_IOMUX_U0_SAIF_AUDIO_SDIN_MUX_I2SRX_EXT_SDIN1        24
+#define GPI_SYS_IOMUX_U0_SAIF_AUDIO_SDIN_MUX_I2SRX_EXT_SDIN2        25
+#define GPI_SYS_IOMUX_U0_SSP_SPI_SSPCLKIN                           26
+#define GPI_SYS_IOMUX_U0_SSP_SPI_SSPFSSIN                           27
+#define GPI_SYS_IOMUX_U0_SSP_SPI_SSPRXD                             28
+#define GPI_SYS_IOMUX_U0_SYS_CRG_CLK_JTAG_TCK                       29
+#define GPI_SYS_IOMUX_U0_SYS_CRG_EXT_MCLK                           30
+#define GPI_SYS_IOMUX_U0_SYS_CRG_I2SRX_BCLK_SLV                     31
+#define GPI_SYS_IOMUX_U0_SYS_CRG_I2SRX_LRCK_SLV                     32
+#define GPI_SYS_IOMUX_U0_SYS_CRG_I2STX_BCLK_SLV                     33
+#define GPI_SYS_IOMUX_U0_SYS_CRG_I2STX_LRCK_SLV                     34
+#define GPI_SYS_IOMUX_U0_SYS_CRG_TDM_CLK_SLV                        35
+#define GPI_SYS_IOMUX_U0_TDM16SLOT_PCM_RXD                          36
+#define GPI_SYS_IOMUX_U0_TDM16SLOT_PCM_SYNCIN                       37
+#define GPI_SYS_IOMUX_U1_CAN_CTRL_RXD                               38
+#define GPI_SYS_IOMUX_U1_DW_I2C_IC_CLK_IN_A                         39
+#define GPI_SYS_IOMUX_U1_DW_I2C_IC_DATA_IN_A                        40
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CARD_DETECT_N                      41
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CARD_INT_N                         42
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CARD_WRITE_PRT                     43
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CCMD_IN                            44
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_0                         45
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_1                         46
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_2                         47
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_3                         48
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_4                         49
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_5                         50
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_6                         51
+#define GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_7                         52
+#define GPI_SYS_IOMUX_U1_DW_SDIO_DATA_STROBE                        53
+#define GPI_SYS_IOMUX_U1_DW_UART_CTS_N                              54
+#define GPI_SYS_IOMUX_U1_DW_UART_SIN                                55
+#define GPI_SYS_IOMUX_U1_SSP_SPI_SSPCLKIN                           56
+#define GPI_SYS_IOMUX_U1_SSP_SPI_SSPFSSIN                           57
+#define GPI_SYS_IOMUX_U1_SSP_SPI_SSPRXD                             58
+#define GPI_SYS_IOMUX_U2_DW_I2C_IC_CLK_IN_A                         59
+#define GPI_SYS_IOMUX_U2_DW_I2C_IC_DATA_IN_A                        60
+#define GPI_SYS_IOMUX_U2_DW_UART_CTS_N                              61
+#define GPI_SYS_IOMUX_U2_DW_UART_SIN                                62
+#define GPI_SYS_IOMUX_U2_SSP_SPI_SSPCLKIN                           63
+#define GPI_SYS_IOMUX_U2_SSP_SPI_SSPFSSIN                           64
+#define GPI_SYS_IOMUX_U2_SSP_SPI_SSPRXD                             65
+#define GPI_SYS_IOMUX_U3_DW_I2C_IC_CLK_IN_A                         66
+#define GPI_SYS_IOMUX_U3_DW_I2C_IC_DATA_IN_A                        67
+#define GPI_SYS_IOMUX_U3_DW_UART_SIN                                68
+#define GPI_SYS_IOMUX_U3_SSP_SPI_SSPCLKIN                           69
+#define GPI_SYS_IOMUX_U3_SSP_SPI_SSPFSSIN                           70
+#define GPI_SYS_IOMUX_U3_SSP_SPI_SSPRXD                             71
+#define GPI_SYS_IOMUX_U4_DW_I2C_IC_CLK_IN_A                         72
+#define GPI_SYS_IOMUX_U4_DW_I2C_IC_DATA_IN_A                        73
+#define GPI_SYS_IOMUX_U4_DW_UART_CTS_N                              74
+#define GPI_SYS_IOMUX_U4_DW_UART_SIN                                75
+#define GPI_SYS_IOMUX_U4_SSP_SPI_SSPCLKIN                           76
+#define GPI_SYS_IOMUX_U4_SSP_SPI_SSPFSSIN                           77
+#define GPI_SYS_IOMUX_U4_SSP_SPI_SSPRXD                             78
+#define GPI_SYS_IOMUX_U5_DW_I2C_IC_CLK_IN_A                         79
+#define GPI_SYS_IOMUX_U5_DW_I2C_IC_DATA_IN_A                        80
+#define GPI_SYS_IOMUX_U5_DW_UART_CTS_N                              81
+#define GPI_SYS_IOMUX_U5_DW_UART_SIN                                82
+#define GPI_SYS_IOMUX_U5_SSP_SPI_SSPCLKIN                           83
+#define GPI_SYS_IOMUX_U5_SSP_SPI_SSPFSSIN                           84
+#define GPI_SYS_IOMUX_U5_SSP_SPI_SSPRXD                             85
+#define GPI_SYS_IOMUX_U6_DW_I2C_IC_CLK_IN_A                         86
+#define GPI_SYS_IOMUX_U6_DW_I2C_IC_DATA_IN_A                        87
+#define GPI_SYS_IOMUX_U6_SSP_SPI_SSPCLKIN                           88
+#define GPI_SYS_IOMUX_U6_SSP_SPI_SSPFSSIN                           89
+#define GPI_SYS_IOMUX_U6_SSP_SPI_SSPRXD                             90
+
+
+
+//gpo(n)_dout signal pool
+#define GPO_LOW 	0
+#define GPO_HIGH 	1
+#define GPO_CAN0_CTRL_STBY              \
+        GPO_SYS_IOMUX_U0_CAN_CTRL_STBY
+#define GPO_CAN0_CTRL_TST_NEXT_BIT      \
+        GPO_SYS_IOMUX_U0_CAN_CTRL_TST_NEXT_BIT
+#define GPO_CAN0_CTRL_TST_SAMPLE_POINT  \
+        GPO_SYS_IOMUX_U0_CAN_CTRL_TST_SAMPLE_POINT
+#define GPO_CAN0_CTRL_TXD               \
+        GPO_SYS_IOMUX_U0_CAN_CTRL_TXD
+#define GPO_CAN1_CTRL_STBY              \
+        GPO_SYS_IOMUX_U1_CAN_CTRL_STBY
+#define GPO_CAN1_CTRL_TST_NEXT_BIT      \
+        GPO_SYS_IOMUX_U1_CAN_CTRL_TST_NEXT_BIT
+#define GPO_CAN1_CTRL_TST_SAMPLE_POINT  \
+        GPO_SYS_IOMUX_U1_CAN_CTRL_TST_SAMPLE_POINT
+#define GPO_CAN1_CTRL_TXD               \
+        GPO_SYS_IOMUX_U1_CAN_CTRL_TXD
+#define GPO_CRG0_MCLK_OUT               \
+        GPO_SYS_IOMUX_U0_SYS_CRG_MCLK_OUT
+#define GPO_GMAC0_CLK_PHY               \
+        GPO_SYS_IOMUX_U0_SYS_CRG_CLK_GMAC_PHY
+#define GPO_HDMI0_CEC_SDA_OUT           \
+        GPO_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_CEC_SDA_OUT
+#define GPO_HDMI0_DDC_SCL_OUT           \
+        GPO_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SCL_OUT
+#define GPO_HDMI0_DDC_SDA_OUT           \
+        GPO_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SDA_OUT
+#define GPO_I2C0_IC_CLK_OUT_A           \
+        GPO_SYS_IOMUX_U0_DW_I2C_IC_CLK_OUT_A
+#define GPO_I2C0_IC_DATA_OUT_A          \
+        GPO_SYS_IOMUX_U0_DW_I2C_IC_DATA_OUT_A
+#define GPO_I2C1_IC_CLK_OUT_A           \
+        GPO_SYS_IOMUX_U1_DW_I2C_IC_CLK_OUT_A
+#define GPO_I2C1_IC_DATA_OUT_A          \
+        GPO_SYS_IOMUX_U1_DW_I2C_IC_DATA_OUT_A
+#define GPO_I2C2_IC_CLK_OUT_A           \
+        GPO_SYS_IOMUX_U2_DW_I2C_IC_CLK_OUT_A
+#define GPO_I2C2_IC_DATA_OUT_A          \
+        GPO_SYS_IOMUX_U2_DW_I2C_IC_DATA_OUT_A
+#define GPO_I2C3_IC_CLK_OUT_A           \
+        GPO_SYS_IOMUX_U3_DW_I2C_IC_CLK_OUT_A
+#define GPO_I2C3_IC_DATA_OUT_A          \
+        GPO_SYS_IOMUX_U3_DW_I2C_IC_DATA_OUT_A
+#define GPO_I2C4_IC_CLK_OUT_A           \
+        GPO_SYS_IOMUX_U4_DW_I2C_IC_CLK_OUT_A
+#define GPO_I2C4_IC_DATA_OUT_A          \
+        GPO_SYS_IOMUX_U4_DW_I2C_IC_DATA_OUT_A
+#define GPO_I2C5_IC_CLK_OUT_A           \
+        GPO_SYS_IOMUX_U5_DW_I2C_IC_CLK_OUT_A
+#define GPO_I2C5_IC_DATA_OUT_A          \
+        GPO_SYS_IOMUX_U5_DW_I2C_IC_DATA_OUT_A
+#define GPO_I2C6_IC_CLK_OUT_A           \
+        GPO_SYS_IOMUX_U6_DW_I2C_IC_CLK_OUT_A
+#define GPO_I2C6_IC_DATA_OUT_A          \
+        GPO_SYS_IOMUX_U6_DW_I2C_IC_DATA_OUT_A
+#define GPO_I2SRX0_BCLK_MST             \
+        GPO_SYS_IOMUX_U0_SYS_CRG_I2SRX_BCLK_MST
+#define GPO_I2SRX0_LRCK_MST             \
+        GPO_SYS_IOMUX_U0_SYS_CRG_I2SRX_LRCK_MST
+#define GPO_I2STX_4CH1_SDO0             \
+        GPO_SYS_IOMUX_U1_I2STX_4CH_SDO0
+#define GPO_I2STX_4CH1_SDO1             \
+        GPO_SYS_IOMUX_U1_I2STX_4CH_SDO1
+#define GPO_I2STX_4CH1_SDO2             \
+        GPO_SYS_IOMUX_U1_I2STX_4CH_SDO2
+#define GPO_I2STX_4CH1_SDO3             \
+        GPO_SYS_IOMUX_U1_I2STX_4CH_SDO3
+#define GPO_I2STX0_BCLK_MST             \
+        GPO_SYS_IOMUX_U0_SYS_CRG_I2STX_BCLK_MST
+#define GPO_I2STX0_LRCK_MST             \
+        GPO_SYS_IOMUX_U0_SYS_CRG_I2STX_LRCK_MST
+#define GPO_JTAG_CPU_CERTIFICATION_TDO  \
+        GPO_SYS_IOMUX_U0_JTAG_CERTIFICATION_TDO
+#define GPO_JTAG_DSP_TDO                \
+        GPO_SYS_IOMUX_U0_HIFI4_JTDO
+#define GPO_PDM_4MIC0_DMIC_MCLK         \
+        GPO_SYS_IOMUX_U0_PDM_4MIC_DMIC_MCLK
+#define GPO_PTC0_PWM_0                  \
+        GPO_SYS_IOMUX_U0_PWM_8CH_PTC_PWM_0
+#define GPO_PTC0_PWM_1                  \
+        GPO_SYS_IOMUX_U0_PWM_8CH_PTC_PWM_1
+#define GPO_PTC0_PWM_2                  \
+        GPO_SYS_IOMUX_U0_PWM_8CH_PTC_PWM_2
+#define GPO_PTC0_PWM_3                  \
+        GPO_SYS_IOMUX_U0_PWM_8CH_PTC_PWM_3
+#define GPO_PWMDAC0_LEFT_OUTPUT         \
+        GPO_SYS_IOMUX_U0_PWMDAC_PWMDAC_LEFT_OUTPUT
+#define GPO_PWMDAC0_RIGHT_OUTPUT        \
+        GPO_SYS_IOMUX_U0_PWMDAC_PWMDAC_RIGHT_OUTPUT
+#define GPO_QSPI0_CSN1                  \
+        GPO_SYS_IOMUX_U0_CDNS_QSPI_CSN1
+#define GPO_SDIO0_BACK_END_POWER        \
+        GPO_SYS_IOMUX_U0_DW_SDIO_BACK_END_POWER
+#define GPO_SDIO0_CARD_POWER_EN         \
+        GPO_SYS_IOMUX_U0_DW_SDIO_CARD_POWER_EN
+#define GPO_SDIO0_CCMD_OD_PULLUP_EN_N   \
+        GPO_SYS_IOMUX_U0_DW_SDIO_CCMD_OD_PULLUP_EN_N
+#define GPO_SDIO0_RST_N                 \
+        GPO_SYS_IOMUX_U0_DW_SDIO_RST_N
+#define GPO_SDIO1_BACK_END_POWER        \
+        GPO_SYS_IOMUX_U1_DW_SDIO_BACK_END_POWER
+#define GPO_SDIO1_CARD_POWER_EN         \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CARD_POWER_EN
+#define GPO_SDIO1_CCLK_OUT              \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CCLK_OUT
+#define GPO_SDIO1_CCMD_OD_PULLUP_EN_N   \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CCMD_OD_PULLUP_EN_N
+#define GPO_SDIO1_CCMD_OUT              \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CCMD_OUT
+#define GPO_SDIO1_CDATA_OUT_0           \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_0
+#define GPO_SDIO1_CDATA_OUT_1           \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_1
+#define GPO_SDIO1_CDATA_OUT_2           \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_2
+#define GPO_SDIO1_CDATA_OUT_3           \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_3
+#define GPO_SDIO1_CDATA_OUT_4           \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_4
+#define GPO_SDIO1_CDATA_OUT_5           \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_5
+#define GPO_SDIO1_CDATA_OUT_6           \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_6
+#define GPO_SDIO1_CDATA_OUT_7           \
+        GPO_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_7
+#define GPO_SDIO1_RST_N                 \
+        GPO_SYS_IOMUX_U1_DW_SDIO_RST_N
+#define GPO_SPDIF0_SPDIFO               \
+        GPO_SYS_IOMUX_U0_CDNS_SPDIF_SPDIFO
+#define GPO_SPI0_SSPCLKOUT              \
+        GPO_SYS_IOMUX_U0_SSP_SPI_SSPCLKOUT
+#define GPO_SPI0_SSPFSSOUT              \
+        GPO_SYS_IOMUX_U0_SSP_SPI_SSPFSSOUT
+#define GPO_SPI0_SSPTXD                 \
+        GPO_SYS_IOMUX_U0_SSP_SPI_SSPTXD
+#define GPO_SPI1_SSPCLKOUT              \
+        GPO_SYS_IOMUX_U1_SSP_SPI_SSPCLKOUT
+#define GPO_SPI1_SSPFSSOUT              \
+        GPO_SYS_IOMUX_U1_SSP_SPI_SSPFSSOUT
+#define GPO_SPI1_SSPTXD                 \
+        GPO_SYS_IOMUX_U1_SSP_SPI_SSPTXD
+#define GPO_SPI2_SSPCLKOUT              \
+        GPO_SYS_IOMUX_U2_SSP_SPI_SSPCLKOUT
+#define GPO_SPI2_SSPFSSOUT              \
+        GPO_SYS_IOMUX_U2_SSP_SPI_SSPFSSOUT
+#define GPO_SPI2_SSPTXD                 \
+        GPO_SYS_IOMUX_U2_SSP_SPI_SSPTXD
+#define GPO_SPI3_SSPCLKOUT              \
+        GPO_SYS_IOMUX_U3_SSP_SPI_SSPCLKOUT
+#define GPO_SPI3_SSPFSSOUT              \
+        GPO_SYS_IOMUX_U3_SSP_SPI_SSPFSSOUT
+#define GPO_SPI3_SSPTXD                 \
+        GPO_SYS_IOMUX_U3_SSP_SPI_SSPTXD
+#define GPO_SPI4_SSPCLKOUT              \
+        GPO_SYS_IOMUX_U4_SSP_SPI_SSPCLKOUT
+#define GPO_SPI4_SSPFSSOUT              \
+        GPO_SYS_IOMUX_U4_SSP_SPI_SSPFSSOUT
+#define GPO_SPI4_SSPTXD                 \
+        GPO_SYS_IOMUX_U4_SSP_SPI_SSPTXD
+#define GPO_SPI5_SSPCLKOUT              \
+        GPO_SYS_IOMUX_U5_SSP_SPI_SSPCLKOUT
+#define GPO_SPI5_SSPFSSOUT              \
+        GPO_SYS_IOMUX_U5_SSP_SPI_SSPFSSOUT
+#define GPO_SPI5_SSPTXD                 \
+        GPO_SYS_IOMUX_U5_SSP_SPI_SSPTXD
+#define GPO_SPI6_SSPCLKOUT              \
+        GPO_SYS_IOMUX_U6_SSP_SPI_SSPCLKOUT
+#define GPO_SPI6_SSPFSSOUT              \
+        GPO_SYS_IOMUX_U6_SSP_SPI_SSPFSSOUT
+#define GPO_SPI6_SSPTXD                 \
+        GPO_SYS_IOMUX_U6_SSP_SPI_SSPTXD
+#define GPO_TDM0_CLK_MST                \
+        GPO_SYS_IOMUX_U0_SYS_CRG_TDM_CLK_MST
+#define GPO_TDM0_PCM_SYNCOUT            \
+        GPO_SYS_IOMUX_U0_TDM16SLOT_PCM_SYNCOUT
+#define GPO_TDM0_PCM_TXD                \
+        GPO_SYS_IOMUX_U0_TDM16SLOT_PCM_TXD
+#define GPO_U7MC_TRACE0_TDATA_0         \
+        GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TDATA_0
+#define GPO_U7MC_TRACE0_TDATA_1         \
+        GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TDATA_1
+#define GPO_U7MC_TRACE0_TDATA_2         \
+        GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TDATA_2
+#define GPO_U7MC_TRACE0_TDATA_3         \
+        GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TDATA_3
+#define GPO_U7MC_TRACE0_TREF            \
+        GPO_SYS_IOMUX_U0_U7MC_SFT7110_TRACE_COM_PIB_TREF
+#define GPO_UART0_SOUT                  \
+        GPO_SYS_IOMUX_U0_DW_UART_SOUT
+#define GPO_UART1_RTS_N                 \
+        GPO_SYS_IOMUX_U1_DW_UART_RTS_N
+#define GPO_UART1_SOUT                  \
+        GPO_SYS_IOMUX_U1_DW_UART_SOUT
+#define GPO_UART2_RTS_N                 \
+        GPO_SYS_IOMUX_U2_DW_UART_RTS_N
+#define GPO_UART2_SOUT                  \
+        GPO_SYS_IOMUX_U2_DW_UART_SOUT
+#define GPO_UART3_SOUT                  \
+        GPO_SYS_IOMUX_U3_DW_UART_SOUT
+#define GPO_UART4_RTS_N                 \
+        GPO_SYS_IOMUX_U4_DW_UART_RTS_N
+#define GPO_UART4_SOUT                  \
+        GPO_SYS_IOMUX_U4_DW_UART_SOUT
+#define GPO_UART5_RTS_N                 \
+        GPO_SYS_IOMUX_U5_DW_UART_RTS_N
+#define GPO_UART5_SOUT                  \
+        GPO_SYS_IOMUX_U5_DW_UART_SOUT
+#define GPO_USB0_DRIVE_VBUS_IO          \
+        GPO_SYS_IOMUX_U0_CDN_USB_DRIVE_VBUS_IO
+#define GPO_WAVE511_0_O_UART_TXSOUT     \
+        GPO_SYS_IOMUX_U0_WAVE511_O_UART_TXSOUT
+#define GPO_WDT0_WDOGRES                \
+        GPO_SYS_IOMUX_U0_DSKIT_WDT_WDOGRES
+#define GPO_NONE                        \
+        GPO_SYS_IOMUX_U6_SSP_SPI_SSPTXD + 1
+
+
+//gpo(n)_doen signal pool
+#define OEN_LOW 	0
+#define OEN_HIGH 	1
+#define OEN_HDMI0_CEC_SDA_OEN               \
+        GPEN_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_CEC_SDA_OEN
+#define OEN_HDMI0_DDC_SCL_OEN               \
+        GPEN_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SCL_OEN
+#define OEN_HDMI0_DDC_SDA_OEN               \
+        GPEN_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SDA_OEN
+#define OEN_I2C0_IC_CLK_OE                  \
+        GPEN_SYS_IOMUX_U0_DW_I2C_IC_CLK_OE
+#define OEN_I2C0_IC_DATA_OE                 \
+        GPEN_SYS_IOMUX_U0_DW_I2C_IC_DATA_OE
+#define OEN_I2C1_IC_CLK_OE                  \
+        GPEN_SYS_IOMUX_U1_DW_I2C_IC_CLK_OE
+#define OEN_I2C1_IC_DATA_OE                 \
+        GPEN_SYS_IOMUX_U1_DW_I2C_IC_DATA_OE
+#define OEN_I2C2_IC_CLK_OE                  \
+        GPEN_SYS_IOMUX_U2_DW_I2C_IC_CLK_OE
+#define OEN_I2C2_IC_DATA_OE                 \
+        GPEN_SYS_IOMUX_U2_DW_I2C_IC_DATA_OE
+#define OEN_I2C3_IC_CLK_OE                  \
+        GPEN_SYS_IOMUX_U3_DW_I2C_IC_CLK_OE
+#define OEN_I2C3_IC_DATA_OE                 \
+        GPEN_SYS_IOMUX_U3_DW_I2C_IC_DATA_OE
+#define OEN_I2C4_IC_CLK_OE                  \
+        GPEN_SYS_IOMUX_U4_DW_I2C_IC_CLK_OE
+#define OEN_I2C4_IC_DATA_OE                 \
+        GPEN_SYS_IOMUX_U4_DW_I2C_IC_DATA_OE
+#define OEN_I2C5_IC_CLK_OE                  \
+        GPEN_SYS_IOMUX_U5_DW_I2C_IC_CLK_OE
+#define OEN_I2C5_IC_DATA_OE                 \
+        GPEN_SYS_IOMUX_U5_DW_I2C_IC_DATA_OE
+#define OEN_I2C6_IC_CLK_OE                  \
+        GPEN_SYS_IOMUX_U6_DW_I2C_IC_CLK_OE
+#define OEN_I2C6_IC_DATA_OE                 \
+        GPEN_SYS_IOMUX_U6_DW_I2C_IC_DATA_OE
+#define OEN_JTAG_CPU_CERTIFICATION_TDO_OE   \
+        GPEN_SYS_IOMUX_U0_JTAG_CERTIFICATION_TDO_OE
+#define OEN_JTAG_DSP_TDO_OEN                \
+        GPEN_SYS_IOMUX_U0_HIFI4_JTDOEN
+#define OEN_PTC0_PWM_0_OE_N                 \
+        GPEN_SYS_IOMUX_U0_PWM_8CH_PTC_OE_N_0
+#define OEN_PTC0_PWM_1_OE_N                 \
+        GPEN_SYS_IOMUX_U0_PWM_8CH_PTC_OE_N_1
+#define OEN_PTC0_PWM_2_OE_N                 \
+        GPEN_SYS_IOMUX_U0_PWM_8CH_PTC_OE_N_2
+#define OEN_PTC0_PWM_3_OE_N                 \
+        GPEN_SYS_IOMUX_U0_PWM_8CH_PTC_OE_N_3
+#define OEN_SDIO1_CCMD_OUT_EN               \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CCMD_OUT_EN
+#define OEN_SDIO1_CDATA_OUT_EN_0            \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_0
+#define OEN_SDIO1_CDATA_OUT_EN_1            \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_1
+#define OEN_SDIO1_CDATA_OUT_EN_2            \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_2
+#define OEN_SDIO1_CDATA_OUT_EN_3            \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_3
+#define OEN_SDIO1_CDATA_OUT_EN_4            \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_4
+#define OEN_SDIO1_CDATA_OUT_EN_5            \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_5
+#define OEN_SDIO1_CDATA_OUT_EN_6            \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_6
+#define OEN_SDIO1_CDATA_OUT_EN_7            \
+        GPEN_SYS_IOMUX_U1_DW_SDIO_CDATA_OUT_EN_7
+#define OEN_SPI0_NSSPCTLOE                  \
+        GPEN_SYS_IOMUX_U0_SSP_SPI_NSSPCTLOE
+#define OEN_SPI0_NSSPOE                     \
+        GPEN_SYS_IOMUX_U0_SSP_SPI_NSSPOE
+#define OEN_SPI1_NSSPCTLOE                  \
+        GPEN_SYS_IOMUX_U1_SSP_SPI_NSSPCTLOE
+#define OEN_SPI1_NSSPOE                     \
+        GPEN_SYS_IOMUX_U1_SSP_SPI_NSSPOE
+#define OEN_SPI2_NSSPCTLOE                  \
+        GPEN_SYS_IOMUX_U2_SSP_SPI_NSSPCTLOE
+#define OEN_SPI2_NSSPOE                     \
+        GPEN_SYS_IOMUX_U2_SSP_SPI_NSSPOE
+#define OEN_SPI3_NSSPCTLOE                  \
+        GPEN_SYS_IOMUX_U3_SSP_SPI_NSSPCTLOE
+#define OEN_SPI3_NSSPOE                     \
+        GPEN_SYS_IOMUX_U3_SSP_SPI_NSSPOE
+#define OEN_SPI4_NSSPCTLOE                  \
+        GPEN_SYS_IOMUX_U4_SSP_SPI_NSSPCTLOE
+#define OEN_SPI4_NSSPOE                     \
+        GPEN_SYS_IOMUX_U4_SSP_SPI_NSSPOE
+#define OEN_SPI5_NSSPCTLOE                  \
+        GPEN_SYS_IOMUX_U5_SSP_SPI_NSSPCTLOE
+#define OEN_SPI5_NSSPOE                     \
+        GPEN_SYS_IOMUX_U5_SSP_SPI_NSSPOE
+#define OEN_SPI6_NSSPCTLOE                  \
+        GPEN_SYS_IOMUX_U6_SSP_SPI_NSSPCTLOE
+#define OEN_SPI6_NSSPOE                     \
+        GPEN_SYS_IOMUX_U6_SSP_SPI_NSSPOE
+#define OEN_TDM0_NPCM_SYNCOE                \
+        GPEN_SYS_IOMUX_U0_TDM16SLOT_NPCM_SYNCOE
+#define OEN_TDM0_NPCM_TXDOE                 \
+        GPEN_SYS_IOMUX_U0_TDM16SLOT_NPCM_TXDOE
+#define OEN_NONE                            \
+        GPEN_SYS_IOMUX_U6_SSP_SPI_NSSPOE + 1
+
+//sys_iomux gpi din
+#define	GPI_CAN0_CTRL_RXD                       \
+        GPI_SYS_IOMUX_U0_CAN_CTRL_RXD
+#define	GPI_CAN1_CTRL_RXD                       \
+        GPI_SYS_IOMUX_U1_CAN_CTRL_RXD
+#define	GPI_CRG0_EXT_MCLK                       \
+        GPI_SYS_IOMUX_U0_SYS_CRG_EXT_MCLK
+#define	GPI_HDMI0_CEC_SDA_IN                    \
+        GPI_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_CEC_SDA_IN
+#define	GPI_HDMI0_DDC_SCL_IN                    \
+        GPI_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SCL_IN
+#define	GPI_HDMI0_DDC_SDA_IN                    \
+        GPI_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_DDC_SDA_IN
+#define	GPI_HDMI0_HPD                           \
+        GPI_SYS_IOMUX_U0_DOM_VOUT_TOP_U0_HDMI_TX_PIN_HPD
+#define	GPI_I2C0_IC_CLK_IN_A                    \
+        GPI_SYS_IOMUX_U0_DW_I2C_IC_CLK_IN_A
+#define	GPI_I2C0_IC_DATA_IN_A                   \
+        GPI_SYS_IOMUX_U0_DW_I2C_IC_DATA_IN_A
+#define	GPI_I2C1_IC_CLK_IN_A                    \
+        GPI_SYS_IOMUX_U1_DW_I2C_IC_CLK_IN_A
+#define	GPI_I2C1_IC_DATA_IN_A                   \
+        GPI_SYS_IOMUX_U1_DW_I2C_IC_DATA_IN_A
+#define	GPI_I2C2_IC_CLK_IN_A                    \
+        GPI_SYS_IOMUX_U2_DW_I2C_IC_CLK_IN_A
+#define	GPI_I2C2_IC_DATA_IN_A                   \
+        GPI_SYS_IOMUX_U2_DW_I2C_IC_DATA_IN_A
+#define	GPI_I2C3_IC_CLK_IN_A                    \
+        GPI_SYS_IOMUX_U3_DW_I2C_IC_CLK_IN_A
+#define	GPI_I2C3_IC_DATA_IN_A                   \
+        GPI_SYS_IOMUX_U3_DW_I2C_IC_DATA_IN_A
+#define	GPI_I2C4_IC_CLK_IN_A                    \
+        GPI_SYS_IOMUX_U4_DW_I2C_IC_CLK_IN_A
+#define	GPI_I2C4_IC_DATA_IN_A                   \
+        GPI_SYS_IOMUX_U4_DW_I2C_IC_DATA_IN_A
+#define	GPI_I2C5_IC_CLK_IN_A                    \
+        GPI_SYS_IOMUX_U5_DW_I2C_IC_CLK_IN_A
+#define	GPI_I2C5_IC_DATA_IN_A                   \
+        GPI_SYS_IOMUX_U5_DW_I2C_IC_DATA_IN_A
+#define	GPI_I2C6_IC_CLK_IN_A                    \
+        GPI_SYS_IOMUX_U6_DW_I2C_IC_CLK_IN_A
+#define	GPI_I2C6_IC_DATA_IN_A                   \
+        GPI_SYS_IOMUX_U6_DW_I2C_IC_DATA_IN_A
+#define	GPI_I2SRX0_BCLK_SLV                     \
+        GPI_SYS_IOMUX_U0_SYS_CRG_I2SRX_BCLK_SLV
+#define	GPI_I2SRX0_EXT_SDIN0                    \
+        GPI_SYS_IOMUX_U0_SAIF_AUDIO_SDIN_MUX_I2SRX_EXT_SDIN0
+#define	GPI_I2SRX0_EXT_SDIN1                    \
+        GPI_SYS_IOMUX_U0_SAIF_AUDIO_SDIN_MUX_I2SRX_EXT_SDIN1
+#define	GPI_I2SRX0_EXT_SDIN2                    \
+        GPI_SYS_IOMUX_U0_SAIF_AUDIO_SDIN_MUX_I2SRX_EXT_SDIN2
+#define	GPI_I2SRX0_LRCK_SLV                     \
+        GPI_SYS_IOMUX_U0_SYS_CRG_I2SRX_LRCK_SLV
+#define	GPI_I2STX0_BCLK_SLV                     \
+        GPI_SYS_IOMUX_U0_SYS_CRG_I2STX_BCLK_SLV
+#define	GPI_I2STX0_LRCK_SLV                     \
+        GPI_SYS_IOMUX_U0_SYS_CRG_I2STX_LRCK_SLV
+#define	GPI_JTAG_CPU_CERTIFICATION_BYPASS_TRSTN \
+        GPI_SYS_IOMUX_U0_CLKRST_SRC_BYPASS_JTAG_TRSTN
+#define	GPI_JTAG_CPU_CERTIFICATION_TCK          \
+        GPI_SYS_IOMUX_U0_SYS_CRG_CLK_JTAG_TCK
+#define	GPI_JTAG_CPU_CERTIFICATION_TDI          \
+        GPI_SYS_IOMUX_U0_JTAG_CERTIFICATION_TDI
+#define	GPI_JTAG_CPU_CERTIFICATION_TMS          \
+        GPI_SYS_IOMUX_U0_JTAG_CERTIFICATION_TMS
+#define	GPI_JTAG_DSP_TCK                        \
+        GPI_SYS_IOMUX_U0_HIFI4_JTCK
+#define	GPI_JTAG_DSP_TDI                        \
+        GPI_SYS_IOMUX_U0_HIFI4_JTDI
+#define	GPI_JTAG_DSP_TMS                        \
+        GPI_SYS_IOMUX_U0_HIFI4_JTMS
+#define	GPI_JTAG_DSP_TRST_N                     \
+        GPI_SYS_IOMUX_U0_HIFI4_JTRSTN
+#define	GPI_PDM_4MIC0_DMIC0_DIN                 \
+        GPI_SYS_IOMUX_U0_PDM_4MIC_DMIC0_DIN
+#define	GPI_PDM_4MIC0_DMIC1_DIN                 \
+        GPI_SYS_IOMUX_U0_PDM_4MIC_DMIC1_DIN
+#define	GPI_SDIO0_CARD_DETECT_N                 \
+        GPI_SYS_IOMUX_U0_DW_SDIO_CARD_DETECT_N
+#define	GPI_SDIO0_CARD_INT_N                    \
+        GPI_SYS_IOMUX_U0_DW_SDIO_CARD_INT_N
+#define	GPI_SDIO0_CARD_WRITE_PRT                \
+        GPI_SYS_IOMUX_U0_DW_SDIO_CARD_WRITE_PRT
+#define	GPI_SDIO1_CARD_DETECT_N                 \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CARD_DETECT_N
+#define	GPI_SDIO1_CARD_INT_N                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CARD_INT_N
+#define	GPI_SDIO1_CARD_WRITE_PRT                \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CARD_WRITE_PRT
+#define	GPI_SDIO1_CCMD_IN                       \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CCMD_IN
+#define	GPI_SDIO1_CDATA_IN_0                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_0
+#define	GPI_SDIO1_CDATA_IN_1                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_1
+#define	GPI_SDIO1_CDATA_IN_2                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_2
+#define	GPI_SDIO1_CDATA_IN_3                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_3
+#define	GPI_SDIO1_CDATA_IN_4                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_4
+#define	GPI_SDIO1_CDATA_IN_5                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_5
+#define	GPI_SDIO1_CDATA_IN_6                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_6
+#define	GPI_SDIO1_CDATA_IN_7                    \
+        GPI_SYS_IOMUX_U1_DW_SDIO_CDATA_IN_7
+#define	GPI_SDIO1_DATA_STROBE                   \
+        GPI_SYS_IOMUX_U1_DW_SDIO_DATA_STROBE
+#define	GPI_SPDIF0_SPDIFI                       \
+        GPI_SYS_IOMUX_U0_CDNS_SPDIF_SPDIFI
+#define	GPI_SPI0_SSPCLKIN                       \
+        GPI_SYS_IOMUX_U0_SSP_SPI_SSPCLKIN
+#define	GPI_SPI0_SSPFSSIN                       \
+        GPI_SYS_IOMUX_U0_SSP_SPI_SSPFSSIN
+#define	GPI_SPI0_SSPRXD                         \
+        GPI_SYS_IOMUX_U0_SSP_SPI_SSPRXD
+#define	GPI_SPI1_SSPCLKIN                       \
+        GPI_SYS_IOMUX_U1_SSP_SPI_SSPCLKIN
+#define	GPI_SPI1_SSPFSSIN                       \
+        GPI_SYS_IOMUX_U1_SSP_SPI_SSPFSSIN
+#define	GPI_SPI1_SSPRXD                         \
+        GPI_SYS_IOMUX_U1_SSP_SPI_SSPRXD
+#define	GPI_SPI2_SSPCLKIN                       \
+        GPI_SYS_IOMUX_U2_SSP_SPI_SSPCLKIN
+#define	GPI_SPI2_SSPFSSIN                       \
+        GPI_SYS_IOMUX_U2_SSP_SPI_SSPFSSIN
+#define	GPI_SPI2_SSPRXD                         \
+        GPI_SYS_IOMUX_U2_SSP_SPI_SSPRXD
+#define	GPI_SPI3_SSPCLKIN                       \
+        GPI_SYS_IOMUX_U3_SSP_SPI_SSPCLKIN
+#define	GPI_SPI3_SSPFSSIN                       \
+        GPI_SYS_IOMUX_U3_SSP_SPI_SSPFSSIN
+#define	GPI_SPI3_SSPRXD                         \
+        GPI_SYS_IOMUX_U3_SSP_SPI_SSPRXD
+#define	GPI_SPI4_SSPCLKIN                       \
+        GPI_SYS_IOMUX_U4_SSP_SPI_SSPCLKIN
+#define	GPI_SPI4_SSPFSSIN                       \
+        GPI_SYS_IOMUX_U4_SSP_SPI_SSPFSSIN
+#define	GPI_SPI4_SSPRXD                         \
+        GPI_SYS_IOMUX_U4_SSP_SPI_SSPRXD
+#define	GPI_SPI5_SSPCLKIN                       \
+        GPI_SYS_IOMUX_U5_SSP_SPI_SSPCLKIN
+#define	GPI_SPI5_SSPFSSIN                       \
+        GPI_SYS_IOMUX_U5_SSP_SPI_SSPFSSIN
+#define	GPI_SPI5_SSPRXD                         \
+        GPI_SYS_IOMUX_U5_SSP_SPI_SSPRXD
+#define	GPI_SPI6_SSPCLKIN                       \
+        GPI_SYS_IOMUX_U6_SSP_SPI_SSPCLKIN
+#define	GPI_SPI6_SSPFSSIN                       \
+        GPI_SYS_IOMUX_U6_SSP_SPI_SSPFSSIN
+#define	GPI_SPI6_SSPRXD                         \
+        GPI_SYS_IOMUX_U6_SSP_SPI_SSPRXD
+#define	GPI_TDM0_CLK_SLV                        \
+        GPI_SYS_IOMUX_U0_SYS_CRG_TDM_CLK_SLV
+#define	GPI_TDM0_PCM_RXD                        \
+        GPI_SYS_IOMUX_U0_TDM16SLOT_PCM_RXD
+#define	GPI_TDM0_PCM_SYNCIN                     \
+        GPI_SYS_IOMUX_U0_TDM16SLOT_PCM_SYNCIN
+#define	GPI_UART0_SIN                           \
+        GPI_SYS_IOMUX_U0_DW_UART_SIN
+#define	GPI_UART1_CTS_N                         \
+        GPI_SYS_IOMUX_U1_DW_UART_CTS_N
+#define	GPI_UART1_SIN                           \
+        GPI_SYS_IOMUX_U1_DW_UART_SIN
+#define	GPI_UART2_CTS_N                         \
+        GPI_SYS_IOMUX_U2_DW_UART_CTS_N
+#define	GPI_UART2_SIN                           \
+        GPI_SYS_IOMUX_U2_DW_UART_SIN
+#define	GPI_UART3_SIN                           \
+        GPI_SYS_IOMUX_U3_DW_UART_SIN
+#define	GPI_UART4_CTS_N                         \
+        GPI_SYS_IOMUX_U4_DW_UART_CTS_N
+#define	GPI_UART4_SIN                           \
+        GPI_SYS_IOMUX_U4_DW_UART_SIN
+#define	GPI_UART5_CTS_N                         \
+        GPI_SYS_IOMUX_U5_DW_UART_CTS_N
+#define	GPI_UART5_SIN                           \
+        GPI_SYS_IOMUX_U5_DW_UART_SIN
+#define	GPI_USB0_OVERCURRENT_N_IO               \
+        GPI_SYS_IOMUX_U0_CDN_USB_OVERCURRENT_N_IO
+#define	GPI_WAVE511_0_I_UART_RXSIN              \
+        GPI_SYS_IOMUX_U0_WAVE511_I_UART_RXSIN
+#define	GPI_NONE  					GPI_SYS_IOMUX_U6_SSP_SPI_SSPRXD
+
+//sys_iomux syscon
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_588_ADDR               (0x24cU)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_592_ADDR               (0x250U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_596_ADDR               (0x254U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_600_ADDR               (0x258U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_604_ADDR               (0x25cU)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_608_ADDR               (0x260U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_612_ADDR               (0x264U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_616_ADDR               (0x268U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_620_ADDR               (0x26cU)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_624_ADDR               (0x270U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_628_ADDR               (0x274U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_632_ADDR               (0x278U)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_636_ADDR               (0x27cU)
+#define SYS_IOMUX_CFG__SAIF__SYSCFG_640_ADDR               (0x280U)
+
+#define PADCFG_PAD_GMAC1_MDC_SYSCON     SYS_IOMUX_CFG__SAIF__SYSCFG_588_ADDR
+#define PADCFG_PAD_GMAC1_MDIO_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_592_ADDR
+#define PADCFG_PAD_GMAC1_RXD0_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_596_ADDR
+#define PADCFG_PAD_GMAC1_RXD1_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_600_ADDR
+#define PADCFG_PAD_GMAC1_RXD2_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_604_ADDR
+#define PADCFG_PAD_GMAC1_RXD3_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_608_ADDR
+#define PADCFG_PAD_GMAC1_RXDV_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_612_ADDR
+#define PADCFG_PAD_GMAC1_RXC_SYSCON     SYS_IOMUX_CFG__SAIF__SYSCFG_616_ADDR
+#define PADCFG_PAD_GMAC1_TXD0_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_620_ADDR
+#define PADCFG_PAD_GMAC1_TXD1_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_624_ADDR
+#define PADCFG_PAD_GMAC1_TXD2_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_628_ADDR
+#define PADCFG_PAD_GMAC1_TXD3_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_632_ADDR
+#define PADCFG_PAD_GMAC1_TXEN_SYSCON    SYS_IOMUX_CFG__SAIF__SYSCFG_636_ADDR
+#define PADCFG_PAD_GMAC1_TXC_SYSCON     SYS_IOMUX_CFG__SAIF__SYSCFG_640_ADDR
+
+
+//sys_iomux func sel setting
+#define SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                 (0x29cU)
+#define PAD_GMAC1_RXC_FUNC_SEL_WIDTH                       0x2U
+#define PAD_GMAC1_RXC_FUNC_SEL_SHIFT                       0x0U
+#define PAD_GMAC1_RXC_FUNC_SEL_MASK                        0x3U
+#define PAD_GPIO10_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO10_FUNC_SEL_SHIFT                          0x2U
+#define PAD_GPIO10_FUNC_SEL_MASK                           0x1CU
+#define PAD_GPIO11_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO11_FUNC_SEL_SHIFT                          0x5U
+#define PAD_GPIO11_FUNC_SEL_MASK                           0xE0U
+#define PAD_GPIO12_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO12_FUNC_SEL_SHIFT                          0x8U
+#define PAD_GPIO12_FUNC_SEL_MASK                           0x700U
+#define PAD_GPIO13_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO13_FUNC_SEL_SHIFT                          0xBU
+#define PAD_GPIO13_FUNC_SEL_MASK                           0x3800U
+#define PAD_GPIO14_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO14_FUNC_SEL_SHIFT                          0xEU
+#define PAD_GPIO14_FUNC_SEL_MASK                           0x1C000U
+#define PAD_GPIO15_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO15_FUNC_SEL_SHIFT                          0x11U
+#define PAD_GPIO15_FUNC_SEL_MASK                           0xE0000U
+#define PAD_GPIO16_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO16_FUNC_SEL_SHIFT                          0x14U
+#define PAD_GPIO16_FUNC_SEL_MASK                           0x700000U
+#define PAD_GPIO17_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO17_FUNC_SEL_SHIFT                          0x17U
+#define PAD_GPIO17_FUNC_SEL_MASK                           0x3800000U
+#define PAD_GPIO18_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO18_FUNC_SEL_SHIFT                          0x1AU
+#define PAD_GPIO18_FUNC_SEL_MASK                           0x1C000000U
+#define PAD_GPIO19_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO19_FUNC_SEL_SHIFT                          0x1DU
+#define PAD_GPIO19_FUNC_SEL_MASK                           0xE0000000U
+#define SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                 (0x2a0U)
+#define PAD_GPIO20_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO20_FUNC_SEL_SHIFT                          0x0U
+#define PAD_GPIO20_FUNC_SEL_MASK                           0x7U
+#define PAD_GPIO21_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO21_FUNC_SEL_SHIFT                          0x3U
+#define PAD_GPIO21_FUNC_SEL_MASK                           0x38U
+#define PAD_GPIO22_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO22_FUNC_SEL_SHIFT                          0x6U
+#define PAD_GPIO22_FUNC_SEL_MASK                           0x1C0U
+#define PAD_GPIO23_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO23_FUNC_SEL_SHIFT                          0x9U
+#define PAD_GPIO23_FUNC_SEL_MASK                           0xE00U
+#define PAD_GPIO24_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO24_FUNC_SEL_SHIFT                          0xCU
+#define PAD_GPIO24_FUNC_SEL_MASK                           0x7000U
+#define PAD_GPIO25_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO25_FUNC_SEL_SHIFT                          0xFU
+#define PAD_GPIO25_FUNC_SEL_MASK                           0x38000U
+#define PAD_GPIO26_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO26_FUNC_SEL_SHIFT                          0x12U
+#define PAD_GPIO26_FUNC_SEL_MASK                           0x1C0000U
+#define PAD_GPIO27_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO27_FUNC_SEL_SHIFT                          0x15U
+#define PAD_GPIO27_FUNC_SEL_MASK                           0xE00000U
+#define PAD_GPIO28_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO28_FUNC_SEL_SHIFT                          0x18U
+#define PAD_GPIO28_FUNC_SEL_MASK                           0x7000000U
+#define PAD_GPIO29_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO29_FUNC_SEL_SHIFT                          0x1BU
+#define PAD_GPIO29_FUNC_SEL_MASK                           0x38000000U
+#define SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                 (0x2a4U)
+#define PAD_GPIO30_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO30_FUNC_SEL_SHIFT                          0x0U
+#define PAD_GPIO30_FUNC_SEL_MASK                           0x7U
+#define PAD_GPIO31_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO31_FUNC_SEL_SHIFT                          0x3U
+#define PAD_GPIO31_FUNC_SEL_MASK                           0x38U
+#define PAD_GPIO32_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO32_FUNC_SEL_SHIFT                          0x6U
+#define PAD_GPIO32_FUNC_SEL_MASK                           0x1C0U
+#define PAD_GPIO33_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO33_FUNC_SEL_SHIFT                          0x9U
+#define PAD_GPIO33_FUNC_SEL_MASK                           0xE00U
+#define PAD_GPIO34_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO34_FUNC_SEL_SHIFT                          0xCU
+#define PAD_GPIO34_FUNC_SEL_MASK                           0x7000U
+#define PAD_GPIO35_FUNC_SEL_WIDTH                          0x2U
+#define PAD_GPIO35_FUNC_SEL_SHIFT                          0xFU
+#define PAD_GPIO35_FUNC_SEL_MASK                           0x18000U
+#define PAD_GPIO36_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO36_FUNC_SEL_SHIFT                          0x11U
+#define PAD_GPIO36_FUNC_SEL_MASK                           0xE0000U
+#define PAD_GPIO37_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO37_FUNC_SEL_SHIFT                          0x14U
+#define PAD_GPIO37_FUNC_SEL_MASK                           0x700000U
+#define PAD_GPIO38_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO38_FUNC_SEL_SHIFT                          0x17U
+#define PAD_GPIO38_FUNC_SEL_MASK                           0x3800000U
+#define PAD_GPIO39_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO39_FUNC_SEL_SHIFT                          0x1AU
+#define PAD_GPIO39_FUNC_SEL_MASK                           0x1C000000U
+#define PAD_GPIO40_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO40_FUNC_SEL_SHIFT                          0x1DU
+#define PAD_GPIO40_FUNC_SEL_MASK                           0xE0000000U
+#define SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                 (0x2a8U)
+#define PAD_GPIO41_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO41_FUNC_SEL_SHIFT                          0x0U
+#define PAD_GPIO41_FUNC_SEL_MASK                           0x7U
+#define PAD_GPIO42_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO42_FUNC_SEL_SHIFT                          0x3U
+#define PAD_GPIO42_FUNC_SEL_MASK                           0x38U
+#define PAD_GPIO43_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO43_FUNC_SEL_SHIFT                          0x6U
+#define PAD_GPIO43_FUNC_SEL_MASK                           0x1C0U
+#define PAD_GPIO44_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO44_FUNC_SEL_SHIFT                          0x9U
+#define PAD_GPIO44_FUNC_SEL_MASK                           0xE00U
+#define PAD_GPIO45_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO45_FUNC_SEL_SHIFT                          0xCU
+#define PAD_GPIO45_FUNC_SEL_MASK                           0x7000U
+#define PAD_GPIO46_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO46_FUNC_SEL_SHIFT                          0xFU
+#define PAD_GPIO46_FUNC_SEL_MASK                           0x38000U
+#define PAD_GPIO47_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO47_FUNC_SEL_SHIFT                          0x12U
+#define PAD_GPIO47_FUNC_SEL_MASK                           0x1C0000U
+#define PAD_GPIO48_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO48_FUNC_SEL_SHIFT                          0x15U
+#define PAD_GPIO48_FUNC_SEL_MASK                           0xE00000U
+#define PAD_GPIO49_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO49_FUNC_SEL_SHIFT                          0x18U
+#define PAD_GPIO49_FUNC_SEL_MASK                           0x7000000U
+#define PAD_GPIO50_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO50_FUNC_SEL_SHIFT                          0x1BU
+#define PAD_GPIO50_FUNC_SEL_MASK                           0x38000000U
+#define PAD_GPIO51_FUNC_SEL_WIDTH                          0x2U
+#define PAD_GPIO51_FUNC_SEL_SHIFT                          0x1EU
+#define PAD_GPIO51_FUNC_SEL_MASK                           0xC0000000U
+#define SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                 (0x2acU)
+#define PAD_GPIO52_FUNC_SEL_WIDTH                          0x2U
+#define PAD_GPIO52_FUNC_SEL_SHIFT                          0x0U
+#define PAD_GPIO52_FUNC_SEL_MASK                           0x3U
+#define PAD_GPIO53_FUNC_SEL_WIDTH                          0x2U
+#define PAD_GPIO53_FUNC_SEL_SHIFT                          0x2U
+#define PAD_GPIO53_FUNC_SEL_MASK                           0xCU
+#define PAD_GPIO54_FUNC_SEL_WIDTH                          0x2U
+#define PAD_GPIO54_FUNC_SEL_SHIFT                          0x4U
+#define PAD_GPIO54_FUNC_SEL_MASK                           0x30U
+#define PAD_GPIO55_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO55_FUNC_SEL_SHIFT                          0x6U
+#define PAD_GPIO55_FUNC_SEL_MASK                           0x1C0U
+#define PAD_GPIO56_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO56_FUNC_SEL_SHIFT                          0x9U
+#define PAD_GPIO56_FUNC_SEL_MASK                           0xE00U
+#define PAD_GPIO57_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO57_FUNC_SEL_SHIFT                          0xCU
+#define PAD_GPIO57_FUNC_SEL_MASK                           0x7000U
+#define PAD_GPIO58_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO58_FUNC_SEL_SHIFT                          0xFU
+#define PAD_GPIO58_FUNC_SEL_MASK                           0x38000U
+#define PAD_GPIO59_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO59_FUNC_SEL_SHIFT                          0x12U
+#define PAD_GPIO59_FUNC_SEL_MASK                           0x1C0000U
+#define PAD_GPIO60_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO60_FUNC_SEL_SHIFT                          0x15U
+#define PAD_GPIO60_FUNC_SEL_MASK                           0xE00000U
+#define PAD_GPIO61_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO61_FUNC_SEL_SHIFT                          0x18U
+#define PAD_GPIO61_FUNC_SEL_MASK                           0x7000000U
+#define PAD_GPIO62_FUNC_SEL_WIDTH                          0x3U
+#define PAD_GPIO62_FUNC_SEL_SHIFT                          0x1BU
+#define PAD_GPIO62_FUNC_SEL_MASK                           0x38000000U
+#define PAD_GPIO63_FUNC_SEL_WIDTH                          0x2U
+#define PAD_GPIO63_FUNC_SEL_SHIFT                          0x1EU
+#define PAD_GPIO63_FUNC_SEL_MASK                           0xC0000000U
+#define SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                 (0x2b0U)
+#define PAD_GPIO6_FUNC_SEL_WIDTH                           0x2U
+#define PAD_GPIO6_FUNC_SEL_SHIFT                           0x0U
+#define PAD_GPIO6_FUNC_SEL_MASK                            0x3U
+#define PAD_GPIO7_FUNC_SEL_WIDTH                           0x3U
+#define PAD_GPIO7_FUNC_SEL_SHIFT                           0x2U
+#define PAD_GPIO7_FUNC_SEL_MASK                            0x1CU
+#define PAD_GPIO8_FUNC_SEL_WIDTH                           0x3U
+#define PAD_GPIO8_FUNC_SEL_SHIFT                           0x5U
+#define PAD_GPIO8_FUNC_SEL_MASK                            0xE0U
+#define PAD_GPIO9_FUNC_SEL_WIDTH                           0x3U
+#define PAD_GPIO9_FUNC_SEL_SHIFT                           0x8U
+#define PAD_GPIO9_FUNC_SEL_MASK                            0x700U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C0_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C0_FUNC_SEL_SHIFT   0xBU
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C0_FUNC_SEL_MASK    0x3800U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C10_FUNC_SEL_WIDTH  0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C10_FUNC_SEL_SHIFT  0xEU
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C10_FUNC_SEL_MASK   0x1C000U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C11_FUNC_SEL_WIDTH  0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C11_FUNC_SEL_SHIFT  0x11U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C11_FUNC_SEL_MASK   0xE0000U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C1_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C1_FUNC_SEL_SHIFT   0x14U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C1_FUNC_SEL_MASK    0x700000U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C2_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C2_FUNC_SEL_SHIFT   0x17U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C2_FUNC_SEL_MASK    0x3800000U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C3_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C3_FUNC_SEL_SHIFT   0x1AU
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C3_FUNC_SEL_MASK    0x1C000000U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C4_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C4_FUNC_SEL_SHIFT   0x1DU
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C4_FUNC_SEL_MASK    0xE0000000U
+#define SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                 (0x2b4U)
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C5_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C5_FUNC_SEL_SHIFT   0x0U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C5_FUNC_SEL_MASK    0x7U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C6_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C6_FUNC_SEL_SHIFT   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C6_FUNC_SEL_MASK    0x38U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C7_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C7_FUNC_SEL_SHIFT   0x6U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C7_FUNC_SEL_MASK    0x1C0U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C8_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C8_FUNC_SEL_SHIFT   0x9U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C8_FUNC_SEL_MASK    0xE00U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C9_FUNC_SEL_WIDTH   0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C9_FUNC_SEL_SHIFT   0xCU
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C9_FUNC_SEL_MASK    0x7000U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_HVALID_C_FUNC_SEL_WIDTH  0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_HVALID_C_FUNC_SEL_SHIFT  0xFU
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_HVALID_C_FUNC_SEL_MASK   0x38000U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_VVALID_C_FUNC_SEL_WIDTH  0x3U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_VVALID_C_FUNC_SEL_SHIFT  0x12U
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_VVALID_C_FUNC_SEL_MASK   0x1C0000U
+#define U0_SYS_CRG_DVP_CLK_FUNC_SEL_WIDTH                  0x3U
+#define U0_SYS_CRG_DVP_CLK_FUNC_SEL_SHIFT                  0x15U
+#define U0_SYS_CRG_DVP_CLK_FUNC_SEL_MASK                   0xE00000U
+
+#define PAD_GMAC1_RXC_FUNC_SEL                              \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GMAC1_RXC_FUNC_SEL_SHIFT                        \
+        PAD_GMAC1_RXC_FUNC_SEL_MASK
+#define PAD_GPIO10_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO10_FUNC_SEL_SHIFT                           \
+        PAD_GPIO10_FUNC_SEL_MASK
+#define PAD_GPIO11_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO11_FUNC_SEL_SHIFT                           \
+        PAD_GPIO11_FUNC_SEL_MASK
+#define PAD_GPIO12_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO12_FUNC_SEL_SHIFT                           \
+        PAD_GPIO12_FUNC_SEL_MASK
+#define PAD_GPIO13_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO13_FUNC_SEL_SHIFT                           \
+        PAD_GPIO13_FUNC_SEL_MASK
+#define PAD_GPIO14_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO14_FUNC_SEL_SHIFT                           \
+        PAD_GPIO14_FUNC_SEL_MASK
+#define PAD_GPIO15_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO15_FUNC_SEL_SHIFT                           \
+        PAD_GPIO15_FUNC_SEL_MASK
+#define PAD_GPIO16_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO16_FUNC_SEL_SHIFT                           \
+        PAD_GPIO16_FUNC_SEL_MASK
+#define PAD_GPIO17_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO17_FUNC_SEL_SHIFT                           \
+        PAD_GPIO17_FUNC_SEL_MASK
+#define PAD_GPIO18_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO18_FUNC_SEL_SHIFT                           \
+        PAD_GPIO18_FUNC_SEL_MASK
+#define PAD_GPIO19_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_668_ADDR                  \
+        PAD_GPIO19_FUNC_SEL_SHIFT                           \
+        PAD_GPIO19_FUNC_SEL_MASK
+#define PAD_GPIO20_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO20_FUNC_SEL_SHIFT                           \
+        PAD_GPIO20_FUNC_SEL_MASK
+#define PAD_GPIO21_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO21_FUNC_SEL_SHIFT                           \
+        PAD_GPIO21_FUNC_SEL_MASK
+#define PAD_GPIO22_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO22_FUNC_SEL_SHIFT                           \
+        PAD_GPIO22_FUNC_SEL_MASK
+#define PAD_GPIO23_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO23_FUNC_SEL_SHIFT                           \
+        PAD_GPIO23_FUNC_SEL_MASK
+#define PAD_GPIO24_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO24_FUNC_SEL_SHIFT                           \
+        PAD_GPIO24_FUNC_SEL_MASK
+#define PAD_GPIO25_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO25_FUNC_SEL_SHIFT                           \
+        PAD_GPIO25_FUNC_SEL_MASK
+#define PAD_GPIO26_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO26_FUNC_SEL_SHIFT                           \
+        PAD_GPIO26_FUNC_SEL_MASK
+#define PAD_GPIO27_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO27_FUNC_SEL_SHIFT                           \
+        PAD_GPIO27_FUNC_SEL_MASK
+#define PAD_GPIO28_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO28_FUNC_SEL_SHIFT                           \
+        PAD_GPIO28_FUNC_SEL_MASK
+#define PAD_GPIO29_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_672_ADDR                  \
+        PAD_GPIO29_FUNC_SEL_SHIFT                           \
+        PAD_GPIO29_FUNC_SEL_MASK
+#define PAD_GPIO30_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO30_FUNC_SEL_SHIFT                           \
+        PAD_GPIO30_FUNC_SEL_MASK
+#define PAD_GPIO31_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO31_FUNC_SEL_SHIFT                           \
+        PAD_GPIO31_FUNC_SEL_MASK
+#define PAD_GPIO32_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO32_FUNC_SEL_SHIFT                           \
+        PAD_GPIO32_FUNC_SEL_MASK
+#define PAD_GPIO33_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO33_FUNC_SEL_SHIFT                           \
+        PAD_GPIO33_FUNC_SEL_MASK
+#define PAD_GPIO34_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO34_FUNC_SEL_SHIFT                           \
+        PAD_GPIO34_FUNC_SEL_MASK
+#define PAD_GPIO35_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO35_FUNC_SEL_SHIFT                           \
+        PAD_GPIO35_FUNC_SEL_MASK
+#define PAD_GPIO36_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO36_FUNC_SEL_SHIFT                           \
+        PAD_GPIO36_FUNC_SEL_MASK
+#define PAD_GPIO37_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO37_FUNC_SEL_SHIFT                           \
+        PAD_GPIO37_FUNC_SEL_MASK
+#define PAD_GPIO38_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO38_FUNC_SEL_SHIFT                           \
+        PAD_GPIO38_FUNC_SEL_MASK
+#define PAD_GPIO39_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO39_FUNC_SEL_SHIFT                           \
+        PAD_GPIO39_FUNC_SEL_MASK
+#define PAD_GPIO40_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_676_ADDR                  \
+        PAD_GPIO40_FUNC_SEL_SHIFT                           \
+        PAD_GPIO40_FUNC_SEL_MASK
+#define PAD_GPIO41_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO41_FUNC_SEL_SHIFT                           \
+        PAD_GPIO41_FUNC_SEL_MASK
+#define PAD_GPIO42_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO42_FUNC_SEL_SHIFT                           \
+        PAD_GPIO42_FUNC_SEL_MASK
+#define PAD_GPIO43_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO43_FUNC_SEL_SHIFT                           \
+        PAD_GPIO43_FUNC_SEL_MASK
+#define PAD_GPIO44_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO44_FUNC_SEL_SHIFT                           \
+        PAD_GPIO44_FUNC_SEL_MASK
+#define PAD_GPIO45_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO45_FUNC_SEL_SHIFT                           \
+        PAD_GPIO45_FUNC_SEL_MASK
+#define PAD_GPIO46_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO46_FUNC_SEL_SHIFT                           \
+        PAD_GPIO46_FUNC_SEL_MASK
+#define PAD_GPIO47_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO47_FUNC_SEL_SHIFT                           \
+        PAD_GPIO47_FUNC_SEL_MASK
+#define PAD_GPIO48_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO48_FUNC_SEL_SHIFT                           \
+        PAD_GPIO48_FUNC_SEL_MASK
+#define PAD_GPIO49_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO49_FUNC_SEL_SHIFT                           \
+        PAD_GPIO49_FUNC_SEL_MASK
+#define PAD_GPIO50_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO50_FUNC_SEL_SHIFT                           \
+        PAD_GPIO50_FUNC_SEL_MASK
+#define PAD_GPIO51_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_680_ADDR                  \
+        PAD_GPIO51_FUNC_SEL_SHIFT                           \
+        PAD_GPIO51_FUNC_SEL_MASK
+#define PAD_GPIO52_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO52_FUNC_SEL_SHIFT                           \
+        PAD_GPIO52_FUNC_SEL_MASK
+#define PAD_GPIO53_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO53_FUNC_SEL_SHIFT                           \
+        PAD_GPIO53_FUNC_SEL_MASK
+#define PAD_GPIO54_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO54_FUNC_SEL_SHIFT                           \
+        PAD_GPIO54_FUNC_SEL_MASK
+#define PAD_GPIO55_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO55_FUNC_SEL_SHIFT                           \
+        PAD_GPIO55_FUNC_SEL_MASK
+#define PAD_GPIO56_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO56_FUNC_SEL_SHIFT                           \
+        PAD_GPIO56_FUNC_SEL_MASK
+#define PAD_GPIO57_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO57_FUNC_SEL_SHIFT                           \
+        PAD_GPIO57_FUNC_SEL_MASK
+#define PAD_GPIO58_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO58_FUNC_SEL_SHIFT                           \
+        PAD_GPIO58_FUNC_SEL_MASK
+#define PAD_GPIO59_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO59_FUNC_SEL_SHIFT                           \
+        PAD_GPIO59_FUNC_SEL_MASK
+#define PAD_GPIO60_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO60_FUNC_SEL_SHIFT                           \
+        PAD_GPIO60_FUNC_SEL_MASK
+#define PAD_GPIO61_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO61_FUNC_SEL_SHIFT                           \
+        PAD_GPIO61_FUNC_SEL_MASK
+#define PAD_GPIO62_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO62_FUNC_SEL_SHIFT                           \
+        PAD_GPIO62_FUNC_SEL_MASK
+#define PAD_GPIO63_FUNC_SEL                                 \
+        SYS_IOMUX_CFGSAIF__SYSCFG_684_ADDR                  \
+        PAD_GPIO63_FUNC_SEL_SHIFT                           \
+        PAD_GPIO63_FUNC_SEL_MASK
+#define PAD_GPIO6_FUNC_SEL                                  \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        PAD_GPIO6_FUNC_SEL_SHIFT                            \
+        PAD_GPIO6_FUNC_SEL_MASK
+#define PAD_GPIO7_FUNC_SEL                                  \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        PAD_GPIO7_FUNC_SEL_SHIFT                            \
+        PAD_GPIO7_FUNC_SEL_MASK
+#define PAD_GPIO8_FUNC_SEL                                  \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        PAD_GPIO8_FUNC_SEL_SHIFT                            \
+        PAD_GPIO8_FUNC_SEL_MASK
+#define PAD_GPIO9_FUNC_SEL                                  \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        PAD_GPIO9_FUNC_SEL_SHIFT                            \
+        PAD_GPIO9_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C0_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C0_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C0_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C10_FUNC_SEL         \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C10_FUNC_SEL_SHIFT   \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C10_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C11_FUNC_SEL         \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C11_FUNC_SEL_SHIFT   \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C11_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C1_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C1_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C1_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C2_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C2_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C2_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C3_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C3_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C3_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C4_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_688_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C4_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C4_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C5_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C5_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C5_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C6_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C6_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C6_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C7_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C7_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C7_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C8_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C8_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C8_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C9_FUNC_SEL          \
+        SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C9_FUNC_SEL_SHIFT    \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_DATA_C9_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_HVALID_C_FUNC_SEL         \
+        SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_HVALID_C_FUNC_SEL_SHIFT   \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_HVALID_C_FUNC_SEL_MASK
+#define U0_DOM_ISP_TOP_U0_VIN_DVP_VVALID_C_FUNC_SEL         \
+        SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                  \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_VVALID_C_FUNC_SEL_SHIFT   \
+        U0_DOM_ISP_TOP_U0_VIN_DVP_VVALID_C_FUNC_SEL_MASK
+#define U0_SYS_CRG_DVP_CLK_FUNC_SEL                         \
+        SYS_IOMUX_CFGSAIF__SYSCFG_692_ADDR                  \
+        U0_SYS_CRG_DVP_CLK_FUNC_SEL_SHIFT                   \
+        U0_SYS_CRG_DVP_CLK_FUNC_SEL_MASK
+/************************sys_iomux***************************/
+//aon ioconfig
+
+// POS[0]
+#define TESTEN_POS(data)        ((data << 0x0U) & 0x1U)
+
+// SMT[0] POS[1]
+#define RSTN_SMT(data)          ((data << 0x0U) & 0x1U)
+#define RSTN_POS(data)          ((data << 0x1U) & 0x2U)
+
+// DS[1:0]
+#define OSC_DS(data)            ((data << 0x0U) & 0x3U)
+
+//sys ioconfig
+// IE[0] DS[2:1] PU[3] PD[4] SLEW[5] SMT[6] POS[7]
+#define GPIO_IE(data)           ((data << 0x0U) & 0x1U)
+#define GPIO_DS(data)           ((data << 0x1U) & 0x6U)
+#define GPIO_PU(data)           ((data << 0x3U) & 0x8U)
+#define GPIO_PD(data)           ((data << 0x4U) & 0x10U)
+#define GPIO_SLEW(data)         ((data << 0x5U) & 0x20U)
+#define GPIO_SMT(data)          ((data << 0x6U) & 0x40U)
+#define GPIO_POS(data)          ((data << 0x7U) & 0x80U)
+
+#define IO(config)              ((config) & 0xFF)
+#define DOUT(dout)              ((dout) & 0xFF)
+#define DOEN(doen)              ((doen) & 0xFF)
+#define DIN(din_reg)            ((din_reg) & 0xFF)
+
+//syscon value
+#define IO_3_3V                 0 /*00:3.3v*/
+#define IO_2_5V                 1 /*01:2.5v*/
+#define IO_1_8V                 2 /*10:1.8v*/
+
+#endif
diff --git a/include/dt-bindings/power/jh7110-power.h b/include/dt-bindings/power/jh7110-power.h
new file mode 100755
index 000000000000..97528f5c4b5b
--- /dev/null
+++ b/include/dt-bindings/power/jh7110-power.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: (GPL-2.0) */
+/*
+ * Copyright (c) 2022 Starfive, Inc.
+ * Author: Walker Chen <walker.chen@starfivetech.com>
+ */
+#ifndef __DT_BINDINGS_POWER_JH7110_POWER_H__
+#define __DT_BINDINGS_POWER_JH7110_POWER_H__
+
+#define JH7110_PD_SYSTOP	0
+#define JH7110_PD_CPU		1
+#define JH7110_PD_GPUA		2
+#define JH7110_PD_VDEC		3
+#define JH7110_PD_VOUT		4
+#define JH7110_PD_ISP		5
+#define JH7110_PD_VENC		6
+#define JH7110_PD_GPUB		7
+
+#endif
diff --git a/include/dt-bindings/reset/starfive-jh7110.h b/include/dt-bindings/reset/starfive-jh7110.h
new file mode 100644
index 000000000000..538070f4e6e8
--- /dev/null
+++ b/include/dt-bindings/reset/starfive-jh7110.h
@@ -0,0 +1,217 @@
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
+/*
+ *  Copyright (C) 2021 samin <samin.guo@starfivetech.com>
+ */
+
+#ifndef __DT_BINDINGS_RESET_STARFIVE_JH7110_H__
+#define __DT_BINDINGS_RESET_STARFIVE_JH7110_H__
+
+/*
+ * group[0]: syscrg: assert0
+ */
+#define RSTN_U0_JTAG2APB_PRESETN	0
+#define	RSTN_U0_SYS_SYSCON_PRESETN	1
+#define	RSTN_U0_SYS_IOMUX_PRESETN	2
+#define	RSTN_U0_U7MC_RST_BUS		3
+#define	RSTN_U0_U7MC_DEBUG		4
+#define	RSTN_U0_U7MC_CORE0		5
+#define	RSTN_U0_U7MC_CORE1		6
+#define	RSTN_U0_U7MC_CORE2		7
+#define	RSTN_U0_U7MC_CORE3		8
+#define	RSTN_U0_U7MC_CORE4		9
+#define	RSTN_U0_U7MC_CORE0_ST		10
+#define	RSTN_U0_U7MC_CORE1_ST		11
+#define	RSTN_U0_U7MC_CORE2_ST		12
+#define	RSTN_U0_U7MC_CORE3_ST		13
+#define	RSTN_U0_U7MC_CORE4_ST		14
+#define	RSTN_U0_U7MC_TRACE_RST0		15
+#define	RSTN_U0_U7MC_TRACE_RST1		16
+#define	RSTN_U0_U7MC_TRACE_RST2		17
+#define	RSTN_U0_U7MC_TRACE_RST3		18
+#define	RSTN_U0_U7MC_TRACE_RST4		19
+#define	RSTN_U0_U7MC_TRACE_COM		20
+#define	RSTN_U0_IMG_GPU_APB		21
+#define	RSTN_U0_IMG_GPU_DOMA		22
+#define	RSTN_U0_NOC_BUS_APB_BUS_N	23
+#define	RSTN_U0_NOC_BUS_AXICFG0_AXI_N	24
+#define	RSTN_U0_NOC_BUS_CPU_AXI_N	25
+#define	RSTN_U0_NOC_BUS_DISP_AXI_N	26
+#define	RSTN_U0_NOC_BUS_GPU_AXI_N	27
+#define	RSTN_U0_NOC_BUS_ISP_AXI_N	28
+#define	RSTN_U0_NOC_BUS_DDRC_N		29
+#define	RSTN_U0_NOC_BUS_STG_AXI_N	30
+#define	RSTN_U0_NOC_BUS_VDEC_AXI_N	31
+/*
+ * group[1]: syscrg: assert1
+ */
+#define	RSTN_U0_NOC_BUS_VENC_AXI_N	32
+#define	RSTN_U0_AXI_CFG1_DEC_AHB	33
+#define	RSTN_U0_AXI_CFG1_DEC_MAIN	34
+#define	RSTN_U0_AXI_CFG0_DEC_MAIN	35
+#define	RSTN_U0_AXI_CFG0_DEC_MAIN_DIV	36
+#define	RSTN_U0_AXI_CFG0_DEC_HIFI4	37
+#define	RSTN_U0_DDR_AXI			38
+#define	RSTN_U0_DDR_OSC			39
+#define	RSTN_U0_DDR_APB			40
+#define	RSTN_U0_DOM_ISP_TOP_N		41
+#define	RSTN_U0_DOM_ISP_TOP_AXI		42
+#define	RSTN_U0_DOM_VOUT_TOP_SRC	43
+#define	RSTN_U0_CODAJ12_AXI		44
+#define	RSTN_U0_CODAJ12_CORE		45
+#define	RSTN_U0_CODAJ12_APB		46
+#define	RSTN_U0_WAVE511_AXI		47
+#define	RSTN_U0_WAVE511_BPU		48
+#define	RSTN_U0_WAVE511_VCE		49
+#define	RSTN_U0_WAVE511_APB		50
+#define	RSTN_U0_VDEC_JPG_ARB_JPG	51
+#define	RSTN_U0_VDEC_JPG_ARB_MAIN	52
+#define	RSTN_U0_AXIMEM_128B_AXI		53
+#define	RSTN_U0_WAVE420L_AXI		54
+#define	RSTN_U0_WAVE420L_BPU		55
+#define	RSTN_U0_WAVE420L_VCE		56
+#define	RSTN_U0_WAVE420L_APB		57
+#define	RSTN_U1_AXIMEM_128B_AXI		58
+#define	RSTN_U2_AXIMEM_128B_AXI		59
+#define	RSTN_U0_INTMEM_ROM_SRAM_ROM	60
+#define	RSTN_U0_CDNS_QSPI_AHB		61
+#define	RSTN_U0_CDNS_QSPI_APB		62
+#define	RSTN_U0_CDNS_QSPI_REF		63
+/*
+ * group[2]: syscrg: assert2
+ */
+#define	RSTN_U0_DW_SDIO_AHB		64
+#define	RSTN_U1_DW_SDIO_AHB		65
+#define	RSTN_U1_DW_GMAC5_AXI64_A_I	66
+#define	RSTN_U1_DW_GMAC5_AXI64_H_N	67
+#define	RSTN_U0_MAILBOX_RRESETN		68
+#define	RSTN_U0_SSP_SPI_APB		69
+#define	RSTN_U1_SSP_SPI_APB		70
+#define	RSTN_U2_SSP_SPI_APB		71
+#define	RSTN_U3_SSP_SPI_APB		72
+#define	RSTN_U4_SSP_SPI_APB		73
+#define	RSTN_U5_SSP_SPI_APB		74
+#define	RSTN_U6_SSP_SPI_APB		75
+#define	RSTN_U0_DW_I2C_APB		76
+#define	RSTN_U1_DW_I2C_APB		77
+#define	RSTN_U2_DW_I2C_APB		78
+#define	RSTN_U3_DW_I2C_APB		79
+#define	RSTN_U4_DW_I2C_APB		80
+#define	RSTN_U5_DW_I2C_APB		81
+#define	RSTN_U6_DW_I2C_APB		82
+#define	RSTN_U0_DW_UART_APB		83
+#define	RSTN_U0_DW_UART_CORE		84
+#define	RSTN_U1_DW_UART_APB		85
+#define	RSTN_U1_DW_UART_CORE		86
+#define	RSTN_U2_DW_UART_APB		87
+#define	RSTN_U2_DW_UART_CORE		88
+#define	RSTN_U3_DW_UART_APB		89
+#define	RSTN_U3_DW_UART_CORE		90
+#define	RSTN_U4_DW_UART_APB		91
+#define	RSTN_U4_DW_UART_CORE		92
+#define	RSTN_U5_DW_UART_APB		93
+#define	RSTN_U5_DW_UART_CORE		94
+#define	RSTN_U0_CDNS_SPDIF_APB		95
+/*
+ * group[3]: syscrg: assert3
+ */
+#define	RSTN_U0_PWMDAC_APB		96
+#define	RSTN_U0_PDM_4MIC_DMIC		97
+#define	RSTN_U0_PDM_4MIC_APB		98
+#define	RSTN_U0_I2SRX_3CH_APB		99
+#define	RSTN_U0_I2SRX_3CH_BCLK		100
+#define	RSTN_U0_I2STX_4CH_APB		101
+#define	RSTN_U0_I2STX_4CH_BCLK		102
+#define	RSTN_U1_I2STX_4CH_APB		103
+#define	RSTN_U1_I2STX_4CH_BCLK		104
+#define	RSTN_U0_TDM16SLOT_AHB		105
+#define	RSTN_U0_TDM16SLOT_TDM		106
+#define	RSTN_U0_TDM16SLOT_APB		107
+#define	RSTN_U0_PWM_8CH_APB		108
+#define	RSTN_U0_DSKIT_WDT_APB		109
+#define	RSTN_U0_DSKIT_WDT_CORE		110
+#define	RSTN_U0_CAN_CTRL_APB		111
+#define	RSTN_U0_CAN_CTRL_CORE		112
+#define	RSTN_U0_CAN_CTRL_TIMER		113
+#define	RSTN_U1_CAN_CTRL_APB		114
+#define	RSTN_U1_CAN_CTRL_CORE		115
+#define	RSTN_U1_CAN_CTRL_TIMER		116
+#define	RSTN_U0_TIMER_APB		117
+#define	RSTN_U0_TIMER_TIMER0		118
+#define	RSTN_U0_TIMER_TIMER1		119
+#define	RSTN_U0_TIMER_TIMER2		120
+#define	RSTN_U0_TIMER_TIMER3		121
+#define	RSTN_U0_INT_CTRL_APB		122
+#define	RSTN_U0_TEMP_SENSOR_APB		123
+#define	RSTN_U0_TEMP_SENSOR_TEMP	124
+#define	RSTN_U0_JTAG_CERTIFICATION_N	125
+/*
+ * group[4]: stgcrg
+ */
+#define	RSTN_U0_STG_SYSCON_PRESETN	128
+#define	RSTN_U0_HIFI4_CORE		129
+#define	RSTN_U0_HIFI4_AXI		130
+#define	RSTN_U0_SEC_TOP_HRESETN		131
+#define	RSTN_U0_E24_CORE		132
+#define	RSTN_U0_DW_DMA1P_AXI		133
+#define	RSTN_U0_DW_DMA1P_AHB		134
+#define	RSTN_U0_CDN_USB_AXI		135
+#define	RSTN_U0_CDN_USB_APB		136
+#define	RSTN_U0_CDN_USB_UTMI_APB	137
+#define	RSTN_U0_CDN_USB_PWRUP		138
+#define	RSTN_U0_PLDA_PCIE_AXI_MST0	139
+#define	RSTN_U0_PLDA_PCIE_AXI_SLV0	140
+#define	RSTN_U0_PLDA_PCIE_AXI_SLV	141
+#define	RSTN_U0_PLDA_PCIE_BRG		142
+#define	RSTN_U0_PLDA_PCIE_CORE		143
+#define	RSTN_U0_PLDA_PCIE_APB		144
+#define	RSTN_U1_PLDA_PCIE_AXI_MST0	145
+#define	RSTN_U1_PLDA_PCIE_AXI_SLV0	146
+#define	RSTN_U1_PLDA_PCIE_AXI_SLV	147
+#define	RSTN_U1_PLDA_PCIE_BRG		148
+#define	RSTN_U1_PLDA_PCIE_CORE		149
+#define	RSTN_U1_PLDA_PCIE_APB		150
+/*
+ * group[5]: aoncrg
+ */
+#define	RSTN_U0_DW_GMAC5_AXI64_AXI	160
+#define	RSTN_U0_DW_GMAC5_AXI64_AHB	161
+#define	RSTN_U0_AON_IOMUX_PRESETN	162
+#define	RSTN_U0_PMU_APB			163
+#define	RSTN_U0_PMU_WKUP		164
+#define	RSTN_U0_RTC_HMS_APB		165
+#define	RSTN_U0_RTC_HMS_CAL		166
+#define	RSTN_U0_RTC_HMS_OSC32K		167
+/*
+ * group[6]: ispcrg
+ */
+#define	RSTN_U0_ISPV2_TOP_WRAPPER_P	192
+#define	RSTN_U0_ISPV2_TOP_WRAPPER_C	193
+#define	RSTN_U0_M31DPHY_HW		194
+#define	RSTN_U0_M31DPHY_B09_ALWAYS_ON	195
+#define	RSTN_U0_VIN_N_PCLK		196
+#define	RSTN_U0_VIN_N_PIXEL_CLK_IF0	197
+#define	RSTN_U0_VIN_N_PIXEL_CLK_IF1	198
+#define	RSTN_U0_VIN_N_PIXEL_CLK_IF2	199
+#define	RSTN_U0_VIN_N_PIXEL_CLK_IF3	200
+#define	RSTN_U0_VIN_N_SYS_CLK		201
+#define	RSTN_U0_VIN_P_AXIRD		202
+#define	RSTN_U0_VIN_P_AXIWR		203
+/*
+ * group[7]: voutcrg
+ */
+#define	RSTN_U0_DC8200_AXI		224
+#define	RSTN_U0_DC8200_AHB		225
+#define	RSTN_U0_DC8200_CORE		226
+#define	RSTN_U0_CDNS_DSITX_DPI		227
+#define	RSTN_U0_CDNS_DSITX_APB		228
+#define	RSTN_U0_CDNS_DSITX_RXESC	229
+#define	RSTN_U0_CDNS_DSITX_SYS		230
+#define	RSTN_U0_CDNS_DSITX_TXBYTEHS	231
+#define	RSTN_U0_CDNS_DSITX_TXESC	232
+#define	RSTN_U0_HDMI_TX_HDMI		233
+#define	RSTN_U0_MIPITX_DPHY_SYS		234
+#define	RSTN_U0_MIPITX_DPHY_TXBYTEHS	235
+
+#define	RSTN_JH7110_RESET_END		236
+
+#endif /* __DT_BINDINGS_RESET_STARFIVE_JH7110_H__ */
diff --git a/include/linux/amba/bus.h b/include/linux/amba/bus.h
index 6cc93ab5b809..0bbfd647f5c6 100644
--- a/include/linux/amba/bus.h
+++ b/include/linux/amba/bus.h
@@ -76,7 +76,7 @@ struct amba_device {
 struct amba_driver {
 	struct device_driver	drv;
 	int			(*probe)(struct amba_device *, const struct amba_id *);
-	void			(*remove)(struct amba_device *);
+	int			(*remove)(struct amba_device *);
 	void			(*shutdown)(struct amba_device *);
 	const struct amba_id	*id_table;
 };
diff --git a/include/linux/dma/starfive-dma.h b/include/linux/dma/starfive-dma.h
new file mode 100755
index 000000000000..2bb7c461dd92
--- /dev/null
+++ b/include/linux/dma/starfive-dma.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef _STARFIVE_DMA_H_
+#define _STARFIVE_DMA_H_
+
+#include <linux/dmaengine.h>
+
+void axi_dma_cyclic_stop(struct dma_chan *chan);
+
+#endif /* _STARFIVE_DMA_H_ */
diff --git a/include/linux/regulator/jh7110.h b/include/linux/regulator/jh7110.h
new file mode 100644
index 000000000000..e76c9a67eabd
--- /dev/null
+++ b/include/linux/regulator/jh7110.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2022 Starfive Technology Co., Ltd.
+ * Author: Mason Huo <mason.huo@starfivetech.com>
+ */
+
+#ifndef __LINUX_REGULATOR_JH7110_H
+#define __LINUX_REGULATOR_JH7110_H
+
+#define JH7110_MAX_REGULATORS	7
+
+
+enum jh7110_reg_id {
+	JH7110_ID_LDO_REG1 = 0,
+	JH7110_ID_LDO_REG2,
+	JH7110_ID_LDO_REG3,
+	JH7110_ID_LDO_REG4,
+	JH7110_ID_LDO_REG5,
+	JH7110_ID_LDO_REG6,
+	JH7110_ID_LDO_REG7,
+};
+
+
+#endif /* __LINUX_REGULATOR_JH7110_H */
diff --git a/include/soc/starfive/jh7110.h b/include/soc/starfive/jh7110.h
new file mode 100644
index 000000000000..9eeef74fe7d5
--- /dev/null
+++ b/include/soc/starfive/jh7110.h
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2022 YanHong Wang <yanhong.wang@starfivetech.com>
+ */
+
+#ifndef __SOC_STARFIVE_JH71100_H
+#define __SOC_STARFIVE_JH71100_H
+#include <linux/io.h>
+#include <soc/sifive/sifive_l2_cache.h>
+
+
+#define starfive_flush_dcache(start, len) \
+	sifive_l2_flush64_range(start, len)
+
+#endif /*__SOC_STARFIVE_JH71100_H*/
diff --git a/include/soc/starfive/jh7110_pmu.h b/include/soc/starfive/jh7110_pmu.h
new file mode 100755
index 000000000000..47838e002179
--- /dev/null
+++ b/include/soc/starfive/jh7110_pmu.h
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Reset driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 samin <samin.guo@starfivetech.com>
+ */
+
+#ifndef __SOC_STARFIVE_JH7110_PMU_H__
+#define __SOC_STARFIVE_JH7110_PMU_H__
+
+#include <linux/bits.h>
+#include <linux/types.h>
+
+/* SW/HW Power domain id  */
+enum PMU_POWER_DOMAIN {
+	POWER_DOMAIN_SYSTOP	= BIT(0),
+	POWER_DOMAIN_CPU	= BIT(1),
+	POWER_DOMAIN_GPUA	= BIT(2),
+	POWER_DOMAIN_VDEC	= BIT(3),
+	POWER_DOMAIN_JPU	= POWER_DOMAIN_VDEC,
+	POWER_DOMAIN_VOUT	= BIT(4),
+	POWER_DOMAIN_ISP	= BIT(5),
+	POWER_DOMAIN_VENC	= BIT(6),
+	POWER_DOMAIN_GPUB	= BIT(7),
+	POWER_DOMAIN_ALL	= GENMASK(7, 0),
+};
+
+enum PMU_HARD_EVENT {
+	PMU_HW_EVENT_RTC	= BIT(0),
+	PMU_HW_EVENT_GMAC	= BIT(1),
+	PMU_HW_EVENT_RFU	= BIT(2),
+	PMU_HW_EVENT_RGPIO0	= BIT(3),
+	PMU_HW_EVENT_RGPIO1	= BIT(4),
+	PMU_HW_EVENT_RGPIO2	= BIT(5),
+	PMU_HW_EVENT_RGPIO3	= BIT(6),
+	PMU_HW_EVENT_GPU	= BIT(7),
+	PMU_HW_EVENT_ALL	= GENMASK(7, 0),
+};
+
+/*
+ * @func: starfive_power_domain_set
+ * @dec: power domain turn-on/off by software
+ * @domain: power domain id
+ *	POWER_DOMAIN_SYSTOP:
+ *	POWER_DOMAIN_CPU
+ *	POWER_DOMAIN_GPUA
+ *	POWER_DOMAIN_VDEC
+ *	POWER_DOMAIN_VOUT
+ *	POWER_DOMAIN_ISP
+ *	POWER_DOMAIN_VENC
+ *	POWER_DOMAIN_GPUB
+ * @enable: 1:enable 0:disable
+ */
+//void starfive_power_domain_set(u32 domain, bool enable);
+
+/*
+ * @func: starfive_pmu_hw_encourage
+ * @dec: power domain turn-on/off by HW envent(interrupt)
+ * @domain: power domain id
+ * @event: Hardware trigger event. PMU_HARD_EVENT:
+	PMU_HW_EVENT_RTC,
+	PMU_HW_EVENT_GMAC,
+	PMU_HW_EVENT_RFU,
+	PMU_HW_EVENT_RGPIO0,
+	PMU_HW_EVENT_RGPIO1,
+	PMU_HW_EVENT_RGPIO2,
+	PMU_HW_EVENT_RGPIO3,
+	PMU_HW_EVENT_GPU,
+ * @enable: 1:enable 0:disable
+ *
+ * @for example:
+ *	starfive_power_domain_set_by_hwevent(POWER_DOMAIN_VDEC, RTC_EVENT, 0);
+ *
+ *	Means that when the RTC alarm is interrupted, the hardware
+ *	is triggered to close the power domain of VDEC.
+ */
+void starfive_power_domain_set_by_hwevent(u32 domain, u32 event, bool enable);
+
+/*
+ * @func: starfive_power_domain_order_on_get
+ * @dec: PMU power domian power on order get.
+ * @domian: powerff domain id
+ */
+int starfive_power_domain_order_on_get(u32 domain);
+
+/*
+ * @func: starfive_power_domain_order_off_get
+ * @dec: PMU power domian power off order get.
+ * @domian: power domain id
+ */
+int starfive_power_domain_order_off_get(u32 domain);
+
+/*
+ * @func: starfive_power_domain_order_on_set
+ * @dec: PMU power domian power on order set.
+ * @domian: powerff domain id
+ * @order: the poweron order of domain
+ */
+void starfive_power_domain_order_on_set(u32 domain, u32 order);
+
+/*
+ * @func: starfive_power_domain_order_off_set
+ * @dec: PMU power domian power off order set.
+ * @domian: power domain id
+ * @order: the poweroff order of domain
+ */
+void starfive_power_domain_order_off_set(u32 domain, u32 order);
+
+void starfive_pmu_hw_event_turn_off_mask(u32 mask);
+
+#endif /* __SOC_STARFIVE_JH7110_PMU_H__ */
diff --git a/include/video/stf-vin.h b/include/video/stf-vin.h
new file mode 100644
index 000000000000..bdae4aaa3f5a
--- /dev/null
+++ b/include/video/stf-vin.h
@@ -0,0 +1,443 @@
+/* include/video/stf-vin.h
+ *
+ * Copyright 2020 starfive tech.
+ *	Eric Tang <eric.tang@starfivetech.com>
+ *
+ * Generic vin notifier interface
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+*/
+#ifndef _VIDEO_VIN_H
+#define _VIDEO_VIN_H
+
+#include <linux/cdev.h>
+
+#define DRV_NAME "jh7110-vin"
+#define FB_FIRST_ADDR      0xf9000000
+#define FB_SECOND_ADDR     0xf97e9000
+
+#define RESERVED_MEM_SIZE  0x1000000
+
+#define VIN_MIPI_CONTROLLER0_OFFSET 0x00000
+#define VIN_CLKGEN_OFFSET           0x10000
+#define VIN_RSTGEN_OFFSET           0x20000
+#define VIN_MIPI_CONTROLLER1_OFFSET 0x30000
+#define VIN_SYSCONTROLLER_OFFSET    0x40000
+
+#define VD_1080P    1080
+#define VD_720P     720
+#define VD_PAL      480
+
+#define VD_HEIGHT_1080P     VD_1080P
+#define VD_WIDTH_1080P      1920
+
+#define VD_HEIGHT_720P      VD_720P
+#define VD_WIDTH_720P       1080
+
+#define VD_HEIGHT_480       480
+#define VD_WIDTH_640        640
+
+#define SEEED_WIDTH_800       800
+#define SEEED_HIGH_480        480
+
+#define VIN_TOP_CLKGEN_BASE_ADDR	    0x11800000
+#define VIN_TOP_RSTGEN_BASE_ADDR	    0x11840000
+#define VIN_TOP_IOPAD_BASE_ADDR	        0x11858000
+
+#define ISP_BASE_MIPI0_ADDR             0x19800000
+#define ISP_BASE_CLKGEN_ADDR            0x19810000
+#define ISP_BASE_RSTGEN_ADDR            0x19820000
+#define ISP_BASE_MIPI1_ADDR             0x19830000
+#define ISP_BASE_SYSCTRL_ADDR	        0x19840000
+#define ISP_BASE_ISP0_ADDR	            0x19870000
+#define ISP_BASE_ISP1_ADDR	            0x198a0000
+
+
+//vin clk registers
+#define CLK_VIN_SRC_CTRL		    0x188
+#define CLK_ISP0_AXI_CTRL		    0x190
+#define CLK_ISP0NOC_AXI_CTRL	    0x194
+#define CLK_ISPSLV_AXI_CTRL		    0x198
+#define CLK_ISP1_AXI_CTRL		    0x1A0
+#define CLK_ISP1NOC_AXI_CTRL	    0x1A4
+#define CLK_VIN_AXI		            0x1AC
+#define CLK_VINNOC_AXI		        0x1B0
+
+
+#define CLK_DOM4_APB_FUNC			0x0
+#define CLK_MUX_SEL					0xffffff
+
+#define CLK_MIPI_RX0_PXL            0x4
+
+#define CLK_DVP_INV					0x8
+#define CLK_U0_VIN_PCLK				0x18
+#define CLK_U0_VIN_PCLK_ICG						(0x1<<31)
+
+#define CLK_U0_VIN_SYS_CLK			0x1c
+#define CLK_U0_VIN_CLK_P_AXIWR 		0x30
+#define CLK_U0_VIN_MUX_SEL			(BIT(24) | BIT(25) | BIT(26) | BIT(27) | BIT(28) | BIT(29))
+
+#define CLK_U0_VIN_PIXEL_CLK_IF0    0x20
+#define CLK_U0_VIN_PIXEL_CLK_IF1    0x24
+#define CLK_U0_VIN_PIXEL_CLK_IF2    0x28
+#define CLK_U0_VIN_PIXEL_CLK_IF3    0x2c
+
+#define CLK_U0_VIN_CLK_P_AXIWR      0x30
+
+#define CLK_U0_ISPV2_TOP_WRAPPER_CLK_C	0x34u
+#define CLK_U0_ISPV2_MUX_SEL		(0x1<<24 | 0x1<<25 | 0x1<<26 | 0x1<<27 | 0x1<<28 | 0x1<< 29)
+
+#define CLK_U0_ISPV2_CLK_ICG						(0x1<<31)
+
+#define SOFTWARE_RESET_ASSERT0_ASSERT_SET 0x38U
+#define SOFTWARE_RESET_ASSERT0_ASSERT_SET_STATE 0x3CU
+#define RST_U0_ISPV2_TOP_WRAPPER_RST_P	BIT(0)
+#define RST_U0_ISPV2_TOP_WRAPPER_RST_C	BIT(1)
+#define RSTN_U0_VIN_RST_N_PCLK	BIT(4)
+#define RSTN_U0_VIN_RST_N_SYS_CLK	BIT(9)
+#define RSTN_U0_VIN_RST_P_AXIRD	BIT(10)
+#define RSTN_U0_VIN_RST_P_AXIWR	BIT(11)
+
+
+#define CLK_POLARITY				(0x1<<30)
+
+#define M31DPHY_APBCFGSAIF__SYSCFG_0	0x0
+#define M31DPHY_APBCFGSAIF__SYSCFG_4	0x4
+#define M31DPHY_APBCFGSAIF__SYSCFG_8	0x8
+#define M31DPHY_APBCFGSAIF__SYSCFG_12	0xc
+#define M31DPHY_APBCFGSAIF__SYSCFG_16	0x10
+#define M31DPHY_APBCFGSAIF__SYSCFG_20	0x14
+#define M31DPHY_APBCFGSAIF__SYSCFG_24	0x18
+#define M31DPHY_APBCFGSAIF__SYSCFG_28	0x1c
+#define M31DPHY_APBCFGSAIF__SYSCFG_32	0x20
+#define M31DPHY_APBCFGSAIF__SYSCFG_36	0x24
+#define M31DPHY_APBCFGSAIF__SYSCFG_40	0x28
+#define M31DPHY_APBCFGSAIF__SYSCFG_44	0x2c
+#define M31DPHY_APBCFGSAIF__SYSCFG_48	0x30
+#define M31DPHY_APBCFGSAIF__SYSCFG_52	0x34
+#define M31DPHY_APBCFGSAIF__SYSCFG_56	0x38
+#define M31DPHY_APBCFGSAIF__SYSCFG_60	0x3c
+#define M31DPHY_APBCFGSAIF__SYSCFG_64	0x40
+#define M31DPHY_APBCFGSAIF__SYSCFG_68	0x44
+#define M31DPHY_APBCFGSAIF__SYSCFG_72	0x48
+#define M31DPHY_APBCFGSAIF__SYSCFG_76	0x4c
+#define M31DPHY_APBCFGSAIF__SYSCFG_80	0x50
+#define M31DPHY_APBCFGSAIF__SYSCFG_84	0x54
+#define M31DPHY_APBCFGSAIF__SYSCFG_88	0x58
+#define M31DPHY_APBCFGSAIF__SYSCFG_92	0x5c
+#define M31DPHY_APBCFGSAIF__SYSCFG_96	0x60
+#define M31DPHY_APBCFGSAIF__SYSCFG_100	0x64
+#define M31DPHY_APBCFGSAIF__SYSCFG_104	0x68
+#define M31DPHY_APBCFGSAIF__SYSCFG_108	0x6c
+#define M31DPHY_APBCFGSAIF__SYSCFG_112	0x70
+#define M31DPHY_APBCFGSAIF__SYSCFG_116	0x74
+#define M31DPHY_APBCFGSAIF__SYSCFG_120	0x78
+#define M31DPHY_APBCFGSAIF__SYSCFG_124	0x7c
+#define M31DPHY_APBCFGSAIF__SYSCFG_128	0x80
+#define M31DPHY_APBCFGSAIF__SYSCFG_132	0x84
+#define M31DPHY_APBCFGSAIF__SYSCFG_136	0x88
+#define M31DPHY_APBCFGSAIF__SYSCFG_140	0x8c
+#define M31DPHY_APBCFGSAIF__SYSCFG_144	0x90
+#define M31DPHY_APBCFGSAIF__SYSCFG_184	0xb8
+
+//pmu registers
+#define SW_DEST_POWER_ON			0x0C
+#define SW_DEST_POWER_OFF			0x10
+#define SW_ENCOURAGE				0x44
+
+
+//isp clk registers
+#define CLK_DPHY_CFGCLK_ISPCORE_2X_CTRL    0x00
+#define CLK_DPHY_REFCLK_ISPCORE_2X_CTRL    0x04
+#define CLK_DPHY_TXCLKESC_IN_CTRL          0x08
+#define CLK_MIPI_RX0_PXL_CTRL       0x0c
+#define CLK_MIPI_RX1_PXL_CTRL       0x10
+#define CLK_MIPI_RX0_PXL_0_CTRL     0X14
+#define CLK_MIPI_RX0_PXL_1_CTRL     0X18
+#define CLK_MIPI_RX0_PXL_2_CTRL     0X1C
+#define CLK_MIPI_RX0_PXL_3_CTRL     0X20
+#define CLK_MIPI_RX0_SYS0_CTRL      0x24
+#define CLK_MIPI_RX1_PXL_0_CTRL     0X28
+#define CLK_MIPI_RX1_PXL_1_CTRL     0X2C
+#define CLK_MIPI_RX1_PXL_2_CTRL     0X30
+#define CLK_MIPI_RX1_PXL_3_CTRL     0X34
+#define CLK_MIPI_RX1_SYS1_CTRL      0x38
+#define CLK_ISP_CTRL               0x3c
+#define CLK_ISP_2X_CTRL            0x40
+#define CLK_ISP_MIPI_CTRL          0x44
+#define CLK_C_ISP_CTRL             0x64
+#define CLK_CSI2RX0_APB_CTRL        0x58
+
+
+#define CLK_VIN_AXI_WR_CTRL         0x5C
+
+#define SOFTWARE_RESET_ASSERT0		0x0
+#define SOFTWARE_RESET_ASSERT1		0x4
+#define SOFTWARE_RESET_STATUS		0x4
+
+#define IOPAD_REG81		        0x144
+#define IOPAD_REG82		        0x148
+#define IOPAD_REG83		        0x14C
+#define IOPAD_REG84		        0x150
+#define IOPAD_REG85		        0x154
+#define IOPAD_REG86		        0x158
+#define IOPAD_REG87	            0x15C
+#define IOPAD_REG88	            0x160
+#define IOPAD_REG89	            0x164
+
+//sys control REG DEFINE
+#define SYSCONSAIF_SYSCFG_0						0X0
+#define U0_VIN_SCFG_SRAM_CONFIG     (BIT(0) | BIT(1))
+
+#define SYSCONSAIF_SYSCFG_4			0x4
+#define U0_VIN_CNFG_AXIRD_END_ADDR 0xffffffff
+#define SYSCONSAIF_SYSCFG_8			0x8
+#define U0_VIN_CNFG_AXIRD_LINE_CNT_END (BIT(2) | BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7) | BIT(8) | BIT(9) | BIT(10) | BIT(11) | BIT(12) | BIT(13))
+#define U0_VIN_CNFG_AXIRD_LINE_CNT_START (BIT(14) | BIT(15) | BIT(16) | BIT(17) | BIT(18) | BIT(19) | BIT(20) | BIT(21) | BIT(22) | BIT(23) | BIT(24) | BIT(25))
+#define SYSCONSAIF_SYSCFG_12		0xc
+#define U0_VIN_CNFG_AXIRD_PIX_CNT_END  (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7) | BIT(8) | BIT(9) | BIT(10) | BIT(11) | BIT(12))
+#define U0_VIN_CNFG_AXIRD_PIX_CNT_START (BIT(13) | BIT(14) | BIT(15) | BIT(16) | BIT(17) | BIT(18) | BIT(19) | BIT(20) | BIT(21) | BIT(22) | BIT(23) | BIT(24) | BIT(25))
+#define U0_VIN_CNFG_AXIRD_PIX_CT	(BIT(26) | BIT(27))
+#define SYSCONSAIF_SYSCFG_16		0x10
+#define U0_VIN_CNFG_AXIRD_START_ADDR 0xFFFFFFFF
+#define SYSCONSAIF_SYSCFG_20		0x14
+#define U0_VIN_CNFG_AXIWR0_EN		BIT(4)
+#define U0_VIN_CNFG_AXIWR0_CHANNEL_SEL (BIT(0) | BIT(1) | BIT(2) | BIT(3))
+#define SYSCONSAIF_SYSCFG_24		0x18
+#define U0_VIN_CNFG_AXIWR0_END_ADDR 0xFFFFFFFF
+
+#define SYSCONSAIF_SYSCFG_28		0x1c
+#define U0_VIN_CNFG_AXIWR0_INTR_CLEAN BIT(0)
+#define U0_VIN_CNFG_AXIWR0_MASK		BIT(1)
+#define U0_VIN_CNFG_AXIWR0_PIX_CNT_END (BIT(2) | BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7) | BIT(8) | BIT(9) | BIT(10) | BIT(11) | BIT(12))
+#define U0_VIN_CNFG_AXIWR0_PIX_CT (BIT(13) | BIT(14))
+#define UO_VIN_CNFG_AXIWR0_PIXEL_HEIGH_BIT_SEL (BIT(15) | BIT(16))
+#define SYSCONSAIF_SYSCFG_32		0x20
+
+#define SYSCONSAIF_SYSCFG_36			0x24
+#define UO_VIN_CNFG_COLOR_BAR_EN	BIT(0)
+#define U0_VIN_CNFG_DVP_HS_POS		(0x1<<1)
+#define U0_VIN_CNFG_DVP_SWAP_EN		BIT(2)
+#define U0_VIN_CNFG_DVP_VS_POS		(0x1<<3)
+#define U0_VIN_CNFG_GEN_EN_AXIRD	BIT(4)
+#define U0_VIN_CNFG_ISP_DVP_EN0		BIT(5)
+#define U0_VIN_CNFG_MIPI_BYTE_EN_ISP0	(BIT(6) |BIT(7))
+#define U0_VIN_CNFG_P_I_MIPI_CHANNEL_SEL0	(BIT(8) |BIT(9) | BIT(10) | BIT(11))
+#define U0_VIN_CNFG_P_I_MIPI_HEADER_EN0 BIT(12)
+
+#define U0_VIN_CNFG_PIX_NUM			(0x1<<13 | 0x1<<14 | 0x1<<15 | 0x1<<16)
+#define U0_VIN_CNFG_AXIRD_AXI_CNT_END	(BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7) | BIT(8) | BIT(9) | BIT(10) | BIT(11) | BIT(12) | BIT(13))
+
+#define U0_VIN_CNFG_AXI_DVP_EN 		BIT(2)
+#define U0_VIN_CNFG_AXIRD_INTR_MASK	BIT(1)
+#define U0_VIN_CNFG_AXIWRD_INTR_MASK	BIT(1)
+#define U0_VIN_CNFG_AXIWR0_START_ADDR	0xffffffff
+#define U0_VIN_CNFG_COLOR_BAR_EN 	0X0
+#define U0_VIN_CNFG_AXIWR0_PIX_CNT_CT (BIT(13) | BIT(14))
+#define U0_VIN_CNFG_AXIWR0_PIX_CNT_CNT_END (BIT(2) | BIT(3) | BIT(4) | BIT(5) | BIT(6) | BIT(7) | BIT(8) | BIT(9) | BIT(10) | BIT(11) | BIT(12))
+#define U0_VIN_CNFG_AXIWR0_PIXEL_HITH_BIT_SEL (BIT(15) | BIT(16))
+
+#define SYSCTRL_REG4	            0x10
+#define SYSCTRL_DPHY_CTRL	        0x14
+#define SYSCTRL_VIN_AXI_CTRL	    0x18
+#define SYSCTRL_VIN_WR_START_ADDR	0x28
+#define SYSCTRL_VIN_RD_END_ADDR	    0x2C
+#define SYSCTRL_VIN_WR_PIX_TOTAL	0x30
+#define SYSCTRL_VIN_RD_PIX_TOTAL	0x34
+#define SYSCTRL_VIN_RW_CTRL	        0x38
+#define SYSCTRL_VIN_SRC_CHAN_SEL	0x24
+#define SYSCTRL_VIN_SRC_DW_SEL	    0x40
+#define SYSCTRL_VIN_RD_VBLANK	    0x44
+#define SYSCTRL_VIN_RD_VEND	        0x48
+#define SYSCTRL_VIN_RD_HBLANK	    0x4C
+#define SYSCTRL_VIN_RD_HEND	        0x50
+#define SYSCTRL_VIN_INTP_CTRL	    0x54
+
+#define ISP_NO_SCALE_ENABLE     (0x1<<20)
+#define ISP_MULTI_FRAME_ENABLE  (0x1<<17)
+#define ISP_SS0_ENABLE          (0x1<<11)
+#define ISP_SS1_ENABLE          (0x1<<12)
+#define ISP_RESET               (0x1<<1)
+#define ISP_ENBALE              (0x1)
+
+
+
+ //ISP REG DEFINE
+#define ISP_REG_DVP_POLARITY_CFG            0x00000014
+#define ISP_REG_RAW_FORMAT_CFG              0x00000018
+#define ISP_REG_CFA_MODE                    0x00000A1C
+#define ISP_REG_PIC_CAPTURE_START_CFG       0x0000001C
+#define ISP_REG_PIC_CAPTURE_END_CFG         0x00000020
+#define ISP_REG_PIPELINE_XY_SIZE            0x00000A0C
+#define ISP_REG_Y_PLANE_START_ADDR          0x00000A80
+#define ISP_REG_UV_PLANE_START_ADDR         0x00000A84
+#define ISP_REG_STRIDE                      0x00000A88
+#define ISP_REG_PIXEL_COORDINATE_GEN        0x00000A8C
+#define ISP_REG_PIXEL_AXI_CONTROL           0x00000A90
+#define ISP_REG_SS_AXI_CONTROL              0x00000AC4
+#define ISP_REG_RGB_TO_YUV_COVERSION0       0x00000E40
+#define ISP_REG_RGB_TO_YUV_COVERSION1       0x00000E44
+#define ISP_REG_RGB_TO_YUV_COVERSION2       0x00000E48
+#define ISP_REG_RGB_TO_YUV_COVERSION3       0x00000E4C
+#define ISP_REG_RGB_TO_YUV_COVERSION4       0x00000E50
+#define ISP_REG_RGB_TO_YUV_COVERSION5       0x00000E54
+#define ISP_REG_RGB_TO_YUV_COVERSION6       0x00000E58
+#define ISP_REG_RGB_TO_YUV_COVERSION7       0x00000E5C
+#define ISP_REG_RGB_TO_YUV_COVERSION8       0x00000E60
+#define ISP_REG_CSI_MODULE_CFG              0x00000010
+#define ISP_REG_ISP_CTRL_1                  0x00000A08
+#define ISP_REG_ISP_CTRL_0                  0x00000A00
+#define ISP_REG_DC_AXI_ID                   0x00000044
+#define ISP_REG_CSI_INPUT_EN_AND_STATUS     0x00000000
+
+//CSI registers
+#define DEVICE_CONFIG           0x00
+#define SOFT_RESET              0x04
+#define STATIC_CFG              0x08
+#define ERROR_BYPASS_CFG        0x10
+#define MONITOR_IRQS            0x18
+#define MONITOR_IRQS_MASK_CFG   0x1c
+#define INFO_IRQS               0x20
+#define INFO_IRQS_MASK_CFG      0x24
+#define ERROR_IRQS              0x28
+#define ERROR_IRQS_MASK_CFG     0x2c
+#define DPHY_LANE_CONTROL       0x40
+#define DPHY_STATUS             0x48
+#define DPHY_ERR_STATUS_IRQ     0x4C
+#define DPHY_ERR_IRQ_MASK_CFG   0x50
+#define INTEGRATION_DEBUG       0x60
+#define ERROR_DEBUG             0x74
+
+#define STREAM0_CTRL            0x100
+#define STREAM0_STATUS          0x104
+#define STREAM0_DATA_CFG        0x108
+#define STREAM0_CFG             0x10c
+#define STREAM0_MONITOR_CTRL    0x110
+#define STREAM0_MONITOR_FRAME   0x114
+#define STREAM0_MONITOR_LB      0x118
+#define STREAM0_TIMER           0x11c
+#define STREAM0_FCC_CFG         0x120
+#define STREAM0_FCC_CTRL        0x124
+#define STREAM0_FIFO_FILL_LVL   0x128
+
+//m31_dphy registers
+#define M31DPHY_APBCFGSAIF__SYSCFG_188      0xbc
+#define M31DPHY_APBCFGSAIF__SYSCFG_192      0xc0
+#define M31DPHY_APBCFGSAIF__SYSCFG_196      0xc4
+#define M31DPHY_APBCFGSAIF__SYSCFG_200      0xc8
+
+typedef enum
+{
+    DT_RAW6  = 0x28,
+    DT_RAW7  = 0x29,
+    DT_RAW8  = 0x2a,
+    DT_RAW10 = 0x2b,
+    DT_RAW12 = 0x2c,
+    DT_RAW14 = 0x2d,
+} mipicam_data_type_t;
+
+
+enum VIN_SOURCE_FORMAT {
+	SRC_COLORBAR_VIN_ISP = 0,
+	SRC_DVP_SENSOR_VIN,
+	SRC_DVP_SENSOR_VIN_ISP,//need replace sensor
+	SRC_CSI2RX_VIN_ISP,
+	SRC_DVP_SENSOR_VIN_OV5640,
+};
+
+struct reg_name {
+	char name[10];
+};
+
+typedef struct
+{
+    int dlane_nb;
+    int dlane_map[4];
+    int dlane_en[4];
+    int dlane_pn_swap[4];
+    int clane_nb;
+    int clane_map[2];
+    int clane_pn_swap[2];
+} csi2rx_dphy_cfg_t;
+
+typedef struct
+{
+    int lane_nb;
+    int dlane_map[4];
+    int dt;
+    int hsize;
+    int vsize;
+} csi2rx_cfg_t;
+
+
+typedef struct
+{
+    int mipi_id, w, h, dt, bpp, fps,lane;
+	u8  clane_swap;
+    u8  clane_pn_swap;
+    u8  dlane_swap[4];
+    u8  dlane_pn_swap[4];
+} csi_format;
+
+struct vin_params {
+	void *paddr;
+	unsigned long size;
+};
+
+struct vin_buf {
+	void *vaddr;
+	dma_addr_t paddr;
+	u32 size;
+};
+
+struct vin_framesize {
+	u32 width;
+	u32 height;
+};
+
+struct vin_format {
+	enum VIN_SOURCE_FORMAT format;
+	u8 fps;
+};
+
+struct stf_vin_dev {
+	/* Protects the access of variables shared within the interrupt */
+	spinlock_t irqlock;
+	int irq;
+	struct device *dev;
+	struct cdev vin_cdev;
+	void __iomem *base;
+	void __iomem *csi2rx_base;
+	void __iomem *clkgen_base;
+	void __iomem *rstgen_base;
+	void __iomem *sysctrl_base;
+	void __iomem *isp_base;
+	void __iomem *vin_top_clkgen_base;
+	void __iomem *vin_top_rstgen_base;
+	void __iomem *vin_top_iopad_base;
+	void __iomem *pmu_test;
+	void __iomem *sys_crg;
+	struct vin_framesize frame;
+	struct vin_format format;
+	bool isp;
+	int isp_irq;
+	int isp_csi_irq;
+	int isp_scd_irq;
+	int isp_irq_csiline;
+	u32 major;
+	struct vin_buf buf;
+
+	wait_queue_head_t wq;
+	bool condition;
+	int odd;
+
+	csi_format csi_fmt;
+};
+
+extern int vin_notifier_register(struct notifier_block *nb);
+extern void vin_notifier_unregister(struct notifier_block *nb);
+extern int vin_notifier_call(unsigned long e, void *v);
+#endif
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 71a6fe87d1a1..7e68d05822ad 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -76,7 +76,7 @@ source "sound/soc/uniphier/Kconfig"
 source "sound/soc/ux500/Kconfig"
 source "sound/soc/xilinx/Kconfig"
 source "sound/soc/xtensa/Kconfig"
-source "sound/soc/zte/Kconfig"
+source "sound/soc/starfive/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index ddbac3a2169f..ef11f887ba95 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -59,4 +59,5 @@ obj-$(CONFIG_SND_SOC)	+= uniphier/
 obj-$(CONFIG_SND_SOC)	+= ux500/
 obj-$(CONFIG_SND_SOC)	+= xilinx/
 obj-$(CONFIG_SND_SOC)	+= xtensa/
+obj-$(CONFIG_SND_SOC)	+= starfive/
 obj-$(CONFIG_SND_SOC)	+= zte/
diff --git a/sound/soc/starfive/Kconfig b/sound/soc/starfive/Kconfig
new file mode 100644
index 000000000000..bbe50975d540
--- /dev/null
+++ b/sound/soc/starfive/Kconfig
@@ -0,0 +1,70 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config SND_SOC_STARFIVE
+	tristate "Audio support for Starfive"
+	depends on COMPILE_TEST || SOC_STARFIVE
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the Starfive SoCs' Audio interfaces. You will also need to
+	  select the audio interfaces to support below.
+
+config SND_SOC_STARFIVE_PWMDAC
+	tristate "Starfive PWMDAC module"
+	depends on HAVE_CLK && SND_SOC_STARFIVE
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	 Say Y or M if you want to add support for sf pwmdac driver.
+
+config SND_SOC_STARFIVE_PWMDAC_TRANSMITTER
+        tristate "Starfive PWMDAC transmitter dit codecs"
+        depends on SND_SOC_STARFIVE_PWMDAC
+        default SND_SOC_STARFIVE_PWMDAC
+        help
+         Say Y or M if you want to add support for sf pwmdac transmitter dit driver.
+
+config SND_SOC_STARFIVE_PWMDAC_PCM
+	bool "PCM PIO extension for PWMDAC"
+	depends on SND_SOC_STARFIVE_PWMDAC
+	help
+	 Say Y or N if you want to add a custom ALSA extension that registers
+	 a PCM and uses PIO to transfer data.
+	 
+config SND_SOC_STARFIVE_I2S
+	tristate "Starfive I2S module"
+	depends on HAVE_CLK && SND_SOC_STARFIVE
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	  Say 'Y' or 'M' here if you are building for StarFive SoCs
+	  platforms that contain i2s controller core like i2stx_4ch0
+	  and i2srx_master.
+
+config SND_SOC_STARFIVE_PDM
+	tristate "Starfive PDM module"
+	depends on HAVE_CLK && SND_SOC_STARFIVE
+	select SND_SOC_STARFIVE_I2S
+	select REGMAP_MMIO
+	help
+	 Say Y or M if you want to add support for sf pdm driver.
+	 
+config SND_SOC_STARFIVE_TDM
+	tristate "Starfive TDM module"
+	depends on HAVE_CLK && SND_SOC_STARFIVE
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	 Say Y or M if you want to add support for sf tdm driver.
+
+config SND_SOC_STARFIVE_SPDIF
+	tristate "Starfive SPDIF module"
+	depends on HAVE_CLK && SND_SOC_STARFIVE
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	help
+	  Say Y or M if you want to add support for codecs attached to the
+	  I2S interface on VIC vic_starlight board. You will also need to select
+	  the drivers for the rest of VIC audio subsystem.
+	  
+config SND_SOC_STARFIVE_SPDIF_PCM
+	bool "PCM PIO extension for SPDIF"
+	depends on SND_SOC_STARFIVE_SPDIF
+	help
+	 Say Y or N if you want to add a custom ALSA extension that registers
+	 a PCM and uses PIO to transfer data. 
diff --git a/sound/soc/starfive/Makefile b/sound/soc/starfive/Makefile
new file mode 100644
index 000000000000..85c07592aed6
--- /dev/null
+++ b/sound/soc/starfive/Makefile
@@ -0,0 +1,13 @@
+# starfive Platform Support
+obj-$(CONFIG_SND_SOC_STARFIVE_PWMDAC) += starfive_pwmdac.o
+obj-$(CONFIG_SND_SOC_STARFIVE_PWMDAC_TRANSMITTER) += starfive_pwmdac_transmitter.o
+pwmdac-$(CONFIG_SND_SOC_STARFIVE_PWMDAC_PCM) += starfive_pwmdac_pcm.o
+
+obj-$(CONFIG_SND_SOC_STARFIVE_PDM) += starfive_pdm.o
+obj-$(CONFIG_SND_SOC_STARFIVE_TDM) += starfive_tdm.o
+
+obj-$(CONFIG_SND_SOC_STARFIVE_SPDIF) += spdif.o
+spdif-y := starfive_spdif.o
+spdif-$(CONFIG_SND_SOC_STARFIVE_SPDIF_PCM) += starfive_spdif_pcm.o
+
+obj-$(CONFIG_SND_SOC_STARFIVE_I2S) += starfive_i2s.o
diff --git a/sound/soc/starfive/pwmdac.h b/sound/soc/starfive/pwmdac.h
new file mode 100644
index 000000000000..d4742f99a51b
--- /dev/null
+++ b/sound/soc/starfive/pwmdac.h
@@ -0,0 +1,159 @@
+/*
+ * PWMDAC driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+  
+#ifndef __STARFIVE_PWMDAC_LOCAL_H
+#define __STARFIVE_PWMDAC_LOCAL_H
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+
+#define PWMDAC_WDATA		0	/*PWMDAC_BASE_ADDR*/
+#define PWMDAC_CTRL		0x04	/*PWMDAC_BASE_ADDR + 0x04*/
+#define PWMDAC_SATAE		0x08	/*PWMDAC_BASE_ADDR + 0x08*/
+#define PWMDAC_RESERVED		0x0C	/*PWMDAC_BASE_ADDR + 0x0C*/
+
+#define SFC_PWMDAC_SHIFT			BIT(1)
+#define SFC_PWMDAC_DUTY_CYCLE			BIT(2)
+#define SFC_PWMDAC_CNT_N			BIT(4)
+
+#define SFC_PWMDAC_LEFT_RIGHT_DATA_CHANGE	BIT(13)
+#define SFC_PWMDAC_DATA_MODE			BIT(14)
+
+#define FIFO_UN_FULL	0
+#define FIFO_FULL	1
+
+#define PWMDAC_CTRL_DATA_SHIFT  4
+#define PWMDAC_CTRL_DATA_MASK	0xF
+#define PWMDAC_DATA_LEFT_SHIFT  15
+#define PWMDAC_DUTY_CYCLE_LOW	2
+#define PWMDAC_DUTY_CYCLE_HIGH	3
+
+#define PWMDAC_MCLK	4096000
+
+enum pwmdac_lr_change{
+	NO_CHANGE = 0,
+	CHANGE,
+};
+
+enum pwmdac_d_mode{
+	UNSINGED_DATA = 0,
+	INVERTER_DATA_MSB,
+};
+
+enum pwmdac_shift_bit{
+	PWMDAC_SHIFT_8 = 8,		/*pwmdac shift 8 bit*/
+	PWMDAC_SHIFT_10 = 10,		/*pwmdac shift 10 bit*/
+};
+
+enum pwmdac_duty_cycle{
+	PWMDAC_CYCLE_LEFT = 0,		/*pwmdac duty cycle left*/
+	PWMDAC_CYCLE_RIGHT = 1,		/*pwmdac duty cycle right*/
+	PWMDAC_CYCLE_CENTER = 2,	/*pwmdac duty cycle center*/
+};
+
+/*sample count [12:4] <511*/
+enum pwmdac_sample_count{
+	PWMDAC_SAMPLE_CNT_1 = 1,
+	PWMDAC_SAMPLE_CNT_2,
+	PWMDAC_SAMPLE_CNT_3,
+	PWMDAC_SAMPLE_CNT_4,
+	PWMDAC_SAMPLE_CNT_5,
+	PWMDAC_SAMPLE_CNT_6,
+	PWMDAC_SAMPLE_CNT_7,
+	PWMDAC_SAMPLE_CNT_8 = 1,	/*(32.468/8) == (12.288/3) == 4.096*/
+	PWMDAC_SAMPLE_CNT_9,
+	PWMDAC_SAMPLE_CNT_10,
+	PWMDAC_SAMPLE_CNT_11,
+	PWMDAC_SAMPLE_CNT_12,
+	PWMDAC_SAMPLE_CNT_13,
+	PWMDAC_SAMPLE_CNT_14,
+	PWMDAC_SAMPLE_CNT_15,
+	PWMDAC_SAMPLE_CNT_16,
+	PWMDAC_SAMPLE_CNT_17,
+	PWMDAC_SAMPLE_CNT_18,
+	PWMDAC_SAMPLE_CNT_19,
+	PWMDAC_SAMPLE_CNT_20 = 20,
+	PWMDAC_SAMPLE_CNT_30 = 30,
+	PWMDAC_SAMPLE_CNT_511 = 511,
+};
+
+enum data_shift{
+	PWMDAC_DATA_LEFT_SHIFT_BIT_0 = 0,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_1,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_2,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_3,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_4,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_5,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_6,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_7,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_ALL,
+};
+
+enum pwmdac_config_list{
+	shift_8Bit_unsigned = 0,
+	shift_8Bit_unsigned_dataShift,
+	shift_10Bit_unsigned,
+	shift_10Bit_unsigned_dataShift,
+
+	shift_8Bit_inverter,
+	shift_8Bit_inverter_dataShift,
+	shift_10Bit_inverter,
+	shift_10Bit_inverter_dataShift,
+};
+
+struct sf_pwmdac_dev {
+	void __iomem *pwmdac_base;
+	resource_size_t	mapbase;
+	u8  mode;
+	u8 shift_bit;
+	u8 duty_cycle;
+	u8 datan;
+	u8 data_mode;
+	u8 lr_change;
+	u8 shift;
+	u8 fifo_th;
+	bool use_pio;
+	spinlock_t lock;
+	int active;
+
+	struct clk *clk_apb0;
+	struct clk *clk_pwmdac_apb;
+	struct clk *clk_pwmdac_core;
+	struct reset_control *rst_apb;
+
+	struct device *dev;
+	struct snd_dmaengine_dai_dma_data play_dma_data;
+	struct snd_pcm_substream __rcu *tx_substream;
+	unsigned int (*tx_fn)(struct sf_pwmdac_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+			bool *period_elapsed);
+	unsigned int tx_ptr;
+	struct task_struct *tx_thread;
+	bool tx_thread_exit;
+
+	struct clk *audio_src;
+	struct clk *pwmdac_apb;
+	struct clk *pwmdac_mclk;
+	unsigned int pwmdac_ctrl_data;
+};
+
+#if IS_ENABLED(CONFIG_SND_SOC_STARFIVE_PWMDAC_PCM)
+void sf_pwmdac_pcm_push_tx(struct sf_pwmdac_dev *dev);
+void sf_pwmdac_pcm_pop_rx(struct sf_pwmdac_dev *dev);
+int sf_pwmdac_pcm_register(struct platform_device *pdev);
+#else
+void sf_pwmdac_pcm_push_tx(struct sf_pwmdac_dev *dev) { }
+void sf_pwmdac_pcm_pop_rx(struct sf_pwmdac_dev *dev) { }
+int sf_pwmdac_pcm_register(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
diff --git a/sound/soc/starfive/starfive_i2s.c b/sound/soc/starfive/starfive_i2s.c
new file mode 100644
index 000000000000..8a92602be6f8
--- /dev/null
+++ b/sound/soc/starfive/starfive_i2s.c
@@ -0,0 +1,1378 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ALSA SoC Synopsys I2S Audio Layer
+ *
+ * sound/soc/dwc/designware_i2s.c
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Rajeev Kumar <rajeevkumar.linux@gmail.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <sound/designware_i2s.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/dma/starfive-dma.h>
+#include "starfive_i2s.h"
+
+static inline void i2s_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 i2s_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static inline void i2s_disable_channels(struct dw_i2s_dev *dev, u32 stream)
+{
+	u32 i = 0;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			i2s_write_reg(dev->i2s_base, TER(i), 0);
+	} else {
+		for (i = 0; i < 4; i++)
+			i2s_write_reg(dev->i2s_base, RER(i), 0);
+	}
+}
+
+static inline void i2s_clear_irqs(struct dw_i2s_dev *dev, u32 stream)
+{
+	u32 i = 0;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < 4; i++)
+			i2s_read_reg(dev->i2s_base, TOR(i));
+	} else {
+		for (i = 0; i < 4; i++)
+			i2s_read_reg(dev->i2s_base, ROR(i));
+	}
+}
+
+static inline void i2s_disable_irqs(struct dw_i2s_dev *dev, u32 stream,
+				    int chan_nr)
+{
+	u32 i, irq;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq | 0x30);
+		}
+	} else {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq | 0x03);
+		}
+	}
+}
+
+static inline void i2s_enable_irqs(struct dw_i2s_dev *dev, u32 stream,
+				   int chan_nr)
+{
+	u32 i, irq;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq & ~0x30);
+		}
+	} else {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq & ~0x03);
+		}
+	}
+}
+
+static irqreturn_t i2s_irq_handler(int irq, void *dev_id)
+{
+	struct dw_i2s_dev *dev = dev_id;
+	bool irq_valid = false;
+	u32 isr[4];
+	int i;
+
+	for (i = 0; i < 4; i++)
+		isr[i] = i2s_read_reg(dev->i2s_base, ISR(i));
+
+	i2s_clear_irqs(dev, SNDRV_PCM_STREAM_PLAYBACK);
+	i2s_clear_irqs(dev, SNDRV_PCM_STREAM_CAPTURE);
+
+	for (i = 0; i < 4; i++) {
+		/*
+		 * Check if TX fifo is empty. If empty fill FIFO with samples
+		 * NOTE: Only two channels supported
+		 */
+		if ((isr[i] & ISR_TXFE) && (i == 0) && dev->use_pio) {
+			dw_pcm_push_tx(dev);
+			irq_valid = true;
+		}
+
+		/*
+		 * Data available. Retrieve samples from FIFO
+		 * NOTE: Only two channels supported
+		 */
+		if ((isr[i] & ISR_RXDA) && (i == 0) && dev->use_pio) {
+			dw_pcm_pop_rx(dev);
+			irq_valid = true;
+		}
+
+		/* Error Handling: TX */
+		if (isr[i] & ISR_TXFO) {
+			dev_err(dev->dev, "TX overrun (ch_id=%d)\n", i);
+			irq_valid = true;
+		}
+
+		/* Error Handling: TX */
+		if (isr[i] & ISR_RXFO) {
+			dev_err(dev->dev, "RX overrun (ch_id=%d)\n", i);
+			irq_valid = true;
+		}
+	}
+
+	if (irq_valid)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+static void i2s_start(struct dw_i2s_dev *dev,
+		      struct snd_pcm_substream *substream)
+{
+	struct i2s_clk_config_data *config = &dev->config;
+
+	i2s_write_reg(dev->i2s_base, IER, 1);
+	i2s_enable_irqs(dev, substream->stream, config->chan_nr);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, ITER, 1);
+	else
+		i2s_write_reg(dev->i2s_base, IRER, 1);
+
+	i2s_write_reg(dev->i2s_base, CER, 1);
+
+}
+
+static void i2s_stop(struct dw_i2s_dev *dev,
+		struct snd_pcm_substream *substream)
+{
+	i2s_clear_irqs(dev, substream->stream);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, ITER, 0);
+	else
+		i2s_write_reg(dev->i2s_base, IRER, 0);
+
+	i2s_disable_irqs(dev, substream->stream, 8);
+
+	if (!dev->active) {
+		i2s_write_reg(dev->i2s_base, CER, 0);
+		i2s_write_reg(dev->i2s_base, IER, 0);
+	}
+}
+
+static void dw_i2s_config(struct dw_i2s_dev *dev, int stream)
+{
+	u32 ch_reg;
+	struct i2s_clk_config_data *config = &dev->config;
+
+	i2s_disable_channels(dev, stream);
+
+	for (ch_reg = 0; ch_reg < (config->chan_nr / 2); ch_reg++) {
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s_write_reg(dev->i2s_base, TCR(ch_reg),
+				      dev->xfer_resolution);
+			i2s_write_reg(dev->i2s_base, TFCR(ch_reg),
+				      dev->fifo_th - 1);
+			i2s_write_reg(dev->i2s_base, TER(ch_reg), 1);
+		} else {
+			i2s_write_reg(dev->i2s_base, RCR(ch_reg),
+				      dev->xfer_resolution);
+			i2s_write_reg(dev->i2s_base, RFCR(ch_reg),
+				      dev->fifo_th - 1);
+			i2s_write_reg(dev->i2s_base, RER(ch_reg), 1);
+		}
+	}
+}
+
+static int dw_i2s_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	struct i2s_clk_config_data *config = &dev->config;
+	int ret;
+	unsigned int bclk_rate;
+	bool playback;
+	union dw_i2s_snd_dma_data *dma_data = NULL;
+
+	config->chan_nr = params_channels(params);
+	config->sample_rate = params_rate(params);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		playback = false;
+	else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		playback = true;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		if ((config->sample_rate == 8000) && playback &&
+			(dev->capability & DW_I2S_SLAVE)) {
+			dev_warn(dev->dev, "I2S: unsupported 8000 rate with S16_LE, Stereo if use wm8960.\n");
+		}
+
+		config->data_width = 16;
+		dev->ccr = 0x00;
+		dev->xfer_resolution = 0x02;
+		if (playback)
+			dev->play_dma_data.dt.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		else
+			dev->capture_dma_data.dt.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		config->data_width = 32;
+		dev->ccr = 0x10;
+		dev->xfer_resolution = 0x05;
+		if (playback)
+			dev->play_dma_data.dt.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		else
+			dev->capture_dma_data.dt.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+
+	default:
+		dev_err(dev->dev, "designware-i2s: unsupported PCM fmt");
+		return -EINVAL;
+	}
+
+	if (dev->capability & DW_I2S_MASTER) {
+		switch (params_rate(params)) {
+		case 8000:
+			bclk_rate = 512000;
+			break;
+		case 11025:
+			bclk_rate = 705600;
+			break;
+		case 16000:
+			bclk_rate = 1024000;
+			break;
+		case 32000:
+			bclk_rate = 2048000;
+			break;
+		case 48000:
+			bclk_rate = 3072000;
+			break;
+		default:
+			dev_err(dai->dev, "%d rate not supported\n",
+					params_rate(params));
+			ret = -EINVAL;
+			goto err_return;
+		}
+	}
+
+	switch (config->chan_nr) {
+	case EIGHT_CHANNEL_SUPPORT:
+	case SIX_CHANNEL_SUPPORT:
+	case FOUR_CHANNEL_SUPPORT:
+	case TWO_CHANNEL_SUPPORT:
+		break;
+	default:
+		dev_err(dev->dev, "channel not supported\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		dma_data = &dev->capture_dma_data;
+	else if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &dev->play_dma_data;
+	snd_soc_dai_set_dma_data(dai, substream, (void *)dma_data);
+
+	dw_i2s_config(dev, substream->stream);
+
+	i2s_write_reg(dev->i2s_base, CCR, dev->ccr);
+
+	if (dev->capability & DW_I2S_MASTER) {
+		if (dev->i2s_clk_cfg) {
+			ret = dev->i2s_clk_cfg(config);
+			if (ret < 0) {
+				dev_err(dev->dev, "runtime audio clk config fail\n");
+				goto err_return;
+			}
+		} else {
+			if (playback) {
+				ret = clk_set_parent(dev->clk_mclk, dev->clk_mclk_ext);
+				if (ret) {
+					dev_err(dev->dev,
+						"failed to set mclk parent to mclk_ext\n");
+					goto err_return;
+				}
+			}
+
+			ret = clk_set_rate(dev->clk_i2s_bclk_mst, bclk_rate);
+			if (ret) {
+				dev_err(dev->dev, "Can't set i2s bclk: %d\n", ret);
+				goto err_return;
+			}
+
+			dev_dbg(dev->dev, "get rate mclk: %ld\n",
+				clk_get_rate(dev->clk_mclk));
+			dev_dbg(dev->dev, "get rate bclk:%ld\n",
+				clk_get_rate(dev->clk_i2s_bclk));
+			dev_dbg(dev->dev, "get rate lrck:%ld\n",
+				clk_get_rate(dev->clk_i2s_lrck));
+		}
+	}
+	return 0;
+
+err_return:
+	return ret;
+}
+
+static int dw_i2s_prepare(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, TXFFR, 1);
+	else
+		i2s_write_reg(dev->i2s_base, RXFFR, 1);
+
+	return 0;
+}
+
+static int dw_i2s_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev->active++;
+		i2s_start(dev, substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev->active--;
+		axi_dma_cyclic_stop(chan);
+		i2s_stop(dev, substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int dw_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		if (dev->capability & DW_I2S_SLAVE)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		if (dev->capability & DW_I2S_MASTER)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		ret = -EINVAL;
+		break;
+	default:
+		dev_dbg(dev->dev, "dwc : Invalid master/slave format\n");
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static const struct snd_soc_dai_ops dw_i2s_dai_ops = {
+	.hw_params	= dw_i2s_hw_params,
+	.prepare	= dw_i2s_prepare,
+	.trigger	= dw_i2s_trigger,
+	.set_fmt	= dw_i2s_set_fmt,
+};
+
+#ifdef CONFIG_PM
+static int dw_i2s_runtime_suspend(struct device *dev)
+{
+	struct dw_i2s_dev *dw_dev = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(dw_dev->clk_i2s_bclk_mst);
+	clk_disable_unprepare(dw_dev->clk_i2s_apb);
+
+	return 0;
+}
+
+static int dw_i2s_runtime_resume(struct device *dev)
+{
+	struct dw_i2s_dev *dw_dev = dev_get_drvdata(dev);
+	int ret;
+
+	ret = clk_prepare_enable(dw_dev->clk_i2s_apb);
+	if (ret) {
+		dev_err(dw_dev->dev, "Failed to enable clk_i2s_apb\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(dw_dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(dw_dev->dev, "Failed to enable clk_i2s_lrck\n");
+		return ret;
+	}
+
+	if (dw_dev->rst_i2s_apb) {
+		ret = reset_control_deassert(dw_dev->rst_i2s_apb);
+		if (ret)
+			return ret;
+	}
+	if (dw_dev->rst_i2s_bclk) {
+		ret = reset_control_deassert(dw_dev->rst_i2s_bclk);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static int dw_i2s_suspend(struct snd_soc_component *component)
+{
+	return pm_runtime_force_suspend(component->dev);
+}
+
+static int dw_i2s_resume(struct snd_soc_component *component)
+{
+	struct dw_i2s_dev *dev = snd_soc_component_get_drvdata(component);
+	struct snd_soc_dai *dai;
+	int stream;
+	int ret;
+
+	if (!dev->is_master) {
+		ret = clk_set_parent(dev->clk_i2s_bclk, dev->clk_i2s_bclk_mst);
+		if (ret) {
+			dev_err(dev->dev, "%s: failed to set clk_i2s_bclk parent to bclk_mst.\n",
+				__func__);
+			goto exit;
+		}
+
+		ret = clk_set_parent(dev->clk_i2s_lrck, dev->clk_i2s_lrck_mst);
+		if (ret) {
+			dev_err(dev->dev, "%s: failed to set clk_i2s_lrck parent to lrck_mst.\n",
+				__func__);
+			goto exit;
+		}
+	}
+
+	ret = pm_runtime_force_resume(component->dev);
+	if (ret)
+		return ret;
+
+	if (dev->syscon_base) {
+		if (dev->is_master) {
+			/* config i2s data source: PDM  */
+			regmap_update_bits(dev->syscon_base, dev->syscon_offset_34,
+						AUDIO_SDIN_MUX_MASK, I2SRX_DATA_SRC_PDM);
+
+			regmap_update_bits(dev->syscon_base, dev->syscon_offset_18,
+				I2SRX_3CH_ADC_MASK, I2SRX_3CH_ADC_EN);
+		} else {
+			/*i2srx_3ch_adc_enable*/
+			regmap_update_bits(dev->syscon_base, dev->syscon_offset_18,
+						0x1 << 1, 0x1 << 1);
+
+			/*set i2sdin_sel*/
+			regmap_update_bits(dev->syscon_base, dev->syscon_offset_34,
+				(0x1 << 10) | (0x1 << 14) | (0x1<<17), (0x0<<10) | (0x0<<14) | (0x0<<17));
+		}
+	}
+
+	for_each_component_dais(component, dai) {
+		for_each_pcm_streams(stream)
+			if (snd_soc_dai_stream_active(dai, stream))
+				dw_i2s_config(dev, stream);
+	}
+
+	i2s_write_reg(dev->i2s_base, CCR, dev->ccr);
+
+	if (!dev->is_master) {
+		ret = clk_set_parent(dev->clk_mclk, dev->clk_mclk_ext);
+		if (ret) {
+			dev_err(dev->dev, "failed to set mclk parent to mclk_ext\n");
+			goto exit;
+		}
+
+		ret = clk_set_parent(dev->clk_i2s_bclk, dev->clk_bclk_ext);
+		if (ret) {
+			dev_err(dev->dev, "%s: failed to set clk_i2s_bclk parent to bclk_ext.\n",
+				__func__);
+			goto exit;
+		}
+
+		ret = clk_set_parent(dev->clk_i2s_lrck, dev->clk_lrck_ext);
+		if (ret) {
+			dev_err(dev->dev, "%s: failed to set clk_i2s_lrck parent to lrck_ext.\n",
+				__func__);
+			goto exit;
+		}
+	}
+
+	return 0;
+
+exit:
+	return ret;
+}
+
+#else
+#define dw_i2s_suspend	NULL
+#define dw_i2s_resume	NULL
+#endif
+
+static const struct snd_soc_component_driver dw_i2s_component = {
+	.name		= "dw-i2s",
+	.suspend	= dw_i2s_suspend,
+	.resume		= dw_i2s_resume,
+};
+
+static int dw_i2srx_mst_clk_init(struct platform_device *pdev, struct dw_i2s_dev *dev)
+{
+	int ret = 0;
+
+	static struct clk_bulk_data clks[] = {
+		{ .id = "i2srx_apb" },
+		{ .id = "i2srx_bclk_mst" },
+		{ .id = "i2srx_lrck_mst" },
+		{ .id = "i2srx_bclk" },
+		{ .id = "i2srx_lrck" },
+		{ .id = "mclk" },
+		{ .id = "mclk_ext" },
+	};
+
+	ret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(clks), clks);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to get i2srx clocks\n", __func__);
+		goto exit;
+	}
+
+	dev->clk_i2s_apb = clks[0].clk;
+	dev->clk_i2s_bclk_mst = clks[1].clk;
+	dev->clk_i2s_lrck_mst = clks[2].clk;
+	dev->clk_i2s_bclk = clks[3].clk;
+	dev->clk_i2s_lrck = clks[4].clk;
+	dev->clk_mclk = clks[5].clk;
+	dev->clk_mclk_ext = clks[6].clk;
+
+	dev->rst_i2s_apb = devm_reset_control_get_exclusive(&pdev->dev, "rst_apb_rx");
+	if (IS_ERR(dev->rst_i2s_apb)) {
+		dev_err(&pdev->dev, "failed to get apb_i2srx reset control\n");
+		ret = PTR_ERR(dev->rst_i2s_apb);
+		goto exit;
+	}
+
+	dev->rst_i2s_bclk = devm_reset_control_get_exclusive(&pdev->dev, "rst_bclk_rx");
+	if (IS_ERR(dev->rst_i2s_bclk)) {
+		dev_err(&pdev->dev, "failed to get i2s bclk rx reset control\n");
+		ret = PTR_ERR(dev->rst_i2s_bclk);
+		goto exit;
+	}
+
+	ret = clk_prepare_enable(dev->clk_i2s_apb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to prepare enable clk_i2srx_apb\n");
+		goto exit;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_bclk, dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set parent clk_i2s_bclk\n");
+		goto err_dis_bclk_mst;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_lrck, dev->clk_i2s_lrck_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set parent clk_i2s_lrck\n");
+		goto err_dis_bclk_mst;
+	}
+
+	ret = clk_set_parent(dev->clk_mclk, dev->clk_mclk_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set mclk parent to mclk_ext\n");
+		goto err_dis_bclk_mst;
+	}
+
+	ret = clk_prepare_enable(dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to prepare enable clk_i2srx_3ch_bclk_mst\n");
+		goto err_dis_bclk_mst;
+	}
+
+	reset_control_deassert(dev->rst_i2s_apb);
+	reset_control_deassert(dev->rst_i2s_bclk);
+
+	regmap_update_bits(dev->syscon_base, dev->syscon_offset_18,
+				I2SRX_3CH_ADC_MASK, I2SRX_3CH_ADC_EN);
+
+	return 0;
+
+err_dis_bclk_mst:
+	clk_disable_unprepare(dev->clk_i2s_apb);
+exit:
+	return ret;
+}
+
+static int dw_i2srx_clk_init(struct platform_device *pdev, struct dw_i2s_dev *dev)
+{
+	int ret = 0;
+
+	static struct clk_bulk_data clks[] = {
+		{ .id = "3ch-apb" },
+		{ .id = "bclk_mst" },
+		{ .id = "3ch-lrck" },
+		{ .id = "rx-bclk" },
+		{ .id = "rx-lrck" },
+		{ .id = "bclk-ext" },
+		{ .id = "lrck-ext" },
+		{ .id = "mclk" },
+		{ .id = "mclk_ext" },
+	};
+
+	ret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(clks), clks);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to get audio_subsys clocks\n", __func__);
+		return ret;
+	}
+
+	dev->clk_i2s_apb = clks[0].clk;
+	dev->clk_i2s_bclk_mst = clks[1].clk;
+	dev->clk_i2s_lrck_mst = clks[2].clk;
+	dev->clk_i2s_bclk = clks[3].clk;
+	dev->clk_i2s_lrck = clks[4].clk;
+	dev->clk_bclk_ext = clks[5].clk;
+	dev->clk_lrck_ext = clks[6].clk;
+	dev->clk_mclk = clks[7].clk;
+	dev->clk_mclk_ext = clks[8].clk;
+
+	ret = clk_set_parent(dev->clk_i2s_bclk, dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to set clk_i2s_bclk parent to bclk_mst.\n",
+			__func__);
+		goto exit;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_lrck, dev->clk_i2s_lrck_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to set clk_i2s_lrck parent to lrck_mst.\n",
+			__func__);
+		goto exit;
+	}
+
+	ret = clk_prepare_enable(dev->clk_i2s_apb);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to enable clk_i2s_apb\n", __func__);
+		goto disable_apb_clk;
+	}
+
+	ret = clk_prepare_enable(dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to enable CLK_ADC_BCLK\n", __func__);
+		goto disable_bclk;
+	}
+
+	dev->rst_i2s_apb = devm_reset_control_array_get_exclusive(&pdev->dev);
+	if (IS_ERR(dev->rst_i2s_apb)) {
+		dev_err(&pdev->dev, "%s: failed to get rsts reset control\n", __func__);
+		goto disable_rst;
+	}
+
+	ret = reset_control_assert(dev->rst_i2s_apb);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to reset control assert rstc_rx\n", __func__);
+		goto disable_rst;
+	}
+	udelay(5);
+	ret = reset_control_deassert(dev->rst_i2s_apb);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to reset control deassert rstc_rx\n", __func__);
+		goto disable_rst;
+	}
+
+	/*i2srx_3ch_adc_enable*/
+	regmap_update_bits(dev->syscon_base, dev->syscon_offset_18,
+					0x1 << 1, 0x1 << 1);
+
+	/*set i2sdin_sel*/
+	regmap_update_bits(dev->syscon_base, dev->syscon_offset_34,
+		(0x1 << 10) | (0x1 << 14) | (0x1<<17), (0x0<<10) | (0x0<<14) | (0x0<<17));
+
+
+	ret = clk_set_parent(dev->clk_mclk, dev->clk_mclk_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set mclk parent to mclk_ext\n");
+		goto disable_parent;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_bclk, dev->clk_bclk_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to set clk_i2s_bclk parent to bclk_ext.\n",
+			__func__);
+		goto disable_parent;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_lrck, dev->clk_lrck_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to set clk_i2s_lrck parent to lrck_ext.\n",
+			__func__);
+		goto disable_parent;
+	}
+
+	return 0;
+
+disable_parent:
+disable_rst:
+	clk_disable_unprepare(dev->clk_i2s_bclk_mst);
+disable_bclk:
+	clk_disable_unprepare(dev->clk_i2s_apb);
+disable_apb_clk:
+exit:
+
+	return ret;
+}
+
+static int dw_i2stx_4ch0_clk_init(struct platform_device *pdev, struct dw_i2s_dev *dev)
+{
+	int ret = 0;
+
+	static struct clk_bulk_data clks[] = {
+		{ .id = "bclk-mst" },
+		{ .id = "lrck-mst" },
+		{ .id = "mclk" },
+		{ .id = "bclk0" },
+		{ .id = "lrck0" },
+		{ .id = "i2s_apb" },
+		{ .id = "mclk_ext" },
+	};
+
+	ret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(clks), clks);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to get i2s clocks\n", __func__);
+		goto exit;
+	}
+
+	dev->clk_i2s_bclk_mst = clks[0].clk;
+	dev->clk_i2s_lrck_mst = clks[1].clk;
+	dev->clk_mclk = clks[2].clk;
+	dev->clk_i2s_bclk = clks[3].clk;
+	dev->clk_i2s_lrck = clks[4].clk;
+	dev->clk_i2s_apb = clks[5].clk;
+	dev->clk_mclk_ext = clks[6].clk;
+
+	dev->rst_i2s_apb = devm_reset_control_get_exclusive(&pdev->dev, "rst_apb");
+	if (IS_ERR(dev->rst_i2s_apb)) {
+		dev_err(&pdev->dev, "failed to get i2s apb reset control\n");
+		ret = PTR_ERR(dev->rst_i2s_apb);
+		goto exit;
+	}
+
+	dev->rst_i2s_bclk = devm_reset_control_get_exclusive(&pdev->dev, "rst_bclk");
+	if (IS_ERR(dev->rst_i2s_bclk)) {
+		dev_err(&pdev->dev, "failed to get i2s bclk reset control\n");
+		ret = PTR_ERR(dev->rst_i2s_bclk);
+		goto exit;
+	}
+
+	ret = clk_prepare_enable(dev->clk_i2s_apb);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to prepare enable clk_i2s_apb\n");
+		goto exit;
+	}
+
+	ret = clk_set_parent(dev->clk_mclk, dev->clk_mclk_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set mclk parent to mclk_ext\n");
+		goto err_set_parent;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_lrck_mst, dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set parent clk_i2s_lrck_mst\n");
+		goto err_dis_bclk_mst;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_bclk, dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set parent clk_i2s_bclk\n");
+		goto err_dis_bclk_mst;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_lrck, dev->clk_i2s_lrck_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set parent clk_i2s_lrck\n");
+		goto err_dis_bclk_mst;
+	}
+
+	ret = clk_prepare_enable(dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to prepare enable clk_i2srx_3ch_bclk_mst\n");
+		goto err_dis_bclk_mst;
+	}
+
+	reset_control_deassert(dev->rst_i2s_apb);
+	reset_control_deassert(dev->rst_i2s_bclk);
+
+	return 0;
+
+err_dis_bclk_mst:
+err_set_parent:
+	clk_disable_unprepare(dev->clk_i2s_apb);
+exit:
+	return ret;
+}
+
+static int dw_i2stx_4ch1_clk_init(struct platform_device *pdev, struct dw_i2s_dev *dev)
+{
+	int ret = 0;
+
+	static struct clk_bulk_data clks[] = {
+		{ .id = "bclk_mst" },
+		{ .id = "lrck_mst" },
+		{ .id = "mclk" },
+		{ .id = "4chbclk" },
+		{ .id = "4chlrck" },
+		{ .id = "clk_apb" },
+		{ .id = "mclk_ext" },
+		{ .id = "bclk_ext" },
+		{ .id = "lrck_ext" },
+	};
+
+	ret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(clks), clks);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to get i2s clocks\n", __func__);
+		goto exit;
+	}
+
+	dev->clk_i2s_bclk_mst = clks[0].clk;
+	dev->clk_i2s_lrck_mst = clks[1].clk;
+	dev->clk_mclk = clks[2].clk;
+	dev->clk_i2s_bclk = clks[3].clk;
+	dev->clk_i2s_lrck = clks[4].clk;
+	dev->clk_i2s_apb = clks[5].clk;
+	dev->clk_mclk_ext = clks[6].clk;
+	dev->clk_bclk_ext = clks[7].clk;
+	dev->clk_lrck_ext = clks[8].clk;
+
+	ret = clk_set_parent(dev->clk_i2s_bclk, dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to set clk_i2s_bclk parent to bclk_mst.\n",
+			__func__);
+		goto exit;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_lrck, dev->clk_i2s_lrck_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to set clk_i2s_lrck parent to lrck_mst.\n",
+			__func__);
+		goto exit;
+	}
+
+	ret = clk_prepare_enable(dev->clk_i2s_apb);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to enable clk_i2s_apb\n", __func__);
+		goto exit;
+	}
+
+	ret = clk_prepare_enable(dev->clk_i2s_bclk_mst);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to enable clk_i2s_bclk_mst\n", __func__);
+		goto disable_bclk;
+	}
+
+	dev->rst_i2s_apb = devm_reset_control_array_get_exclusive(&pdev->dev);
+	if (IS_ERR(dev->rst_i2s_apb)) {
+		dev_err(&pdev->dev, "%s: failed to get rsts reset control\n", __func__);
+		goto disable_rst;
+	}
+
+	ret = reset_control_assert(dev->rst_i2s_apb);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to reset control assert rsts\n", __func__);
+		goto disable_rst;
+	}
+	udelay(5);
+	ret = reset_control_deassert(dev->rst_i2s_apb);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to reset control deassert rsts\n", __func__);
+		goto disable_rst;
+	}
+
+	ret = clk_set_parent(dev->clk_mclk, dev->clk_mclk_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set mclk parent to mclk_ext\n");
+		goto exit;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_bclk, dev->clk_bclk_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to set clk_i2s_bclk parent to bclk_ext.\n",
+			__func__);
+		goto disable_parent;
+	}
+
+	ret = clk_set_parent(dev->clk_i2s_lrck, dev->clk_lrck_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to set clk_i2s_lrck parent to lrck_ext.\n",
+			__func__);
+		goto disable_parent;
+	}
+
+	return 0;
+
+disable_parent:
+disable_rst:
+	clk_disable_unprepare(dev->clk_i2s_bclk_mst);
+disable_bclk:
+	clk_disable_unprepare(dev->clk_i2s_apb);
+exit:
+	return ret;
+}
+
+/*
+ * The following tables allow a direct lookup of various parameters
+ * defined in the I2S block's configuration in terms of sound system
+ * parameters.  Each table is sized to the number of entries possible
+ * according to the number of configuration bits describing an I2S
+ * block parameter.
+ */
+
+/* Maximum bit resolution of a channel - not uniformly spaced */
+static const u32 fifo_width[COMP_MAX_WORDSIZE] = {
+	12, 16, 20, 24, 32, 0, 0, 0
+};
+
+/* Width of (DMA) bus */
+static const u32 bus_widths[COMP_MAX_DATA_WIDTH] = {
+	DMA_SLAVE_BUSWIDTH_1_BYTE,
+	DMA_SLAVE_BUSWIDTH_2_BYTES,
+	DMA_SLAVE_BUSWIDTH_4_BYTES,
+	DMA_SLAVE_BUSWIDTH_UNDEFINED
+};
+
+/* PCM format to support channel resolution */
+static const u32 formats[COMP_MAX_WORDSIZE] = {
+	SNDRV_PCM_FMTBIT_S16_LE,
+	SNDRV_PCM_FMTBIT_S16_LE,
+	SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S32_LE,
+	0,
+	0,
+	0
+};
+
+#define SF_PCM_RATE_32000_192000  (SNDRV_PCM_RATE_32000 | \
+				   SNDRV_PCM_RATE_44100 | \
+				   SNDRV_PCM_RATE_48000 | \
+				   SNDRV_PCM_RATE_88200 | \
+				   SNDRV_PCM_RATE_96000 | \
+				   SNDRV_PCM_RATE_176400 | \
+				   SNDRV_PCM_RATE_192000)
+
+static int dw_configure_dai(struct dw_i2s_dev *dev,
+				   struct snd_soc_dai_driver *dw_i2s_dai,
+				   unsigned int rates)
+{
+	/*
+	 * Read component parameter registers to extract
+	 * the I2S block's configuration.
+	 */
+	u32 comp1 = i2s_read_reg(dev->i2s_base, dev->i2s_reg_comp1);
+	u32 comp2 = i2s_read_reg(dev->i2s_base, dev->i2s_reg_comp2);
+	u32 fifo_depth = 1 << (1 + COMP1_FIFO_DEPTH_GLOBAL(comp1));
+	u32 idx;
+
+	if (dev->capability & DWC_I2S_RECORD &&
+			dev->quirks & DW_I2S_QUIRK_COMP_PARAM1)
+		comp1 = comp1 & ~BIT(5);
+
+	if (dev->capability & DWC_I2S_PLAY &&
+			dev->quirks & DW_I2S_QUIRK_COMP_PARAM1)
+		comp1 = comp1 & ~BIT(6);
+
+	if (COMP1_TX_ENABLED(comp1)) {
+		dev_info(dev->dev, " designware: play supported\n");
+		idx = COMP1_TX_WORDSIZE_0(comp1);
+		if (WARN_ON(idx >= ARRAY_SIZE(formats)))
+			return -EINVAL;
+		if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
+			idx = 1;
+		dw_i2s_dai->playback.channels_min = MIN_CHANNEL_NUM;
+		dw_i2s_dai->playback.channels_max =
+				(COMP1_TX_CHANNELS(comp1) + 1);
+		dw_i2s_dai->playback.formats = formats[idx];
+		for (; idx > 0; idx--)
+			dw_i2s_dai->playback.formats |= formats[idx - 1];
+		dw_i2s_dai->playback.rates = rates;
+	}
+
+	if (COMP1_RX_ENABLED(comp1)) {
+		dev_info(dev->dev, "designware: record supported\n");
+		idx = COMP2_RX_WORDSIZE_0(comp2);
+		if (WARN_ON(idx >= ARRAY_SIZE(formats)))
+			return -EINVAL;
+		if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
+			idx = 1;
+		dw_i2s_dai->capture.channels_min = MIN_CHANNEL_NUM;
+		dw_i2s_dai->capture.channels_max =
+				(COMP1_RX_CHANNELS(comp1) + 1);
+		dw_i2s_dai->capture.formats = formats[idx];
+		for (; idx > 0; idx--)
+			dw_i2s_dai->capture.formats |= formats[idx - 1];
+		dw_i2s_dai->capture.rates = rates;
+	}
+
+	if (COMP1_MODE_EN(comp1) || dev->is_master) {
+		dev_err(dev->dev, "designware: i2s master mode supported\n");
+		dev->capability |= DW_I2S_MASTER;
+	} else {
+		dev_err(dev->dev, "designware: i2s slave mode supported\n");
+		dev->capability |= DW_I2S_SLAVE;
+	}
+
+	dev->fifo_th = fifo_depth / 2;
+	dev_dbg(dev->dev, "fifo_th :%d\n", dev->fifo_th);
+	return 0;
+}
+
+static int dw_configure_dai_by_pd(struct dw_i2s_dev *dev,
+				   struct snd_soc_dai_driver *dw_i2s_dai,
+				   struct resource *res,
+				   const struct i2s_platform_data *pdata)
+{
+	u32 comp1 = i2s_read_reg(dev->i2s_base, dev->i2s_reg_comp1);
+	u32 idx = COMP1_APB_DATA_WIDTH(comp1);
+	int ret;
+
+	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))
+		return -EINVAL;
+
+	ret = dw_configure_dai(dev, dw_i2s_dai, pdata->snd_rates);
+	if (ret < 0)
+		return ret;
+
+	if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
+		idx = 1;
+	/* Set DMA slaves info */
+	dev->play_dma_data.pd.data = pdata->play_dma_data;
+	dev->capture_dma_data.pd.data = pdata->capture_dma_data;
+	dev->play_dma_data.pd.addr = res->start + I2S_TXDMA;
+	dev->capture_dma_data.pd.addr = res->start + I2S_RXDMA;
+	dev->play_dma_data.pd.max_burst = 16;
+	dev->capture_dma_data.pd.max_burst = 16;
+	dev->play_dma_data.pd.addr_width = bus_widths[idx];
+	dev->capture_dma_data.pd.addr_width = bus_widths[idx];
+	dev->play_dma_data.pd.filter = pdata->filter;
+	dev->capture_dma_data.pd.filter = pdata->filter;
+
+	return 0;
+}
+
+static int dw_configure_dai_by_dt(struct dw_i2s_dev *dev,
+				   struct snd_soc_dai_driver *dw_i2s_dai,
+				   struct resource *res)
+{
+	u32 comp1 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_1);
+	u32 comp2 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_2);
+	u32 fifo_depth = 1 << (1 + COMP1_FIFO_DEPTH_GLOBAL(comp1));
+	u32 idx = COMP1_APB_DATA_WIDTH(comp1);
+	u32 idx2;
+	int ret;
+
+	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))
+		return -EINVAL;
+
+	ret = dw_configure_dai(dev, dw_i2s_dai, dev->susport_rate);
+	if (ret < 0)
+		return ret;
+
+	if (COMP1_TX_ENABLED(comp1)) {
+		idx2 = COMP1_TX_WORDSIZE_0(comp1);
+
+		dev->capability |= DWC_I2S_PLAY;
+		dev->play_dma_data.dt.addr = res->start + I2S_TXDMA;
+		dev->play_dma_data.dt.addr_width = bus_widths[idx];
+		dev->play_dma_data.dt.fifo_size = fifo_depth *
+			(fifo_width[idx2]) >> 8;
+		dev->play_dma_data.dt.maxburst = 16;
+	}
+	if (COMP1_RX_ENABLED(comp1)) {
+		idx2 = COMP2_RX_WORDSIZE_0(comp2);
+
+		/* force change to 1 */
+		if (dev->is_master) {
+			idx = 1;
+			idx2 = 1;
+		}
+		dev->capability |= DWC_I2S_RECORD;
+		dev->capture_dma_data.dt.addr = res->start + I2S_RXDMA;
+		dev->capture_dma_data.dt.addr_width = bus_widths[idx];
+		dev->capture_dma_data.dt.fifo_size = fifo_depth *
+			(fifo_width[idx2] >> 8);
+		dev->capture_dma_data.dt.maxburst = 16;
+	}
+
+	return 0;
+
+}
+
+static int dw_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, &dev->play_dma_data, &dev->capture_dma_data);
+	return 0;
+}
+
+static int dw_i2s_probe(struct platform_device *pdev)
+{
+	const struct i2s_platform_data *pdata = pdev->dev.platform_data;
+	struct device_node *np = pdev->dev.of_node;
+	struct of_phandle_args args;
+	struct dw_i2s_dev *dev;
+	struct resource *res;
+	int ret, irq;
+	struct snd_soc_dai_driver *dw_i2s_dai;
+	const char *clk_id;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dw_i2s_dai = devm_kzalloc(&pdev->dev, sizeof(*dw_i2s_dai), GFP_KERNEL);
+	if (!dw_i2s_dai)
+		return -ENOMEM;
+
+	dw_i2s_dai->ops = &dw_i2s_dai_ops;
+	dw_i2s_dai->probe = dw_i2s_dai_probe;
+
+	dev->i2s_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(dev->i2s_base))
+		return PTR_ERR(dev->i2s_base);
+
+	dev->dev = &pdev->dev;
+
+	irq = platform_get_irq_optional(pdev, 0);
+	if (irq >= 0) {
+		ret = devm_request_irq(&pdev->dev, irq, i2s_irq_handler, 0,
+				pdev->name, dev);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to request irq\n");
+			return ret;
+		}
+	}
+
+	if (of_device_is_compatible(np, "starfive,jh7110-i2srx-master")) {
+		ret = of_parse_phandle_with_fixed_args(dev->dev->of_node,
+						"starfive,sys-syscon", 2, 0, &args);
+		if (ret) {
+			dev_err(dev->dev, "Failed to parse starfive,sys-syscon\n");
+			return -EINVAL;
+		}
+
+		dev->syscon_base = syscon_node_to_regmap(args.np);
+		of_node_put(args.np);
+		if (IS_ERR(dev->syscon_base))
+			return PTR_ERR(dev->syscon_base);
+
+		dev->syscon_offset_18 = args.args[0];
+		dev->syscon_offset_34 = args.args[1];
+
+		/* config i2s data source: PDM  */
+		regmap_update_bits(dev->syscon_base, dev->syscon_offset_34,
+					AUDIO_SDIN_MUX_MASK, I2SRX_DATA_SRC_PDM);
+
+		ret = dw_i2srx_mst_clk_init(pdev, dev);
+		if (ret < 0)
+			goto err_init;
+		dev->is_master = true;
+		dev->susport_rate = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |
+				SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000;
+	} else if (of_device_is_compatible(np, "starfive,jh7110-i2srx")) {
+		ret = of_parse_phandle_with_fixed_args(dev->dev->of_node,
+							"starfive,sys-syscon", 2, 0, &args);
+		if (ret) {
+			dev_err(dev->dev, "Failed to parse starfive,sys-syscon\n");
+			return -EINVAL;
+		}
+		dev->syscon_base = syscon_node_to_regmap(args.np);
+		of_node_put(args.np);
+		if (IS_ERR(dev->syscon_base))
+			return PTR_ERR(dev->syscon_base);
+
+		dev->syscon_offset_18 = args.args[0];
+		dev->syscon_offset_34 = args.args[1];
+		ret = dw_i2srx_clk_init(pdev, dev);
+		if (ret < 0)
+			goto err_init;
+		dev->is_master = false;
+		dev->susport_rate = SNDRV_PCM_RATE_8000_192000;
+	} else if (of_device_is_compatible(np, "starfive,jh7110-i2stx-4ch0")) {
+		/* hdmi audio  */
+		ret = dw_i2stx_4ch0_clk_init(pdev, dev);
+		if (ret < 0)
+			goto err_init;
+		dev->is_master = true;
+		dev->susport_rate = SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_48000;
+	} else if (of_device_is_compatible(np, "starfive,jh7110-i2stx-4ch1")) {
+		ret = dw_i2stx_4ch1_clk_init(pdev, dev);
+		if (ret < 0)
+			goto err_init;
+		dev->is_master = false;
+		dev->susport_rate = SNDRV_PCM_RATE_8000_192000;
+	}
+
+	dev->i2s_reg_comp1 = I2S_COMP_PARAM_1;
+	dev->i2s_reg_comp2 = I2S_COMP_PARAM_2;
+
+	if (pdata) {
+		dev->capability = pdata->cap;
+		clk_id = NULL;
+		dev->quirks = pdata->quirks;
+		if (dev->quirks & DW_I2S_QUIRK_COMP_REG_OFFSET) {
+			dev->i2s_reg_comp1 = pdata->i2s_reg_comp1;
+			dev->i2s_reg_comp2 = pdata->i2s_reg_comp2;
+		}
+		ret = dw_configure_dai_by_pd(dev, dw_i2s_dai, res, pdata);
+	} else {
+		clk_id = "i2stx_bclk";
+		ret = dw_configure_dai_by_dt(dev, dw_i2s_dai, res);
+	}
+	if (ret < 0)
+		goto err_clk_disable;
+
+	if (dev->capability & DW_I2S_MASTER) {
+		if (pdata) {
+			dev->i2s_clk_cfg = pdata->i2s_clk_cfg;
+			if (!dev->i2s_clk_cfg) {
+				dev_err(&pdev->dev, "no clock configure method\n");
+				ret = -ENODEV;
+				goto err_clk_disable;
+			}
+		}
+	}
+
+	dev_set_drvdata(&pdev->dev, dev);
+	ret = devm_snd_soc_register_component(&pdev->dev, &dw_i2s_component,
+					 dw_i2s_dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "not able to register dai\n");
+		goto err_clk_disable;
+	}
+
+	if (!pdata) {
+		if (irq >= 0) {
+			ret = dw_pcm_register(pdev);
+			dev->use_pio = true;
+		} else {
+			ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,
+					0);
+			dev->use_pio = false;
+		}
+
+		if (ret) {
+			dev_err(&pdev->dev, "could not register pcm: %d\n",
+					ret);
+			goto err_clk_disable;
+		}
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+#ifdef CONFIG_PM
+	clk_disable_unprepare(dev->clk_i2s_bclk_mst);
+	clk_disable_unprepare(dev->clk_i2s_apb);
+#endif
+
+	return 0;
+
+err_clk_disable:
+	clk_disable_unprepare(dev->clk_i2s_bclk_mst);
+	clk_disable_unprepare(dev->clk_i2s_apb);
+err_init:
+	return ret;
+}
+
+static int dw_i2s_remove(struct platform_device *pdev)
+{
+#ifndef CONFIG_PM
+	struct dw_i2s_dev *dev = dev_get_drvdata(&pdev->dev);
+
+	clk_disable_unprepare(dev->clk_i2s_bclk_mst);
+	clk_disable_unprepare(dev->clk_i2s_apb);
+#endif
+
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id dw_i2s_of_match[] = {
+	{ .compatible = "starfive,jh7110-i2srx-master", },
+	{ .compatible = "starfive,jh7110-i2srx", },
+	{ .compatible = "starfive,jh7110-i2stx-4ch0", },
+	{ .compatible = "starfive,jh7110-i2stx-4ch1", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, dw_i2s_of_match);
+#endif
+
+static const struct dev_pm_ops dwc_pm_ops = {
+	SET_RUNTIME_PM_OPS(dw_i2s_runtime_suspend, dw_i2s_runtime_resume, NULL)
+};
+
+static struct platform_driver dw_i2s_driver = {
+	.probe		= dw_i2s_probe,
+	.remove		= dw_i2s_remove,
+	.driver		= {
+		.name	= "starfive-i2s",
+		.of_match_table = of_match_ptr(dw_i2s_of_match),
+		.pm = &dwc_pm_ops,
+	},
+};
+
+module_platform_driver(dw_i2s_driver);
+
+MODULE_AUTHOR("Rajeev Kumar <rajeevkumar.linux@gmail.com>");
+MODULE_AUTHOR("Walker Chen <walker.chen@starfivetech.com>");
+MODULE_AUTHOR("Xingyu Wu <xingyu.wu@starfivetech.com>");
+MODULE_DESCRIPTION("DESIGNWARE I2S SoC Interface");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:designware_i2s");
diff --git a/sound/soc/starfive/starfive_i2s.h b/sound/soc/starfive/starfive_i2s.h
new file mode 100644
index 000000000000..8effed739fdd
--- /dev/null
+++ b/sound/soc/starfive/starfive_i2s.h
@@ -0,0 +1,160 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (ST) 2012 Rajeev Kumar (rajeevkumar.linux@gmail.com)
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __STARFIVE_I2S_H
+#define __STARFIVE_I2S_H
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <sound/designware_i2s.h>
+
+/* common register for all channel */
+#define IER		0x000
+#define IRER		0x004
+#define ITER		0x008
+#define CER		0x00C
+#define CCR		0x010
+#define RXFFR		0x014
+#define TXFFR		0x018
+
+/* Interrupt status register fields */
+#define ISR_TXFO	BIT(5)
+#define ISR_TXFE	BIT(4)
+#define ISR_RXFO	BIT(1)
+#define ISR_RXDA	BIT(0)
+
+/* I2STxRxRegisters for all channels */
+#define LRBR_LTHR(x)	(0x40 * x + 0x020)
+#define RRBR_RTHR(x)	(0x40 * x + 0x024)
+#define RER(x)		(0x40 * x + 0x028)
+#define TER(x)		(0x40 * x + 0x02C)
+#define RCR(x)		(0x40 * x + 0x030)
+#define TCR(x)		(0x40 * x + 0x034)
+#define ISR(x)		(0x40 * x + 0x038)
+#define IMR(x)		(0x40 * x + 0x03C)
+#define ROR(x)		(0x40 * x + 0x040)
+#define TOR(x)		(0x40 * x + 0x044)
+#define RFCR(x)		(0x40 * x + 0x048)
+#define TFCR(x)		(0x40 * x + 0x04C)
+#define RFF(x)		(0x40 * x + 0x050)
+#define TFF(x)		(0x40 * x + 0x054)
+
+/* I2SCOMPRegisters */
+#define I2S_COMP_PARAM_2	0x01F0
+#define I2S_COMP_PARAM_1	0x01F4
+#define I2S_COMP_VERSION	0x01F8
+#define I2S_COMP_TYPE		0x01FC
+
+/*
+ * Component parameter register fields - define the I2S block's
+ * configuration.
+ */
+#define	COMP1_TX_WORDSIZE_3(r)	(((r) & GENMASK(27, 25)) >> 25)
+#define	COMP1_TX_WORDSIZE_2(r)	(((r) & GENMASK(24, 22)) >> 22)
+#define	COMP1_TX_WORDSIZE_1(r)	(((r) & GENMASK(21, 19)) >> 19)
+#define	COMP1_TX_WORDSIZE_0(r)	(((r) & GENMASK(18, 16)) >> 16)
+#define	COMP1_TX_CHANNELS(r)	(((r) & GENMASK(10, 9)) >> 9)
+#define	COMP1_RX_CHANNELS(r)	(((r) & GENMASK(8, 7)) >> 7)
+#define	COMP1_RX_ENABLED(r)	(((r) & BIT(6)) >> 6)
+#define	COMP1_TX_ENABLED(r)	(((r) & BIT(5)) >> 5)
+#define	COMP1_MODE_EN(r)	(((r) & BIT(4)) >> 4)
+#define	COMP1_FIFO_DEPTH_GLOBAL(r)	(((r) & GENMASK(3, 2)) >> 2)
+#define	COMP1_APB_DATA_WIDTH(r)	(((r) & GENMASK(1, 0)) >> 0)
+
+#define	COMP2_RX_WORDSIZE_3(r)	(((r) & GENMASK(12, 10)) >> 10)
+#define	COMP2_RX_WORDSIZE_2(r)	(((r) & GENMASK(9, 7)) >> 7)
+#define	COMP2_RX_WORDSIZE_1(r)	(((r) & GENMASK(5, 3)) >> 3)
+#define	COMP2_RX_WORDSIZE_0(r)	(((r) & GENMASK(2, 0)) >> 0)
+
+/* Number of entries in WORDSIZE and DATA_WIDTH parameter registers */
+#define	COMP_MAX_WORDSIZE	(1 << 3)
+#define	COMP_MAX_DATA_WIDTH	(1 << 2)
+
+#define MAX_CHANNEL_NUM		8
+#define MIN_CHANNEL_NUM		2
+
+/* SYSCON Registers */
+#define I2SRX_3CH_ADC_MASK	0x2
+#define I2SRX_3CH_ADC_EN	BIT(1)
+#define AUDIO_SDIN_MUX_MASK	0x3FC00
+#define I2SRX_DATA_SRC_PDM	(0x91 << 10)
+
+union dw_i2s_snd_dma_data {
+	struct i2s_dma_data pd;
+	struct snd_dmaengine_dai_dma_data dt;
+};
+
+struct dw_i2s_dev {
+	void __iomem *i2s_base;
+	struct regmap *syscon_base;
+	int active;
+	unsigned int capability;
+	unsigned int quirks;
+	unsigned int i2s_reg_comp1;
+	unsigned int i2s_reg_comp2;
+	struct device *dev;
+	u32 ccr;
+	u32 xfer_resolution;
+	u32 fifo_th;
+	u32 syscon_offset_18;
+	u32 syscon_offset_34;
+
+	struct clk *clk_apb0;
+	struct clk *clk_i2s_apb;
+	struct clk *clk_i2s_bclk_mst;
+	struct clk *clk_i2s_lrck_mst;
+	struct clk *clk_i2s_bclk;
+	struct clk *clk_i2s_lrck;
+	struct clk *clk_mclk;
+	struct clk *clk_mclk_ext;
+	struct clk *clk_mclk_inner;
+	struct clk *clk_bclk_ext;
+	struct clk *clk_lrck_ext;
+	struct reset_control *rst_i2s_apb;
+	struct reset_control *rst_i2s_bclk;
+
+	/* data related to DMA transfers b/w i2s and DMAC */
+	union dw_i2s_snd_dma_data play_dma_data;
+	union dw_i2s_snd_dma_data capture_dma_data;
+	struct i2s_clk_config_data config;
+	int (*i2s_clk_cfg)(struct i2s_clk_config_data *config);
+
+	/* data related to PIO transfers */
+	bool use_pio;
+	struct snd_pcm_substream __rcu *tx_substream;
+	struct snd_pcm_substream __rcu *rx_substream;
+	unsigned int (*tx_fn)(struct dw_i2s_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+			bool *period_elapsed);
+	unsigned int (*rx_fn)(struct dw_i2s_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int rx_ptr,
+			bool *period_elapsed);
+	unsigned int tx_ptr;
+	unsigned int rx_ptr;
+	bool is_master;
+	unsigned int susport_rate;
+};
+
+#if IS_ENABLED(CONFIG_SND_DESIGNWARE_PCM)
+void dw_pcm_push_tx(struct dw_i2s_dev *dev);
+void dw_pcm_pop_rx(struct dw_i2s_dev *dev);
+int dw_pcm_register(struct platform_device *pdev);
+#else
+static inline void dw_pcm_push_tx(struct dw_i2s_dev *dev) { }
+static inline void dw_pcm_pop_rx(struct dw_i2s_dev *dev) { }
+static inline int dw_pcm_register(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
diff --git a/sound/soc/starfive/starfive_pdm.c b/sound/soc/starfive/starfive_pdm.c
new file mode 100644
index 000000000000..ba0a9143f57b
--- /dev/null
+++ b/sound/soc/starfive/starfive_pdm.c
@@ -0,0 +1,445 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * PDM driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/reset.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/pm_runtime.h>
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include "starfive_pdm.h"
+
+struct sf_pdm {
+	struct regmap *pdm_map;
+	struct device *dev;
+	struct clk *clk_pdm_apb;
+	struct clk *clk_pdm_mclk;
+	struct clk *clk_mclk;
+	struct clk *clk_mclk_ext;
+	struct reset_control *rst_pdm_dmic;
+	struct reset_control *rst_pdm_apb;
+	unsigned char flag_first;
+	unsigned int saved_ctrl0;
+	unsigned int saved_scale0;
+};
+
+static const DECLARE_TLV_DB_SCALE(volume_tlv, -9450, 150, 0);
+
+static const struct snd_kcontrol_new sf_pdm_snd_controls[] = {
+	SOC_SINGLE("DC compensation Control", PDM_DMIC_CTRL0, 30, 1, 0),
+	SOC_SINGLE("High Pass Filter Control", PDM_DMIC_CTRL0, 28, 1, 0),
+	SOC_SINGLE("Left Channel Volume Control", PDM_DMIC_CTRL0, 23, 1, 0),
+	SOC_SINGLE("Right Channel Volume Control", PDM_DMIC_CTRL0, 22, 1, 0),
+	SOC_SINGLE_TLV("Volume", PDM_DMIC_CTRL0, 16, 0x3F, 1, volume_tlv),
+	SOC_SINGLE("Data MSB Shift", PDM_DMIC_CTRL0, 1, 7, 0),
+	SOC_SINGLE("SCALE", PDM_DC_SCALE0, 0, 0x3F, 0),
+	SOC_SINGLE("DC offset", PDM_DC_SCALE0, 8, 0xFFFFF, 0),
+};
+
+static void sf_pdm_enable(struct regmap *map)
+{
+	/* Left and Right Channel Volume Control Enable */
+	regmap_update_bits(map, PDM_DMIC_CTRL0, PDM_DMIC_RVOL_MASK, 0);
+	regmap_update_bits(map, PDM_DMIC_CTRL0, PDM_DMIC_LVOL_MASK, 0);
+}
+
+static void sf_pdm_disable(struct regmap *map)
+{
+	/* Left and Right Channel Volume Control Disable */
+	regmap_update_bits(map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_RVOL_MASK, PDM_DMIC_RVOL_MASK);
+	regmap_update_bits(map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_LVOL_MASK, PDM_DMIC_LVOL_MASK);
+}
+
+static int sf_pdm_trigger(struct snd_pcm_substream *substream, int cmd,
+			   struct snd_soc_dai *dai)
+{
+	struct sf_pdm *priv = snd_soc_dai_get_drvdata(dai);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (priv->flag_first) {
+			priv->flag_first = 0;
+			mdelay(200);
+		}
+
+		sf_pdm_enable(priv->pdm_map);
+		return 0;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		sf_pdm_disable(priv->pdm_map);
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sf_pdm_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *dai)
+{
+	struct sf_pdm *priv = snd_soc_dai_get_drvdata(dai);
+	unsigned int sample_rate;
+	unsigned int data_width;
+	int ret;
+	const int pdm_mul = 128;
+
+	sample_rate = params_rate(params);
+	switch (sample_rate) {
+	case 8000:
+	case 11025:
+	case 16000:
+		break;
+	default:
+		dev_err(priv->dev, "can't support sample rate:%d\n", sample_rate);
+		return -EINVAL;
+	}
+
+	data_width = params_width(params);
+	switch (data_width) {
+	case 16:
+	case 32:
+		break;
+	default:
+		dev_err(priv->dev, "can't support bit width %d\n", data_width);
+		return -EINVAL;
+	}
+
+	/* set pdm_mclk,  PDM MCLK = 128 * LRCLK */
+	ret = clk_set_rate(priv->clk_pdm_mclk, pdm_mul * sample_rate);
+	if (ret) {
+		dev_err(priv->dev, "Can't set pdm_mclk: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sf_pdm_dai_ops = {
+	.trigger	= sf_pdm_trigger,
+	.hw_params	= sf_pdm_hw_params,
+};
+
+static void sf_pdm_module_init(struct sf_pdm *priv)
+{
+	/* Reset */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_SW_RST_MASK, 0x00);
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_SW_RST_MASK, PDM_SW_RST_RELEASE);
+
+	/* Make sure the device is initially disabled */
+	sf_pdm_disable(priv->pdm_map);
+
+	/* MUTE */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_VOL_MASK, PDM_VOL_DB_MUTE);
+
+	/* UNMUTE */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_VOL_MASK, PDM_VOL_DB_MAX);
+
+	/* enable high pass filter */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_HPF_EN, PDM_DMIC_HPF_EN);
+
+	/* i2s slave mode */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_I2S_SLAVE, PDM_DMIC_I2S_SLAVE);
+
+	/* disable fast mode */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_FASTMODE_MASK, 0);
+
+	/* dmic msb shift 0 */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_MSB_MASK, 0);
+
+	/* scale: 0x8 */
+	regmap_update_bits(priv->pdm_map, PDM_DC_SCALE0,
+			   DMIC_SCALE_MASK, DMIC_SCALE_DEF_VAL);
+
+	regmap_update_bits(priv->pdm_map, PDM_DC_SCALE0,
+			   DMIC_DCOFF1_MASK, DMIC_DCOFF1_VAL);
+
+	regmap_update_bits(priv->pdm_map, PDM_DC_SCALE0,
+			   DMIC_DCOFF3_MASK, DMIC_DCOFF3_VAL);
+
+	/* scale: 0x3f */
+	regmap_update_bits(priv->pdm_map, PDM_DC_SCALE0,
+			   DMIC_SCALE_MASK, DMIC_SCALE_MASK);
+
+	/* dmic msb shift 2 */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+			   PDM_DMIC_MSB_MASK, PDM_MSB_SHIFT_4);
+}
+
+#define SF_PDM_RATES	(SNDRV_PCM_RATE_8000 | \
+			SNDRV_PCM_RATE_11025 | \
+			SNDRV_PCM_RATE_16000)
+
+#define SF_PDM_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_driver sf_pdm_dai_drv = {
+	.name = "PDM",
+	.id = 0,
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= SF_PDM_RATES,
+		.formats	= SF_PDM_FORMATS,
+	},
+	.ops = &sf_pdm_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static int sf_pdm_component_probe(struct snd_soc_component *component)
+{
+	struct sf_pdm *priv = snd_soc_component_get_drvdata(component);
+
+	snd_soc_component_init_regmap(component, priv->pdm_map);
+	snd_soc_add_component_controls(component, sf_pdm_snd_controls,
+				       ARRAY_SIZE(sf_pdm_snd_controls));
+
+	return 0;
+}
+
+static int sf_pdm_clock_enable(struct sf_pdm *priv)
+{
+	int ret;
+
+	ret = clk_prepare_enable(priv->clk_pdm_mclk);
+	if (ret) {
+		dev_err(priv->dev, "failed to prepare enable clk_pdm_mclk\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(priv->clk_pdm_apb);
+	if (ret) {
+		dev_err(priv->dev, "failed to prepare enable clk_pdm_apb\n");
+		goto disable_pdm_mclk;
+	}
+
+	ret = reset_control_deassert(priv->rst_pdm_dmic);
+	if (ret) {
+		dev_err(priv->dev, "failed to deassert pdm_dmic\n");
+		goto disable_pdm_apb;
+	}
+
+	ret = reset_control_deassert(priv->rst_pdm_apb);
+	if (ret) {
+		dev_err(priv->dev, "failed to deassert pdm_apb\n");
+		goto disable_pdm_apb;
+	}
+
+	ret = clk_set_parent(priv->clk_mclk, priv->clk_mclk_ext);
+	if (ret) {
+		dev_err(priv->dev, "failed to set parent clk_mclk ret=%d\n", ret);
+		goto disable_pdm_apb;
+	}
+
+	return 0;
+
+disable_pdm_apb:
+	clk_disable_unprepare(priv->clk_pdm_apb);
+disable_pdm_mclk:
+	clk_disable_unprepare(priv->clk_pdm_mclk);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int sf_pdm_runtime_suspend(struct device *dev)
+{
+	struct sf_pdm *priv = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(priv->clk_pdm_apb);
+	clk_disable_unprepare(priv->clk_pdm_mclk);
+
+	return 0;
+}
+
+static int sf_pdm_runtime_resume(struct device *dev)
+{
+	struct sf_pdm *priv = dev_get_drvdata(dev);
+	int ret;
+
+	ret = sf_pdm_clock_enable(priv);
+	if (!ret)
+		sf_pdm_module_init(priv);
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int sf_pdm_suspend(struct snd_soc_component *component)
+{
+	return pm_runtime_force_suspend(component->dev);
+}
+
+static int sf_pdm_resume(struct snd_soc_component *component)
+{
+	return pm_runtime_force_resume(component->dev);
+}
+
+#else
+#define sf_pdm_suspend	NULL
+#define sf_pdm_resume	NULL
+#endif
+
+static const struct snd_soc_component_driver sf_pdm_component_drv = {
+	.name = "jh7110-pdm",
+	.probe = sf_pdm_component_probe,
+	.suspend = sf_pdm_suspend,
+	.resume = sf_pdm_resume,
+};
+
+static const struct regmap_config sf_pdm_regmap_cfg = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x20,
+};
+
+static int sf_pdm_clock_get(struct platform_device *pdev, struct sf_pdm *priv)
+{
+	int ret;
+
+	static struct clk_bulk_data clks[] = {
+		{ .id = "pdm_mclk" },
+		{ .id = "pdm_apb" },
+		{ .id = "clk_mclk" },
+		{ .id = "mclk_ext" },
+	};
+
+	ret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(clks), clks);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get pdm clocks\n");
+		goto exit;
+	}
+
+	priv->clk_pdm_mclk = clks[0].clk;
+	priv->clk_pdm_apb = clks[1].clk;
+	priv->clk_mclk = clks[2].clk;
+	priv->clk_mclk_ext = clks[3].clk;
+
+	priv->rst_pdm_dmic = devm_reset_control_get_exclusive(&pdev->dev, "pdm_dmic");
+	if (IS_ERR(priv->rst_pdm_dmic)) {
+		dev_err(&pdev->dev, "failed to get pdm_dmic reset control\n");
+		ret = PTR_ERR(priv->rst_pdm_dmic);
+		goto exit;
+	}
+
+	priv->rst_pdm_apb = devm_reset_control_get_exclusive(&pdev->dev, "pdm_apb");
+	if (IS_ERR(priv->rst_pdm_apb)) {
+		dev_err(&pdev->dev, "failed to get pdm_apb reset control\n");
+		ret = PTR_ERR(priv->rst_pdm_apb);
+		goto exit;
+	}
+
+	/*
+	 * pdm clock must always be enabled as hardware issue that
+	 * no data in the first 4 seconds of the first recording
+	 */
+	ret = sf_pdm_clock_enable(priv);
+
+exit:
+	return ret;
+}
+
+static int sf_pdm_probe(struct platform_device *pdev)
+{
+	struct sf_pdm *priv;
+	struct resource *res;
+	void __iomem *regs;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, priv);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pdm");
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	priv->pdm_map = devm_regmap_init_mmio(&pdev->dev, regs, &sf_pdm_regmap_cfg);
+	if (IS_ERR(priv->pdm_map)) {
+		dev_err(&pdev->dev, "failed to init regmap: %ld\n",
+			PTR_ERR(priv->pdm_map));
+		return PTR_ERR(priv->pdm_map);
+	}
+
+	priv->dev = &pdev->dev;
+	priv->flag_first = 1;
+
+	ret = sf_pdm_clock_get(pdev, priv);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable audio-pdm clock\n");
+		return ret;
+	}
+
+	dev_set_drvdata(&pdev->dev, priv);
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sf_pdm_component_drv,
+					      &sf_pdm_dai_drv, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register pdm dai\n");
+		return ret;
+	}
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
+}
+
+static int sf_pdm_dev_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+
+static const struct of_device_id sf_pdm_of_match[] = {
+	{.compatible = "starfive,jh7110-pdm",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sf_pdm_of_match);
+
+static const struct dev_pm_ops sf_pdm_pm_ops = {
+	SET_RUNTIME_PM_OPS(sf_pdm_runtime_suspend,
+			   sf_pdm_runtime_resume, NULL)
+};
+
+static struct platform_driver sf_pdm_driver = {
+	.driver = {
+		.name = "jh7110-pdm",
+		.of_match_table = sf_pdm_of_match,
+		.pm = &sf_pdm_pm_ops,
+	},
+	.probe = sf_pdm_probe,
+	.remove = sf_pdm_dev_remove,
+};
+module_platform_driver(sf_pdm_driver);
+
+MODULE_AUTHOR("Walker Chen <walker.chen@starfivetech.com>");
+MODULE_DESCRIPTION("Starfive PDM Controller Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/starfive/starfive_pdm.h b/sound/soc/starfive/starfive_pdm.h
new file mode 100644
index 000000000000..4f514a06cb07
--- /dev/null
+++ b/sound/soc/starfive/starfive_pdm.h
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * PDM driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef __SND_SOC_STARFIVE_PDM_H__
+#define __SND_SOC_STARFIVE_PDM_H__
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <linux/dmaengine.h>
+#include <linux/types.h>
+
+#define PDM_DMIC_CTRL0			0x00
+#define PDM_DC_SCALE0			0x04
+#define PDM_DMIC_CTRL1			0x10
+#define PDM_DC_SCALE1			0x14
+
+/* PDM CTRL OFFSET */
+#define PDM_DMIC_MSB_SHIFT		1
+#define PDM_DMIC_MSB_MASK		(0x7 << PDM_DMIC_MSB_SHIFT)
+#define PDM_DMIC_VOL_SHIFT		16
+#define PDM_DMIC_VOL_MASK		(0x3f << PDM_DMIC_VOL_SHIFT)
+#define PDM_VOL_DB_MUTE			(0x3f << PDM_DMIC_VOL_SHIFT)
+#define PDM_VOL_DB_MAX			0
+
+#define PDM_DMIC_RVOL_MASK		BIT(22)
+#define PDM_DMIC_LVOL_MASK		BIT(23)
+#define PDM_DMIC_I2S_SLAVE		BIT(24)
+#define PDM_DMIC_HPF_EN			BIT(28)
+#define PDM_DMIC_FASTMODE_MASK		BIT(29)
+#define PDM_DMIC_DC_BYPASS_MASK		BIT(30)
+#define PDM_SW_RST_MASK			BIT(31)
+#define PDM_SW_RST_RELEASE		BIT(31)
+
+/* PDM SCALE OFFSET */
+#define DMIC_DCOFF3_SHIFT		24
+#define DMIC_DCOFF2_SHIFT		16
+#define DMIC_DCOFF1_SHIFT		8
+
+#define DMIC_DCOFF3_MASK		(0xf << DMIC_DCOFF3_SHIFT)
+#define DMIC_DCOFF3_VAL			(0xc << DMIC_DCOFF3_SHIFT)
+#define DMIC_DCOFF1_MASK		(0xff << DMIC_DCOFF1_SHIFT)
+#define DMIC_DCOFF1_VAL			(0x5 << DMIC_DCOFF1_SHIFT)
+#define DMIC_SCALE_MASK			0x3f
+#define DMIC_SCALE_DEF_VAL		0x8
+
+enum PDM_MSB_SHIFT {
+	PDM_MSB_SHIFT_NONE = 0,
+	PDM_MSB_SHIFT_1,
+	PDM_MSB_SHIFT_2,
+	PDM_MSB_SHIFT_3,
+	PDM_MSB_SHIFT_4,
+	PDM_MSB_SHIFT_5,
+	PDM_MSB_SHIFT_6,
+	PDM_MSB_SHIFT_7,
+};
+
+#endif	/* __SND_SOC_STARFIVE_PDM_H__ */
diff --git a/sound/soc/starfive/starfive_pwmdac.c b/sound/soc/starfive/starfive_pwmdac.c
new file mode 100644
index 000000000000..63b7d8b0d51c
--- /dev/null
+++ b/sound/soc/starfive/starfive_pwmdac.c
@@ -0,0 +1,958 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * PWMDAC driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/kthread.h>
+#include <linux/reset.h>
+#include <linux/dma/starfive-dma.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include "pwmdac.h"
+
+struct ct_pwmdac {
+	char *name;
+	unsigned int vals;
+};
+
+static const struct ct_pwmdac pwmdac_ct_shift_bit[] = {
+	{ .name = "8bit", .vals = PWMDAC_SHIFT_8 },
+	{ .name = "10bit", .vals = PWMDAC_SHIFT_10 }
+};
+
+static const struct ct_pwmdac pwmdac_ct_duty_cycle[] = {
+	{ .name = "left", .vals = PWMDAC_CYCLE_LEFT },
+	{ .name = "right", .vals = PWMDAC_CYCLE_RIGHT },
+	{ .name = "center", .vals = PWMDAC_CYCLE_CENTER }
+};
+
+static const struct ct_pwmdac pwmdac_ct_data_mode[] = {
+	{ .name = "unsinged", .vals = UNSINGED_DATA },
+	{ .name = "inverter", .vals = INVERTER_DATA_MSB }
+};
+
+static const struct ct_pwmdac pwmdac_ct_lr_change[] = {
+	{ .name = "no_change", .vals = NO_CHANGE },
+	{ .name = "change", .vals = CHANGE }
+};
+
+static const struct ct_pwmdac pwmdac_ct_shift[] = {
+	{ .name = "left 0 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_0 },
+	{ .name = "left 1 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_1 },
+	{ .name = "left 2 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_2 },
+	{ .name = "left 3 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_3 },
+	{ .name = "left 4 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_4 },
+	{ .name = "left 5 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_5 },
+	{ .name = "left 6 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_6 }
+};
+
+static int pwmdac_shift_bit_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_shift_bit);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_shift_bit[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+static int pwmdac_shift_bit_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	unsigned int item;
+
+	if (dev->shift_bit == pwmdac_ct_shift_bit[0].vals)
+		item = 0;
+	else
+		item = 1;
+
+	ucontrol->value.enumerated.item[0] = item;
+
+	return 0;
+}
+
+static int pwmdac_shift_bit_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_shift_bit);
+
+	if (sel > items)
+		return 0;
+
+	switch (sel) {
+	case 1:
+		dev->shift_bit = pwmdac_ct_shift_bit[1].vals;
+		break;
+	default:
+		dev->shift_bit = pwmdac_ct_shift_bit[0].vals;
+		break;
+	}
+
+	return 0;
+}
+
+static int pwmdac_duty_cycle_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_duty_cycle);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_duty_cycle[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int pwmdac_duty_cycle_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.enumerated.item[0] = dev->duty_cycle;
+	return 0;
+}
+
+static int pwmdac_duty_cycle_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_duty_cycle);
+
+	if (sel > items)
+		return 0;
+
+	dev->duty_cycle = pwmdac_ct_duty_cycle[sel].vals;
+	return 0;
+}
+
+static int pwmdac_data_mode_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_data_mode);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_data_mode[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int pwmdac_data_mode_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.enumerated.item[0] = dev->data_mode;
+	return 0;
+}
+
+static int pwmdac_data_mode_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_data_mode);
+
+	if (sel > items)
+		return 0;
+
+	dev->data_mode = pwmdac_ct_data_mode[sel].vals;
+	return 0;
+}
+
+static int pwmdac_shift_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_shift);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_shift[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int pwmdac_shift_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	unsigned int item = dev->shift;
+
+	ucontrol->value.enumerated.item[0] =  pwmdac_ct_shift[item].vals;
+	return 0;
+}
+
+static int pwmdac_shift_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_shift);
+
+	if (sel > items)
+		return 0;
+
+	dev->shift = pwmdac_ct_shift[sel].vals;
+	return 0;
+}
+
+static int pwmdac_lr_change_info(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_lr_change);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_lr_change[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int pwmdac_lr_change_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.enumerated.item[0] = dev->lr_change;
+	return 0;
+}
+
+static int pwmdac_lr_change_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_lr_change);
+
+	if (sel > items)
+		return 0;
+
+	dev->lr_change = pwmdac_ct_lr_change[sel].vals;
+	return 0;
+}
+
+static inline void pwmdc_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 pwmdc_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+/*
+ * 32bit-4byte
+ */
+static void pwmdac_set_ctrl_enable(struct sf_pwmdac_dev *dev)
+{
+	u32 date;
+
+	date = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, date | BIT(0));
+}
+
+/*
+ * 32bit-4byte
+ */
+static void pwmdac_set_ctrl_disable(struct sf_pwmdac_dev *dev)
+{
+	u32 date;
+
+	date = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, date & ~BIT(0));
+}
+
+/*
+ * 8:8-bit
+ * 10:10-bit
+ */
+static void pwmdac_set_ctrl_shift(struct sf_pwmdac_dev *dev, u8 data)
+{
+	u32 value = 0;
+
+	if (data == PWMDAC_SHIFT_8) {
+		value = (~((~value) | SFC_PWMDAC_SHIFT));
+		pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+	} else if (data == PWMDAC_SHIFT_10) {
+		value |= SFC_PWMDAC_SHIFT;
+		pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+	}
+}
+
+/*
+ * 00:left
+ * 01:right
+ * 10:center
+ */
+static void pwmdac_set_ctrl_dutyCycle(struct sf_pwmdac_dev *dev, u8 data)
+{
+	u32 value = 0;
+
+	value = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	if (data == PWMDAC_CYCLE_LEFT) {
+		value = (~((~value) | (0x03<<PWMDAC_DUTY_CYCLE_LOW)));
+		pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+	} else if (data == PWMDAC_CYCLE_RIGHT) {
+		value = (~((~value) | (0x01<<PWMDAC_DUTY_CYCLE_HIGH))) |
+			(0x01<<PWMDAC_DUTY_CYCLE_LOW);
+		pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+	} else if (data == PWMDAC_CYCLE_CENTER) {
+		value = (~((~value) | (0x01<<PWMDAC_DUTY_CYCLE_LOW))) |
+			(0x01<<PWMDAC_DUTY_CYCLE_HIGH);
+		pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+	}
+}
+
+
+static void pwmdac_set_ctrl_N(struct sf_pwmdac_dev *dev, u16 data)
+{
+	u32 value = 0;
+
+	value = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL,
+		(value & PWMDAC_CTRL_DATA_MASK) | ((data - 1) << PWMDAC_CTRL_DATA_SHIFT));
+}
+
+
+static void pwmdac_LR_data_change(struct sf_pwmdac_dev *dev, u8 data)
+{
+	u32 value = 0;
+
+	value = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	switch (data) {
+	case NO_CHANGE:
+		value &= (~SFC_PWMDAC_LEFT_RIGHT_DATA_CHANGE);
+		break;
+	case CHANGE:
+		value |= SFC_PWMDAC_LEFT_RIGHT_DATA_CHANGE;
+		break;
+	}
+
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+}
+
+static void pwmdac_data_mode(struct sf_pwmdac_dev *dev,  u8 data)
+{
+	u32 value = 0;
+
+	value = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	if (data == UNSINGED_DATA)
+		value &= (~SFC_PWMDAC_DATA_MODE);
+	else if (data == INVERTER_DATA_MSB)
+		value |= SFC_PWMDAC_DATA_MODE;
+
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+}
+
+static int pwmdac_data_shift(struct sf_pwmdac_dev *dev, u8 data)
+{
+	u32 value = 0;
+
+	if ((data < PWMDAC_DATA_LEFT_SHIFT_BIT_0) ||
+			(data > PWMDAC_DATA_LEFT_SHIFT_BIT_7))
+		return -1;
+
+	value = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	value &= (~(PWMDAC_DATA_LEFT_SHIFT_BIT_ALL << PWMDAC_DATA_LEFT_SHIFT));
+	value |= (data<<PWMDAC_DATA_LEFT_SHIFT);
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+	return 0;
+}
+
+static int get_pwmdac_fifo_state(struct sf_pwmdac_dev *dev)
+{
+	u32 value;
+
+	value = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_SATAE);
+	if ((value & 0x02) == 0)
+		return FIFO_UN_FULL;
+
+	return FIFO_FULL;
+}
+
+static void pwmdac_set(struct sf_pwmdac_dev *dev)
+{
+	/*8-bit + left + N=16*/
+	pwmdac_set_ctrl_shift(dev, dev->shift_bit);
+	pwmdac_set_ctrl_dutyCycle(dev, dev->duty_cycle);
+	pwmdac_set_ctrl_N(dev, dev->datan);
+	pwmdac_set_ctrl_enable(dev);
+
+	pwmdac_LR_data_change(dev, dev->lr_change);
+	pwmdac_data_mode(dev, dev->data_mode);
+	if (dev->shift)
+		pwmdac_data_shift(dev, dev->shift);
+}
+
+static void pwmdac_stop(struct sf_pwmdac_dev *dev)
+{
+	pwmdac_set_ctrl_disable(dev);
+}
+
+static int pwmdac_config(struct sf_pwmdac_dev *dev)
+{
+	switch (dev->mode) {
+	case shift_8Bit_unsigned:
+	case shift_8Bit_unsigned_dataShift:
+		/* 8 bit, unsigned */
+		dev->shift_bit	= PWMDAC_SHIFT_8;
+		dev->duty_cycle	= PWMDAC_CYCLE_CENTER;
+		dev->datan	= PWMDAC_SAMPLE_CNT_8;
+		dev->data_mode	= UNSINGED_DATA;
+		break;
+
+	case shift_8Bit_inverter:
+	case shift_8Bit_inverter_dataShift:
+		/* 8 bit, invert */
+		dev->shift_bit	= PWMDAC_SHIFT_8;
+		dev->duty_cycle	= PWMDAC_CYCLE_CENTER;
+		dev->datan	= PWMDAC_SAMPLE_CNT_8;
+		dev->data_mode	= INVERTER_DATA_MSB;
+		break;
+
+	case shift_10Bit_unsigned:
+	case shift_10Bit_unsigned_dataShift:
+		/* 10 bit, unsigend */
+		dev->shift_bit	= PWMDAC_SHIFT_10;
+		dev->duty_cycle	= PWMDAC_CYCLE_CENTER;
+		dev->datan	= PWMDAC_SAMPLE_CNT_8;
+		dev->data_mode	= UNSINGED_DATA;
+		break;
+
+	case shift_10Bit_inverter:
+	case shift_10Bit_inverter_dataShift:
+		/* 10 bit, invert */
+		dev->shift_bit	= PWMDAC_SHIFT_10;
+		dev->duty_cycle	= PWMDAC_CYCLE_CENTER;
+		dev->datan	= PWMDAC_SAMPLE_CNT_8;
+		dev->data_mode	= INVERTER_DATA_MSB;
+		break;
+
+	default:
+		return -1;
+	}
+
+	if ((dev->mode == shift_8Bit_unsigned_dataShift) ||
+		(dev->mode == shift_8Bit_inverter_dataShift) ||
+		(dev->mode == shift_10Bit_unsigned_dataShift) ||
+		(dev->mode == shift_10Bit_inverter_dataShift))
+		dev->shift = 4; /*0~7*/
+	else
+		dev->shift = 0;
+
+	dev->lr_change = NO_CHANGE;
+	return 0;
+}
+
+static int sf_pwmdac_prepare(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	return 0;
+}
+
+int pwmdac_tx_thread(void *dev)
+{
+	struct sf_pwmdac_dev *pwmdac_dev =  (struct sf_pwmdac_dev *)dev;
+
+	if (!pwmdac_dev) {
+		dev_err(pwmdac_dev->dev, "%s L.%d  dev is null.\n", __FILE__, __LINE__);
+		return -1;
+	}
+
+	while (!pwmdac_dev->tx_thread_exit) {
+		if (get_pwmdac_fifo_state(pwmdac_dev) == 0)
+			sf_pwmdac_pcm_push_tx(pwmdac_dev);
+		else
+			udelay(100);
+	}
+	return 0;
+}
+
+static int sf_pwmdac_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct sf_pwmdac_dev *dev = snd_soc_dai_get_drvdata(dai);
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev->active++;
+		pwmdac_set(dev);
+		if (dev->use_pio) {
+			dev->tx_thread = kthread_create(pwmdac_tx_thread, (void *)dev, "pwmdac");
+			if (IS_ERR(dev->tx_thread))
+				return PTR_ERR(dev->tx_thread);
+
+			wake_up_process(dev->tx_thread);
+			dev->tx_thread_exit = 0;
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev->active--;
+		axi_dma_cyclic_stop(chan);
+		mdelay(10);
+		pwmdac_stop(dev);
+		if (dev->use_pio) {
+			if (dev->tx_thread)
+				dev->tx_thread_exit = 1;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sf_pwmdac_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	int ret = 0;
+	unsigned long mclk_dac_value;
+	struct sf_pwmdac_dev *dev = dev_get_drvdata(dai->dev);
+
+	dev->play_dma_data.addr = dev->mapbase + PWMDAC_WDATA;
+
+	switch (params_rate(params)) {
+	case 8000:
+		dev->datan = PWMDAC_SAMPLE_CNT_3;
+		mclk_dac_value = 6144000;
+		break;
+	case 11025:
+		dev->datan = PWMDAC_SAMPLE_CNT_2;
+		mclk_dac_value = 5644800;
+		break;
+	case 16000:
+		dev->datan = PWMDAC_SAMPLE_CNT_3;
+		mclk_dac_value = 12288000;
+		break;
+	case 22050:
+		dev->datan = PWMDAC_SAMPLE_CNT_1;
+		mclk_dac_value = 5644800;
+		break;
+	case 32000:
+		dev->datan = PWMDAC_SAMPLE_CNT_1;
+		mclk_dac_value = 8192000;
+		break;
+	case 44100:
+		dev->datan = PWMDAC_SAMPLE_CNT_1;
+		mclk_dac_value = 11289600;
+		break;
+	case 48000:
+		dev->datan = PWMDAC_SAMPLE_CNT_1;
+		mclk_dac_value = 12288000;
+		break;
+	default:
+		dev_err(dai->dev, "%d rate not supported\n",
+				params_rate(params));
+		return -EINVAL;
+	}
+
+	switch (params_channels(params)) {
+	case 2:
+		dev->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	case 1:
+		dev->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	default:
+		dev_err(dai->dev, "%d channels not supported\n",
+				params_channels(params));
+		return -EINVAL;
+	}
+
+	/* The mclock for the clock driver always rounds down so add a little slack */
+	mclk_dac_value = mclk_dac_value + 64;
+	pwmdac_set(dev);
+
+	ret = clk_set_rate(dev->clk_pwmdac_core, mclk_dac_value);
+	if (ret) {
+		dev_err(dai->dev, "failed to set rate for clk_pwmdac_core %lu\n", mclk_dac_value);
+		goto err_clk_pwmdac;
+	}
+
+	dev->play_dma_data.fifo_size = 1;
+	dev->play_dma_data.maxburst = 16;
+
+	snd_soc_dai_init_dma_data(dai, &dev->play_dma_data, NULL);
+	snd_soc_dai_set_drvdata(dai, dev);
+
+	return 0;
+
+err_clk_pwmdac:
+	return ret;
+
+}
+
+static int sf_pwmdac_clks_get(struct platform_device *pdev,
+				struct sf_pwmdac_dev *dev)
+{
+	dev->clk_apb0 = devm_clk_get(&pdev->dev, "apb0");
+	if (IS_ERR(dev->clk_apb0))
+		return PTR_ERR(dev->clk_apb0);
+
+	dev->clk_pwmdac_apb = devm_clk_get(&pdev->dev, "pwmdac-apb");
+	if (IS_ERR(dev->clk_pwmdac_apb))
+		return PTR_ERR(dev->clk_pwmdac_apb);
+
+	dev->clk_pwmdac_core = devm_clk_get(&pdev->dev, "pwmdac-core");
+	if (IS_ERR(dev->clk_pwmdac_core))
+		return PTR_ERR(dev->clk_pwmdac_core);
+
+	return 0;
+}
+
+static int sf_pwmdac_resets_get(struct platform_device *pdev,
+				struct sf_pwmdac_dev *dev)
+{
+	dev->rst_apb = devm_reset_control_get_exclusive(&pdev->dev, "rst-apb");
+	if (IS_ERR(dev->rst_apb)) {
+		dev_err(&pdev->dev, "%s: failed to get pwmdac apb reset control\n", __func__);
+		return PTR_ERR(dev->rst_apb);
+	}
+
+	return 0;
+}
+
+static int starfive_pwmdac_crg_enable(struct sf_pwmdac_dev *dev, bool enable)
+{
+	int ret = 0;
+
+	dev_dbg(dev->dev, "starfive_pwmdac clk&rst %sable.\n", enable ? "en":"dis");
+	if (enable) {
+		ret = clk_prepare_enable(dev->clk_apb0);
+		if (ret) {
+			dev_err(dev->dev, "failed to prepare enable clk_apb0\n");
+			goto err_clk_apb0;
+		}
+
+		ret = clk_prepare_enable(dev->clk_pwmdac_apb);
+		if (ret) {
+			dev_err(dev->dev, "failed to prepare enable clk_pwmdac_apb\n");
+			goto err_clk_apb;
+		}
+
+		ret = clk_prepare_enable(dev->clk_pwmdac_core);
+		if (ret) {
+			dev_err(dev->dev, "failed to prepare enable clk_pwmdac_core\n");
+			goto err_clk_core;
+		}
+
+		ret = reset_control_deassert(dev->rst_apb);
+		if (ret) {
+			dev_err(dev->dev, "failed to deassert apb\n");
+			goto err_rst_apb;
+		}
+	} else {
+		clk_disable_unprepare(dev->clk_pwmdac_core);
+		clk_disable_unprepare(dev->clk_pwmdac_apb);
+		clk_disable_unprepare(dev->clk_apb0);
+	}
+
+	return 0;
+
+err_rst_apb:
+	clk_disable_unprepare(dev->clk_pwmdac_core);
+err_clk_core:
+	clk_disable_unprepare(dev->clk_pwmdac_apb);
+err_clk_apb:
+	clk_disable_unprepare(dev->clk_apb0);
+err_clk_apb0:
+	return ret;
+}
+
+static int sf_pwmdac_clk_init(struct platform_device *pdev,
+				struct sf_pwmdac_dev *dev)
+{
+	int ret = 0;
+
+	ret = starfive_pwmdac_crg_enable(dev, true);
+	if (ret)
+		goto err_clk_pwmdac;
+
+	ret = clk_set_rate(dev->clk_pwmdac_core, 4096000);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set rate for clk_pwmdac_core\n");
+		goto err_clk_pwmdac;
+	}
+
+	dev_info(&pdev->dev, "clk_apb0 = %lu, clk_pwmdac_apb = %lu, clk_pwmdac_core = %lu\n",
+		clk_get_rate(dev->clk_apb0), clk_get_rate(dev->clk_pwmdac_apb),
+		clk_get_rate(dev->clk_pwmdac_core));
+
+err_clk_pwmdac:
+	return ret;
+}
+
+static int sf_pwmdac_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sf_pwmdac_dev *dev = dev_get_drvdata(dai->dev);
+
+	dev->play_dma_data.addr = dev->mapbase + PWMDAC_WDATA;
+	dev->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dev->play_dma_data.fifo_size = 1;
+	dev->play_dma_data.maxburst = 16;
+
+	snd_soc_dai_init_dma_data(dai, &dev->play_dma_data, NULL);
+	snd_soc_dai_set_drvdata(dai, dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int starfive_pwmdac_system_suspend(struct device *dev)
+{
+	struct sf_pwmdac_dev *pwmdac = dev_get_drvdata(dev);
+
+	/* save the register value */
+	pwmdac->pwmdac_ctrl_data = pwmdc_read_reg(pwmdac->pwmdac_base, PWMDAC_CTRL);
+	return pm_runtime_force_suspend(dev);
+}
+
+static int starfive_pwmdac_system_resume(struct device *dev)
+{
+	struct sf_pwmdac_dev *pwmdac = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret)
+		return ret;
+
+	/* restore the register value */
+	pwmdc_write_reg(pwmdac->pwmdac_base, PWMDAC_CTRL, pwmdac->pwmdac_ctrl_data);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static int starfive_pwmdac_runtime_suspend(struct device *dev)
+{
+	struct sf_pwmdac_dev *pwmdac = dev_get_drvdata(dev);
+
+	return starfive_pwmdac_crg_enable(pwmdac, false);
+}
+
+static int starfive_pwmdac_runtime_resume(struct device *dev)
+{
+	struct sf_pwmdac_dev *pwmdac = dev_get_drvdata(dev);
+
+	return starfive_pwmdac_crg_enable(pwmdac, true);
+}
+#endif
+
+static const struct dev_pm_ops starfive_pwmdac_pm_ops = {
+	SET_RUNTIME_PM_OPS(starfive_pwmdac_runtime_suspend, starfive_pwmdac_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(starfive_pwmdac_system_suspend, starfive_pwmdac_system_resume)
+};
+
+#define SOC_PWMDAC_ENUM_DECL(xname, xinfo, xget, xput) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = xinfo, .get = xget, .put = xput,}
+
+static const struct snd_kcontrol_new pwmdac_snd_controls[] = {
+	SOC_PWMDAC_ENUM_DECL("shift_bit", pwmdac_shift_bit_info,
+		pwmdac_shift_bit_get, pwmdac_shift_bit_put),
+	SOC_PWMDAC_ENUM_DECL("duty_cycle", pwmdac_duty_cycle_info,
+		pwmdac_duty_cycle_get, pwmdac_duty_cycle_put),
+	SOC_PWMDAC_ENUM_DECL("data_mode", pwmdac_data_mode_info,
+		pwmdac_data_mode_get, pwmdac_data_mode_put),
+	SOC_PWMDAC_ENUM_DECL("shift", pwmdac_shift_info,
+		pwmdac_shift_get, pwmdac_shift_put),
+	SOC_PWMDAC_ENUM_DECL("lr_change", pwmdac_lr_change_info,
+		pwmdac_lr_change_get, pwmdac_lr_change_put),
+};
+
+static int pwmdac_probe(struct snd_soc_component *component)
+{
+	snd_soc_add_component_controls(component, pwmdac_snd_controls,
+					ARRAY_SIZE(pwmdac_snd_controls));
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sf_pwmdac_dai_ops = {
+	.hw_params  = sf_pwmdac_hw_params,
+	.prepare	= sf_pwmdac_prepare,
+	.trigger	= sf_pwmdac_trigger,
+};
+
+static const struct snd_soc_component_driver sf_pwmdac_component = {
+	.name		= "starfive-pwmdac",
+	.probe		= pwmdac_probe,
+};
+
+static struct snd_soc_dai_driver pwmdac_dai = {
+	.name = "pwmdac",
+	.id = 0,
+	.probe	= sf_pwmdac_dai_probe,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &sf_pwmdac_dai_ops,
+};
+
+static int sf_pwmdac_probe(struct platform_device *pdev)
+{
+	struct sf_pwmdac_dev *dev;
+	struct resource *res;
+	int ret;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dev->pwmdac_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);
+	if (IS_ERR(dev->pwmdac_base))
+		return PTR_ERR(dev->pwmdac_base);
+
+	dev->mapbase = res->start;
+	dev->dev = &pdev->dev;
+
+	ret = sf_pwmdac_clks_get(pdev, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get pwmdac clock\n");
+		return ret;
+	}
+
+	ret = sf_pwmdac_resets_get(pdev, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get pwmdac reset controls\n");
+		return ret;
+	}
+
+	ret = sf_pwmdac_clk_init(pdev, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable pwmdac clock\n");
+		return ret;
+	}
+
+	dev->mode = shift_8Bit_inverter;
+	dev->fifo_th = 1;//8byte
+	pwmdac_config(dev);
+
+	dev->use_pio = false;
+	dev_set_drvdata(&pdev->dev, dev);
+	ret = devm_snd_soc_register_component(&pdev->dev, &sf_pwmdac_component,
+					 &pwmdac_dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "not able to register dai\n");
+		return ret;
+	}
+
+	if (dev->use_pio) {
+		ret = sf_pwmdac_pcm_register(pdev);
+	} else {
+		ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,
+				0);
+	}
+
+#ifdef CONFIG_PM
+	starfive_pwmdac_crg_enable(dev, false);
+#endif
+
+	pm_runtime_enable(dev->dev);
+
+	return 0;
+}
+
+
+static int sf_pwmdac_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id sf_pwmdac_of_match[] = {
+	{ .compatible = "starfive,jh7110-pwmdac", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, sf_pwmdac_of_match);
+#endif
+
+
+static struct platform_driver sf_pwmdac_driver = {
+	.probe		= sf_pwmdac_probe,
+	.remove		= sf_pwmdac_remove,
+	.driver		= {
+		.name	= "starfive-pwmdac",
+		.of_match_table = of_match_ptr(sf_pwmdac_of_match),
+		.pm = &starfive_pwmdac_pm_ops,
+	},
+};
+
+
+static int __init pwmdac_driver_init(void)
+{
+	return platform_driver_register(&sf_pwmdac_driver);
+}
+
+static void pwmdac_driver_exit(void)
+{
+	platform_driver_unregister(&sf_pwmdac_driver);
+}
+
+late_initcall(pwmdac_driver_init);
+module_exit(pwmdac_driver_exit);
+
+MODULE_AUTHOR("curry.zhang <curry.zhang@starfivetech.com>");
+MODULE_AUTHOR("Xingyu Wu <xingyu.wu@starfivetech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("starfive pwmdac SoC Interface");
+MODULE_ALIAS("platform:starfive-pwmdac");
diff --git a/sound/soc/starfive/starfive_pwmdac_pcm.c b/sound/soc/starfive/starfive_pwmdac_pcm.c
new file mode 100644
index 000000000000..55141445de22
--- /dev/null
+++ b/sound/soc/starfive/starfive_pwmdac_pcm.c
@@ -0,0 +1,251 @@
+/**
+  ******************************************************************************
+  * @file  sf_pwmdac_pcm.c
+  * @author  StarFive Technology
+  * @version  V1.0
+  * @date  05/27/2021
+  * @brief
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 20120 Shanghai StarFive Technology Co., Ltd. </center></h2>
+  */
+  
+#include <linux/io.h>
+#include <linux/rcupdate.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include "pwmdac.h"
+
+#define BUFFER_BYTES_MAX	(3 * 2 * 8 * PERIOD_BYTES_MIN)
+#define PERIOD_BYTES_MIN	4096
+#define PERIODS_MIN		2
+
+static unsigned int sf_pwmdac_pcm_tx_8(struct sf_pwmdac_dev *dev, 
+		struct snd_pcm_runtime *runtime, unsigned int tx_ptr, 
+		bool *period_elapsed) 
+{ 
+	const u8 (*p)[2] = (void *)runtime->dma_area; 
+	unsigned int period_pos = tx_ptr % runtime->period_size; 
+	int i; 
+	u32 basedat = 0;
+	
+	for (i = 0; i < dev->fifo_th; i++) { 
+		basedat = (p[tx_ptr][0]<<8)|(p[tx_ptr][1] << 24);
+		iowrite32(basedat,dev->pwmdac_base + PWMDAC_WDATA); 
+		period_pos++; 
+		if (++tx_ptr >= runtime->buffer_size) 
+			tx_ptr = 0; 
+	} 
+	
+	*period_elapsed = period_pos >= runtime->period_size; 
+	
+	return tx_ptr; 
+}
+		
+
+static unsigned int sf_pwmdac_pcm_tx_16(struct sf_pwmdac_dev *dev, 
+		struct snd_pcm_runtime *runtime, unsigned int tx_ptr, 
+		bool *period_elapsed) 
+{ 
+	const u16 (*p)[2] = (void *)runtime->dma_area; 
+	unsigned int period_pos = tx_ptr % runtime->period_size; 
+	int i; 
+	u32 basedat = 0;
+	
+	for (i = 0; i < dev->fifo_th; i++) { 
+		basedat = (p[tx_ptr][0])|(p[tx_ptr][1] << 16);
+		iowrite32(basedat,dev->pwmdac_base + PWMDAC_WDATA); 
+		period_pos++; 
+		if (++tx_ptr >= runtime->buffer_size) 
+			tx_ptr = 0; 
+	} 
+	
+	*period_elapsed = period_pos >= runtime->period_size; 
+	return tx_ptr; 
+}
+		
+
+static const struct snd_pcm_hardware sf_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.rates = SNDRV_PCM_RATE_16000,
+	.rate_min = 16000,
+	.rate_max = 16000,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = BUFFER_BYTES_MAX,
+	.period_bytes_min = PERIOD_BYTES_MIN,
+	.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN,
+	.periods_min = PERIODS_MIN,
+	.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN,
+	.fifo_size = 2,
+};
+
+static void sf_pcm_transfer(struct sf_pwmdac_dev *dev, bool push)
+{
+	struct snd_pcm_substream *substream;
+	bool active, period_elapsed;
+
+	rcu_read_lock();
+	if (push)
+		substream = rcu_dereference(dev->tx_substream);
+
+	active = substream && snd_pcm_running(substream);
+	if (active) {
+		unsigned int ptr;
+		unsigned int new_ptr;
+
+		if (push) {
+			ptr = READ_ONCE(dev->tx_ptr);
+			new_ptr = dev->tx_fn(dev, substream->runtime, ptr,
+					&period_elapsed);
+			cmpxchg(&dev->tx_ptr, ptr, new_ptr);
+		}
+		
+		if (period_elapsed)
+			snd_pcm_period_elapsed(substream);
+	}
+	rcu_read_unlock();
+}
+
+void sf_pwmdac_pcm_push_tx(struct sf_pwmdac_dev *dev)
+{
+	sf_pcm_transfer(dev, true);
+}
+
+
+static int sf_pcm_open(struct snd_soc_component *component,
+		    struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct sf_pwmdac_dev *dev = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));
+
+	snd_soc_set_runtime_hwparams(substream, &sf_pcm_hardware);
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	runtime->private_data = dev;
+
+	return 0;
+}
+
+
+static int sf_pcm_close(struct snd_soc_component *component,
+		    struct snd_pcm_substream *substream)
+{
+	synchronize_rcu();
+	return 0;
+}
+
+static int sf_pcm_hw_params(struct snd_soc_component *component,
+			    struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_pwmdac_dev *dev = runtime->private_data;
+	int ret;
+
+
+	switch (params_channels(hw_params)) {
+	case 2:
+		break;
+	default:
+		dev_err(dev->dev, "invalid channels number\n");
+		return -EINVAL;
+	}
+
+	switch (params_format(hw_params)) {
+	case SNDRV_PCM_FORMAT_U8:
+	case SNDRV_PCM_FORMAT_S8:
+		dev->tx_fn = sf_pwmdac_pcm_tx_8;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		dev->tx_fn = sf_pwmdac_pcm_tx_16;
+		break;
+	default:
+		dev_err(dev->dev, "invalid format\n");
+		return -EINVAL;
+	}
+
+		return 0;
+}
+
+
+static int sf_pcm_trigger(struct snd_soc_component *component,
+		    struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_pwmdac_dev *dev = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			WRITE_ONCE(dev->tx_ptr, 0);
+			rcu_assign_pointer(dev->tx_substream, substream);
+		} 
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rcu_assign_pointer(dev->tx_substream, NULL);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t sf_pcm_pointer(struct snd_soc_component *component,
+				     struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_pwmdac_dev *dev = runtime->private_data;
+	snd_pcm_uframes_t pos;
+	
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		pos = READ_ONCE(dev->tx_ptr);
+
+	return pos < runtime->buffer_size ? pos : 0;
+}
+
+static int sf_pcm_new(struct snd_soc_component *component,
+		      struct snd_soc_pcm_runtime *rtd)
+{
+	size_t size = sf_pcm_hardware.buffer_bytes_max;
+	
+	snd_pcm_set_managed_buffer_all(rtd->pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			NULL, size, size);
+	return 0;
+}
+
+static const struct snd_soc_component_driver dw_pcm_component = {
+	.open		= sf_pcm_open,
+	.close		= sf_pcm_close,
+	.hw_params	= sf_pcm_hw_params,
+	.trigger	= sf_pcm_trigger,
+	.pointer	= sf_pcm_pointer,
+	.pcm_construct	= sf_pcm_new,
+};
+
+int sf_pwmdac_pcm_register(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &dw_pcm_component,
+					       NULL, 0);
+}
diff --git a/sound/soc/starfive/starfive_pwmdac_transmitter.c b/sound/soc/starfive/starfive_pwmdac_transmitter.c
new file mode 100644
index 000000000000..6d58fcfd5592
--- /dev/null
+++ b/sound/soc/starfive/starfive_pwmdac_transmitter.c
@@ -0,0 +1,110 @@
+/**
+  ******************************************************************************
+  * @file  sf_pwmdac_transmitter.c
+  * @author  StarFive Technology
+  * @version  V1.0
+  * @date  05/27/2021
+  * @brief
+  ******************************************************************************
+  * @copy
+  *
+  * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+  * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+  * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+  *
+  * <h2><center>&copy; COPYRIGHT 20120 Shanghai StarFive Technology Co., Ltd. </center></h2>
+  */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+
+#define DRV_NAME "pwmdac-dit"
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S8|\
+			SNDRV_PCM_FMTBIT_U8|\
+			SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE  | \
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+static const struct snd_soc_dapm_widget dit_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("pwmdac-out"),
+};
+
+static const struct snd_soc_dapm_route dit_routes[] = {
+	{ "pwmdac-out", NULL, "Playback" },
+};
+
+static struct snd_soc_component_driver soc_codec_pwmdac_dit = {
+	.dapm_widgets		= dit_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(dit_widgets),
+	.dapm_routes		= dit_routes,
+	.num_dapm_routes	= ARRAY_SIZE(dit_routes),
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "pwmdac-dit-hifi",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static int pwmdac_dit_probe(struct platform_device *pdev)
+{
+
+	return devm_snd_soc_register_component(&pdev->dev,
+			&soc_codec_pwmdac_dit,
+			&dit_stub_dai, 1);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id pwmdac_dit_dt_ids[] = {
+	{ .compatible = "starfive,jh7110-pwmdac-dit", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pwmdac_dit_dt_ids);
+#endif
+
+static struct platform_driver pwmdac_dit_driver = {
+	.probe		= pwmdac_dit_probe,
+	.driver		= {
+		.name	= DRV_NAME,
+		.of_match_table = of_match_ptr(pwmdac_dit_dt_ids),
+	},
+};
+
+static int __init pwmdac_dit_driver_init(void)
+{
+	return platform_driver_register(&pwmdac_dit_driver);
+}
+
+static void pwmdac_dit_driver_exit(void)
+{
+	platform_driver_unregister(&pwmdac_dit_driver);
+}
+
+late_initcall(pwmdac_dit_driver_init);
+module_exit(pwmdac_dit_driver_exit);
+
+
+MODULE_AUTHOR("curry.zhang <curry.zhang@starfivetech.com>");
+MODULE_DESCRIPTION("pwmdac dummy codec driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform: starfive-pwmdac dummy codec");
diff --git a/sound/soc/starfive/starfive_spdif.c b/sound/soc/starfive/starfive_spdif.c
new file mode 100644
index 000000000000..40849e654ecc
--- /dev/null
+++ b/sound/soc/starfive/starfive_spdif.c
@@ -0,0 +1,617 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * SPDIF driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/pm_runtime.h>
+#include "starfive_spdif.h"
+
+static irqreturn_t spdif_irq_handler(int irq, void *dev_id)
+{
+	struct sf_spdif_dev *dev = dev_id;
+	bool irq_valid = false;
+	unsigned int intr;
+	unsigned int stat;
+
+	regmap_read(dev->regmap, SPDIF_INT_REG, &intr);
+	regmap_read(dev->regmap, SPDIF_STAT_REG, &stat);
+	regmap_update_bits(dev->regmap, SPDIF_CTRL,
+		SPDIF_MASK_ENABLE, 0);
+	regmap_update_bits(dev->regmap, SPDIF_INT_REG,
+		SPDIF_INT_REG_BIT, 0);
+
+	if ((stat & SPDIF_EMPTY_FLAG) || (stat & SPDIF_AEMPTY_FLAG)) {
+		sf_spdif_pcm_push_tx(dev);
+		irq_valid = true;
+	}
+
+	if ((stat & SPDIF_FULL_FLAG) || (stat & SPDIF_AFULL_FLAG)) {
+		sf_spdif_pcm_pop_rx(dev);
+		irq_valid = true;
+	}
+
+	if (stat & SPDIF_PARITY_FLAG)
+		irq_valid = true;
+
+	if (stat & SPDIF_UNDERR_FLAG)
+		irq_valid = true;
+
+	if (stat & SPDIF_OVRERR_FLAG)
+		irq_valid = true;
+
+	if (stat & SPDIF_SYNCERR_FLAG)
+		irq_valid = true;
+
+	if (stat & SPDIF_LOCK_FLAG)
+		irq_valid = true;
+
+	if (stat & SPDIF_BEGIN_FLAG)
+		irq_valid = true;
+
+	if (stat & SPDIF_RIGHT_LEFT)
+		irq_valid = true;
+
+	regmap_update_bits(dev->regmap, SPDIF_CTRL,
+		SPDIF_MASK_ENABLE, SPDIF_MASK_ENABLE);
+
+	if (irq_valid)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+static int sf_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct sf_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
+	bool tx;
+
+	tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	if (tx) {
+		/* tx mode */
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_TR_MODE, SPDIF_TR_MODE);
+
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_MASK_FIFO, SPDIF_EMPTY_MASK | SPDIF_AEMPTY_MASK);
+	} else {
+		/* rx mode */
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_TR_MODE, 0);
+
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_MASK_FIFO, SPDIF_FULL_MASK | SPDIF_AFULL_MASK);
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/* clock recovery form the SPDIF data stream  0:clk_enable */
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_CLK_ENABLE, 0);
+
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_ENABLE, SPDIF_ENABLE);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		/* clock recovery form the SPDIF data stream  1:power save mode */
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_CLK_ENABLE, SPDIF_CLK_ENABLE);
+
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_ENABLE, 0);
+		break;
+	default:
+		dev_err(dai->dev, "%s L.%d cmd:%d\n", __func__, __LINE__, cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sf_spdif_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sf_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int channels;
+	unsigned int rate;
+	unsigned int format;
+	unsigned int tsamplerate;
+	unsigned int mclk;
+	unsigned int audio_root;
+	int ret;
+
+	channels = params_channels(params);
+	rate = params_rate(params);
+	format = params_format(params);
+
+	switch (channels) {
+	case 1:
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_CHANNEL_MODE, SPDIF_CHANNEL_MODE);
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_DUPLICATE, SPDIF_DUPLICATE);
+		spdif->channels = false;
+		break;
+	case 2:
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_CHANNEL_MODE, 0);
+		spdif->channels = true;
+		break;
+	default:
+		dev_err(dai->dev, "invalid channels number\n");
+		return -EINVAL;
+	}
+
+	switch (format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S24_3LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		break;
+	default:
+		dev_err(dai->dev, "invalid format\n");
+		return -EINVAL;
+	}
+
+	switch (rate) {
+	case 8000:
+		break;
+	case 11025:
+		audio_root = 148500000;
+		/* 11025 * 512 = 5644800 */
+		/* But now pll2 is 1188m and mclk should be 5711539 closely. */
+		mclk = 5711539;
+		break;
+	case 16000:
+		break;
+	case 22050:
+		audio_root = 148500000;
+		mclk = 11423077;
+		break;
+	default:
+		dev_err(dai->dev, "channel:%d sample rate:%d\n", channels, rate);
+		return -EINVAL;
+	}
+
+	/* use mclk_inner clock from 1188m PLL2 will be better about 11k and 22k*/
+	if ((rate == 11025) || (rate == 22050)) {
+		ret = clk_set_parent(spdif->mclk, spdif->mclk_inner);
+		if (ret) {
+			dev_err(dai->dev,
+				"failed to set parent to mclk_inner ret=%d\n", ret);
+			goto fail_ext;
+		}
+
+		ret = clk_set_rate(spdif->audio_root, audio_root);
+		if (ret) {
+			dev_err(dai->dev, "failed to set audio_root rate :%d\n", ret);
+			goto fail_ext;
+		}
+		dev_dbg(dai->dev, "audio_root get rate:%ld\n",
+				clk_get_rate(spdif->audio_root));
+
+		ret = clk_set_rate(spdif->mclk_inner, mclk);
+		if (ret) {
+			dev_err(dai->dev, "failed to set mclk_inner rate :%d\n", ret);
+			goto fail_ext;
+		}
+
+		mclk = clk_get_rate(spdif->mclk_inner);
+		dev_dbg(dai->dev, "mclk_inner get rate:%d\n", mclk);
+	} else {
+		ret = clk_set_parent(spdif->mclk, spdif->mclk_ext);
+		if (ret) {
+			dev_err(dai->dev,
+				"failed to set parent to mclk_ext ret=%d\n", ret);
+			goto fail_ext;
+		}
+
+		mclk = clk_get_rate(spdif->mclk_ext);
+		dev_dbg(dai->dev, "mclk_ext get rate:%d\n", mclk);
+	}
+
+	/* (FCLK)4096000/128=32000 */
+	tsamplerate = (mclk / 128 + rate / 2) / rate - 1;
+	if (tsamplerate < 3)
+		tsamplerate = 3;
+
+	/* transmission sample rate */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL, 0xFF, tsamplerate);
+
+	return 0;
+
+fail_ext:
+	return ret;
+}
+
+static int sf_spdif_clks_get(struct platform_device *pdev,
+				struct sf_spdif_dev *spdif)
+{
+	static struct clk_bulk_data clks[] = {
+		{ .id = "spdif-apb" },		/* clock-names in dts file */
+		{ .id = "spdif-core" },
+		{ .id = "audroot" },
+		{ .id = "mclk_inner"},
+		{ .id = "mclk_ext"},
+		{ .id = "mclk"},
+	};
+	int ret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(clks), clks);
+
+	spdif->spdif_apb = clks[0].clk;
+	spdif->spdif_core = clks[1].clk;
+	spdif->audio_root = clks[2].clk;
+	spdif->mclk_inner = clks[3].clk;
+	spdif->mclk_ext = clks[4].clk;
+	spdif->mclk = clks[5].clk;
+
+	return ret;
+}
+
+static int sf_spdif_resets_get(struct platform_device *pdev,
+				struct sf_spdif_dev *spdif)
+{
+	spdif->rst_apb = devm_reset_control_get_exclusive(&pdev->dev, "rst_apb");
+	if (IS_ERR(spdif->rst_apb)) {
+		dev_err(&pdev->dev, "%s: failed to get spdif apb reset control\n", __func__);
+		return PTR_ERR(spdif->rst_apb);
+	}
+
+	return 0;
+}
+
+static int starfive_spdif_crg_enable(struct sf_spdif_dev *spdif, bool enable)
+{
+	int ret;
+
+	dev_dbg(spdif->dev, "starfive_spdif clk&rst %sable.\n", enable ? "en":"dis");
+	if (enable) {
+		ret = clk_prepare_enable(spdif->spdif_apb);
+		if (ret) {
+			dev_err(spdif->dev, "failed to prepare enable spdif_apb\n");
+			goto failed_apb_clk;
+		}
+
+		ret = clk_prepare_enable(spdif->spdif_core);
+		if (ret) {
+			dev_err(spdif->dev, "failed to prepare enable spdif_core\n");
+			goto failed_core_clk;
+		}
+
+		ret = reset_control_deassert(spdif->rst_apb);
+		if (ret) {
+			dev_err(spdif->dev, "failed to deassert apb\n");
+			goto failed_rst;
+		}
+	} else {
+		clk_disable_unprepare(spdif->spdif_core);
+		clk_disable_unprepare(spdif->spdif_apb);
+	}
+
+	return 0;
+
+failed_rst:
+	clk_disable_unprepare(spdif->spdif_core);
+failed_core_clk:
+	clk_disable_unprepare(spdif->spdif_apb);
+failed_apb_clk:
+	return ret;
+}
+
+static int sf_spdif_clk_init(struct platform_device *pdev,
+				struct sf_spdif_dev *spdif)
+{
+	int ret = 0;
+
+	ret = starfive_spdif_crg_enable(spdif, true);
+	if (ret)
+		return ret;
+
+	ret = clk_set_rate(spdif->audio_root, 204800000);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set rate for spdif audroot ret=%d\n", ret);
+		goto disable_core_clk;
+	}
+
+	ret = clk_set_rate(spdif->mclk_inner, 8192000);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set rate for spdif mclk_inner ret=%d\n", ret);
+		goto disable_core_clk;
+	}
+
+	dev_dbg(&pdev->dev, "spdif->spdif_apb = %lu\n", clk_get_rate(spdif->spdif_apb));
+	dev_dbg(&pdev->dev, "spdif->spdif_core = %lu\n", clk_get_rate(spdif->spdif_core));
+
+	ret = clk_set_parent(spdif->mclk, spdif->mclk_ext);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to set parent for mclk to mclk_ext ret=%d\n", ret);
+		goto disable_core_clk;
+	}
+
+	return 0;
+
+disable_core_clk:
+	clk_disable_unprepare(spdif->spdif_core);
+	clk_disable_unprepare(spdif->spdif_apb);
+
+	return ret;
+}
+
+static int sf_spdif_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sf_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
+
+	pm_runtime_get_sync(spdif->dev);
+
+	/* reset */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_ENABLE | SPDIF_SFR_ENABLE | SPDIF_FIFO_ENABLE, 0);
+
+	/* clear irq */
+	regmap_update_bits(spdif->regmap, SPDIF_INT_REG,
+		SPDIF_INT_REG_BIT, 0);
+
+	/* power save mode */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_CLK_ENABLE, SPDIF_CLK_ENABLE);
+
+	/* power save mode */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_CLK_ENABLE, SPDIF_CLK_ENABLE);
+
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_PARITCHECK|SPDIF_VALIDITYCHECK|SPDIF_DUPLICATE,
+		SPDIF_PARITCHECK|SPDIF_VALIDITYCHECK|SPDIF_DUPLICATE);
+
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_SETPREAMBB, SPDIF_SETPREAMBB);
+
+	regmap_update_bits(spdif->regmap, SPDIF_INT_REG,
+		BIT8TO20MASK<<SPDIF_PREAMBLEDEL, 0x3<<SPDIF_PREAMBLEDEL);
+
+	regmap_update_bits(spdif->regmap, SPDIF_FIFO_CTRL,
+		ALLBITMASK, 0x20|(0x20<<SPDIF_AFULL_THRESHOLD));
+
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_PARITYGEN, SPDIF_PARITYGEN);
+
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_MASK_ENABLE, SPDIF_MASK_ENABLE);
+
+	/* APB access to FIFO enable, disable if use DMA/FIFO */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_USE_FIFO_IF, 0);
+
+	/* two channel */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_CHANNEL_MODE, 0);
+
+	pm_runtime_put_sync(spdif->dev);
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sf_spdif_dai_ops = {
+	.trigger = sf_spdif_trigger,
+	.hw_params = sf_spdif_hw_params,
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int spdif_system_suspend(struct device *dev)
+{
+	struct sf_spdif_dev *spdif = dev_get_drvdata(dev);
+
+	/* save the register value */
+	regmap_read(spdif->regmap, SPDIF_CTRL, &spdif->reg_spdif_ctrl);
+	regmap_read(spdif->regmap, SPDIF_INT_REG, &spdif->reg_spdif_int);
+	regmap_read(spdif->regmap, SPDIF_FIFO_CTRL, &spdif->reg_spdif_fifo_ctrl);
+
+	return pm_runtime_force_suspend(dev);
+}
+
+static int spdif_system_resume(struct device *dev)
+{
+	struct sf_spdif_dev *spdif = dev_get_drvdata(dev);
+	int ret;
+
+	ret = pm_runtime_force_resume(dev);
+	if (ret)
+		return ret;
+
+	/* restore the register value */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			   ALLBITMASK, spdif->reg_spdif_ctrl);
+	regmap_update_bits(spdif->regmap, SPDIF_INT_REG,
+			   ALLBITMASK, spdif->reg_spdif_int);
+	regmap_update_bits(spdif->regmap, SPDIF_FIFO_CTRL,
+			   ALLBITMASK, spdif->reg_spdif_fifo_ctrl);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static int spdif_runtime_suspend(struct device *dev)
+{
+	struct sf_spdif_dev *spdif = dev_get_drvdata(dev);
+
+	return starfive_spdif_crg_enable(spdif, false);
+}
+
+static int spdif_runtime_resume(struct device *dev)
+{
+	struct sf_spdif_dev *spdif = dev_get_drvdata(dev);
+
+	return starfive_spdif_crg_enable(spdif, true);
+}
+#endif
+
+static const struct dev_pm_ops spdif_pm_ops = {
+	SET_RUNTIME_PM_OPS(spdif_runtime_suspend, spdif_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(spdif_system_suspend, spdif_system_resume)
+};
+
+#define SF_PCM_RATE_44100_192000  (SNDRV_PCM_RATE_44100 | \
+				   SNDRV_PCM_RATE_48000 | \
+				   SNDRV_PCM_RATE_96000 | \
+				   SNDRV_PCM_RATE_192000)
+
+#define SF_PCM_RATE_8000_22050  (SNDRV_PCM_RATE_8000 | \
+				 SNDRV_PCM_RATE_11025 | \
+				 SNDRV_PCM_RATE_16000 | \
+				 SNDRV_PCM_RATE_22050)
+
+static struct snd_soc_dai_driver sf_spdif_dai = {
+	.name = "spdif",
+	.id = 0,
+	.probe = sf_spdif_dai_probe,
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SF_PCM_RATE_8000_22050,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE |
+			   SNDRV_PCM_FMTBIT_S24_LE |
+			   SNDRV_PCM_FMTBIT_S24_3LE |
+			   SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sf_spdif_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static const struct snd_soc_component_driver sf_spdif_component = {
+	.name = "starfive-spdif",
+};
+
+static const struct regmap_config sf_spdif_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = 0x200,
+};
+
+static int sf_spdif_probe(struct platform_device *pdev)
+{
+	struct sf_spdif_dev *spdif;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+	int irq;
+
+	spdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);
+	if (!spdif)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, spdif);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	spdif->spdif_base = base;
+	spdif->regmap = devm_regmap_init_mmio(&pdev->dev, spdif->spdif_base,
+					    &sf_spdif_regmap_config);
+	if (IS_ERR(spdif->regmap))
+		return PTR_ERR(spdif->regmap);
+
+	spdif->dev = &pdev->dev;
+
+	ret = sf_spdif_clks_get(pdev, spdif);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get audio clock\n");
+		return ret;
+	}
+
+	ret = sf_spdif_resets_get(pdev, spdif);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get audio reset controls\n");
+		return ret;
+	}
+
+	ret = sf_spdif_clk_init(pdev, spdif);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable audio clock\n");
+		return ret;
+	}
+
+	spdif->fifo_th = 16;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq >= 0) {
+		ret = devm_request_irq(&pdev->dev, irq, spdif_irq_handler, 0,
+				pdev->name, spdif);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to request irq\n");
+			return ret;
+		}
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sf_spdif_component,
+					 &sf_spdif_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	if (irq >= 0) {
+		ret = sf_spdif_pcm_register(pdev);
+		spdif->use_pio = true;
+	} else {
+		ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,
+					0);
+		spdif->use_pio = false;
+	}
+
+	if (ret)
+		goto err_clk_disable;
+
+	starfive_spdif_crg_enable(spdif, false);
+	pm_runtime_enable(&pdev->dev);
+	dev_info(&pdev->dev, "spdif register done.\n");
+
+	return 0;
+
+err_clk_disable:
+	return ret;
+}
+
+static const struct of_device_id sf_spdif_of_match[] = {
+	{ .compatible = "starfive,jh7110-spdif", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sf_spdif_of_match);
+
+static struct platform_driver sf_spdif_driver = {
+	.driver = {
+		.name = "starfive-spdif",
+		.of_match_table = sf_spdif_of_match,
+		.pm = &spdif_pm_ops,
+	},
+	.probe = sf_spdif_probe,
+};
+module_platform_driver(sf_spdif_driver);
+
+MODULE_AUTHOR("curry.zhang <curry.zhang@starfive.com>");
+MODULE_AUTHOR("Xingyu Wu <xingyu.wu@starfivetech.com>");
+MODULE_DESCRIPTION("starfive SPDIF driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/starfive/starfive_spdif.h b/sound/soc/starfive/starfive_spdif.h
new file mode 100644
index 000000000000..a0c91ae804d6
--- /dev/null
+++ b/sound/soc/starfive/starfive_spdif.h
@@ -0,0 +1,179 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * SPDIF driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+
+#ifndef __SND_SOC_STARFIVE_SPDIF_H
+#define __SND_SOC_STARFIVE_SPDIF_H
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <linux/dmaengine.h>
+#include <linux/types.h>
+
+#define SPDIF_CTRL			0x0
+#define SPDIF_INT_REG			0x4
+#define SPDIF_FIFO_CTRL			0x8
+#define SPDIF_STAT_REG			0xC
+
+#define SPDIF_FIFO_ADDR			0x100
+#define DMAC_SPDIF_POLLING_LEN		256
+
+/* ctrl: sampled on the rising clock edge */
+#define	SPDIF_TSAMPLERATE	0	/* [SRATEW-1:0] */
+#define SPDIF_SFR_ENABLE	(1<<8)	/* 0:SFR reg reset to defualt value; auto set back to '1' after reset */
+#define SPDIF_ENABLE		(1<<9)	/* 0:reset of SPDIF block, SRF bits are unchanged; 1:enables SPDIF module */
+#define SPDIF_FIFO_ENABLE	(1<<10)	/* 0:FIFO pointers are reset to zero,threshold levels for FIFO are unchaned; auto set back to '1' */
+#define SPDIF_CLK_ENABLE	(1<<11)	/* 1:blocked and the modules are in power save mode; 0:block feeds the modules */
+#define SPDIF_TR_MODE		(1<<12)	/* 0:rx; 1:tx */
+#define SPDIF_PARITCHECK	(1<<13)	/* 0:party bit rx in a sub-frame is repeated on the parity; 1:check on a parity error */
+#define SPDIF_PARITYGEN		(1<<14)	/* 0:parity bit from FIFO is transmitted in sub-frame;1:parity bit generated inside the core and added to a transmitted sub-frame */
+#define SPDIF_VALIDITYCHECK	(1<<15)	/* 0:validity bit in frame isn't checked and all frame are written; 1:validity bit rx is checked */
+#define SPDIF_CHANNEL_MODE	(1<<16)	/* 0:two-channel; 1:single-channel */
+#define SPDIF_DUPLICATE		(1<<17)	/* only tx -single-channel mode; 0:secondary channel; 1: left(primary) channel */
+#define SPDIF_SETPREAMBB	(1<<18)	/* only tx; 0:first preamble B after reset tx valid sub-frame; 1:first preamble B is tx after preambleddel(INT_REG) */
+#define SPDIF_USE_FIFO_IF	(1<<19)	/* 0:FIFO disabled ,APB accese FIFO; 1:FIFO enable, APB access to FIFO disable; */
+#define SPDIF_PARITY_MASK	(1<<21)
+#define SPDIF_UNDERR_MASK	(1<<22)
+#define SPDIF_OVRERR_MASK	(1<<23)
+#define SPDIF_EMPTY_MASK	(1<<24)
+#define	SPDIF_AEMPTY_MASK	(1<<25)
+#define SPDIF_FULL_MASK		(1<<26)
+#define SPDIF_AFULL_MASK	(1<<27)
+#define SPDIF_SYNCERR_MASK	(1<<28)
+#define SPDIF_LOCK_MASK		(1<<29)
+#define SPDIF_BEGIN_MASK	(1<<30)
+#define SPDIF_INTEREQ_MAKS	(1<<31)
+
+#define SPDIF_MASK_ENABLE	(SPDIF_PARITY_MASK | SPDIF_UNDERR_MASK | \
+				 SPDIF_OVRERR_MASK | SPDIF_EMPTY_MASK | \
+				 SPDIF_AEMPTY_MASK | SPDIF_FULL_MASK | \
+				 SPDIF_AFULL_MASK | SPDIF_SYNCERR_MASK | \
+				 SPDIF_LOCK_MASK | SPDIF_BEGIN_MASK | \
+				 SPDIF_INTEREQ_MAKS)
+
+#define SPDIF_MASK_FIFO     (SPDIF_EMPTY_MASK | SPDIF_AEMPTY_MASK | \
+			     SPDIF_FULL_MASK | SPDIF_AFULL_MASK)
+
+/* INT_REG */
+#define SPDIF_RSAMPLERATE	0	/* [SRATEW-1:0] */
+#define SPDIF_PREAMBLEDEL	8	/* [PDELAYW+7:8] first B delay */
+#define SPDIF_PARITYO		(1<<21)	/* 0:clear parity error */
+#define SPDIF_TDATA_UNDERR	(1<<22)	/* tx data underrun error;0:clear */
+#define SPDIF_RDATA_OVRERR	(1<<23)	/* rx data overrun error; 0:clear */
+#define SPDIF_FIFO_EMPTY	(1<<24)	/* empty; 0:clear */
+#define SPDIF_FIOF_AEMPTY	(1<<25)	/* almost empty; 0:clear */
+#define SPDIF_FIFO_FULL		(1<<26)	/* FIFO full; 0:clear */
+#define SPDIF_FIFO_AFULL	(1<<27)	/* FIFO almost full; 0:clear */
+#define SPDIF_SYNCERR		(1<<28)	/* sync error; 0:clear */
+#define SPDIF_LOCK		(1<<29)	/* sync; 0:clear */
+#define SPDIF_BLOCK_BEGIN	(1<<30)	/* new start block rx data */
+
+#define SPDIF_INT_REG_BIT	(SPDIF_PARITYO | SPDIF_TDATA_UNDERR | \
+				 SPDIF_RDATA_OVRERR | SPDIF_FIFO_EMPTY | \
+				 SPDIF_FIOF_AEMPTY | SPDIF_FIFO_FULL | \
+				 SPDIF_FIFO_AFULL | SPDIF_SYNCERR | \
+				 SPDIF_LOCK | SPDIF_BLOCK_BEGIN)
+
+#define SPDIF_ERROR_INT_STATUS	(SPDIF_PARITYO | \
+				 SPDIF_TDATA_UNDERR | SPDIF_RDATA_OVRERR)
+#define SPDIF_FIFO_INT_STATUS	(SPDIF_FIFO_EMPTY | SPDIF_FIOF_AEMPTY | \
+				 SPDIF_FIFO_FULL | SPDIF_FIFO_AFULL)
+
+#define SPDIF_INT_PARITY_ERROR	(-1)
+#define SPDIF_INT_TDATA_UNDERR	(-2)
+#define SPDIF_INT_RDATA_OVRERR	(-3)
+#define SPDIF_INT_FIFO_EMPTY	1
+#define SPDIF_INT_FIFO_AEMPTY	2
+#define SPDIF_INT_FIFO_FULL	3
+#define SPDIF_INT_FIFO_AFULL	4
+#define SPDIF_INT_SYNCERR	(-4)
+#define SPDIF_INT_LOCK		5	/* reciever has become synchronized with input data stream */
+#define SPDIF_INT_BLOCK_BEGIN	6	/* start a new block in recieve data, written into FIFO */
+
+/* FIFO_CTRL */
+#define SPDIF_AEMPTY_THRESHOLD	0	/* [depth-1:0] */
+#define SPDIF_AFULL_THRESHOLD	16	/* [depth+15:16] */
+
+/* STAT_REG */
+#define SPDIF_FIFO_LEVEL	(1<<0)
+#define SPDIF_PARITY_FLAG	(1<<21)	/* 1:error; 0:repeated */
+#define SPDIF_UNDERR_FLAG	(1<<22)	/* 1:error */
+#define SPDIF_OVRERR_FLAG	(1<<23)	/* 1:error */
+#define SPDIF_EMPTY_FLAG	(1<<24)	/* 1:fifo empty */
+#define SPDIF_AEMPTY_FLAG	(1<<25)	/* 1:fifo almost empty */
+#define SPDIF_FULL_FLAG		(1<<26)	/* 1:fifo full */
+#define SPDIF_AFULL_FLAG	(1<<27)	/* 1:fifo almost full */
+#define SPDIF_SYNCERR_FLAG	(1<<28)	/* 1:rx sync error */
+#define SPDIF_LOCK_FLAG		(1<<29)	/* 1:RX sync */
+#define SPDIF_BEGIN_FLAG	(1<<30)	/* 1:start a new block */
+#define SPDIF_RIGHT_LEFT	(1<<31)	/* 1:left channel received and tx into FIFO; 0:right channel received and tx into FIFO */
+
+#define BIT8TO20MASK	0x1FFF
+#define ALLBITMASK		0xFFFFFFFF
+
+#define SPDIF_STAT		(SPDIF_PARITY_FLAG | SPDIF_UNDERR_FLAG | \
+				 SPDIF_OVRERR_FLAG | SPDIF_EMPTY_FLAG | \
+				 SPDIF_AEMPTY_FLAG | SPDIF_FULL_FLAG | \
+				 SPDIF_AFULL_FLAG | SPDIF_SYNCERR_FLAG | \
+				 SPDIF_LOCK_FLAG | SPDIF_BEGIN_FLAG | \
+				 SPDIF_RIGHT_LEFT)
+struct sf_spdif_dev {
+	void __iomem *spdif_base;
+	struct regmap *regmap;
+	struct device *dev;
+	u32 fifo_th;
+	int active;
+
+	/* data related to DMA transfers b/w i2s and DMAC */
+	struct snd_dmaengine_dai_dma_data play_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+
+	bool use_pio;
+	struct snd_pcm_substream __rcu *tx_substream;
+	struct snd_pcm_substream __rcu *rx_substream;
+
+	unsigned int (*tx_fn)(struct sf_spdif_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+			bool *period_elapsed, snd_pcm_format_t format);
+	unsigned int (*rx_fn)(struct sf_spdif_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int rx_ptr,
+			bool *period_elapsed, snd_pcm_format_t format);
+
+	snd_pcm_format_t format;
+	bool channels;
+	unsigned int tx_ptr;
+	unsigned int rx_ptr;
+	struct clk *spdif_apb;
+	struct clk *spdif_core;
+	struct clk *audio_root;
+	struct clk *mclk_inner;
+	struct clk *mclk;
+	struct clk *mclk_ext;
+	struct reset_control *rst_apb;
+	unsigned int reg_spdif_ctrl;
+	unsigned int reg_spdif_int;
+	unsigned int reg_spdif_fifo_ctrl;
+
+	struct snd_dmaengine_dai_dma_data dma_data;
+};
+
+#if IS_ENABLED(CONFIG_SND_SOC_STARFIVE_SPDIF_PCM)
+void sf_spdif_pcm_push_tx(struct sf_spdif_dev *dev);
+void sf_spdif_pcm_pop_rx(struct sf_spdif_dev *dev);
+int sf_spdif_pcm_register(struct platform_device *pdev);
+#else
+void sf_spdif_pcm_push_tx(struct sf_spdif_dev *dev) { }
+void sf_spdif_pcm_pop_rx(struct sf_spdif_dev *dev) { }
+int sf_spdif_pcm_register(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif	/* __SND_SOC_STARFIVE_SPDIF_H */
diff --git a/sound/soc/starfive/starfive_spdif_pcm.c b/sound/soc/starfive/starfive_spdif_pcm.c
new file mode 100644
index 000000000000..436ea894956f
--- /dev/null
+++ b/sound/soc/starfive/starfive_spdif_pcm.c
@@ -0,0 +1,339 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * SPDIF PCM driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+
+#include <linux/io.h>
+#include <linux/rcupdate.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include "starfive_spdif.h"
+
+#define BUFFER_BYTES_MAX	(3 * 2 * 8 * PERIOD_BYTES_MIN)
+#define PERIOD_BYTES_MIN	4096
+#define PERIODS_MIN		2
+
+static unsigned int sf_spdif_pcm_tx(struct sf_spdif_dev *dev,
+		struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+		bool *period_elapsed, snd_pcm_format_t format)
+{
+	u32 data[2];
+	unsigned int period_pos = tx_ptr % runtime->period_size;
+	int i;
+
+	/* two- channel and signal-channel mode */
+	if (dev->channels) {
+		const u16 (*p16)[2] = (void *)runtime->dma_area;
+		const u32 (*p32)[2] = (void *)runtime->dma_area;
+
+		for (i = 0; i < dev->fifo_th; i++) {
+			if (format == SNDRV_PCM_FORMAT_S16_LE) {
+				data[0] = p16[tx_ptr][0];
+				data[0] = data[0]<<8;
+				data[0] &= 0x00ffff00;
+				data[1] = p16[tx_ptr][1];
+				data[1] = data[1]<<8;
+				data[1] &= 0x00ffff00;
+			} else if (format == SNDRV_PCM_FORMAT_S24_LE) {
+				data[0] = p32[tx_ptr][0];
+				data[1] = p32[tx_ptr][1];
+
+				/*
+				 * To adapt S24_3LE and ALSA pass parameter of S24_LE.
+				 * operation of S24_LE should be same to S24_3LE.
+				 * So it would wrong when playback S24_LE file.
+				 * when want to playback S24_LE file, should add in there:
+				 * data[0] = data[0]>>8;
+				 * data[1] = data[1]>>8;
+				 */
+
+				data[0] &= 0x00ffffff;
+				data[1] &= 0x00ffffff;
+			} else if (format == SNDRV_PCM_FORMAT_S24_3LE) {
+				data[0] = p32[tx_ptr][0];
+				data[1] = p32[tx_ptr][1];
+				data[0] &= 0x00ffffff;
+				data[1] &= 0x00ffffff;
+			} else if (format == SNDRV_PCM_FORMAT_S32_LE) {
+				data[0] = p32[tx_ptr][0];
+				data[0] = data[0]>>8;
+				data[1] = p32[tx_ptr][1];
+				data[1] = data[1]>>8;
+			}
+
+			iowrite32(data[0], dev->spdif_base + SPDIF_FIFO_ADDR);
+			iowrite32(data[1], dev->spdif_base + SPDIF_FIFO_ADDR);
+			period_pos++;
+			if (++tx_ptr >= runtime->buffer_size)
+				tx_ptr = 0;
+		}
+	} else {
+		const u16 (*p16) = (void *)runtime->dma_area;
+		const u32 (*p32) = (void *)runtime->dma_area;
+
+		for (i = 0; i < dev->fifo_th; i++) {
+			if (format == SNDRV_PCM_FORMAT_S16_LE) {
+				data[0] = p16[tx_ptr];
+				data[0] = data[0]<<8;
+				data[0] &= 0x00ffff00;
+			} else if (format == SNDRV_PCM_FORMAT_S24_LE ||
+				format == SNDRV_PCM_FORMAT_S24_3LE) {
+				data[0] = p32[tx_ptr];
+				data[0] &= 0x00ffffff;
+			} else if (format == SNDRV_PCM_FORMAT_S32_LE) {
+				data[0] = p32[tx_ptr];
+				data[0] = data[0]>>8;
+			}
+
+			iowrite32(data[0], dev->spdif_base + SPDIF_FIFO_ADDR);
+			period_pos++;
+			if (++tx_ptr >= runtime->buffer_size)
+				tx_ptr = 0;
+		}
+	}
+
+	*period_elapsed = period_pos >= runtime->period_size;
+	return tx_ptr;
+}
+
+static unsigned int sf_spdif_pcm_rx(struct sf_spdif_dev *dev,
+		struct snd_pcm_runtime *runtime, unsigned int rx_ptr,
+		bool *period_elapsed, snd_pcm_format_t format)
+{
+	u16 (*p16)[2] = (void *)runtime->dma_area;
+	u32 (*p32)[2] = (void *)runtime->dma_area;
+	u32 data[2];
+	unsigned int period_pos = rx_ptr % runtime->period_size;
+	int i;
+
+	for (i = 0; i < dev->fifo_th; i++) {
+		data[0] = ioread32(dev->spdif_base + SPDIF_FIFO_ADDR);
+		data[1] = ioread32(dev->spdif_base + SPDIF_FIFO_ADDR);
+		if (format == SNDRV_PCM_FORMAT_S16_LE) {
+			p16[rx_ptr][0] = data[0]>>8;
+			p16[rx_ptr][1] = data[1]>>8;
+		} else if (format == SNDRV_PCM_FORMAT_S24_LE) {
+			p32[rx_ptr][0] = data[0];
+			p32[rx_ptr][1] = data[1];
+		} else if (format == SNDRV_PCM_FORMAT_S32_LE) {
+			p32[rx_ptr][0] = data[0]<<8;
+			p32[rx_ptr][1] = data[1]<<8;
+		}
+
+		period_pos++;
+		if (++rx_ptr >= runtime->buffer_size)
+			rx_ptr = 0;
+	}
+
+	*period_elapsed = period_pos >= runtime->period_size;
+	return rx_ptr;
+}
+
+static const struct snd_pcm_hardware sf_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_PAUSE |
+		SNDRV_PCM_INFO_RESUME,
+	.rates = SNDRV_PCM_RATE_8000 |
+		SNDRV_PCM_RATE_11025 |
+		SNDRV_PCM_RATE_16000 |
+		SNDRV_PCM_RATE_22050 |
+		SNDRV_PCM_RATE_32000 |
+		SNDRV_PCM_RATE_44100 |
+		SNDRV_PCM_RATE_48000,
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE |
+		SNDRV_PCM_FMTBIT_S24_LE |
+		SNDRV_PCM_FMTBIT_S24_3LE |
+		SNDRV_PCM_FMTBIT_S32_LE,
+	.channels_min = 1,
+	.channels_max = 2,
+	.buffer_bytes_max = BUFFER_BYTES_MAX,
+	.period_bytes_min = PERIOD_BYTES_MIN,
+	.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN,
+	.periods_min = PERIODS_MIN,
+	.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN,
+	.fifo_size = 16,
+};
+
+static void sf_spdif_pcm_transfer(struct sf_spdif_dev *dev, bool push)
+{
+	struct snd_pcm_substream *substream;
+	bool active, period_elapsed;
+
+	rcu_read_lock();
+	if (push)
+		substream = rcu_dereference(dev->tx_substream);
+	else
+		substream = rcu_dereference(dev->rx_substream);
+
+	active = substream && snd_pcm_running(substream);
+	if (active) {
+		unsigned int ptr;
+		unsigned int new_ptr;
+
+		if (push) {
+			ptr = READ_ONCE(dev->tx_ptr);
+			new_ptr = dev->tx_fn(dev, substream->runtime, ptr,
+					&period_elapsed, dev->format);
+			cmpxchg(&dev->tx_ptr, ptr, new_ptr);
+		} else {
+			ptr = READ_ONCE(dev->rx_ptr);
+			new_ptr = dev->rx_fn(dev, substream->runtime, ptr,
+					&period_elapsed, dev->format);
+			cmpxchg(&dev->rx_ptr, ptr, new_ptr);
+		}
+
+		if (period_elapsed)
+			snd_pcm_period_elapsed(substream);
+	}
+	rcu_read_unlock();
+}
+
+void sf_spdif_pcm_push_tx(struct sf_spdif_dev *dev)
+{
+	sf_spdif_pcm_transfer(dev, true);
+}
+
+void sf_spdif_pcm_pop_rx(struct sf_spdif_dev *dev)
+{
+	sf_spdif_pcm_transfer(dev, false);
+}
+
+static int sf_pcm_open(struct snd_soc_component *component,
+		       struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct sf_spdif_dev *dev = snd_soc_dai_get_drvdata(asoc_rtd_to_cpu(rtd, 0));
+
+	snd_soc_set_runtime_hwparams(substream, &sf_pcm_hardware);
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	runtime->private_data = dev;
+
+	return 0;
+}
+
+static int sf_pcm_close(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
+{
+	synchronize_rcu();
+	return 0;
+}
+
+static int sf_pcm_hw_params(struct snd_soc_component *component,
+			    struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_spdif_dev *dev = runtime->private_data;
+
+	switch (params_channels(hw_params)) {
+	case 1:
+	case 2:
+		break;
+	default:
+		dev_err(dev->dev, "invalid channels number\n");
+		return -EINVAL;
+	}
+
+	dev->format = params_format(hw_params);
+	switch (dev->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S24_3LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		break;
+	default:
+		dev_err(dev->dev, "invalid format\n");
+		return -EINVAL;
+	}
+
+	dev->tx_fn = sf_spdif_pcm_tx;
+	dev->rx_fn = sf_spdif_pcm_rx;
+
+	return 0;
+}
+
+static int sf_pcm_trigger(struct snd_soc_component *component,
+			  struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_spdif_dev *dev = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			WRITE_ONCE(dev->tx_ptr, 0);
+			rcu_assign_pointer(dev->tx_substream, substream);
+		} else {
+			WRITE_ONCE(dev->rx_ptr, 0);
+			rcu_assign_pointer(dev->rx_substream, substream);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rcu_assign_pointer(dev->tx_substream, NULL);
+		else
+			rcu_assign_pointer(dev->rx_substream, NULL);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t sf_pcm_pointer(struct snd_soc_component *component,
+					struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_spdif_dev *dev = runtime->private_data;
+	snd_pcm_uframes_t pos;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		pos = READ_ONCE(dev->tx_ptr);
+	else
+		pos = READ_ONCE(dev->rx_ptr);
+
+	return pos < runtime->buffer_size ? pos : 0;
+}
+
+static int sf_pcm_new(struct snd_soc_component *component,
+		      struct snd_soc_pcm_runtime *rtd)
+{
+	size_t size = sf_pcm_hardware.buffer_bytes_max;
+
+	snd_pcm_set_managed_buffer_all(rtd->pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			NULL, size, size);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver sf_pcm_component = {
+	.open		= sf_pcm_open,
+	.close		= sf_pcm_close,
+	.hw_params	= sf_pcm_hw_params,
+	.trigger	= sf_pcm_trigger,
+	.pointer	= sf_pcm_pointer,
+	.pcm_construct	= sf_pcm_new,
+};
+
+int sf_spdif_pcm_register(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &sf_pcm_component,
+					       NULL, 0);
+}
+
diff --git a/sound/soc/starfive/starfive_tdm.c b/sound/soc/starfive/starfive_tdm.c
new file mode 100644
index 000000000000..3ee1b13bd079
--- /dev/null
+++ b/sound/soc/starfive/starfive_tdm.c
@@ -0,0 +1,704 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * TDM driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2022 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/reset.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <linux/pm_runtime.h>
+#include <linux/dma/starfive-dma.h>
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include "starfive_tdm.h"
+
+static inline u32 sf_tdm_readl(struct sf_tdm_dev *dev, u16 reg)
+{
+	return readl_relaxed(dev->tdm_base + reg);
+}
+
+static inline void sf_tdm_writel(struct sf_tdm_dev *dev, u16 reg, u32 val)
+{
+	writel_relaxed(val, dev->tdm_base + reg);
+}
+
+static void sf_tdm_save_context(struct sf_tdm_dev *dev)
+{
+	dev->saved_reg_value[0] = sf_tdm_readl(dev, TDM_PCMGBCR);
+	dev->saved_reg_value[3] = sf_tdm_readl(dev, TDM_PCMDIV);
+}
+
+static void sf_tdm_start(struct sf_tdm_dev *dev, struct snd_pcm_substream *substream)
+{
+	u32 data;
+	unsigned int val;
+
+	data = sf_tdm_readl(dev, TDM_PCMGBCR);
+	sf_tdm_writel(dev, TDM_PCMGBCR, data | PCMGBCR_ENABLE);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		val = sf_tdm_readl(dev, TDM_PCMTXCR);
+		sf_tdm_writel(dev, TDM_PCMTXCR, val | PCMTXCR_TXEN);
+	} else {
+		val = sf_tdm_readl(dev, TDM_PCMRXCR);
+		sf_tdm_writel(dev, TDM_PCMRXCR, val | PCMRXCR_RXEN);
+	}
+}
+
+static void sf_tdm_stop(struct sf_tdm_dev *dev, struct snd_pcm_substream *substream)
+{
+	unsigned int val;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		val = sf_tdm_readl(dev, TDM_PCMTXCR);
+		val &= ~PCMTXCR_TXEN;
+		sf_tdm_writel(dev, TDM_PCMTXCR, val);
+	} else {
+		val = sf_tdm_readl(dev, TDM_PCMRXCR);
+		val &= ~PCMRXCR_RXEN;
+		sf_tdm_writel(dev, TDM_PCMRXCR, val);
+	}
+}
+
+static int sf_tdm_syncdiv(struct sf_tdm_dev *dev)
+{
+	u32 sl, sscale, syncdiv;
+
+	sl = (dev->rx.sl >= dev->tx.sl) ? dev->rx.sl:dev->tx.sl;
+	sscale = (dev->rx.sscale >= dev->tx.sscale) ? dev->rx.sscale:dev->tx.sscale;
+	syncdiv = dev->pcmclk / dev->samplerate - 1;
+
+	if ((syncdiv + 1) < (sl * sscale)) {
+		pr_info("set syncdiv failed !\n");
+		return -1;
+	}
+
+	if ((dev->syncm == TDM_SYNCM_LONG) && 
+			((dev->rx.sscale <= 1) || (dev->tx.sscale <= 1))) {
+		if ((syncdiv + 1) <= sl) {
+			pr_info("set syncdiv failed! it must be (syncdiv+1) > max[tx.sl, rx.sl]\n");
+			return -1;
+		}
+	}
+
+	sf_tdm_writel(dev, TDM_PCMDIV, syncdiv);
+	return 0;
+}
+
+static void sf_tdm_control(struct sf_tdm_dev *dev)
+{
+	u32 data;
+
+	data = (dev->clkpolity << CLKPOL_BIT) |
+		(dev->elm << ELM_BIT) |
+		(dev->syncm << SYNCM_BIT) |
+		(dev->ms_mode << MS_BIT);
+	sf_tdm_writel(dev, TDM_PCMGBCR, data);
+}
+
+static void sf_tdm_config(struct sf_tdm_dev *dev, struct snd_pcm_substream *substream)
+{
+	u32 datarx, datatx;
+
+	sf_tdm_control(dev);
+	sf_tdm_syncdiv(dev);
+
+	datarx = (dev->rx.ifl << IFL_BIT) |
+		(dev->rx.wl << WL_BIT) |
+		(dev->rx.sscale << SSCALE_BIT) |
+		(dev->rx.sl << SL_BIT) |
+		(dev->rx.lrj << LRJ_BIT);
+
+	datatx = (dev->tx.ifl << IFL_BIT) |
+		(dev->tx.wl << WL_BIT) |
+		(dev->tx.sscale << SSCALE_BIT) |
+		(dev->tx.sl << SL_BIT) |
+		(dev->tx.lrj << LRJ_BIT);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sf_tdm_writel(dev, TDM_PCMTXCR, datatx);
+	else
+		sf_tdm_writel(dev, TDM_PCMRXCR, datarx);
+}
+
+static void sf_tdm_clk_disable(struct sf_tdm_dev *priv)
+{
+	clk_disable_unprepare(priv->clk_tdm);
+	clk_disable_unprepare(priv->clk_tdm_ext);
+	clk_disable_unprepare(priv->clk_tdm_internal);
+	clk_disable_unprepare(priv->clk_tdm_apb);
+	clk_disable_unprepare(priv->clk_tdm_ahb);
+	clk_disable_unprepare(priv->clk_mclk_inner);
+}
+
+static int sf_tdm_clk_enable(struct sf_tdm_dev *priv)
+{
+	int ret;
+
+	ret = clk_prepare_enable(priv->clk_mclk_inner);
+	if (ret) {
+		dev_err(priv->dev, "failed to prepare enable clk_mclk_inner\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(priv->clk_tdm_ahb);
+	if (ret) {
+		dev_err(priv->dev, "Failed to prepare enable clk_tdm_ahb\n");
+		goto dis_mclk_inner;
+	}
+
+	ret = clk_prepare_enable(priv->clk_tdm_apb);
+	if (ret) {
+		dev_err(priv->dev, "Failed to prepare enable clk_tdm_apb\n");
+		goto dis_tdm_ahb;
+	}
+
+	ret = clk_prepare_enable(priv->clk_tdm_internal);
+	if (ret) {
+		dev_err(priv->dev, "Failed to prepare enable clk_tdm_intl\n");
+		goto dis_tdm_apb;
+	}
+
+	ret = clk_prepare_enable(priv->clk_tdm_ext);
+	if (ret) {
+		dev_err(priv->dev, "Failed to prepare enable clk_tdm_ext\n");
+		goto dis_tdm_internal;
+	}
+
+	ret = clk_set_parent(priv->clk_tdm, priv->clk_tdm_internal);
+	if (ret) {
+		dev_err(priv->dev, "Can't set internal clock source for clk_tdm: %d\n", ret);
+		goto dis_tdm_ext;
+	}
+
+	ret = clk_prepare_enable(priv->clk_tdm);
+	if (ret) {
+		dev_err(priv->dev, "Failed to prepare enable clk_tdm\n");
+		goto dis_tdm_ext;
+	}
+
+	ret = reset_control_deassert(priv->resets);
+	if (ret) {
+		dev_err(priv->dev, "%s: failed to deassert tdm resets\n", __func__);
+		goto err_reset;
+	}
+
+	ret = clk_set_parent(priv->clk_tdm, priv->clk_tdm_ext);
+	if (ret) {
+		dev_err(priv->dev, "Can't set external clock source for clk_tdm: %d\n", ret);
+		goto err_reset;
+	}
+
+	return 0;
+
+err_reset:
+	clk_disable_unprepare(priv->clk_tdm);	
+dis_tdm_ext:
+	clk_disable_unprepare(priv->clk_tdm_ext);
+dis_tdm_internal:
+	clk_disable_unprepare(priv->clk_tdm_internal);
+dis_tdm_apb:
+	clk_disable_unprepare(priv->clk_tdm_apb);
+dis_tdm_ahb:
+	clk_disable_unprepare(priv->clk_tdm_ahb);
+dis_mclk_inner:
+	clk_disable_unprepare(priv->clk_mclk_inner);
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int sf_tdm_runtime_suspend(struct device *dev)
+{
+	struct sf_tdm_dev *priv = dev_get_drvdata(dev);
+
+	sf_tdm_clk_disable(priv);
+	return 0;
+}
+
+static int sf_tdm_runtime_resume(struct device *dev)
+{
+	struct sf_tdm_dev *priv = dev_get_drvdata(dev);
+
+	return sf_tdm_clk_enable(priv);
+}
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int sf_tdm_suspend(struct snd_soc_component *component)
+{
+	return pm_runtime_force_suspend(component->dev);
+}
+
+static int sf_tdm_resume(struct snd_soc_component *component)
+{
+
+	struct sf_tdm_dev *dev = snd_soc_component_get_drvdata(component);
+
+	// restore context
+	sf_tdm_writel(dev, TDM_PCMGBCR, dev->saved_reg_value[0]);
+	sf_tdm_writel(dev, TDM_PCMDIV, dev->saved_reg_value[3]);
+
+	return pm_runtime_force_resume(component->dev);
+}
+
+#else
+#define sf_tdm_suspend	NULL
+#define sf_tdm_resume	NULL
+#endif
+
+/* 
+ * To stop dma first, we must implement this function, because it is
+ * called before stopping the stream. 
+ */
+static int sf_pcm_trigger(struct snd_soc_component *component,
+			      struct snd_pcm_substream *substream, int cmd)
+{
+	int ret = 0;
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		axi_dma_cyclic_stop(chan);
+		break;
+
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static const struct snd_soc_component_driver sf_tdm_component = {
+	.name		= "jh7110-tdm",
+	.suspend	= sf_tdm_suspend,
+	.resume		= sf_tdm_resume,
+	.trigger	= sf_pcm_trigger,
+};
+
+static int sf_tdm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sf_tdm_dev *dev = snd_soc_dai_get_drvdata(dai);
+	int chan_wl, chan_sl, chan_nr;
+	struct snd_dmaengine_dai_dma_data *dma_data = NULL;
+	unsigned int data_width;
+	unsigned int mclk_rate;
+	unsigned int dma_bus_width;
+	int channels;
+	int ret;
+
+	channels = params_channels(params);
+	data_width = params_width(params);
+
+	dev->samplerate = params_rate(params);
+	switch (dev->samplerate) {
+	/*  There are some limitation when using 8k sample rate  */
+	case 8000:
+		mclk_rate = 12288000;
+		if ((data_width == 16) || (channels == 1)) {
+			pr_err("TDM: not support 16bit or 1-channel when using 8k sample rate\n");
+			return -EINVAL;
+		}
+		break;
+	case 11025:
+		/* sysclk */
+		mclk_rate = 11289600;
+		break;
+	case 16000:
+		mclk_rate = 12288000;
+		break;
+	case 22050:
+		mclk_rate = 11289600;
+		break;
+	case 32000:
+		mclk_rate = 12288000;
+		break;
+	case 44100:
+		mclk_rate = 11289600;
+		break;
+	case 48000:
+		mclk_rate = 12288000;
+		break;
+	default:
+		pr_err("TDM: not support sample rate:%d\n", dev->samplerate);
+		return -EINVAL;
+	}
+
+	dev->pcmclk = channels * dev->samplerate * data_width;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		chan_wl = TDM_16BIT_WORD_LEN;
+		chan_sl = TDM_16BIT_SLOT_LEN;
+		dma_bus_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		chan_wl = TDM_32BIT_WORD_LEN;
+		chan_sl = TDM_32BIT_SLOT_LEN;
+		dma_bus_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+
+	default:
+		dev_err(dev->dev, "tdm: unsupported PCM fmt");
+		return -EINVAL;
+	}
+
+	chan_nr = params_channels(params);
+	switch (chan_nr) {
+	case ONE_CHANNEL_SUPPORT:
+	case TWO_CHANNEL_SUPPORT:
+	case FOUR_CHANNEL_SUPPORT:
+	case SIX_CHANNEL_SUPPORT:
+	case EIGHT_CHANNEL_SUPPORT:
+		break;
+	default:
+		dev_err(dev->dev, "channel not supported\n");
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dev->tx.wl = chan_wl;
+		dev->tx.sl = chan_sl;
+		dev->tx.sscale = chan_nr;
+		dev->play_dma_data.addr_width = dma_bus_width;
+		dma_data = &dev->play_dma_data;
+	} else {
+		dev->rx.wl = chan_wl;
+		dev->rx.sl = chan_sl;
+		dev->rx.sscale = chan_nr;
+		dev->capture_dma_data.addr_width = dma_bus_width;
+		dma_data = &dev->capture_dma_data;
+	}
+
+	snd_soc_dai_set_dma_data(dai, substream, dma_data);
+
+	ret = clk_set_rate(dev->clk_mclk_inner, mclk_rate);
+	if (ret) {
+		dev_err(dev->dev, "Can't set clk_mclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_set_rate(dev->clk_tdm_internal, dev->pcmclk);
+	if (ret) {
+		dev_err(dev->dev, "Can't set clk_tdm_internal: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_set_parent(dev->clk_tdm, dev->clk_tdm_ext);
+	if (ret) {
+		dev_err(dev->dev, "Can't set clock source for clk_tdm: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(dev->clk_tdm_ahb);
+	if (ret) {
+		dev_err(dev->dev, "Failed to prepare enable clk_tdm_ahb\n");
+		return ret;
+	}
+
+	ret = clk_prepare_enable(dev->clk_tdm_apb);
+	if (ret) {
+		dev_err(dev->dev, "Failed to prepare enable clk_tdm_apb\n");
+		return ret;
+	}
+
+	sf_tdm_config(dev, substream);
+	sf_tdm_save_context(dev);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dev->saved_reg_value[1] = sf_tdm_readl(dev, TDM_PCMTXCR);
+	else
+		dev->saved_reg_value[2] = sf_tdm_readl(dev, TDM_PCMRXCR);
+
+	return 0;
+}
+
+static int sf_tdm_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct dma_chan *chan = snd_dmaengine_pcm_get_chan(substream);
+	struct sf_tdm_dev *dev = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev->active++;
+		/* restore context */
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			sf_tdm_writel(dev, TDM_PCMTXCR, dev->saved_reg_value[1]);
+		else
+			sf_tdm_writel(dev, TDM_PCMRXCR, dev->saved_reg_value[2]);
+		sf_tdm_start(dev, substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev->active--;
+		axi_dma_cyclic_stop(chan);
+		mdelay(100);
+		sf_tdm_stop(dev, substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int sf_tdm_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct sf_tdm_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		dev->ms_mode = TDM_AS_SLAVE;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		dev->ms_mode = TDM_AS_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		ret = -EINVAL;
+		break;
+	default:
+		dev_dbg(dev->dev, "tdm : Invalid master/slave format\n");
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static const struct snd_soc_dai_ops sf_tdm_dai_ops = {
+	.hw_params	= sf_tdm_hw_params,
+	.trigger	= sf_tdm_trigger,
+	.set_fmt	= sf_tdm_set_fmt,
+};
+
+static int sf_tdm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sf_tdm_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, &dev->play_dma_data, &dev->capture_dma_data);
+	snd_soc_dai_set_drvdata(dai, dev);
+	return 0;
+}
+
+#define SF_TDM_RATES SNDRV_PCM_RATE_8000_48000
+
+#define SF_TDM_FORMATS	(SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+static struct snd_soc_dai_driver sf_tdm_dai = {
+	.name = "sf_tdm",
+	.id = 0,
+	.playback = {
+		.stream_name    = "Playback",
+		.channels_min   = 1,
+		.channels_max   = 8,
+		.rates          = SF_TDM_RATES,
+		.formats        = SF_TDM_FORMATS,
+	},
+	.capture = {
+		.stream_name    = "Capture",
+		.channels_min   = 1,
+		.channels_max   = 8,
+		.rates          = SF_TDM_RATES,
+		.formats        = SF_TDM_FORMATS,
+	},
+	.ops = &sf_tdm_dai_ops,
+	.probe = sf_tdm_dai_probe,
+	.symmetric_rates = 1,
+};
+
+static const struct snd_pcm_hardware jh71xx_pcm_hardware = {
+	.info			= (SNDRV_PCM_INFO_MMAP		|
+				   SNDRV_PCM_INFO_MMAP_VALID	|
+				   SNDRV_PCM_INFO_PAUSE		|
+				   SNDRV_PCM_INFO_RESUME	|
+				   SNDRV_PCM_INFO_INTERLEAVED	|
+				   SNDRV_PCM_INFO_BLOCK_TRANSFER),
+	.buffer_bytes_max	= 192512,
+	.period_bytes_min	= 4096,
+	.period_bytes_max	= 32768,
+	.periods_min		= 1,
+	.periods_max		= 48,
+	.fifo_size		= 16,
+};
+
+static const struct snd_dmaengine_pcm_config jh71xx_dmaengine_pcm_config = {
+	.pcm_hardware = &jh71xx_pcm_hardware,
+	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+	.prealloc_buffer_size = 192512,
+};
+
+static void tdm_init_params(struct sf_tdm_dev *dev)
+{
+	dev->clkpolity = TDM_TX_RASING_RX_FALLING;
+	if (dev->frame_mode == SHORT_LATER) {
+		dev->elm = TDM_ELM_LATE;
+		dev->syncm = TDM_SYNCM_SHORT;
+	} else if (dev->frame_mode == SHORT_EARLY) {
+		dev->elm = TDM_ELM_EARLY;
+		dev->syncm = TDM_SYNCM_SHORT;
+	} else {
+		dev->elm = TDM_ELM_EARLY;
+		dev->syncm = TDM_SYNCM_LONG;
+	}
+
+	dev->ms_mode = TDM_AS_SLAVE;
+	dev->rx.ifl = dev->tx.ifl = TDM_FIFO_HALF;
+	dev->rx.wl = dev->tx.wl = TDM_16BIT_WORD_LEN;
+	dev->rx.sscale = dev->tx.sscale = 2;
+	dev->rx.lrj = dev->tx.lrj = TDM_LEFT_JUSTIFT;
+
+	dev->play_dma_data.addr = TDM_FIFO;
+	dev->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dev->play_dma_data.fifo_size = TDM_FIFO_DEPTH/2;
+	dev->play_dma_data.maxburst = 16;
+
+	dev->capture_dma_data.addr = TDM_FIFO;
+	dev->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+	dev->capture_dma_data.fifo_size = TDM_FIFO_DEPTH/2;
+	dev->capture_dma_data.maxburst = 8;
+}
+
+static int sf_tdm_clk_reset_init(struct platform_device *pdev, struct sf_tdm_dev *dev)
+{
+	int ret;
+
+	static struct clk_bulk_data clks[] = {
+		{ .id = "clk_tdm_ahb" },
+		{ .id = "clk_tdm_apb" },
+		{ .id = "clk_tdm_internal" },
+		{ .id = "clk_tdm_ext" },
+		{ .id = "clk_tdm" },
+		{ .id = "mclk_inner" },
+	};
+
+	ret = devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(clks), clks);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get tdm clocks\n");
+		goto exit;
+	}
+
+	dev->clk_tdm_ahb = clks[0].clk;
+	dev->clk_tdm_apb = clks[1].clk;
+	dev->clk_tdm_internal = clks[2].clk;
+	dev->clk_tdm_ext = clks[3].clk;
+	dev->clk_tdm = clks[4].clk;
+	dev->clk_mclk_inner = clks[5].clk;
+
+	dev->resets = devm_reset_control_array_get_exclusive(&pdev->dev);
+	if (IS_ERR(dev->resets)) {
+		ret = PTR_ERR(dev->resets);
+		dev_err(&pdev->dev, "Failed to get tdm resets");
+		goto exit;
+	}
+
+	ret = sf_tdm_clk_enable(dev);
+
+exit:
+	return ret;
+}
+
+static int sf_tdm_probe(struct platform_device *pdev)
+{
+	struct sf_tdm_dev *dev;
+	struct resource *res;
+	int ret;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->tdm_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dev->tdm_base))
+		return PTR_ERR(dev->tdm_base);
+
+	dev->dev = &pdev->dev;
+
+	ret = sf_tdm_clk_reset_init(pdev, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable audio-tdm clock\n");
+		return ret;
+	}
+
+	dev->frame_mode = SHORT_LATER;
+	tdm_init_params(dev);
+
+	dev_set_drvdata(&pdev->dev, dev);
+	ret = devm_snd_soc_register_component(&pdev->dev, &sf_tdm_component,
+					 &sf_tdm_dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "failed to register dai\n");
+		return ret;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
+					&jh71xx_dmaengine_pcm_config,
+					SND_DMAENGINE_PCM_FLAG_COMPAT);
+	if (ret) {
+		dev_err(&pdev->dev, "could not register pcm: %d\n", ret);
+		return ret;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+#ifdef CONFIG_PM
+	sf_tdm_clk_disable(dev);
+#endif
+
+	return 0;
+}
+
+static int sf_tdm_dev_remove(struct platform_device *pdev)
+{
+	pm_runtime_disable(&pdev->dev);
+	return 0;
+}
+static const struct of_device_id sf_tdm_of_match[] = {
+	{.compatible = "starfive,jh7110-tdm",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sf_tdm_of_match);
+
+static const struct dev_pm_ops sf_tdm_pm_ops = {
+	SET_RUNTIME_PM_OPS(sf_tdm_runtime_suspend,
+			   sf_tdm_runtime_resume, NULL)
+};
+
+static struct platform_driver sf_tdm_driver = {
+
+	.driver = {
+		.name = "jh7110-tdm",
+		.of_match_table = sf_tdm_of_match,
+		.pm = &sf_tdm_pm_ops,
+	},
+	.probe = sf_tdm_probe,
+	.remove = sf_tdm_dev_remove,
+};
+module_platform_driver(sf_tdm_driver);
+
+MODULE_AUTHOR("Walker Chen <walker.chen@starfivetech.com>");
+MODULE_DESCRIPTION("Starfive TDM Controller Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/starfive/starfive_tdm.h b/sound/soc/starfive/starfive_tdm.h
new file mode 100644
index 000000000000..3428a7807c25
--- /dev/null
+++ b/sound/soc/starfive/starfive_tdm.h
@@ -0,0 +1,153 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * TDM driver for the StarFive JH7110 SoC
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef __SND_SOC_STARFIVE_TDM_H
+#define __SND_SOC_STARFIVE_TDM_H
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <linux/dmaengine.h>
+#include <linux/types.h>
+
+#define TDM_PCMGBCR			0x00
+	#define PCMGBCR_MASK		0x1e
+	#define PCMGBCR_ENABLE		BIT(0)
+	#define PCMGBCR_TRITXEN		BIT(4)
+	#define CLKPOL_BIT		5
+	#define TRITXEN_BIT		4
+	#define ELM_BIT			3
+	#define SYNCM_BIT		2
+	#define MS_BIT			1
+#define TDM_PCMTXCR			0x04
+	#define PCMTXCR_TXEN		BIT(0)
+	#define IFL_BIT			11
+	#define WL_BIT			8
+	#define SSCALE_BIT		4
+	#define SL_BIT			2
+	#define LRJ_BIT			1
+#define TDM_PCMRXCR			0x08
+	#define PCMRXCR_RXEN		BIT(0)
+	#define PCMRXCR_RXSL_MASK	0xc
+	#define PCMRXCR_RXSL_16BIT	0x4
+	#define PCMRXCR_RXSL_32BIT	0x8
+	#define PCMRXCR_SCALE_MASK	0xf0
+	#define PCMRXCR_SCALE_1CH	0x10
+#define TDM_PCMDIV			0x0c
+
+/*  DMA registers */
+#define TDM_FIFO			0x170c0000
+#define TDM_FIFO_DEPTH			32
+
+#define ONE_CHANNEL_SUPPORT		1
+#define TWO_CHANNEL_SUPPORT		2
+#define FOUR_CHANNEL_SUPPORT		4
+#define SIX_CHANNEL_SUPPORT		6
+#define EIGHT_CHANNEL_SUPPORT		8
+
+enum TDM_MASTER_SLAVE_MODE {
+	TDM_AS_MASTER = 0,
+	TDM_AS_SLAVE,
+};
+
+enum TDM_CLKPOL {
+	/* tx raising and rx falling */
+	TDM_TX_RASING_RX_FALLING = 0,
+	/* tx falling and rx raising */
+	TDM_TX_FALLING_RX_RASING,
+};
+
+enum TDM_FRAME_MODE {
+	SHORT_EARLY = 0,
+	SHORT_LATER,
+	LONG,
+};
+
+enum TDM_ELM {
+	/* only work while SYNCM=0 */
+	TDM_ELM_LATE = 0,
+	TDM_ELM_EARLY,
+};
+
+enum TDM_SYNCM {
+	/* short frame sync */
+	TDM_SYNCM_SHORT = 0,
+	/* long frame sync */
+	TDM_SYNCM_LONG,
+};
+
+enum TDM_IFL {
+	/* FIFO to send or received : half-1/2, Quarter-1/4 */
+	TDM_FIFO_HALF = 0,
+	TDM_FIFO_QUARTER,
+};
+
+enum TDM_WL {
+	/* send or received word length */
+	TDM_8BIT_WORD_LEN = 0,
+	TDM_16BIT_WORD_LEN,
+	TDM_20BIT_WORD_LEN,
+	TDM_24BIT_WORD_LEN,
+	TDM_32BIT_WORD_LEN,
+};
+
+enum TDM_SL {
+	/* send or received slot length */
+	TDM_8BIT_SLOT_LEN = 0,
+	TDM_16BIT_SLOT_LEN,
+	TDM_32BIT_SLOT_LEN,
+};
+
+enum TDM_LRJ {
+	/* left-justify or right-justify */
+	TDM_RIGHT_JUSTIFY = 0,
+	TDM_LEFT_JUSTIFT,
+};
+
+typedef struct tdm_chan_cfg {
+	enum TDM_IFL ifl;
+	enum TDM_WL  wl;
+	unsigned char sscale;
+	enum TDM_SL  sl;
+	enum TDM_LRJ lrj;
+	unsigned char enable;
+} tdm_chan_cfg_t;
+
+struct sf_tdm_dev {
+	void __iomem *tdm_base;
+	struct device *dev;
+	struct clk *clk_tdm_ahb;
+	struct clk *clk_tdm_apb;
+	struct clk *clk_tdm_internal;
+	struct clk *clk_tdm_ext;
+	struct clk *clk_tdm;
+	struct clk *clk_mclk_inner;
+	struct reset_control *resets;
+	int active;
+	
+	enum TDM_CLKPOL clkpolity;
+	enum TDM_ELM	elm;
+	enum TDM_SYNCM	syncm;
+	enum TDM_MASTER_SLAVE_MODE ms_mode;
+	enum TDM_FRAME_MODE frame_mode;
+	unsigned char	tritxen;
+	
+	tdm_chan_cfg_t tx;
+	tdm_chan_cfg_t rx;
+	
+	u16 syncdiv;
+	u32 samplerate;
+	u32 pcmclk;
+
+	/* data related to DMA transfers b/w tdm and DMAC */
+	struct snd_dmaengine_dai_dma_data play_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	u32 saved_reg_value[4];
+};
+
+#endif	/* __SND_SOC_STARFIVE_TDM_H */
-- 
2.34.1

